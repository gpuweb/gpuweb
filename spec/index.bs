<pre class='metadata'>
Title: WebGPU
Shortname: webgpu
Level: 1
Status: w3c/ED
Group: webgpu
URL: https://gpuweb.github.io/gpuweb

!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues">open issues</a>)

Editor: Dzmitry Malyshau, Mozilla https://www.mozilla.org, dmalyshau@mozilla.com
Editor: Justin Fan, Apple https://www.apple.com, justin_fan@apple.com
Editor: Kai Ninomiya, Google http://www.google.com, kainino@google.com
Abstract: WebGPU exposes an API for performing operations, such as rendering and computation, on a Graphics Processing Unit.
Markup Shorthands: markdown yes
Markup Shorthands: dfn yes
Markup Shorthands: idl yes
Markup Shorthands: css no
</pre>

<pre class='anchors'>
spec: ECMA-262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: agent; url: agent
spec: webidl; urlPrefix: https://heycam.github.io/webidl/#
    type: dfn
        text: resolve; url: resolve
</pre>

<style>
.validusage {
    padding: .5em;
    border: thin solid #88e !important;
    border-radius: .5em;
}
</style>


# Introduction # {#intro}

*This section is non-normative.*

[Graphics Processing Units](https://en.wikipedia.org/wiki/Graphics_processing_unit), or GPUs for short,
have been essential in enabling rich rendering and computational applications in personal computing.
WebGPU is an API that exposes the capabilities of GPU hardware for the Web.
The API is designed from the ground up to efficiently map to the
[Vulkan](https://www.khronos.org/vulkan/),
[Direct3D 12](https://docs.microsoft.com/en-us/windows/win32/direct3d12/what-is-directx-12-),
and [Metal](https://developer.apple.com/metal/) native GPU APIs.
WebGPU is not related to [WebGL](https://www.khronos.org/webgl/) and does not explicitly target OpenGL ES.

WebGPU sees physical GPU hardware as {{GPUAdapter}}s. It provides a connection to an adapter via
{{GPUDevice}}, which manages resources, and the device's {{GPUQueue}}s, which execute commands.
{{GPUDevice}} may have its own memory with high-speed access to the processing units.
{{GPUBuffer}} and {{GPUTexture}} are the <dfn dfn>physical resources</dfn> backed by GPU memory.
{{GPUCommandBuffer}} and {{GPURenderBundle}} are containers for user-recorded commands.
{{GPUShaderModule}} contains [=shader=] code. The other resources,
such as {{GPUSampler}} or {{GPUBindGroup}}, configure the way [=physical resources=] are used by the GPU.

GPUs execute commands encoded in {{GPUCommandBuffer}}s by feeding data through a [=pipeline=],
which is a mix of fixed-function and programmable stages. Programmable stages execute
<dfn dfn>shaders</dfn>, which are special programs designed to run on GPU hardware.
Most of the state of a [=pipeline=] is defined by
a {{GPURenderPipeline}} or a {{GPUComputePipeline}} object. The state not included
in these [=pipeline=] objects is set during encoding with commands,
such as {{GPUCommandEncoder/beginRenderPass()}} or {{GPURenderPassEncoder/setBlendColor()}}.


# Security considerations # {#security}

## CPU-based undefined behavior ## {#security-cpu-ub}

A WebGPU implementation translates the workloads issued by the user into API commands specific
to the target platform. Native APIs specify the valid usage for the commands
(for example, see [vkCreateDescriptorSetLayout](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateDescriptorSetLayout.html))
and generally don't guarantee any outcome if the valid usage rules are not followed.
This is called "undefined behavior", and it can be exploited by an attacker to access memory
they don't own, or force the driver to execute arbitrary code.

In order to disallow insecure usage, the range of allowed WebGPU behaviors is defined for any input.
An implementation has to validate all the input from the user and only reach the driver
with the valid workloads. This document specifies all the error conditions and handling semantics.
For example, specifying the same buffer with intersecting ranges in both "source" and "destination"
of {{GPUCommandEncoder/copyBufferToBuffer()}} results in {{GPUCommandEncoder}}
generating an error, and no other operation occurring.

See [[#errors-and-debugging]] for more information about error handling.

## GPU-based undefined behavior ## {#security-gpu-ub}

WebGPU [=shader=]s are executed by the compute units inside GPU hardware. In native APIs,
some of the shader instructions may result in undefined behavior on the GPU.
In order to address that, the shader instruction set and its defined behaviors are
strictly defined by WebGPU. When a shader is provided, the WebGPU implementation has to validate it
before doing any translation (to platform-specific shaders) or transformation passes.

## Out-of-bounds access in shaders ## {#security-shader}

[=Shader=]s can access [=physical resource=]s either directly or via <dfn dfn>texture unit</dfn>s,
which are fixed-function hardware blocks that handle texture coordinate conversions.
Validation on the API side can only guarantee that all the inputs to the shader are provided and
they have the correct usage and types.
The API side can not guarantee that the data is accessed within bounds
if the [=texture unit=]s are not involved.

In order to prevent the shaders from accessing GPU memory an application doesn't own,
the WebGPU implementation may enable a special mode (called "robust buffer access") in the driver
that guarantees that the access is limited to buffer bounds.
Alternatively, an implementation may transform the shader code by inserting manual bounds checks.

If the shader attempts to load data outside of [=physical resource=] bounds,
the implementation is allowed to:
  1. return a value at a different location within the resource bounds
  2. return a value vector of "(0, 0, 0, X)" with any "X"
  3. partially discard the draw or dispatch call

If the shader attempts to write data outside of [=physical resource=] bounds,
the implementation is allowed to:
  1. write the value to a different location within the resource bounds
  2. discard the write operation
  3. partially discard the draw or dispatch call

## Invalid data ## {#security-invalid-data}

When uploading [floating-point](https://en.wikipedia.org/wiki/IEEE_754) data from CPU to GPU,
or generating it on the GPU, we may end up with a binary representation that doesn't correspond
to a valid number, such as infinity or NaN (not-a-number). The GPU behavior in this case is
subject to the accuracy of the GPU hardware implementation of the IEEE-754 standard.
WebGPU guarantees that introducing invalid floating-point numbers would only affect the results
of arithmetic computations and will not have other side effects.

## Driver bugs ## {#security-driver-bugs}

GPU drivers are subject to bugs like any other software. If a bug occurs, an attacker
could possibly exploit the incorrect behavior of the driver to get access to unprivileged data.
In order to reduce the risk, the WebGPU working group will coordinate with GPU vendors
to integrate the WebGPU Conformance Test Suite (CTS) as part of their driver testing process,
like it was done for WebGL.
WebGPU implementations are expected to have workarounds for some of the discovered bugs,
and support blacklisting particular drivers from using some of the native API backends.

## Timing attacks ## {#security-timing}

WebGPU is designed for multi-threaded use via Web Workers. Some of the objects,
like {{GPUBuffer}}, have shared state which can be simultaneously accessed.
This allows race conditions to occur, similar to those of accessing a SharedArrayBuffer
from multiple Web Workers, which makes the thread scheduling observable
and allows the creation of high-precision timers.
The theoretical attack vectors are a subset of those of SharedArrayBuffer.

## Denial of service ## {#security-dos}

WebGPU applications have access to GPU memory and compute units. A WebGPU implementation may limit
the available GPU memory to an application, in order to keep other applications responsive.
For GPU processing time, a WebGPU implementation may set up "watchdog" timer that makes sure an
application doesn't cause GPU unresponsiveness for more than a few seconds.
These measures are similar to those used in WebGL.

## Fingerprinting ## {#security-fingerprint}

WebGPU defines the required limits and capabilities of any {{GPUAdapter}}.
and encourages applications to target these standard limits. The actual result from
{{GPU/requestAdapter()}} may have [=better=] limits, and could be subject to fingerprinting.


# Terminology &amp; Conventions # {#terminology-and-conventions}

## Dot Syntax ## {#dot-syntax}

In this specification, the `.` ("dot") syntax, common in programming languages, is used.
The phrasing "`Foo.Bar`" means "the `Bar` member of the value (or interface) `Foo`."

For example, where `buffer` is a {{GPUBuffer}}, `buffer.[[device]].[[adapter]]` means
"the `[[adapter]]` internal slot of the `[[device]]` internal slot of `buffer`.

## Coordinate Systems ## {#coordinate-systems}

WebGPU's coordinate systems match DirectX and Metal's coordinate systems in a graphics pipeline.
  - Y-axis is up in normalized device coordinate (NDC): point(-1.0, -1.0) in NDC is located at the bottom-left corner of NDC.
    In addition, x and y in NDC should be between -1.0 and 1.0 inclusive, while z in NDC should be between 0.0 and 1.0 inclusive.
    Vertices out of this range in NDC will not introduce any errors, but they will be clipped.
  - Y-axis is down in framebuffer coordinate, viewport coordinate and fragment/pixel coordinate:
    origin(0, 0) is located at the top-left corner in these coordinate systems.
  - Window/present coordinate matches framebuffer coordinate.
  - UV of origin(0, 0) in texture coordinate represents the first texel (the lowest byte) in texture memory.

## Internal Objects ## {#webgpu-internal-objects}

An <dfn dfn>internal object</dfn> is a conceptual, non-exposed WebGPU object.
[=Internal objects=] track the state of an API object and hold any underlying implementation.
If the state of a particular [=internal object=] can change in parallel from multiple [=agents=],
those changes are always atomic with respect to all [=agents=].

Note: An "[=agent=]" refers to a JavaScript "thread" (i.e. main thread, or Web Worker).

### Invalid Objects ### {#invalid-objects}

If an object is successfully created, it is <dfn dfn>valid</dfn> at that moment.
An [=internal object=] may be <dfn dfn>invalid</dfn>.
It may become [=invalid=] during its lifetime, but it will never become valid again.

<div class=note>
    [=Invalid=] objects result from a number of situations, including:

      - If there is an error in the creation of an object, it is immediately invalid.
        This can happen, for example, if the [=object descriptor=] doesn't describe a valid
        object, or if there is not enough memory to allocate a [=resource=].
      - If an object is explicitly destroyed (e.g. {{GPUBuffer/destroy()|GPUBuffer.destroy()}}),
        it becomes invalid.
      - If the [=device=] that owns an object is lost, the object becomes invalid.
</div>

## WebGPU Interfaces ## {#webgpu-interfaces}

A <dfn dfn>WebGPU interface</dfn> is an exposed interface which encapsulates an [=internal object=].
It provides the interface through which the [=internal object=]'s state is changed.

As a matter of convention, if a [=WebGPU interface=] is referred to as [=invalid=],
it means that the [=internal object=] it encapsulates is [=invalid=].

Any interface which includes {{GPUObjectBase}} is a [=WebGPU interface=].

<script type=idl>
interface mixin GPUObjectBase {
    attribute DOMString? label;
};
</script>

{{GPUObjectBase}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>label</dfn>
    ::
        A label which can be used by development tools (such as error/warning messages,
        browser developer tools, or platform debugging utilities) to identify the underlying
        [=internal object=] to the developer.
        It has no specified format, and therefore cannot be reliably machine-parsed.

        In any given situation, the user agent may or may not choose to use this label.
</dl>

{{GPUObjectBase}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>\[[device]]</dfn>, of type [=device=], readonly
    ::
        An internal slot holding the [=device=] which owns the [=internal object=].
</dl>

## Object Descriptors ## {#object-descriptors}

An <dfn dfn>object descriptor</dfn> holds the information needed to create an object,
which is typically done via one of the `create*` methods of {{GPUDevice}}.

<script type=idl>
dictionary GPUObjectDescriptorBase {
    DOMString label;
};
</script>

{{GPUObjectDescriptorBase}} has the following members:

<dl dfn-type=dict-member dfn-for=GPUObjectDescriptorBase>
    : <dfn>label</dfn>
    ::
        The initial value of {{GPUObjectBase/label|GPUObjectBase.label}}.
</dl>


# Programming Model # {#programming-model}

## Timelines ## {#programming-model-timelines}

*This section is non-normative.*

A computer system with a user agent at the front-end and GPU at the back-end
has components working on different timelines in parallel:

: <dfn dfn>Content timeline</dfn>
:: Associated with the execution of the Web script.
    It includes calling all methods described by this specification.

: <dfn dfn>Device timeline</dfn>
:: Associated with the GPU device operations
    that are issued by the user agent.
    It includes creation of adapters, devices, and GPU resources
    and state objects, which are typically synchronous operations from the point
    of view of the user agent part that controls the GPU,
    but can live in a separate OS process.

: <dfn dfn>Queue timeline</dfn>
:: Associated with the execution of operations
    on the compute units of the GPU. It includes actual draw, copy,
    and compute jobs that run on the GPU.

In this specification, asynchronous operations are used when the result value
depends on work that happens on any timeline other than the [=Content timeline=].
They are represented by callbacks and promises in JavaScript.

<div class="example">
{{GPUComputePassEncoder/dispatch(x, y, z)|GPUComputePassEncoder.dispatch()}}:

  1. User encodes a `dispatch` command by calling a method of the
    {{GPUComputePassEncoder}} which happens on the [=Content timeline=].
  2. User issues {{GPUQueue/submit(commandBuffers)|GPUQueue.submit()}} that hands over
    the {{GPUCommandBuffer}} to the user agent, which processes it
    on the [=Device timeline=] by calling the OS driver to do a low-level submission.
  3. The submit gets dispatched by the GPU thread scheduler onto the
    actual compute units for execution, which happens on the [=Queue timeline=].

</div>
<div class="example">
{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer()}}:

  1. User fills out a {{GPUBufferDescriptor}} and creates a {{GPUBuffer}} with it,
    which happens on the [=Content timeline=].
  2. User agent creates a low-level buffer on the [=Device timeline=].

</div>
<div class="example">
{{GPUBuffer/mapAsync()|GPUBuffer.mapAsync()}}:

  1. User requests to map a {{GPUBuffer}} on the [=Content timeline=] and
    gets a promise in return.
  2. User agent checks if the buffer is currently used by the GPU
    and makes a reminder to itself to check back when this usage is over.
  3. After the GPU operating on [=Queue timeline=] is done using the buffer,
    the user agent maps it to memory and [=resolves=] the promise.

</div>

## Memory ## {#programming-model-memory}

*This section is non-normative.*

Once a {{GPUDevice}} has been obtained during an application initialization routine,
we can describe the <dfn dfn>WebGPU platform</dfn> as consisting of the following layers:
  1. User agent implementing the specification.
  2. Operating system with low-level native API drivers for this device.
  3. Actual CPU and GPU hardware.

Each layer of the [=WebGPU platform=] may have different memory types
that the user agent needs to consider when implementing the specification:
  - The script-owned memory, such as an {{ArrayBuffer}} created by the script,
    is generally not accessible by a GPU driver.
  - A user agent may have different processes responsible for running
    the content and communication to the GPU driver.
    In this case, it uses inter-process shared memory to transfer data.
  - Dedicated GPUs have their own memory with high bandwidth,
    while integrated GPUs typically share memory with the system.

Most [=physical resources=] are allocated in the memory of type
that is efficient for computation or rendering by the GPU.
When the user needs to provide new data to the GPU,
the data may first need to cross the process boundary in order to reach
the user agent part that communicates with the GPU driver.
Then it may need to be made visible to the driver,
which sometimes requires a copy into driver-allocated staging memory.
Finally, it may need to be transferred to the dedicated GPU memory,
potentially changing the internal layout into one
that is most efficient for GPUs to operate on.

All of these transitions are done by the WebGPU implementation of the user agent.

Note: This example describes the worst case, while in practice
the implementation may not need to cross the process boundary,
or may be able to expose the driver-managed memory directly to
the user behind an `ArrayBuffer`, thus avoiding any data copies.

## Resource usage ## {#programming-model-resource-usage}

Buffers and textures can be used by the GPU in multiple ways,
which can be split into two groups:

: <dfn dfn>Read-only usage</dfn>s
:: Usages like
    {{GPUBufferUsage/VERTEX|GPUBufferUsage.VERTEX}} or
    {{GPUTextureUsage/SAMPLED|GPUTextureUsage.SAMPLED}}
    don't change the contents of a resource.

: <dfn dfn>Mutating usage</dfn>s
:: Usages like {{GPUBufferUsage/STORAGE|GPUBufferUsage.STORAGE}}
    do change the contents of a resource.

Issue(gpuweb/gpuweb#296): Consider merging all read-only usages.

Textures may consist of separate [=mipmap levels=] and [=array layers=],
which can be used differently at any given time.
Each such <dfn dfn>subresource</dfn> is uniquely identified by a
[=texture=], [=mipmap level=], and
(for {{GPUTextureDimension/2d}} textures only) [=array layer=].

The **main usage rule** is that any [=subresource=]
at any given time can only be in either:
  - a combination of [=read-only usage=]s
  - a single [=mutating usage=]

Enforcing this rule allows the API to limit when data races can occur
when working with memory. That property makes applications written against
WebGPU more likely to run without modification on different platforms.

Generally, when an implementation processes an operation that uses a [=subresource=]
in a different way than its current usage allows, it schedules a transition of the resource
into the new state. In some cases, like within an open {{GPURenderPassEncoder}}, such a
transition is impossible due to the hardware limitations.
We define these places as <dfn dfn>usage scopes</dfn>:
each [=subresource=] must not change usage within the [=usage scope=].

For example, binding the same buffer for {{GPUBufferUsage/STORAGE|GPUBufferUsage.STORAGE}} as well as for
{{GPUBufferUsage/VERTEX|GPUBufferUsage.VERTEX}} within the same {{GPURenderPassEncoder}} would put the encoder
as well as the owning {{GPUCommandEncoder}} into the error state. Since
{{GPUBufferUsage/STORAGE|GPUBufferUsage.STORAGE}} is the only [=mutating usage=] for a buffer
that is valid inside a render pass, if it's present,
this buffer can't be used in any other way within this pass.

The [=subresources=] of textures included in the views provided to
{{GPURenderPassColorAttachmentDescriptor/attachment|GPURenderPassColorAttachmentDescriptor.attachment}} and
{{GPURenderPassColorAttachmentDescriptor/resolveTarget|GPURenderPassColorAttachmentDescriptor.resolveTarget}}
are considered to have {{GPUTextureUsage/OUTPUT_ATTACHMENT}}
for the [=usage scope=] of this render pass.

The <dfn dfn>physical size</dfn> of a {{GPUTexture}} [=subresource=] is the dimension of the {{GPUTexture}}
[=subresource=] in texels that includes the possible extra paddings to form complete [=texel blocks=] in the
[=subresource=].

  - For pixel-based {{GPUTextureFormat}}s, the [=physical size=] is always equal to the size of the [=subresource=]
    used in the sampling hardwares.
  - {{GPUTexture}}s in block-based compressed {{GPUTextureFormat}}s always have a [=mipmap level=] 0 whose {{GPUTexture/[[textureSize]]}}
    is a multiple of the [=texel block size=], but the lower mipmap levels might not be the multiple of the [=texel block size=] and can
    have paddings.

<div class="example">
Considering a {{GPUTexture}} in BC format whose {{GPUTexture/[[textureSize]]}} is {60, 60, 1}, when sampling
the {{GPUTexture}} at [=mipmap level=] 2, the sampling hardware uses {15, 15, 1} as the size of the [=subresource=],
while its [=physical size=] is {16, 16, 1} as the block-compression algorithm can only operate on 4x4 [=texel blocks=].
</div>

Issue(gpuweb/gpuweb#514): Document read-only states for depth views.

## Synchronization ## {#programming-model-synchronization}

For each [=subresource=] of a [=physical resource=], its set of
[=usage flags=] is tracked on the [=Queue timeline=].
<dfn dfn>Usage flags</dfn> are {{GPUBufferUsage}} or {{GPUTextureUsage}} flags,
according to the type of the subresource.

Issue: This section will need to be revised to support multiple queues.

On the [=Queue timeline=], there is an ordered sequence of [=usage scopes=].
Each item on the timeline is contained within exactly one scope.
For the duration of each scope, the set of [=usage flags=] of any given
[=subresource=] is constant.
A [=subresource=] may transition to new usages
at the boundaries between [=usage scope=]s.

This specification defines the following [=usage scopes=]:
  1. an individual command on a {{GPUCommandEncoder}}, such as {{GPUCommandEncoder/copyBufferToTexture()|GPUCommandEncoder.copyBufferToTexture}}.
  2. an individual command on a {{GPUComputePassEncoder}}, such as {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|GPUProgrammablePassEncoder.setBindGroup}}.
  3. the whole {{GPURenderPassEncoder}}.

Note: calling {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|GPUProgrammablePassEncoder.setBindGroup}}
adds the {{GPUBindGroup/[[usedBuffers]]}} and {{GPUBindGroup/[[usedTextures]]}} to the [=usage scope=]
regardless of whether the shader or {{GPUPipelineLayout}} actually depends on these bindings.
Similarly {{GPURenderEncoderBase/setIndexBuffer()|GPURenderEncoderBase.setIndexBuffer}}
add the index buffer to the usage scope (as {{GPUBufferUsage/INDEX|GPUBufferUsage.INDEX}})
regardless of whether the indexed draw calls are used afterwards.

The [=usage scopes=] are validated at {{GPUCommandEncoder/finish()|GPUCommandEncoder.finish}} time.
The implementation performs the <dfn dfn>usage scope validation</dfn> by composing
the set of all [=usage flags=] of each [=subresource=] used in the [=usage scope=].
A {{GPUValidationError}} is generated in the current scope with an appropriate error message
if that union contains a [=mutating usage=] combined with any other usage.


# Core Internal Objects # {#core-internal-objects}

## Adapters ## {#adapters}

An <dfn dfn>adapter</dfn> represents an implementation of WebGPU on the system.
Each adapter identifies both an instance of a hardware accelerator (e.g. GPU or CPU) and
an instance of a browser's implementation of WebGPU on top of that accelerator.

If an [=adapter=] becomes unavailable, it becomes [=invalid=].
Once invalid, it never becomes valid again.
Any [=devices=] on the adapter, and [=internal objects=] owned by those devices,
also become invalid.

Note:
An [=adapter=] may be a physical display adapter (GPU), but it could also be
a software renderer.
A returned [=adapter=] could refer to different physical adapters, or to
different browser codepaths or system drivers on the same physical adapters.
Applications can hold onto multiple [=adapters=] at once (via {{GPUAdapter}})
(even if some are [=invalid=]),
and two of these could refer to different instances of the same physical
configuration (e.g. if the GPU was reset or disconnected and reconnected).

An [=adapter=] has the following internal slots:

<dl dfn-type=attribute dfn-for=adapter>
    : <dfn>\[[extensions]]</dfn>, of type sequence<{{GPUExtensionName}}>, readonly
    ::
        The extensions which can be used to create devices on this adapter.

    : <dfn>\[[limits]]</dfn>, of type {{GPULimits}}, readonly
    ::
        The [=better|best=] limits which can be used to create devices on this adapter.

        Each adapter limit must be the same or [=better=] than its default value in {{GPULimits}}.
</dl>

[=Adapters=] are exposed via {{GPUAdapter}}.

## Devices ## {#devices}

A <dfn dfn>device</dfn> is the logical instantiation of an [=adapter=],
through which [=internal objects=] are created.
It can be shared across multiple [=agents=] (e.g. dedicated workers).

A [=device=] is the exclusive owner of all [=internal objects=] created from it:
when the [=device=] is lost, it and all objects created on it (directly, e.g.
{{GPUDevice/createTexture()}}, or indirectly, e.g. {{GPUTexture/createView()}}) become
[=invalid=].

Issue: Define "ownership".

A [=device=] has the following internal slots:

<dl dfn-type=attribute dfn-for=device>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        The [=adapter=] from which this device was created.

    : <dfn>\[[extensions]]</dfn>, of type sequence<{{GPUExtensionName}}>, readonly
    ::
        The extensions which can be used on this device.
        No additional extensions can be used, even if the underlying [=adapter=] can support them.

    : <dfn>\[[limits]]</dfn>, of type {{GPULimits}}, readonly
    ::
        The limits which can be used on this device.
        No [=better=] limits can be used, even if the underlying [=adapter=] can support them.
</dl>

<div algorithm>
    When <dfn dfn>a new device</dfn> |device| is created from [=adapter=] |adapter|
    with {{GPUDeviceDescriptor}} |descriptor|:

      - Set |device|.{{device/[[adapter]]}} to |adapter|.

      - Set |device|.{{device/[[extensions]]}} to |descriptor|.{{GPUDeviceDescriptor/extensions}}.

      - Set |device|.{{device/[[limits]]}} to |descriptor|.{{GPUDeviceDescriptor/limits}}.
</div>

[=Devices=] are exposed via {{GPUDevice}}.


# Initialization # {#initialization}

## Examples ## {#initialization-examples}

Issue:
Need a robust example like the one in ErrorHandling.md, which handles all situations.
Possibly also include a simple example with no handling.

## navigator.gpu ## {#navigator-gpu}

A {{GPU}} object is available via `navigator.gpu` on the {{Window}}:

<script type=idl>
[Exposed=Window]
partial interface Navigator {
    [SameObject] readonly attribute GPU gpu;
};
</script>

... as well as on dedicated workers:

<script type=idl>
[Exposed=DedicatedWorker]
partial interface WorkerNavigator {
    [SameObject] readonly attribute GPU gpu;
};
</script>

## GPU ## {#gpu-interface}

<dfn interface>GPU</dfn> is the entry point to WebGPU.

<script type=idl>
[Exposed=(Window, DedicatedWorker)]
interface GPU {
    Promise<GPUAdapter> requestAdapter(optional GPURequestAdapterOptions options = {});
};
</script>

{{GPU}} has the methods defined by the following sections.

### <dfn method for=GPU>requestAdapter(options)</dfn> ### {#requestadapter}

<div algorithm=GPU.requestAdapter>
    **Arguments:**
      - optional {{GPURequestAdapterOptions}} |options| = {}

    **Returns:** |promise|, of type Promise<{{GPUAdapter}}>.

    Requests an [=adapter=] from the user agent.
    The user agent chooses whether to return an adapter, and, if so,
    chooses according to the provided |options|.

    Returns [=a new promise=], |promise|.
    On the [=Device timeline=], the following steps occur:

      - If the user agent chooses to return an adapter:

          - The user agent chooses an [=adapter=] |adapter| according to the rules in
            [[#adapter-selection]].

          - |promise| [=resolves=] with a new {{GPUAdapter}} encapsulating |adapter|.

      - Otherwise, |promise| [=rejects=] with an {{OperationError}}.
</div>

#### Adapter Selection #### {#adapter-selection}

<dfn dictionary>GPURequestAdapterOptions</dfn>
provides hints to the user agent indicating what
configuration is suitable for the application.

<script type=idl>
dictionary GPURequestAdapterOptions {
    GPUPowerPreference powerPreference;
};
</script>

<script type=idl>
enum GPUPowerPreference {
    "low-power",
    "high-performance"
};
</script>

{{GPURequestAdapterOptions}} has the following members:

<dl dfn-type=dict-member dfn-for=GPURequestAdapterOptions>
    : <dfn>powerPreference</dfn>
    ::
        Optionally provides a hint indicating what class of [=adapter=] should be selected from
        the system's available adapters.

        The value of this hint may influence which adapter is chosen, but it must not
        influence whether an adapter is returned or not.

        Note:
        The primary utility of this hint is to influence which GPU is used in a multi-GPU system.
        For instance, some laptops have a low-power integrated GPU and a high-performance
        discrete GPU.

        Note:
        Depending on the exact hardware configuration, such as battery status and attached displays
        or removable GPUs, the user agent may select different [=adapters=] given the same power
        preference.
        Typically, given the same hardware configuration and state and
        `powerPreference`, the user agent is likely to select the same adapter.

        It must be one of the following values:

        <dl dfn-type=enum-value dfn-for=GPUPowerPreference>
            : `undefined` (or not present)
            ::
                Provides no hint to the user agent.

            : <dfn>"low-power"</dfn>
            ::
                Indicates a request to prioritize power savings over performance.

                Note:
                Generally, content should use this if it is unlikely to be constrained by drawing
                performance; for example, if it renders only one frame per second, draws only relatively
                simple geometry with simple shaders, or uses a small HTML canvas element.
                Developers are encouraged to use this value if their content allows, since it may
                significantly improve battery life on portable devices.

            : <dfn>"high-performance"</dfn>
            ::
                Indicates a request to prioritize performance over power consumption.

                Note:
                By choosing this value, developers should be aware that, for [=devices=] created on the
                resulting adapter, user agents are more likely to force device loss, in order to save
                power by switching to a lower-power adapter.
                Developers are encouraged to only specify this value if they believe it is absolutely
                necessary, since it may significantly decrease battery life on portable devices.
        </dl>
</dl>

## <dfn interface>GPUAdapter</dfn> ## {#gpu-adapter}

A {{GPUAdapter}} encapsulates an [=adapter=],
and describes its capabilities (extensions and limits).

To get a {{GPUAdapter}}, use {{GPU/requestAdapter()}}.

<script type=idl>
interface GPUAdapter {
    readonly attribute DOMString name;
    readonly attribute FrozenArray<GPUExtensionName> extensions;
    //readonly attribute GPULimits limits; Don't expose higher limits for now.

    Promise<GPUDevice> requestDevice(optional GPUDeviceDescriptor descriptor = {});
};
</script>

{{GPUAdapter}} has:

  - These attributes:
    <dl dfn-type=attribute dfn-for=GPUAdapter>
        : <dfn>name</dfn>
        ::
            A human-readable name identifying the adapter.
            The contents are implementation-defined.

        : <dfn>extensions</dfn>
        ::
            Accessor for `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[extensions]]}}.
    </dl>

  - These internal slots:
    <dl dfn-type=attribute dfn-for=GPUAdapter>
        : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
        ::
            An internal slot holding the [=adapter=] to which this {{GPUAdapter}}
            refers.
    </dl>

  - The methods defined by the following sub-sections.

### <dfn method for=GPUAdapter>requestDevice(optional descriptor)</dfn> ### {#requestdevice}

<div algorithm=GPUAdapter.requestDevice>
    <strong>|this|:</strong> of type {{GPUAdapter}}.

    **Arguments:**
        - optional {{GPUDeviceDescriptor}} |descriptor| = {}

    **Returns:** |promise|, of type Promise<{{GPUDevice}}>.

    Requests a [=device=] from the [=adapter=].

    Returns [=a new promise=], |promise|.
    On the [=Device timeline=], the following steps occur:

      - If the user agent can fulfill the request and
        the [$GPUAdapter.requestDevice/Valid Usage$] rules are met:

          - |promise| [=resolves=] to a new {{GPUDevice}} object encapsulating
            [=a new device=] with the capabilities described by |descriptor|.

      - Otherwise, |promise| [=rejects=] with an {{OperationError}}.

    <div class=validusage dfn-for=GPUAdapter.requestDevice>
        <dfn abstract-op>Valid Usage</dfn>

        Let |adapter| be |this|.{{GPUAdapter/[[adapter]]}}.

        - The set of {{GPUExtensionName}} values in
            |descriptor|.{{GPUDeviceDescriptor/extensions}}
            must be a subset of those in |adapter|.{{adapter/[[extensions]]}}.

        - For each type of limit in {{GPULimits}}, the value of that limit in
            |descriptor|.{{GPUDeviceDescriptor/limits}}
            must be no [=better=] than the value of that limit in
            |adapter|.{{adapter/[[limits]]}}.
    </div>
</div>

#### <dfn dictionary>GPUDeviceDescriptor</dfn> #### {#gpudevicedescriptor}

{{GPUDeviceDescriptor}} describes a device request.

<script type=idl>
dictionary GPUDeviceDescriptor : GPUObjectDescriptorBase {
    sequence<GPUExtensionName> extensions = [];
    GPULimits limits = {};
};
</script>

<dl dfn-type=dict-member dfn-for=GPUDeviceDescriptor>
    : <dfn>extensions</dfn>
    ::
        The set of {{GPUExtensionName}} values in this sequence defines the exact set of
        extensions that must be enabled on the device.

    : <dfn>limits</dfn>
    ::
        Defines the exact limits that must be enabled on the device.
</dl>

#### <dfn enum>GPUExtensionName</dfn> #### {#gpuextensionname}

Each {{GPUExtensionName}} identifies a set of functionality which, if available,
allows additional usages of WebGPU that would have otherwise been invalid.

<script type=idl>
enum GPUExtensionName {
    "texture-compression-bc",
    "pipeline-statistics-query"
};
</script>

<dl dfn-type=enum-value dfn-for=GPUExtensionName>
    : <dfn>"texture-compression-bc"</dfn>
    ::
        Issue: Write a spec section for this, and link to it.
</dl>

#### <dfn dictionary>GPULimits</dfn> #### {#gpulimits}

{{GPULimits}} describes various limits in the usage of WebGPU on a device.

One limit value may be <dfn dfn>better</dfn> than another.
For each limit, "better" is defined.

Note:
Setting "better" limits may not necessarily be desirable.
While they enable strictly more programs to be valid, they may have a performance impact.
Because of this, and to improve portability across devices and implementations,
applications should generally request the "worst" limits that work for their content.

<script type=idl>
dictionary GPULimits {
    GPUSize32 maxBindGroups = 4;
    GPUSize32 maxDynamicUniformBuffersPerPipelineLayout = 8;
    GPUSize32 maxDynamicStorageBuffersPerPipelineLayout = 4;
    GPUSize32 maxSampledTexturesPerShaderStage = 16;
    GPUSize32 maxSamplersPerShaderStage = 16;
    GPUSize32 maxStorageBuffersPerShaderStage = 4;
    GPUSize32 maxStorageTexturesPerShaderStage = 4;
    GPUSize32 maxUniformBuffersPerShaderStage = 12;
};
</script>

<dl dfn-type=dict-member dfn-for=GPULimits>
    : <dfn>maxBindGroups</dfn>
    ::
        The maximum number of {{GPUBindGroupLayout|GPUBindGroupLayouts}}
        allowed in {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxDynamicUniformBuffersPerPipelineLayout</dfn>
    ::
        The maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - {{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"uniform-buffer"}}, and
          - {{GPUBindGroupLayoutEntry/hasDynamicOffset}} is true,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxDynamicStorageBuffersPerPipelineLayout</dfn>
    ::
        The maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - {{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"storage-buffer"}}, and
          - {{GPUBindGroupLayoutEntry/hasDynamicOffset}} is true,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxSampledTexturesPerShaderStage</dfn>
    ::
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - {{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"sampled-texture"}}, and
          - {{GPUBindGroupLayoutEntry/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxSamplersPerShaderStage</dfn>
    ::
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - {{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"sampler"}}  or {{GPUBindingType/"comparison-sampler"}}, and
          - {{GPUBindGroupLayoutEntry/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxStorageBuffersPerShaderStage</dfn>
    ::
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - {{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"storage-buffer"}}, and
          - {{GPUBindGroupLayoutEntry/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxStorageTexturesPerShaderStage</dfn>
    ::
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - {{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"readonly-storage-texture"}} or
            {{GPUBindingType/"writeonly-storage-texture"}}, and
          - {{GPUBindGroupLayoutEntry/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxUniformBuffersPerShaderStage</dfn>
    ::
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - {{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/uniform-buffer}}, and
          - {{GPUBindGroupLayoutEntry/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].
</dl>

## <dfn interface>GPUDevice</dfn> ## {#gpu-device}

A {{GPUDevice}} encapsulates a [=device=] and exposes
the functionality of that device.

{{GPUDevice}} is the top-level interface through which [=WebGPU interfaces=] are created.

To get a {{GPUDevice}}, use {{GPUAdapter/requestDevice()}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker), Serializable]
interface GPUDevice : EventTarget {
    [SameObject] readonly attribute GPUAdapter adapter;
    readonly attribute FrozenArray<GPUExtensionName> extensions;
    readonly attribute object limits;

    [SameObject] readonly attribute GPUQueue defaultQueue;

    GPUBuffer createBuffer(GPUBufferDescriptor descriptor);
    GPUMappedBuffer createBufferMapped(GPUBufferDescriptor descriptor);
    GPUTexture createTexture(GPUTextureDescriptor descriptor);
    GPUSampler createSampler(optional GPUSamplerDescriptor descriptor = {});

    GPUBindGroupLayout createBindGroupLayout(GPUBindGroupLayoutDescriptor descriptor);
    GPUPipelineLayout createPipelineLayout(GPUPipelineLayoutDescriptor descriptor);
    GPUBindGroup createBindGroup(GPUBindGroupDescriptor descriptor);

    GPUShaderModule createShaderModule(GPUShaderModuleDescriptor descriptor);
    GPUComputePipeline createComputePipeline(GPUComputePipelineDescriptor descriptor);
    GPURenderPipeline createRenderPipeline(GPURenderPipelineDescriptor descriptor);

    GPUCommandEncoder createCommandEncoder(optional GPUCommandEncoderDescriptor descriptor = {});
    GPURenderBundleEncoder createRenderBundleEncoder(GPURenderBundleEncoderDescriptor descriptor);

    GPUQuerySet createQuerySet(GPUQuerySetDescriptor descriptor);
};
GPUDevice includes GPUObjectBase;
</script>

{{GPUDevice}} has:

  - These attributes:
    <dl dfn-type=attribute dfn-for=GPUDevice>
        : <dfn>adapter</dfn>
        ::
            The {{GPUAdapter}} from which this device was created.

        : <dfn>extensions</dfn>
        ::
            A sequence containing the {{GPUExtensionName}}s of the extensions
            supported by the device (i.e. the ones with which it was created).

        : <dfn>limits</dfn>
        ::
            A {{GPULimits}} object exposing the limits
            supported by the device (i.e. the ones with which it was created).
    </dl>

  - These internal slots:
    <dl dfn-type=attribute dfn-for=GPUDevice>
        : <dfn>\[[device]]</dfn>, of type [=device=], readonly
        ::
            The [=device=] that this {{GPUDevice}} refers to.
    </dl>

  - The methods listed in its WebIDL definition above,
    which are defined elsewhere in this document.

{{GPUDevice}} objects are [=serializable objects=].

<div algorithm>
    <dfn abstract-op>The steps to serialize a GPUDevice object</dfn>,
    given |value|, |serialized|, and |forStorage|, are:
     1. If |forStorage| is true, throw a "{{DataCloneError}}".
     1. Set |serialized|.device to the value of |value|.{{GPUDevice/[[device]]}}.
</div>

<div algorithm>
    <dfn abstract-op>The steps to deserialize a GPUDevice object</dfn>,
    given |serialized| and |value|, are:
     1. Set |value|.{{GPUDevice/[[device]]}} to |serialized|.device.
</div>


# Buffers # {#buffers}

## <dfn interface>GPUBuffer</dfn> ## {#buffer-interface}

Issue: define <dfn dfn>buffer</dfn> (internal object)

A {{GPUBuffer}} represents a block of memory that can be used in GPU operations.
Data is stored in linear layout, meaning that each byte of the allocation can be
addressed by its offset from the start of the {{GPUBuffer}}, subject to alignment
restrictions depending on the operation. Some {{GPUBuffer|GPUBuffers}} can be
mapped which makes the block of memory accessible via an {{ArrayBuffer}} called
its mapping.

{{GPUBuffer|GPUBuffers}} are created via
{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer(descriptor)}}
that returns a new buffer in the [=buffer state/mapped=] or [=buffer state/unmapped=] state.

<script type=idl>
[Serializable]
interface GPUBuffer {
    Promise<void> mapAsync(optional GPUSize64 offset = 0, optional GPUSize64 size = 0);
    ArrayBuffer getMappedRange(optional GPUSize64 offset = 0, optional GPUSize64 size = 0);
    void unmap();

    void destroy();
};
GPUBuffer includes GPUObjectBase;
</script>

{{GPUBuffer}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBuffer">
    : <dfn>\[[size]]</dfn> of type {{GPUSize64}}.
    ::
        The length of the {{GPUBuffer}} allocation in bytes.

    : <dfn>\[[usage]]</dfn> of type {{GPUBufferUsageFlags}}.
    ::
        The allowed usages for this {{GPUBuffer}}.

    : <dfn>\[[state]]</dfn> of type [=buffer state=].
    ::
        The current state of the {{GPUBuffer}}.

    : <dfn>\[[mapping]]</dfn> of type {{ArrayBuffer}} or {{Promise}} or `null`.
    ::
        The mapping for this {{GPUBuffer}}. The {{ArrayBuffer}} isn't directly accessible
        and is instead accessed through views into it, called the mapped ranges, that are
        stored in {{[[mapped_ranges]]}}

        Issue(gpuweb/gpuweb#605): Specify {{[[mapping]]}} in term of `DataBlock` similarly
        to `AllocateArrayBuffer`?

    : <dfn>\[[mapping_range]]</dfn> of type `sequence<Number>` or `null`.
    ::
        The range of this {{GPUBuffer}} that is mapped.

    : <dfn>\[[mapped_ranges]]</dfn> of type `sequence<ArrayBuffer>` or `null`.
    ::
        The {{ArrayBuffer}}s returned via {{getMappedRange}} to the application. They are tracked
        so they can be detached when {{unmap}} is called.
</dl>

Each {{GPUBuffer}} has a current <dfn dfn>buffer state</dfn> on the [=Content timeline=]
which is one of the following:

 - "<dfn dfn for="buffer state">mapped</dfn>" where the {{GPUBuffer}} is
     available for CPU operations on its content.
 - "<dfn dfn for="buffer state">mapped at creation</dfn>" where the {{GPUBuffer}} was
     just created and is available for CPU operations on its content.
 - "<dfn dfn for="buffer state">mapping pending</dfn>" where the {{GPUBuffer}} is
     being made available for CPU operations on its content.
 - "<dfn dfn for="buffer state">unmapped</dfn>" where the {{GPUBuffer}} is
     available for GPU operations.
 - "<dfn dfn for="buffer state">destroyed</dfn>" where the {{GPUBuffer}} is
     no longer available for any operations except {{GPUBuffer/destroy}}.

Note:
{{GPUBuffer/[[size]]}} and {{GPUBuffer/[[usage]]}} are immutable once the
{{GPUBuffer}} has been created.

<div class=note>
   Note: {{GPUBuffer}} has a state machine with the following states.
    ({{GPUBuffer/[[mapping]]}}, {{GPUBuffer/[[mapping_range]]}},
    and {{GPUBuffer/[[mapped_ranges]]}} are null when not specified.)

     - [=buffer state/unmapped=] and [=buffer state/destroyed=].
     - [=buffer state/mapped=] or [=buffer state/mapped at creation=] with an
        {{ArrayBuffer}} typed {{GPUBuffer/[[mapping]]}}, a sequence of two
        numbers in {{[[mapping_range]]}} and a sequence of {{ArrayBuffer}}
        in {{[[mapped_ranges]]}}
     - [=buffer state/mapping pending=] with a {{Promise}} typed {{[[mapping]]}}.
</div>

{{GPUBuffer}} is {{Serializable}}. It is a reference to an internal buffer
object, and {{Serializable}} means that the reference can be *copied* between
realms (threads/workers), allowing multiple realms to access it concurrently.
Since {{GPUBuffer}} has internal state (mapped, destroyed), that state is
internally-synchronized - these state changes occur atomically across realms.

## Buffer Creation ## {#buffer-creation}

### {{GPUBufferDescriptor}} ### {#GPUBufferDescriptor}

This specifies the options to use in creating a {{GPUBuffer}}.

<script type=idl>
dictionary GPUBufferDescriptor : GPUObjectDescriptorBase {
    required GPUSize64 size;
    required GPUBufferUsageFlags usage;
    boolean mappedAtCreation = false;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUBufferDescriptor</dfn>(device, descriptor)
        1. If device is lost return false.
        1. If any of the bits of |descriptor|'s {{GPUBufferDescriptor/usage}} aren't present in this device's [[allowed buffer usages]] return false.
        1. If both the {{GPUBufferUsage/MAP_READ}} and {{GPUBufferUsage/MAP_WRITE}} bits of |descriptor|'s {{GPUBufferDescriptor/usage}} attribute are set, return false.
        1. Return true.
</div>

## Buffer Usage ## {#buffer-usage}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferUsageFlags;
interface GPUBufferUsage {
    const GPUBufferUsageFlags MAP_READ      = 0x0001;
    const GPUBufferUsageFlags MAP_WRITE     = 0x0002;
    const GPUBufferUsageFlags COPY_SRC      = 0x0004;
    const GPUBufferUsageFlags COPY_DST      = 0x0008;
    const GPUBufferUsageFlags INDEX         = 0x0010;
    const GPUBufferUsageFlags VERTEX        = 0x0020;
    const GPUBufferUsageFlags UNIFORM       = 0x0040;
    const GPUBufferUsageFlags STORAGE       = 0x0080;
    const GPUBufferUsageFlags INDIRECT      = 0x0100;
    const GPUBufferUsageFlags QUERY_RESOLVE = 0x0200;
};
</script>

### <dfn method for=GPUDevice>createBuffer(descriptor)</dfn> ### {#GPUDevice-createBuffer}

<div algorithm="GPUDevice.createBuffer">
  **Arguments:**
    - {{GPUBufferDescriptor}} |descriptor|

  **Returns:** {{GPUBuffer}}

  1. If this call doesn't follow the [$createBuffer Valid Usage$]:

    1. Retun an error buffer.

    Issue(gpuweb/gpuweb#605): Explain that the resulting error buffer can still be mapped at creation.

  1. Let |b| be a new {{GPUBuffer}} object.
  1. Set |b|.{{GPUBuffer/[[size]]}} to |descriptor|.{{GPUBufferDescriptor/size}}.
  1. Set |b|.{{GPUBuffer/[[usage]]}} to |descriptor|.{{GPUBufferDescriptor/usage}}.
  1. If |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} is true:

    1. Set |b|.{{GPUBuffer/[[mapping]]}} to a new {{ArrayBuffer}} of size |b|.{{GPUBuffer/[[size]]}}.
    1. Set |b|.{{GPUBuffer/[[mapping_range]]}} to `[0, descriptor.size]`.
    1. Set |b|.{{GPUBuffer/[[mapped_ranges]]}} to `[]`.
    1. Set |b|.{{GPUBuffer/[[state]]}} to [=buffer state/mapped at creation=].

  1. Else:

    1. Set |b|.{{GPUBuffer/[[mapping]]}} to `null`.
    1. Set |b|.{{GPUBuffer/[[mapping_range]]}} to `null`.
    1. Set |b|.{{GPUBuffer/[[mapped_ranges]]}} to `null`.
    1. Set |b|.{{GPUBuffer/[[state]]}} to [=buffer state/unmapped=].

  1. Set each byte of |b|'s allocation to zero.
  1. Return |b|.

  Note: it is valid to set {{GPUBufferDescriptor/mappedAtCreation}} to true without {{GPUBufferUsage/MAP_READ}}
    or {{GPUBufferUsage/MAP_WRITE}} in {{GPUBufferDescriptor/usage}}. This can be used to set the buffer's
    initial data.

  <div algorithm class=validusage>
    <dfn abstract-op>createBuffer Valid Usage</dfn>
      Given a {{GPUDevice}} |this| and a {{GPUBufferDescriptor}} |descriptor|
      the following validation rules apply:

      1. |this| must be a [=valid=] {{GPUDevice}}.
      1. |descriptor|.{{GPUBufferDescriptor/usage}} must be a subset of |this|.[[allowed buffer usages]].
      1. If |descriptor|.{{GPUBufferDescriptor/usage}} contains {{GPUBufferUsage/MAP_READ}} then
        the only other usage it may contain is {{GPUBufferUsage/COPY_DST}}.
      1. If |descriptor|.{{GPUBufferDescriptor/usage}} contains {{GPUBufferUsage/MAP_WRITE}} then
        the only other usage it may contain is {{GPUBufferUsage/COPY_SRC}}.

      Issue(gpuweb/gpuweb#605): Explain what are a {{GPUDevice}}'s `[[allowed buffer usages]]`
    </dfn>
  </div>
</div>

## Buffer Destruction ## {#buffer-destruction}

An application that no longer requires a {{GPUBuffer}} can choose to lose
access to it before garbage collection by calling {{GPUBuffer/destroy()}}.

Note: This allows the user agent to reclaim the GPU memory associated with the {{GPUBuffer}}
once all previously submitted operations using it are complete.

### <dfn method for=GPUBuffer>destroy()</dfn> ### {#GPUBuffer-destroy}

<div algorithm="GPUBuffer.destroy">
  <strong>|this|:</strong> of type {{GPUBuffer}}.

  1. If the |this|.{{[[state]]}} is [=buffer state/mapped=] or [=buffer state/mapped at creation=]:

    1. Run the steps to unmap |this|

  1. Set |this|.{{[[state]]}} to [=buffer state/destroyed=]

  Issue: Handle error buffers once we have a description of the error monad.
</div>

## Buffer Mapping ## {#buffer-mapping}

An application can request to map a {{GPUBuffer}} so that they can access its
content via {{ArrayBuffer}}s that represent part of the {{GPUBuffer}}'s
allocations. Mapping a {{GPUBuffer}} is requested asynchronously with
{{GPUBuffer/mapAsync}} so that the user agent can ensure the GPU
finished using the {{GPUBuffer}} before the application can access its content.
Once the {{GPUBuffer}} is mapped the application can synchronously ask for access
to ranges of its content with {{GPUBuffer/getMappedRange}}. A mapped {{GPUBuffer}}
cannot be used by the GPU and must be unmapped using {{GPUBuffer/unmap}} before
work using it can be submitted to the [=Queue timeline=].

Issue(gpuweb/gpuweb#605): Add client-side validation that a mapped buffer can
  only be unmapped and destroyed on the worker on which it was mapped. Likewise
  {{GPUBuffer/getMappedRange}} can only be called on that worker.

### <dfn method for=GPUBuffer>mapAsync(offset, size)</dfn> ### {#GPUBuffer-mapAsync}

<div algorithm="GPUBuffer.mapAsync">

  Issue(gpuweb/gpuweb#605): There is concern that it should be clearer at a {{GPUBuffer/mapAsync}}
    call point if it is meant for reading or writing because the semantics are very different.
    Alternatives suggested include splitting into `mapReadAsync` vs. `mapWriteAsync`, or
    adding a `GPUMapFlags` as an argument to the call that can later be used to extend the method.

  <strong>|this|:</strong> of type {{GPUBuffer}}.

  **Arguments:**
    - {{GPUSize64}} |offset|
    - {{GPUSize64}} |size|

  **Returns:** {{Promise}}

  Issue(gpuweb/gpuweb#605): Handle error buffers once we have a description of the error monad.

  1. If |size| is 0 and |offset| is less than |this|.{{[[size]]}}:

    1. Set |size| to |this|.{{[[size]]}} - |offset|

  1. If this call doesn't follow [$mapAsync Valid Usage$]:

    1. Record a validation error on the current scope.
    1. Return [=a promise rejected with=] an {{AbortError}} on the [=Device timeline=].

  1. Let |p| be a new {{Promise}}.
  1. Set |this|.{{[[mapping]]}} to |p|.
  1. Set |this|.{{[[state]]}} to [=buffer state/mapping pending=].
  1. Enqueue an operation on the default queue's [=Queue timeline=] that will execute the following:

     1. If |this|.{{[[state]]}} is [=buffer state/mapping pending=]:

        1. Let |m| be a new {{ArrayBuffer}} of size |size|.
        1. Set the content of |m| to the content of |this|'s allocation starting at offset |offset| and for |size| bytes.
        1. Set |this|.{{[[mapping]]}} to |m|.
        1. Set |this|.{{[[state]]}} to [=buffer state/mapped=].
        1. Set |this|.{{[[mapping_range]]}} to `[start, offset]`.
        1. Set |this|.{{[[mapped_ranges]]}} to `[]`.
        1. Resolve |p|.

  1. Return |p|.

  <div algorithm class=validusage>
    <dfn abstract-op>mapAsync Valid Usage</dfn>

      Given a {{GPUBuffer}} |this|, a {{GPUSize64}} |offset| and a {{GPUSize64}} |size|
      the following validation rules apply:

      1. |this| must be a [=valid=] {{GPUBuffer}}.
      1. |offset| must be a multiple of 4.
      1. |size| must be a multiple of 4.
      1. |offset| + |size| must be less or equal to |this|.{{[[size]]}}
      1. |this|.{{[[usage]]}} must contain {{GPUBufferUsage/MAP_READ}} or {{GPUBufferUsage/MAP_WRITE}}.
      1. |this|.{{[[state]]}} must be [=buffer state/unmapped=]

    </dfn>
  </div>
</div>

### <dfn method for=GPUBuffer>getMappedRange(start, offset)</dfn> ### {#GPUBuffer-getMappedRange}

<div algorithm="GPUBuffer.getMappedRange">
  <strong>|this|:</strong> of type {{GPUBuffer}}.

  **Arguments:**
    - {{GPUSize64}} |offset|
    - {{GPUSize64}} |size|

  **Returns:** {{ArrayBuffer}}

  1. If this call doesn't follow the [$getMappedRange Valid Usage$]:

    1. Throw an {{OperationError}}.

  1. Let |m| be a new {{ArrayBuffer}} of size |size| pointing at the content of |this|.{{[[mapping]]}} at offset |offset| - |this|.{{[[mapping_range]]}}[0].
  1. Append |m| to |this|.{{[[mapped_ranges]]}}.
  1. Return |m|.

  <div algorithm class=validusage>
    <dfn abstract-op>getMappedRange Valid Usage</dfn>

      Given a {{GPUBuffer}} |this|, a {{GPUSize64}} |offset| and a {{GPUSize64}} |size|
      the following validation rules apply:

      1. |this|.{{[[state]]}} must be [=buffer state/mapped=] or [=buffer state/mapped at creation=].
      1. |offset| must be a multiple of 8.
      1. |size| must be a multiple of 4.
      1. |offset| must be greater than or equal to |this|.{{[[mapping_range]]}}[0].
      1. |offset| + |size| must be less than or equal to |this|.{{[[mapping_range]]}}[0] + |this|.{{[[mapping_range]]}}[1].
      1. [|offset|, |offset| + |size|) must not overlap another range in |this|.{{[[mapped_ranges]]}}.

      Note: It is valid to get mapped ranges of an error {{GPUBuffer}} that is [=buffer state/mapped at creation=] because
      the [=Content timeline=] might not know it is an error {{GPUBuffer}}.

    </dfn>
  </div>
</div>

### <dfn method for=GPUBuffer>unmap()</dfn> ### {#GPUBuffer-unmap}

<div algorithm="GPUBuffer.unmap">
  <strong>|this|:</strong> of type {{GPUBuffer}}.

  1. If this call doesn't follow [$unmap Valid Usage$]:

    1. Record a validation error on the current scope.
    1. Return.

  1. If |this|.{{[[state]]}} is [=buffer state/mapping pending=]:

    1. [=Reject=] {{[[mapping]]}} with an {{OperationError}}.
    1. Set |this|.{{[[mapping]]}} to null.

  1. If |this|.{{[[state]]}} is [=buffer state/mapped=] or [=buffer state/mapped at creation=]:

    1. If one of the two following conditions holds:

        1. |this|.{{[[state]]}} is [=buffer state/mapped at creation=]
        1. |this|.{{[[state]]}} is [=buffer state/mapped=] and |this|.{{[[usage]]}} contains {{GPUBufferUsage/MAP_WRITE}}

    1. Then:

        1. Enqueue an operation on the default queue's [=Queue timeline=] that updates the |this|.{{[[mapping_range]]}}
            of |this|'s allocation to the content of |this|.{{[[mapping]]}}.

    1. Detach each {{ArrayBuffer}} in |this|.{{[[mapped_ranges]]}} from its content.
    1. Set |this|.{{[[mapping]]}} to null.
    1. Set |this|.{{[[mapping_range]]}} to null.
    1. Set |this|.{{[[mapped_ranges]]}} to null.

  1. Set |this|.{{[[state]]}} to [=buffer state/unmapped=].

  Note: When a {{GPUBufferUsage/MAP_READ}} buffer (not currently mapped at creation) is unmapped,
    any local modifications done by the application to the mapped ranges {{ArrayBuffer}} are
    discarded and will not affect the content of follow-up mappings.

  <div algorithm class=validusage>
    <dfn abstract-op>unmap Valid Usage</dfn>

      Given a {{GPUBuffer}} the following validation rules apply:

      1. |this|.{{[[state]]}} must not be [=buffer state/unmapped=]
      1. |this|.{{[[state]]}} must not be [=buffer state/destroyed=]

      Note: It is valid to unmap an error {{GPUBuffer}} that is [=buffer state/mapped at creation=] because
      the [=Content timeline=] might not know it is an error {{GPUBuffer}}.

    </dfn>
  </div>
</div>

# Textures and Texture Views # {#textures}

Issue: define <dfn dfn>texture</dfn> (internal object)

Issue: define <dfn dfn>mipmap level</dfn>, <dfn dfn>array layer</dfn>, <dfn dfn>slice</dfn> (concepts)

## <dfn interface>GPUTexture</dfn> ## {#texture-interface}

<script type=idl>
[Serializable]
interface GPUTexture {
    GPUTextureView createView(optional GPUTextureViewDescriptor descriptor = {});

    void destroy();
};
GPUTexture includes GPUObjectBase;
</script>

{{GPUTexture}} has the following internal slots:
<dl dfn-type=attribute dfn-for="GPUTexture">
    : <dfn>\[[textureSize]]</dfn> of type {{GPUExtent3D}}.
    ::
        The size of the {{GPUTexture}} in texels in [=mipmap level=] 0.

    : <dfn>\[[mipLevelCount]]</dfn> of type {{GPUIntegerCoordinate}}.
    ::
        The total number of the mipmap levels of the {{GPUTexture}}.

    : <dfn>\[[sampleCount]]</dfn> of type {{GPUSize32}}.
    ::
        The number of samples in each texel of the {{GPUTexture}}.

    : <dfn>\[[dimension]]</dfn> of type {{GPUTextureDimension}}.
    ::
        The dimension of the {{GPUTexture}}.

    : <dfn>\[[format]]</dfn> of type {{GPUTextureFormat}}.
    ::
        The format of the {{GPUTexture}}.

    : <dfn>\[[textureUsage]]</dfn> of type {{GPUTextureUsageFlags}}.
    ::
        The allowed usages for this {{GPUTexture}}.

</dl>

### Texture Creation ### {#texture-creation}

<script type=idl>
dictionary GPUTextureDescriptor : GPUObjectDescriptorBase {
    required GPUExtent3D size;
    GPUIntegerCoordinate mipLevelCount = 1;
    GPUSize32 sampleCount = 1;
    GPUTextureDimension dimension = "2d";
    required GPUTextureFormat format;
    required GPUTextureUsageFlags usage;
};
</script>

<script type=idl>
enum GPUTextureDimension {
    "1d",
    "2d",
    "3d"
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUTextureUsageFlags;
interface GPUTextureUsage {
    const GPUTextureUsageFlags COPY_SRC          = 0x01;
    const GPUTextureUsageFlags COPY_DST          = 0x02;
    const GPUTextureUsageFlags SAMPLED           = 0x04;
    const GPUTextureUsageFlags STORAGE           = 0x08;
    const GPUTextureUsageFlags OUTPUT_ATTACHMENT = 0x10;
};
</script>

## GPUTextureView ## {#gpu-textureview}

<script type=idl>
interface GPUTextureView {
};
GPUTextureView includes GPUObjectBase;
</script>

### Texture View Creation ### {#texture-view-creation}

<script type=idl>
dictionary GPUTextureViewDescriptor : GPUObjectDescriptorBase {
    GPUTextureFormat format;
    GPUTextureViewDimension dimension;
    GPUTextureAspect aspect = "all";
    GPUIntegerCoordinate baseMipLevel = 0;
    GPUIntegerCoordinate mipLevelCount = 0;
    GPUIntegerCoordinate baseArrayLayer = 0;
    GPUIntegerCoordinate arrayLayerCount = 0;
};
</script>

Issue: Make this a standalone algorithm used in the createView algorithm.

Issue: The references to GPUTextureDescriptor here should actually refer to
internal slots of a [=texture=] internal object once we have one.

<div algorithm="resolving GPUTextureViewDescriptor defaults">

  * {{GPUTextureViewDescriptor/format}}:
    If unspecified, defaults to |texture|.{{GPUTextureDescriptor/format}}.

  * {{GPUTextureViewDescriptor/dimension}}:
    If unspecified:
      - If |texture|.{{GPUTextureDescriptor/dimension}} is {{GPUTextureDimension/"1d"}},
        defaults to {{GPUTextureViewDimension/"1d"}}.
      - If |texture|.{{GPUTextureDescriptor/dimension}} is {{GPUTextureDimension/"2d"}}:
          - If |texture|.{{GPUTextureDescriptor/size}}.[=Extent3D/depth=] is greater than 1
            and {{GPUTextureViewDescriptor/arrayLayerCount}} is 0,
            defaults to {{GPUTextureViewDimension/"2d-array"}}.
          - Otherwise, defaults to {{GPUTextureViewDimension/"2d"}}.
      - If |texture|.{{GPUTextureDescriptor/dimension}} is {{GPUTextureDimension/"3d"}},
        defaults to {{GPUTextureViewDimension/"3d"}}.

  * {{GPUTextureViewDescriptor/mipLevelCount}}:
    If 0, defaults to |texture|.{{GPUTextureDescriptor/mipLevelCount}} &minus; {{GPUTextureViewDescriptor/baseMipLevel}}.

  * {{GPUTextureViewDescriptor/arrayLayerCount}}:
    If 0, defaults to |texture|.{{GPUTextureDescriptor/size}}.[=Extent3D/depth=] &minus; {{GPUTextureViewDescriptor/baseArrayLayer}}.

</div>

<script type=idl>
enum GPUTextureViewDimension {
    "1d",
    "2d",
    "2d-array",
    "cube",
    "cube-array",
    "3d"
};
</script>

<script type=idl>
enum GPUTextureAspect {
    "all",
    "stencil-only",
    "depth-only"
};
</script>

### {{GPUTexture}}.<dfn method for=GPUTexture>createView(descriptor)</dfn> ### {#textureview-createview}

<div algorithm=GPUTexture.createView>
    <strong>|this|:</strong> of type {{GPUTexture}}.

    **Arguments:**
        - optional {{GPUTextureViewDescriptor}} |descriptor|

    **Returns:** |view|, of type {{GPUTextureView}}.

    Issue: write definition. |this| |descriptor| |view|
</div>

## Texture Formats ## {#texture-formats}

The name of the format specifies the order of components, bits per component,
and data type for the component.

  * `r`, `g`, `b`, `a` = red, green, blue, alpha
  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

If the format has the `-srgb` suffix, then sRGB conversions from gamma to linear
and vice versa are applied during the reading and writing of color values in the
shader. Compressed texture formats are provided by extensions. Their naming
should follow the convention here, with the texture name as a prefix. e.g.
`etc2-rgba8unorm`.

The <dfn dfn>texel block</dfn> is a single addressable element of the textures in pixel-based {{GPUTextureFormat}}s,
and a single compressed block of the textures in block-based compressed {{GPUTextureFormat}}s.

The <dfn dfn>texel block width</dfn> and <dfn dfn>texel block height</dfn> specifies the dimension of one [=texel block=].
  - For pixel-based {{GPUTextureFormat}}s, the [=texel block width=] and [=texel block height=] are always 1.
  - For block-based compressed {{GPUTextureFormat}}s, the [=texel block width=] is the number of texels in each row of one [=texel block=],
    and the [=texel block height=] is the number of texel rows in one [=texel block=].

The <dfn dfn>texel block size</dfn> of a {{GPUTextureFormat}} is the number of bytes to store one [=texel block=].
The [=texel block size=] of each {{GPUTextureFormat}} is constant except for {{GPUTextureFormat/"depth24plus"}} and
{{GPUTextureFormat/"depth24plus-stencil8"}}.

<script type=idl>
enum GPUTextureFormat {
    // 8-bit formats
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",

    // 16-bit formats
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",

    // 32-bit formats
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    // Packed 32-bit formats
    "rgb10a2unorm",
    "rg11b10float",

    // 64-bit formats
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",

    // 128-bit formats
    "rgba32uint",
    "rgba32sint",
    "rgba32float",

    // Depth and stencil formats
    "depth32float",
    "depth24plus",
    "depth24plus-stencil8"
};
</script>

  * The `depth24plus` family of formats ({{GPUTextureFormat/depth24plus}} and
    {{GPUTextureFormat/depth24plus-stencil8}})
    must have a depth-component precision of
    1 ULP &le; 1 / (2<sup>24</sup>).

    Note: This is unlike the 24-bit unsigned normalized format family typically
    found in native APIs, which has a precision of
    1 ULP = 1 / (2<sup>24</sup> &minus; 1).

<script type=idl>
enum GPUTextureComponentType {
    "float",
    "sint",
    "uint"
};
</script>


# Samplers # {#samplers}

## GPUSampler ## {#sampler}

<script type=idl>
interface GPUSampler {
};
GPUSampler includes GPUObjectBase;
</script>


{{GPUSampler}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUSampler">
    : <dfn>\[[compareEnable]]</dfn> of type {{boolean}}.
    ::
        Whether the {{GPUSampler}} is used as a comparison sampler.
</dl>

### Creation ### {#sampler-creation}

<script type=idl>
dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
    GPUAddressMode addressModeU = "clamp-to-edge";
    GPUAddressMode addressModeV = "clamp-to-edge";
    GPUAddressMode addressModeW = "clamp-to-edge";
    GPUFilterMode magFilter = "nearest";
    GPUFilterMode minFilter = "nearest";
    GPUFilterMode mipmapFilter = "nearest";
    float lodMinClamp = 0;
    float lodMaxClamp = 0xffffffff; // TODO: What should this be? Was Number.MAX_VALUE.
    GPUCompareFunction compare;
};
</script>

### {{GPUDevice}}.<dfn method for=GPUDevice>createSampler(descriptor)</dfn> ### {#sampler-createsampler}

<div algorithm=GPUDevice.createSampler>
    **Arguments:**
        - optional {{GPUSamplerDescriptor}} |descriptor| = {}

    **Returns:** {{GPUSampler}}

    1. Let |s| be a new {{GPUSampler}} object.
    1. Set the {{GPUSampler/[[compareEnable]]}} slot of |s| to false if the {{GPUSamplerDescriptor/compare}} attribute
            of |descriptor| is null or undefined. Otherwise, set it to true.
    1. Return |s|.

    <div class=validusage dfn-for=GPUDevice.createSampler>
        <dfn abstract-op>Valid Usage</dfn>
    </div>
</div>

<script type=idl>
enum GPUAddressMode {
    "clamp-to-edge",
    "repeat",
    "mirror-repeat"
};
</script>

<script type=idl>
enum GPUFilterMode {
    "nearest",
    "linear"
};
</script>

<script type=idl>
enum GPUCompareFunction {
    "never",
    "less",
    "equal",
    "less-equal",
    "greater",
    "not-equal",
    "greater-equal",
    "always"
};
</script>


# Resource Binding # {#bindings}

## GPUBindGroupLayout ## {#bind-group-layout}

A {{GPUBindGroupLayout}} defines the interface between a set of resources bound in a {{GPUBindGroup}} and their accessibility in shader stages.

<script type=idl>
[Serializable]
interface GPUBindGroupLayout {
};
GPUBindGroupLayout includes GPUObjectBase;
</script>

### Creation ### {#bind-group-layout-creation}

A {{GPUBindGroupLayout}} is created via {{GPUDevice/createBindGroupLayout()|GPUDevice.createBindGroupLayout()}}.

<script type=idl>
dictionary GPUBindGroupLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayoutEntry> entries;
};
</script>

A {{GPUBindGroupLayoutEntry}} describes a single shader resource binding to be included in a {{GPUBindGroupLayout}}.

<script type=idl>
dictionary GPUBindGroupLayoutEntry {
    required GPUIndex32 binding;
    required GPUShaderStageFlags visibility;
    required GPUBindingType type;
    GPUTextureViewDimension viewDimension = "2d";
    GPUTextureComponentType textureComponentType = "float";
    GPUTextureFormat storageTextureFormat;
    boolean multisampled = false;
    boolean hasDynamicOffset = false;
};
</script>

  * {{GPUBindGroupLayoutEntry/binding}}:
    A unique identifier for a resource binding within a {{GPUBindGroupLayoutEntry}}, a corresponding {{GPUBindGroupEntry}}, and shader stages.

  * {{GPUBindGroupLayoutEntry/visibility}}:
    A bitset of the members of {{GPUShaderStage}}. Each set bit indicates that a {{GPUBindGroupLayoutEntry}}'s resource will be accessible from the
    associated shader stage.

<script type=idl>
typedef [EnforceRange] unsigned long GPUShaderStageFlags;
interface GPUShaderStage {
    const GPUShaderStageFlags VERTEX   = 0x1;
    const GPUShaderStageFlags FRAGMENT = 0x2;
    const GPUShaderStageFlags COMPUTE  = 0x4;
};
</script>

  * {{GPUBindGroupLayoutEntry/type}}:
    A member of {{GPUBindingType}} that indicates the intended usage of a resource binding in its visible {{GPUShaderStage}}s.

<script type=idl>
enum GPUBindingType {
    "uniform-buffer",
    "storage-buffer",
    "readonly-storage-buffer",
    "sampler",
    "comparison-sampler",
    "sampled-texture",
    "readonly-storage-texture",
    "writeonly-storage-texture"
    // TODO: other binding types
};
</script>

  * {{GPUBindGroupLayoutEntry/viewDimension}}, {{GPUBindGroupLayoutEntry/multisampled}}:
    Describes the dimensionality of texture view bindings, and indicates if they are multisampled.

    Note: This allows Metal-based implementations to back the respective bind
    groups with `MTLArgumentBuffer` objects that are more efficient to bind at
    run-time.

  * {{GPUBindGroupLayoutEntry/hasDynamicOffset}}:
    For {{GPUBindingType/uniform-buffer}}, {{GPUBindingType/storage-buffer}}, and {{GPUBindingType/readonly-storage-buffer}} bindings,
    indicates that the binding has a dynamic offset. One offset must be passed to
    setBindGroup for each dynamic binding in increasing order of
    {{GPUBindGroupLayoutEntry/binding}} number.

A {{GPUBindGroupLayout}} object has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBindGroupLayout">
    : <dfn>\[[entryMap]]</dfn> of type map<u32, {{GPUBindGroupLayoutEntry}}>.
    ::
        The map of binding indices pointing to the {{GPUBindGroupLayoutEntry}}s,
        which this {{GPUBindGroupLayout}} describes.
</dl>

### {{GPUDevice/createBindGroupLayout()|GPUDevice.createBindGroupLayout(GPUBindGroupLayoutDescriptor)}} ### {#GPUDevice-createBindGroupLayout}

<div algorithm="GPUDevice.createBindGroupLayout">
    <strong>this:</strong> of type {{GPUDevice}}.

    **Arguments:**
        - {{GPUBindGroupLayoutDescriptor}} |descriptor|

    **Returns:** {{GPUBindGroupLayout}}.

    The <dfn method for="GPUDevice">createBindGroupLayout(|descriptor|)</dfn> method is used to create {{GPUBindGroupLayout}}s.

    1. Ensure [=bind group layout device validation=] is not violated.
    1. Let |layout| be a new valid {{GPUBindGroupLayout}} object.
    1. For each {{GPUBindGroupLayoutEntry}} |bindingDescriptor| in |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}}:
        1. Ensure |bindingDescriptor|.{{GPUBindGroupLayoutEntry/binding}} does not violate [=binding validation=].
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/visibility}} includes {{GPUShaderStage/VERTEX}}
            , ensure [=vertex shader binding validation=] is not violated.
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/uniform-buffer}}:
            1. Ensure [=uniform buffer validation=] is not violated.
            1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/hasDynamicOffset}} is `true`, ensure [=dynamic uniform buffer validation=] is not violated.
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/storage-buffer}} or {{GPUBindingType/readonly-storage-buffer}}:
            1. Ensure [=storage buffer validation=] is not violated.
            1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/hasDynamicOffset}} is `true`, ensure [=dynamic storage buffer validation=] is not violated.
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/sampled-texture}}
            , ensure [=sampled texture validation=] is not violated.
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/readonly-storage-texture}} or {{GPUBindingType/writeonly-storage-texture}}
            , ensure [=storage texture validation=] is not violated.
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/sampler}}
            , ensure [=sampler validation=] is not violated.
        1. Insert |bindingDescriptor| into |layout|.{{GPUBindGroupLayout/[[entryMap]]}}
            with the key of |bindingDescriptor|/{{GPUBindGroupLayoutEntry/binding}}.
    1. Return |layout|.

    <div class=validusage dfn-for=GPUDevice.createBindGroupLayout>
        <dfn abstract-op>Valid Usage</dfn>

        If any of the following conditions are violated:
            1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
            1. Create a new [=invalid=] {{GPUBindGroupLayout}} and return the result.

        <dfn>bind group layout device validation</dfn>: The {{GPUDevice}} must not be lost.

        <dfn>binding validation</dfn>: Each |bindingDescriptor|.{{GPUBindGroupLayoutEntry/binding}} in |descriptor| must be unique.

        <dfn>vertex shader binding validation</dfn>: {{GPUBindingType/storage-buffer}} is not allowed.

        <dfn>uniform buffer validation</dfn>: There must be {{GPULimits/maxUniformBuffersPerShaderStage|GPULimits.maxUniformBuffersPerShaderStage}} or
            fewer |bindingDescriptor|s of type {{GPUBindingType/uniform-buffer}} visible on each shader stage in |descriptor|.

        <dfn>dynamic uniform buffer validation</dfn>: There must be {{GPULimits/maxDynamicUniformBuffersPerPipelineLayout|GPULimits.maxDynamicUniformBuffersPerPipelineLayout}} or
                fewer |bindingDescriptor|s of type {{GPUBindingType/uniform-buffer}} with {{GPUBindGroupLayoutEntry/hasDynamicOffset}} set to `true` in
                |descriptor| that are visible to any shader stage.

        <dfn>storage buffer validation</dfn>: There must be {{GPULimits/maxStorageBuffersPerShaderStage|GPULimits.maxStorageBuffersPerShaderStage}} or
            fewer |bindingDescriptor|s of type {{GPUBindingType/storage-buffer}} visible on each shader stage in |descriptor|.

        <dfn>dynamic storage buffer validation</dfn>: There must be {{GPULimits/maxDynamicStorageBuffersPerPipelineLayout|GPULimits.maxDynamicStorageBuffersPerPipelineLayout}} or
                fewer |bindingDescriptor|s of type {{GPUBindingType/storage-buffer}} with {{GPUBindGroupLayoutEntry/hasDynamicOffset}} set to `true`
                in |descriptor| that are visible to any shader stage.

        <dfn>sampled texture validation</dfn>: There must be {{GPULimits/maxSampledTexturesPerShaderStage|GPULimits.maxSampledTexturesPerShaderStage}} or
            fewer |bindingDescriptor|s of type {{GPUBindingType/sampled-texture}} visible on each shader stage in |descriptor|.
            |bindingDescriptor|.{{GPUBindGroupLayoutEntry/hasDynamicOffset}} must be `false`.

        <dfn>storage texture validation</dfn>: There must be {{GPULimits/maxStorageTexturesPerShaderStage|GPULimits.maxStorageTexturesPerShaderStage}} or
            fewer |bindingDescriptor|s of type {{GPUBindingType/readonly-storage-texture}} and {{GPUBindingType/writeonly-storage-texture}} visible on each shader stage in |descriptor|.
            |bindingDescriptor|.{{GPUBindGroupLayoutEntry/hasDynamicOffset}} must be `false`.

        <dfn>sampler validation</dfn>: There must be {{GPULimits/maxSamplersPerShaderStage|GPULimits.maxSamplersPerShaderStage}} or
            fewer |bindingDescriptor|s of type {{GPUBindingType/sampler}} visible on each shader stage in |descriptor|.
            |bindingDescriptor|.{{GPUBindGroupLayoutEntry/hasDynamicOffset}} must be `false`.
    </div>
</div>

### Compatibility ### {#bind-group-compatibility}

<div algorithm>
Two {{GPUBindGroupLayout}} objects |a| and |b| are considered <dfn dfn>group-equivalent</dfn>
if and only if, for any binding number |binding|, one of the following is true:
    - it's missing from both |a|.{{GPUBindGroupLayout/[[entryMap]]}} and |b|.{{GPUBindGroupLayout/[[entryMap]]}}.
    - |a|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|] is [=entry-equivalent=] to |b|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|]
</div>

<div algorithm>
Two {{GPUBindGroupLayoutEntry}} entries |a| and |b| are considered <dfn dfn>entry-equivalent</dfn> if all of the conditions are true:

    1. |a|.{{GPUBindGroupLayoutEntry/binding}} == |b|.{{GPUBindGroupLayoutEntry/binding}}
    1. |a|.{{GPUBindGroupLayoutEntry/visibility}} == |b|.{{GPUBindGroupLayoutEntry/visibility}}
    1. |a|.{{GPUBindGroupLayoutEntry/type}} == |b|.{{GPUBindGroupLayoutEntry/type}}
    1. if |a|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"uniform-buffer"}}, {{GPUBindingType/"storage-buffer"}}, or {{GPUBindingType/"readonly-storage-buffer"}}, then:
        - |a|.{{GPUBindGroupLayoutEntry/hasDynamicOffset}} == |b|.{{GPUBindGroupLayoutEntry/hasDynamicOffset}}
    1. if |a|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"sampled-texture"}}, then:
        - |a|.{{GPUBindGroupLayoutEntry/viewDimension}} == |b|.{{GPUBindGroupLayoutEntry/viewDimension}}
        - |a|.{{GPUBindGroupLayoutEntry/textureComponentType}} == |b|.{{GPUBindGroupLayoutEntry/textureComponentType}}
        - |a|.{{GPUBindGroupLayoutEntry/multisampled}} == |b|.{{GPUBindGroupLayoutEntry/multisampled}}
    1. if |a|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"readonly-storage-texture"}} or {{GPUBindingType/"writeonly-storage-texture"}}, then:
        - |a|.{{GPUBindGroupLayoutEntry/viewDimension}} == |b|.{{GPUBindGroupLayoutEntry/viewDimension}}
        - |a|.{{GPUBindGroupLayoutEntry/storageTextureFormat}} == |b|.{{GPUBindGroupLayoutEntry/storageTextureFormat}}
</div>

If bind groups layouts are [=group-equivalent=] they can be interchangeably used in all contents.

## GPUBindGroup ## {#gpu-bind-group}

A {{GPUBindGroup}} defines a set of resources to be bound together in a group
    and how the resources are used in shader stages.

<script type=idl>
interface GPUBindGroup {
};
GPUBindGroup includes GPUObjectBase;
</script>

### Bind Group Creation ### {#bind-group-creation}

A {{GPUBindGroup}} is created via {{GPUDevice/createBindGroup()|GPUDevice.createBindGroup()}}.

<script type=idl>
dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
    required GPUBindGroupLayout layout;
    required sequence<GPUBindGroupEntry> entries;
};
</script>

A {{GPUBindGroupEntry}} describes a single resource to be bound in a {{GPUBindGroup}}.

<script type=idl>
typedef (GPUSampler or GPUTextureView or GPUBufferBinding) GPUBindingResource;

dictionary GPUBindGroupEntry {
    required GPUIndex32 binding;
    required GPUBindingResource resource;
};
</script>

<script type=idl>
dictionary GPUBufferBinding {
    required GPUBuffer buffer;
    GPUSize64 offset = 0;
    GPUSize64 size;
};
</script>

  * {{GPUBufferBinding/size}}: If undefined, specifies the range starting at
      {{GPUBufferBinding/offset}} and ending at the end of the buffer.

A {{GPUBindGroup}} object has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBindGroup">
    : <dfn>\[[layout]]</dfn> of type {{GPUBindGroupLayout}}.
    ::
        The {{GPUBindGroupLayout}} associated with this {{GPUBindGroup}}.

    : <dfn>\[[entries]]</dfn> of type sequence<{{GPUBindGroupEntry}}>.
    ::
        The set of {{GPUBindGroupEntry}}s this {{GPUBindGroup}} describes.

    : <dfn>\[[usedBuffers]]</dfn> of type maplike<{{GPUBuffer}}, {{GPUBufferUsage}}>.
    ::
        The set of buffers used by this bind group and the corresponding usage flags.

    : <dfn>\[[usedTextures]]</dfn> of type maplike<{{GPUTexture}} [=subresource=], {{GPUTextureUsage}}>.
    ::
        The set of texure subresources used by this bind group. Each subresource is
        stored with the union of usage flags that apply to it.
</dl>

### {{GPUDevice/createBindGroup()|GPUDevice.createBindGroup(GPUBindGroupDescriptor)}} ### {#GPUDevice-createBindGroup}

<div algorithm="GPUDevice.createBindGroup">
    **Arguments:**
        - {{GPUBindGroupDescriptor}} |descriptor|

    **Returns:** {{GPUBindGroup}}.

    The <dfn method for="GPUDevice">createBindGroup(|descriptor|)</dfn> method is used to create
        {{GPUBindGroup}}s.

    If any of the conditions below are violated:
        1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
        1. Create a new [=invalid=] {{GPUBindGroup}} and return the result.

    1. Ensure [=bind group device validation=] is not violated.
    1. Ensure |descriptor|.{{GPUBindGroupDescriptor/layout}} is a [=valid=] {{GPUBindGroupLayout}}.
    1. Ensure the number of {{GPUBindGroupLayoutDescriptor/entries}} of
        |descriptor|.{{GPUBindGroupDescriptor/layout}} exactly equals to the number of
        |descriptor|.{{GPUBindGroupDescriptor/entries}}.
    1. For each {{GPUBindGroupEntry}} |bindingDescriptor| in
        |descriptor|.{{GPUBindGroupDescriptor/entries}}:
        1. Ensure there is exactly one {{GPUBindGroupLayoutEntry}} |layoutBinding| in
            {{GPUBindGroupLayoutDescriptor/entries}} of |descriptor|.{{GPUBindGroupDescriptor/layout}}
            such that |layoutBinding|.{{GPUBindGroupLayoutEntry/binding}} equals to
            |bindingDescriptor|.{{GPUBindGroupEntry/binding}}.
        1. If |layoutBinding|.{{GPUBindGroupLayoutEntry/type}} is
            {{GPUBindingType/"sampler"}}:
            1. Ensure |bindingDescriptor|.{{GPUBindGroupEntry/resource}} is a
                valid {{GPUSampler}} object and {{GPUSampler/[[compareEnable]]}} is false.
        1. If |layoutBinding|.{{GPUBindGroupLayoutEntry/type}} is
            {{GPUBindingType/"comparison-sampler"}}:
            1. Ensure |bindingDescriptor|.{{GPUBindGroupEntry/resource}} is a
                valid {{GPUSampler}} object and {{GPUSampler/[[compareEnable]]}} is true.
        1. If |layoutBinding|.{{GPUBindGroupLayoutEntry/type}} is
            {{GPUBindingType/"sampled-texture"}} or {{GPUBindingType/"readonly-storage-texture"}} or
            {{GPUBindingType/"writeonly-storage-texture"}}.
            1. Ensure |bindingDescriptor|.{{GPUBindGroupEntry/resource}} is a
                valid {{GPUTextureView}} object.
            1. Ensure [=texture view binding validation=] is not violated.
            1. Ensure |bindingDescriptor|.{{GPUBindGroupLayoutEntry/storageTextureFormat}} is a valid {{GPUTextureFormat}}.
        1. If |layoutBinding|.{{GPUBindGroupLayoutEntry/type}} is
            {{GPUBindingType/"uniform-buffer"}} or {{GPUBindingType/"storage-buffer"}}
            or {{GPUBindingType/"readonly-storage-buffer"}}.
            1. Ensure |bindingDescriptor|.{{GPUBindGroupEntry/resource}} is a
                valid {{GPUBufferBinding}} object.
            1. Ensure [=buffer binding validation=] is not violated.
    1. Return a new {{GPUBindGroup}} object with:
        - {{GPUBindGroup/[[layout]]}} = |descriptor|.{{GPUBindGroupDescriptor/layout}}
        - {{GPUBindGroup/[[entries]]}} = |descriptor|.{{GPUBindGroupDescriptor/entries}}
        - {{GPUBindGroup/[[usedBuffers]]}} = union of the buffer usages across all entries
        - {{GPUBindGroup/[[usedTextures]]}} = union of the texture [=subresource=] usages across all entries

    <div class=validusage dfn-for=GPUDevice.createBindGroup>
        <dfn abstract-op>Valid Usage</dfn>

        <dfn>bind group device validation</dfn>: The {{GPUDevice}} must not be lost.

        <dfn>texture view binding validation</dfn>: Let |view| be
            |bindingDescriptor|.{{GPUBindGroupEntry/resource}}, a {{GPUTextureView}}.
            This |layoutBinding| must be compatible with this |view|. This requires:
            1. Its |layoutBinding|.{{GPUBindGroupLayoutEntry/viewDimension}} must equal |view|'s
                {{GPUTextureViewDescriptor/dimension}}.
            1. Its |layoutBinding|.{{GPUBindGroupLayoutEntry/textureComponentType}} must be compatible
                with |view|'s {{GPUTextureViewDescriptor/format}}.
            1. If |layoutBinding|.{{GPUBindGroupLayoutEntry/multisampled}} is `true`, |view|'s texture's
                {{GPUTextureDescriptor/sampleCount}} must be greater than 1.
                Otherwise, if |bindingDescriptor|.{{GPUBindGroupLayoutEntry/multisampled}} is `false`,
                |view|'s texture's {{GPUTextureDescriptor/sampleCount}} must be 1.
            1. If |layoutBinding|.{{GPUBindGroupLayoutEntry/type}} is
                {{GPUBindingType/"sampled-texture"}}, |view|'s texture's {{GPUTextureDescriptor/usage}}
                must include {{GPUTextureUsage/SAMPLED}}. Each texture [=subresource=] seen by |view|
                is added to {{GPUBindGroup/[[usedTextures]]}} with {{GPUTextureUsage/SAMPLED}} flag.
            1. If |layoutBinding|.{{GPUBindGroupLayoutEntry/type}} is
                {{GPUBindingType/"readonly-storage-texture"}} or {{GPUBindingType/"writeonly-storage-texture"}},
                |view|'s texture's {{GPUTextureDescriptor/usage}} must include {{GPUTextureUsage/STORAGE}}.
                Each texture [=subresource=] seen by |view|
                is added to {{GPUBindGroup/[[usedTextures]]}} with {{GPUTextureUsage/STORAGE}} flag.

        <dfn>buffer binding validation</dfn>: Let |bufferBinding| be
            |bindingDescriptor|.{{GPUBindGroupEntry/resource}}, a {{GPUBufferBinding}}.
            This |layoutBinding| must be compatible with this |bufferBinding|. This requires:
            1. If |layoutBinding|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"uniform-buffer"}},
                the |bufferBinding|.{{GPUBufferBinding/buffer}}'s {{GPUBufferDescriptor/usage}} must include
                {{GPUBufferUsage/UNIFORM}}. The buffer is added to the {{GPUBindGroup/[[usedBuffers]]}} map
                with {{GPUBufferUsage/UNIFORM}} flag.
            1. If |layoutBinding|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"storage-buffer"}}
                or {{GPUBindingType/"readonly-storage-buffer"}}, the
                |bufferBinding|.{{GPUBufferBinding/buffer}}'s {{GPUBufferDescriptor/usage}} must include
                {{GPUBufferUsage/STORAGE}}. The buffer is added to the {{GPUBindGroup/[[usedBuffers]]}} map
                with {{GPUBufferUsage/STORAGE}} flag.
            1. The bound part designated by |bufferBinding|.{{GPUBufferBinding/offset}} and
                |bufferBinding|.{{GPUBufferBinding/size}} must reside inside the buffer.
    </div>
</div>

## GPUPipelineLayout ## {#pipeline-layout}

A {{GPUPipelineLayout}} defines the mapping between resources of all {{GPUBindGroup}} objects set up during command encoding in {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}}, and the shaders of the pipeline set by {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}} or {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}}.

The full binding address of a resource can be defined as a trio of:
  1. shader stage mask, to which the resource is visible
  2. bind group index
  3. binding number

The components of this address can also be seen as the binding space of a pipeline. A {{GPUBindGroup}} (with the corresponding {{GPUBindGroupLayout}}) covers that space for a fixed bind group index. The contained bindings need to be a superset of the resources used by the shader at this bind group index.

<script type=idl>
[Serializable]
interface GPUPipelineLayout {
};
GPUPipelineLayout includes GPUObjectBase;
</script>

{{GPUPipelineLayout}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUPipelineLayout">
    : <dfn>\[[bindGroupLayouts]]</dfn> of type sequence<{{GPUBindGroupLayout}}>.
    ::
        The {{GPUBindGroupLayout}} objects provided at creation in {{GPUPipelineLayoutDescriptor/bindGroupLayouts|GPUPipelineLayoutDescriptor.bindGroupLayouts}}.
</dl>

Note: using the same {{GPUPipelineLayout}} for many {{GPURenderPipeline}} or {{GPUComputePipeline}} pipelines guarantees that the user agent doesn't need to rebind any resources internally when there is a switch between these pipelines.

<div class="example">
{{GPUComputePipeline}} object X was created with {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, B, C. {{GPUComputePipeline}} object Y was created with {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, D, C. Supposing the command encoding sequence has two dispatches:

  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(0, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(2, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(X)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(Y)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}

In this scenario, the user agent would have to re-bind the group slot 2 for the second dispatch, even though neither the {{GPUBindGroupLayout}} at index 2 of {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGrouplayouts}}, or the {{GPUBindGroup}} at slot 2, change.
</div>

Issue: should this example and the note be moved to some "best practices" document?

Note: the expected usage of the {{GPUPipelineLayout}} is placing the most common and the least frequently changing bind groups at the "bottom" of the layout, meaning lower bind group slot numbers, like 0 or 1. The more frequently a bind group needs to change between draw calls, the higher its index should be. This general guideline allows the user agent to minimize state changes between draw calls, and consequently lower the CPU overhead.

### Creation ### {#pipeline-layout-creation}

A {{GPUPipelineLayout}} is created via {{GPUDevice/createPipelineLayout()|GPUDevice.createPipelineLayout()}}.

<script type=idl>
dictionary GPUPipelineLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayout> bindGroupLayouts;
};
</script>

### {{GPUDevice}}.<dfn method for=GPUDevice>createPipelineLayout(descriptor)</dfn> ### {#device-create-pipeline-layout}

<div algorithm=GPUDevice.createPipelineLayout>
    **Arguments:**
        - {{GPUPipelineLayoutDescriptor}} |descriptor|

    **Returns:** {{GPUPipelineLayout}}.

    1. Ensure [=pipeline layout device validation=] is not violated.
    1. Ensure [=pipeline layout entries validation=] is not violated.
    1. Let |pl| be a new {{GPUPipelineLayout}} object.
    1. Set the |pl|.{{GPUPipelineLayout/[[bindGroupLayouts]]}} to |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}.
    1. Return |pl|.

    <div class=validusage dfn-for=GPUDevice.createPipelineLayout>
        <dfn abstract-op>Valid Usage</dfn>

        If any of the following conditions are violated:
            1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
            1. Create a new [=invalid=] {{GPUPipelineLayout}} and return the result.

        <dfn>pipeline layout device validation</dfn>: The {{GPUDevice}} must not be lost.

        <dfn>pipeline layout entries validation</dfn>:
        There must be {{GPULimits/maxBindGroups|GPULimits.maxBindGroups}} or fewer
        elements in |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}.
        All these {{GPUBindGroupLayout}} entries have to be valid.
    </div>

    Issue: there will be more limits applicable to the whole pipeline layout.
</div>

Note: two {{GPUPipelineLayout}} objects are considered equivalent for any usage
if their internal {{GPUPipelineLayout/[[bindGroupLayouts]]}} sequences contain
{{GPUBindGroupLayout}} objects that are [=group-equivalent=].

# Shader Modules # {#shader-modules}

## GPUShaderModule ## {#shader-module}

<script type=idl>
[Serializable]
interface GPUShaderModule {
};
GPUShaderModule includes GPUObjectBase;
</script>

{{GPUShaderModule}} is {{Serializable}}. It is a reference to an internal
shader module object, and {{Serializable}} means that the reference can be
*copied* between realms (threads/workers), allowing multiple realms to access
it concurrently. Since {{GPUShaderModule}} is immutable, there are no race
conditions.

### Shader Module Creation ### {#shader-module-creation}

<script type=idl>
dictionary GPUShaderModuleDescriptor : GPUObjectDescriptorBase {
    required DOMString code;
};
</script>


# Pipelines # {#pipelines}

A <dfn dfn>pipeline</dfn>, be it {{GPUComputePipeline}} or {{GPURenderPipeline}},
represents the complete function done by a combination of the GPU hardware, the driver,
and the user agent, that process the input data in the shape of bindings and vertex buffers,
and produces some output, like the colors in the output render targets.

Structurally, the [=pipeline=] consists of a sequence of programmable stages (shaders)
and fixed-function states, such as the blending modes.

Note: Internally, depending on the target platform,
the driver may convert some of the fixed-function states into shader code,
and link it together with the shaders provided by the user.
This linking is one of the reason the object is created as a whole.

This combination state is created as a single object
(by {{GPUDevice/createComputePipeline(descriptor)|GPUDevice.createComputePipeline()}} or {{GPUDevice/createRenderPipeline(descriptor)|GPUDevice.createRenderPipeline()}}),
and switched as one
(by {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}} or {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}} correspondingly).

## Base pipelines ## {#pipeline-base}

<script type=idl>
dictionary GPUPipelineDescriptorBase : GPUObjectDescriptorBase {
    GPUPipelineLayout layout;
};

interface mixin GPUPipelineBase {
    GPUBindGroupLayout getBindGroupLayout(unsigned long index);
};
</script>

{{GPUPipelineBase}} has the following internal slots:
<dl dfn-type=attribute dfn-for="GPUPipelineBase">
    : <dfn>\[[layout]]</dfn> of type `GPUPipelineLayout`.
    ::
        The definition of the layout of resources which can be used with `this`.
</dl>

### <dfn method for=GPUPipelineBase>getBindGroupLayout(index)</dfn> ### {#pipelinebase-getBindGroupLayout}

<div algorithm="GPUPipelineBase.getBindGroupLayout">
    **Arguments:**

        - {{unsigned long}} |index|

    **Returns:** {{GPUBindGroupLayout}}

    1. If |index| is greater or equal to {{GPULimits/maxBindGroups}}:

        1. Throw a {{RangeError}}.

    1. If |this| is not [=valid=]:

        1. Return a new error {{GPUBindGroupLayout}}.

    1. Return a new {{GPUBindGroupLayout}} object that references the same internal object as
        |this|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|index|].

    Issue: Specify this more properly once we have internal objects for {{GPUBindGroupLayout}}.
        Alternatively only spec is as a new internal objects that's [=group-equivalent=]

    Note: Only returning new {{GPUBindGroupLayout}} objects ensures no synchronization is necessary
        between the [=Content timeline=] and the [=Device timeline=].

</div>

### Default pipeline layout ### {#default-pipeline-layout}

A {{GPUPipelineBase}} object that was created without a {{GPUPipelineDescriptorBase/layout}}
has a default layout created and used instead.

<div algorithm="default pipeline layout creation">

    1. Let |groupDescs| be a sequence of |device|.{{device/[[limits]]}}.{{GPULimits/maxBindGroups}}
        new {{GPUBindGroupLayoutDescriptor}} objects.
    1. For each |groupDesc| in |groupDescs|:

        1. Set |groupDesc|.{{GPUBindGroupLayoutDescriptor/entries}} to an empty sequence.

    1. For each {{GPUProgrammableStageDescriptor}} |stageDesc| in the descriptor used to create the pipeline:

        1. Let |stageInfo| be the "reflection information" for |stageDesc|.

            Issue: Define the reflection information concept so that this spec can interface with the WGSL
                spec and get information what the interface is for a {{GPUShaderModule}} for a specific
                entrypoint.

        1. Let |shaderStage| be the {{GPUShaderStageFlags}} for |stageDesc|.{{GPUProgrammableStageDescriptor/entryPoint}}
            in |stageDesc|.{{GPUProgrammableStageDescriptor/module}}.
        1. For each resource |resource| in |stageInfo|'s resource interface:

            1. Let |group| be |resource|'s "group" decoration.
            1. Let |binding| be |resource|'s "binding" decoration.
            1. Let |entry| be a new {{GPUBindGroupLayoutEntry}}.
            1. Set |entry|.{{GPUBindGroupLayoutEntry/binding}} to |binding|.
            1. Set |entry|.{{GPUBindGroupLayoutEntry/visibility}} to |shaderStage|.
            1. If |resource| is for a sampler binding:

                    1. Set |entry|.{{GPUBindGroupLayoutEntry/type}} to
                        {{GPUBindingType/sampler}}.

            1. If |resource| is for a comparison sampler binding:

                1. Set |entry|.{{GPUBindGroupLayoutEntry/type}} to {{GPUBindingType/comparison-sampler}}.

            1. If |resource| is for a buffer binding:

                1. Set |entry|.{{GPUBindGroupLayoutEntry/hasDynamicOffset}} to false.

                1. If |resource| is for a uniform buffer:

                    1. Set |entry|.{{GPUBindGroupLayoutEntry/type}} to {{GPUBindingType/uniform-buffer}}.

                1. If |resource| is for a read-only storage buffer:

                    1. Set |entry|.{{GPUBindGroupLayoutEntry/type}} to {{GPUBindingType/readonly-storage-buffer}}.

                1. If |resource| is for a storage buffer:

                    1. Set |entry|.{{GPUBindGroupLayoutEntry/type}} to {{GPUBindingType/storage-buffer}}.

            1. If |resource| is for a texture binding:

                1. Set |entry|.{{GPUBindGroupLayoutEntry/textureComponentType}} to |resource|'s component type.
                1. Set |entry|.{{GPUBindGroupLayoutEntry/viewDimension}} to |resource|'s dimension.
                1. If |resource| is multisampled:

                    1. Set |entry|.{{GPUBindGroupLayoutEntry/multisampled}} to true.

                1. If |resource| is for a sampled texture:

                    1. Set |entry|.{{GPUBindGroupLayoutEntry/type}} to {{GPUBindingType/sampled-texture}}.

                1. If |resource| is for a read-only storage texture:

                    1. Set |entry|.{{GPUBindGroupLayoutEntry/type}} to {{GPUBindingType/readonly-storage-texture}}.
                    1. Set |entry|.{{GPUBindGroupLayoutEntry/storageTextureFormat}} to |resource|'s format.

                1. If |resource| is for a write-only storage texture:

                    1. Set |entry|.{{GPUBindGroupLayoutEntry/type}} to {{GPUBindingType/writeonly-storage-texture}}.
                    1. Set |entry|.{{GPUBindGroupLayoutEntry/storageTextureFormat}} to |resource|'s format.

            1. If |groupDescs|[|group|] has an entry |previousEntry| with {{GPUBindGroupLayoutEntry/binding}} equal to |binding|:

                1. If |previousEntry| is equal to |entry| up to {{GPUBindGroupLayoutEntry/visibility}}:

                    1. Add the bits set in |entry|.{{GPUBindGroupLayoutEntry/visibility}} into |previousEntry|.{{GPUBindGroupLayoutEntry/visibility}}

                1. Else

                    1. Return null (which will cause the creation of the pipeline to fail).

            1. Else

                1. Append |entry| to |groupDescs|[|group|].

    1. Let |groupLayouts| be a new sequence.
    1. For each |groupDesc| in |groupDescs|:

        1. Append |device|.{{GPUDevice/createBindGroupLayout()}}(|groupDesc|) to |groupLayouts|.

    1. Let |desc| be a new {{GPUPipelineLayoutDescriptor}}.
    1. Set |desc|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} to |groupLayouts|.
    1. Return |device|.{{GPUDevice/createPipelineLayout()}}(|desc|).

    Issue: This fills the pipeline layout with empty bindgroups. Revisit once the behavior of empty bindgroups is specified.

</div>

### GPUProgrammableStageDescriptor ### {#GPUProgrammableStageDescriptor}

<script type=idl>
dictionary GPUProgrammableStageDescriptor {
    required GPUShaderModule module;
    required DOMString entryPoint;
};
</script>

A {{GPUProgrammableStageDescriptor}} describes the entry point in the user-provided
{{GPUShaderModule}} that controls one of the programmable stages of a [=pipeline=].

<div algorithm>
    <dfn abstract-op>validating GPUProgrammableStageDescriptor</dfn>(stage, descriptor, layout)
        **Arguments:**
            - {{GPUShaderStage}} |stage|
            - {{GPUProgrammableStageDescriptor}} |descriptor|
            - {{GPUPipelineLayout}} |layout|

        1. If the |descriptor|.{{GPUProgrammableStageDescriptor/module}} is not
            a [=valid=] {{GPUShaderModule}} return false.
        1. If the |descriptor|.{{GPUProgrammableStageDescriptor/module}} doesn't contain
            an entry point at |stage| named |descriptor|.{{GPUProgrammableStageDescriptor/entryPoint}} return false.
        1. For each |binding| that is [=statically used=] by the shader entry point,
            if the result of [$validating shader binding$](|binding|, |layout|) is false, return false.
        1. Return true.
</div>

<div algorithm>
    <dfn abstract-op>validating shader binding</dfn>(binding, layout)
    **Arguments:**
        - shader |binding|, reflected from the shader module
        - {{GPUPipelineLayout}} |layout|

    Consider the shader |binding| annotation of |bindIndex| for the
    binding index and |bindGroup| for the bind group index.

    Return true if all of the following conditions are satisfied:

        1. |layout|.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|bindGroup|] contains
            a {{GPUBindGroupLayoutEntry}} |entry| whose |entry|.{{GPUBindGroupLayoutEntry/binding}} == |bindIndex|.
        1. If |entry|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"sampler"}},
            the |binding| has to be a non-comparison sampler.
        1. If |entry|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"comparison-sampler"}},
            the |binding| has to be a comparison sampler.
        1. If |entry|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"sampled-texture"}},
            the |binding| has to be a sampled texture with the component type of |entry|.{{GPUBindGroupLayoutEntry/textureComponentType}},
            and it must be multisampled if and only if |entry|.{{GPUBindGroupLayoutEntry/multisampled}} is true.
        1. If |entry|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"readonly-storage-texture"}},
            the |binding| has to be a read-only storage texture with format of |entry|.{{GPUBindGroupLayoutEntry/storageTextureFormat}}.
        1. If |entry|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"writeonly-storage-texture"}},
            the |binding| has to be a writable storage texture with format of |entry|.{{GPUBindGroupLayoutEntry/storageTextureFormat}}.
        1. If |entry|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"uniform-buffer"}},
            the |binding| has to be a uniform buffer.
        1. If |entry|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"storage-buffer"}},
            the |binding| has to be a storage buffer.
        1. If |entry|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"readonly-storage-buffer"}},
            the |binding| has to be a read-only storage buffer.
        1. If |entry|.{{GPUBindGroupLayoutEntry/type}} is {{GPUBindingType/"sampled-texture"}}, {{GPUBindingType/"readonly-storage-texture"}}, or {{GPUBindingType/"writeonly-storage-texture"}},
            the shader view dimension of the texture has to match |entry|.{{GPUBindGroupLayoutEntry/viewDimension}}.
</div>

Issue: is there a match/switch statement in bikeshed?

A resource binding is considered to be <dfn dfn>statically used</dfn> by a shader entry point
if and only if it's reachable by the control flow graph of the shader module,
starting at the entry point.

## GPUComputePipeline ## {#compute-pipeline}

A {{GPUComputePipeline}} is a kind of [=pipeline=] that controls the compute shader stage,
and can be used in {{GPUComputePassEncoder}}.

Compute inputs and outputs are all contained in the bindings,
according to the given {{GPUPipelineLayout}}.
The outputs correspond to {{GPUBindingType/"storage-buffer"}} and {{GPUBindingType/"writeonly-storage-texture"}} binding types.

Stages of a compute [=pipeline=]:
  1. Compute shader

<script type=idl>
[Serializable]
interface GPUComputePipeline {
};
GPUComputePipeline includes GPUObjectBase;
GPUComputePipeline includes GPUPipelineBase;
</script>

### Creation ### {#compute-pipeline-creation}

<script type=idl>
dictionary GPUComputePipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStageDescriptor computeStage;
};
</script>

### {{GPUDevice/createComputePipeline()|GPUDevice.createComputePipeline(GPUComputePipelineDescriptor)}} ### {#device-createComputePipeline}

<div algorithm="GPUDevice.createComputePipeline">
    **Arguments:**
        - {{GPUComputePipelineDescriptor}} |descriptor|

    **Returns:** {{GPUComputePipeline}}.

    The <dfn method for="GPUDevice">createComputePipeline(|descriptor|)</dfn> method is used to create {{GPUComputePipeline}}s.

    If any of the conditions below are violated:
        1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
        1. Create a new [=invalid=] {{GPUComputePipeline}} and return the result.

    1. Ensure the {{GPUDevice}} is not lost.
    1. Ensure the |descriptor|.{{GPUPipelineDescriptorBase/layout}} is a [=valid=] {{GPUPipelineLayout}}.
    1. Ensure the [$validating GPUProgrammableStageDescriptor$]({{GPUShaderStage/COMPUTE}},
        |descriptor|.{{GPUComputePipelineDescriptor/computeStage}}, |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
</div>

## GPURenderPipeline ## {#render-pipeline}

A {{GPURenderPipeline}} is a kind of [=pipeline=] that controls the vertex
and fragment shader stages, and can be used in {{GPURenderPassEncoder}}
as well as {{GPURenderBundleEncoder}}.

Render [=pipeline=] inputs are:
  - bindings, according to the given {{GPUPipelineLayout}}
  - vertex and index buffers, described by {{GPUVertexStateDescriptor}}
  - the color attachments, described by {{GPUColorStateDescriptor}}
  - optionally, the depth-stencil attachment, described by {{GPUDepthStencilStateDescriptor}}

Render [=pipeline=] outputs are:
  - bindings of types {{GPUBindingType/"storage-buffer"}} and {{GPUBindingType/"writeonly-storage-texture"}}
  - the color attachments, described by {{GPUColorStateDescriptor}}
  - optionally, depth-stencil attachment, described by {{GPUDepthStencilStateDescriptor}}

Stages of a render [=pipeline=]:
  1. Vertex fetch, controlled by {{GPUVertexStateDescriptor}}
  2. Vertex shader
  3. Primitive assembly, controlled by {{GPUPrimitiveTopology}}
  4. Rasterization, controlled by {{GPURasterizationStateDescriptor}}
  5. Fragment shader
  6. Stencil test and operation, controlled by {{GPUDepthStencilStateDescriptor}}
  7. Depth test and write, controlled by {{GPUDepthStencilStateDescriptor}}
  8. Output merging, controlled by {{GPUColorStateDescriptor}}

Issue: we need a deeper description of these stages

<script type=idl>
[Serializable]
interface GPURenderPipeline {
};
GPURenderPipeline includes GPUObjectBase;
GPURenderPipeline includes GPUPipelineBase;
</script>

### Creation ### {#render-pipeline-creation}

<script type=idl>
dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStageDescriptor vertexStage;
    GPUProgrammableStageDescriptor fragmentStage;

    required GPUPrimitiveTopology primitiveTopology;
    GPURasterizationStateDescriptor rasterizationState = {};
    required sequence<GPUColorStateDescriptor> colorStates;
    GPUDepthStencilStateDescriptor depthStencilState;
    GPUVertexStateDescriptor vertexState = {};

    GPUSize32 sampleCount = 1;
    GPUSampleMask sampleMask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
};
</script>

  * {{GPURenderPipelineDescriptor/vertexStage}} describes
    the vertex shader entry point of the [=pipeline=]
  * {{GPURenderPipelineDescriptor/fragmentStage}} describes
    the fragment shader entry point of the [=pipeline=]. If it's "null", the [[#no-color-output]] mode is enabled.
  * {{GPURenderPipelineDescriptor/primitiveTopology}} configures
    the primitive assembly stage of the [=pipeline=].
  * {{GPURenderPipelineDescriptor/rasterizationState}} configures
    the rasterization stage of the [=pipeline=].
  * {{GPURenderPipelineDescriptor/colorStates}} describes
    the color attachments that are written by the [=pipeline=].
  * {{GPURenderPipelineDescriptor/depthStencilState}} describes
    the optional depth-stencil attachment that is written by the [=pipeline=].
  * {{GPURenderPipelineDescriptor/vertexState}} configures
    the vertex fetch stage of the [=pipeline=].
  * {{GPURenderPipelineDescriptor/sampleCount}} is
    the number of MSAA samples that each attachment has to have.
  * {{GPURenderPipelineDescriptor/sampleMask}} is
    a binary mask of MSAA samples, according to [#sample-masking]].
  * {{GPURenderPipelineDescriptor/alphaToCoverageEnabled}} enables the [[#alpha-to-coverage]] mode.

### No Color Output ### {#no-color-output}

In no-color-output mode, [=pipeline=] does not produce any color attachment outputs,
and the {{GPURenderPipelineDescriptor/colorStates}} is expected to be empty.

The [=pipeline=] still performs rasterization and produces depth values
based on the vertex position output. The depth testing and stencil operations can still be used.

### Alpha to Coverage ### {#alpha-to-coverage}

In alpha-to-coverage mode, an additional <dfn dfn>alpha-to-coverage mask</dfn>
of MSAA samples is generated based on the |alpha| component of the
fragment shader output value of the {{GPURenderPipelineDescriptor/colorStates}}[0].

The algorithm of producing the extra mask is platform-dependent. It guarantees that:
  - if |alpha| is 0.0 or less, the result is 0x0
  - if |alpha| is 1.0 or greater, the result is 0xFFFFFFFF
  - if |alpha| is greater than some other |alpha1|,
    then the produced sample mask has at least as many bits set to 1 as the mask for |alpha1|

### Sample Masking ### {#sample-masking}

The <dfn dfn>final sample mask</dfn> for a pixel is computed as:
[=rasterization mask=] & {{GPURenderPipelineDescriptor/sampleMask}} & [=shader-output mask=].

Only the lower {{GPURenderPipelineDescriptor/sampleCount}} bits of the mask are considered.

If the least-significant bit at position |N| of the [=final sample mask=] has value of "0",
the sample color outputs (corresponding to sample |N|) to all attachments of the fragment shader are discarded.
Also, no depth test or stencil operations are executed on the relevant samples of the depth-stencil attachment.

Note: the color output for sample |N| is produced by the fragment shader execution
with SV_SampleIndex == |N| for the current pixel.
If the fragment shader doesn't use this semantics, it's only executed once per pixel.

The <dfn dfn>rasterization mask</dfn> is produced by the rasterization stage,
based on the shape of the rasterized polygon. The samples incuded in the shape get the relevant
bits 1 in the mask.

The <dfn dfn>shader-output mask</dfn> takes the output value of SV_Coverage semantics in the fragment shader.
If the semantics is not [=statically used=] by the shader, and {{GPURenderPipelineDescriptor/alphaToCoverageEnabled}}
is enabled, the [=shader-output mask=] becomes the [=alpha-to-coverage mask=]. Otherwise, it defaults to 0xFFFFFFFF.

Issue: link to the semantics of SV_SampleIndex and SV_Coverage in WGSL spec.

### {{GPUDevice/createRenderPipeline()|GPUDevice.createRenderPipeline(GPURenderPipelineDescriptor)}} ### {#device-createRenderPipeline}

<div algorithm="GPUDevice.createRenderPipeline">
    **Arguments:**
        - {{GPURenderPipelineDescriptor}} |descriptor|

    **Returns:** {{GPURenderPipeline}}.

    The <dfn method for="GPUDevice">createRenderPipeline(|descriptor|)</dfn> method is used to create {{GPURenderPipeline}}s.

    If any of the conditions below are violated:
        1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
        1. Create a new [=invalid=] {{GPURenderPipeline}} and return the result.

    1. Ensure the {{GPUDevice}} is not lost.
    1. Ensure the |descriptor|.{{GPUPipelineDescriptorBase/layout}} is
        a [=valid=] {{GPUPipelineLayout}}.
    1. Ensure the [$validating GPUProgrammableStageDescriptor$]({{GPUShaderStage/VERTEX}},
        |descriptor|.{{GPURenderPipelineDescriptor/vertexStage}},
        |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
    1. If |descriptor|.{{GPURenderPipelineDescriptor/fragmentStage}} is not "null",
        ensure the [$validating GPUProgrammableStageDescriptor$]({{GPUShaderStage/FRAGMENT}},
        |descriptor|.{{GPURenderPipelineDescriptor/fragmentStage}},
        |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
    1. Ensure the |descriptor|.{{GPURenderPipelineDescriptor/colorStates}}.length is less than or equal to 4.
    1. Ensure [$validating GPUVertexStateDescriptor$](|descriptor|.{{GPURenderPipelineDescriptor/vertexState}},
        |descriptor|.{{GPURenderPipelineDescriptor/vertexStage}}) passes.
    1. If |descriptor|.{{GPURenderPipelineDescriptor/alphaToCoverageEnabled}} is true,
        ensure |descriptor|.{{GPURenderPipelineDescriptor/sampleCount}} is greater than 1.
    2. If the output SV_Coverage semantics is [=statically used=] by |descriptor|.{{GPURenderPipelineDescriptor/fragmentStage}},
        ensure |descriptor|.{{GPURenderPipelineDescriptor/alphaToCoverageEnabled}} is false.
</div>

Issue: need a proper limit for the maximum number of color targets.

Issue: need a more detailed validation of the render states.

Issue: need description of the render states.

### Primitive Topology ### {#primitive-topology}

<script type=idl>
enum GPUPrimitiveTopology {
    "point-list",
    "line-list",
    "line-strip",
    "triangle-list",
    "triangle-strip"
};
</script>

### Rasterization State ### {#rasterization-state}

<script type=idl>
dictionary GPURasterizationStateDescriptor {
    GPUFrontFace frontFace = "ccw";
    GPUCullMode cullMode = "none";

    GPUDepthBias depthBias = 0;
    float depthBiasSlopeScale = 0;
    float depthBiasClamp = 0;
};
</script>

<script type=idl>
enum GPUFrontFace {
    "ccw",
    "cw"
};
</script>

<script type=idl>
enum GPUCullMode {
    "none",
    "front",
    "back"
};
</script>

### Color State ### {#color-state}

<script type=idl>
dictionary GPUColorStateDescriptor {
    required GPUTextureFormat format;

    GPUBlendDescriptor alphaBlend = {};
    GPUBlendDescriptor colorBlend = {};
    GPUColorWriteFlags writeMask = 0xF;  // GPUColorWrite.ALL
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUColorWriteFlags;
interface GPUColorWrite {
    const GPUColorWriteFlags RED   = 0x1;
    const GPUColorWriteFlags GREEN = 0x2;
    const GPUColorWriteFlags BLUE  = 0x4;
    const GPUColorWriteFlags ALPHA = 0x8;
    const GPUColorWriteFlags ALL   = 0xF;
};
</script>

#### Blend State #### {#blend-state}

<script type=idl>
dictionary GPUBlendDescriptor {
    GPUBlendFactor srcFactor = "one";
    GPUBlendFactor dstFactor = "zero";
    GPUBlendOperation operation = "add";
};
</script>

<script type=idl>
enum GPUBlendFactor {
    "zero",
    "one",
    "src-color",
    "one-minus-src-color",
    "src-alpha",
    "one-minus-src-alpha",
    "dst-color",
    "one-minus-dst-color",
    "dst-alpha",
    "one-minus-dst-alpha",
    "src-alpha-saturated",
    "blend-color",
    "one-minus-blend-color"
};
</script>

<script type=idl>
enum GPUBlendOperation {
    "add",
    "subtract",
    "reverse-subtract",
    "min",
    "max"
};
</script>

<script type=idl>
enum GPUStencilOperation {
    "keep",
    "zero",
    "replace",
    "invert",
    "increment-clamp",
    "decrement-clamp",
    "increment-wrap",
    "decrement-wrap"
};
</script>

### Depth/Stencil State ### {#depth-stencil-state}

<script type=idl>
dictionary GPUDepthStencilStateDescriptor {
    required GPUTextureFormat format;

    boolean depthWriteEnabled = false;
    GPUCompareFunction depthCompare = "always";

    GPUStencilStateFaceDescriptor stencilFront = {};
    GPUStencilStateFaceDescriptor stencilBack = {};

    GPUStencilValue stencilReadMask = 0xFFFFFFFF;
    GPUStencilValue stencilWriteMask = 0xFFFFFFFF;
};
</script>

<script type=idl>
dictionary GPUStencilStateFaceDescriptor {
    GPUCompareFunction compare = "always";
    GPUStencilOperation failOp = "keep";
    GPUStencilOperation depthFailOp = "keep";
    GPUStencilOperation passOp = "keep";
};
</script>

### Vertex State ### {#vertex-state}

<script type=idl>
enum GPUIndexFormat {
    "uint16",
    "uint32"
};
</script>

#### Vertex Formats #### {#vertex-formats}

The name of the format specifies the data type of the component, the number of
values, and whether the data is normalized.

  * `uchar` = unsigned 8-bit value
  * `char` = signed 8-bit value
  * `ushort` = unsigned 16-bit value
  * `short` = signed 16-bit value
  * `half` = half-precision 16-bit floating point value
  * `float` = 32-bit floating point value
  * `uint` = unsigned 32-bit integer value
  * `int` = signed 32-bit integer value

If no number of values is given in the name, a single value is provided.
If the format has the `-bgra` suffix, it means the values are arranged as
blue, green, red and alpha values.

<script type=idl>
enum GPUVertexFormat {
    "uchar2",
    "uchar4",
    "char2",
    "char4",
    "uchar2norm",
    "uchar4norm",
    "char2norm",
    "char4norm",
    "ushort2",
    "ushort4",
    "short2",
    "short4",
    "ushort2norm",
    "ushort4norm",
    "short2norm",
    "short4norm",
    "half2",
    "half4",
    "float",
    "float2",
    "float3",
    "float4",
    "uint",
    "uint2",
    "uint3",
    "uint4",
    "int",
    "int2",
    "int3",
    "int4"
};
</script>

<script type=idl>
enum GPUInputStepMode {
    "vertex",
    "instance"
};
</script>

<script type=idl>
dictionary GPUVertexStateDescriptor {
    GPUIndexFormat indexFormat = "uint32";
    sequence<GPUVertexBufferLayoutDescriptor?> vertexBuffers = [];
};
</script>

A <dfn dfn>vertex buffer</dfn> is, conceptually, a view into buffer memory as an *array of structures*.
{{GPUVertexBufferLayoutDescriptor/arrayStride}} is the stride, in bytes, between *elements* of that array.
Each element of a vertex buffer is like a *structure* with a memory layout defined by its
{{GPUVertexBufferLayoutDescriptor/attributes}}, which describe the *members* of the structure.

Each {{GPUVertexAttributeDescriptor}} describes its
{{GPUVertexAttributeDescriptor/format}} and its
{{GPUVertexAttributeDescriptor/offset}}, in bytes, within the structure.

Each attribute appears as a separate input in a vertex shader, each bound by a numeric *location*,
which is specified by {{GPUVertexAttributeDescriptor/shaderLocation}}.
Every location must be unique within the {{GPUVertexStateDescriptor}}.

<script type=idl>
dictionary GPUVertexBufferLayoutDescriptor {
    required GPUSize64 arrayStride;
    GPUInputStepMode stepMode = "vertex";
    required sequence<GPUVertexAttributeDescriptor> attributes;
};
</script>

<script type=idl>
dictionary GPUVertexAttributeDescriptor {
    required GPUVertexFormat format;
    required GPUSize64 offset;

    required GPUIndex32 shaderLocation;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUVertexBufferLayoutDescriptor</dfn>(descriptor, vertexStage)
    **Arguments:**
        - {{GPUVertexBufferLayoutDescriptor}} |descriptor|
        - {{GPUProgrammableStageDescriptor}} |vertexStage|

    Return true, if and only if, all of the following conditions are true:

        1. |descriptor|.{{GPUVertexBufferLayoutDescriptor/attributes}}.length is less than or equal to 16.
        1. |descriptor|.{{GPUVertexBufferLayoutDescriptor/arrayStride}} is less then or equal to 2048.
        1. Any attribute |at| in the list |descriptor|.{{GPUVertexBufferLayoutDescriptor/attributes}} has
            |at|.{{GPUVertexAttributeDescriptor/offset} + sizeOf(|at|.{{GPUVertexAttributeDescriptor/format}} less or equal to
            |descriptor|.{{GPUVertexBufferLayoutDescriptor/arrayStride}}.
        1. For every vertex attribute in the shader reflection of |vertexStage|.{{GPUProgrammableStageDescriptor/module}}
            that is know to be [=statically used=] by |vertexStage|.{{GPUProgrammableStageDescriptor/entryPoint}},
            there is a corresponding |at| element of |descriptor|.{{GPUVertexBufferLayoutDescriptor/attributes}} that:
            1. The shader format is |at|.{{GPUVertexAttributeDescriptor/format}}.
            2. The shader location is |at|.{{GPUVertexAttributeDescriptor/shaderLocation}}.
</div>

Issue(https://github.com/gpuweb/gpuweb/issues/693): add a limit to the number of vertex attributes

<div algorithm>
    <dfn abstract-op>validating GPUVertexStateDescriptor</dfn>(descriptor, vertexStage)
    **Arguments:**
        - {{GPUVertexStateDescriptor}} |descriptor|
        - {{GPUProgrammableStageDescriptor}} |vertexStage|

    Return true, if and only if, all of the following conditions are true:

        1. |descriptor|.{{GPUVertexStateDescriptor/vertexBuffers}}.length is less than or equal to 8
        1. Each |vertexBuffer| layout descriptor in the list |descriptor|.{{GPUVertexStateDescriptor/vertexBuffers}}
            passes [$validating GPUVertexBufferLayoutDescriptor$](|vertexBuffer|, |vertexStage|)
        1. Each |at| in the union of all {{GPUVertexAttributeDescriptor}}
            across |descriptor|.{{GPUVertexStateDescriptor/vertexBuffers}} has a distinct
            |at|.{{GPUVertexAttributeDescriptor/shaderLocation}} value.
</div>

Issue(https://github.com/gpuweb/gpuweb/issues/693): add a limit to the number of vertex buffers

# Command Buffers # {#command-buffers}

## GPUCommandBuffer ## {#command-buffer}

<script type=idl>
interface GPUCommandBuffer {
};
GPUCommandBuffer includes GPUObjectBase;
</script>

### Creation ### {#command-buffer-creation}

<script type=idl>
dictionary GPUCommandBufferDescriptor : GPUObjectDescriptorBase {
};
</script>


# Command Encoding # {#command-encoding}

## GPUCommandEncoder ## {#command-encoder}

<script type=idl>
interface GPUCommandEncoder {
    GPURenderPassEncoder beginRenderPass(GPURenderPassDescriptor descriptor);
    GPUComputePassEncoder beginComputePass(optional GPUComputePassDescriptor descriptor = {});

    void copyBufferToBuffer(
        GPUBuffer source,
        GPUSize64 sourceOffset,
        GPUBuffer destination,
        GPUSize64 destinationOffset,
        GPUSize64 size);

    void copyBufferToTexture(
        GPUBufferCopyView source,
        GPUTextureCopyView destination,
        GPUExtent3D copySize);

    void copyTextureToBuffer(
        GPUTextureCopyView source,
        GPUBufferCopyView destination,
        GPUExtent3D copySize);

    void copyTextureToTexture(
        GPUTextureCopyView source,
        GPUTextureCopyView destination,
        GPUExtent3D copySize);

    void pushDebugGroup(DOMString groupLabel);
    void popDebugGroup();
    void insertDebugMarker(DOMString markerLabel);

    void resolveQuerySet(
        GPUQuerySet querySet,
        GPUSize32 firstQuery,
        GPUSize32 queryCount,
        GPUBuffer destination,
        GPUSize64 destinationOffset);

    GPUCommandBuffer finish(optional GPUCommandBufferDescriptor descriptor = {});
};
GPUCommandEncoder includes GPUObjectBase;
</script>

### Creation ### {#command-encoder-creation}

<script type=idl>
dictionary GPUCommandEncoderDescriptor : GPUObjectDescriptorBase {
    // TODO: reusability flag?
};
</script>

## Copy Commands ## {#copy-commands}

### <dfn dictionary>GPUBufferCopyView</dfn> ### {#gpu-buffer-copy-view}

<script type=idl>
dictionary GPUBufferCopyView {
    required GPUBuffer buffer;
    GPUSize64 offset = 0;
    required GPUSize32 bytesPerRow;
    GPUSize32 rowsPerImage = 0;
};
</script>

A {{GPUBufferCopyView}} is a view of a [=buffer=] as an array of <dfn dfn>images</dfn>,
used when copying data between a [=texture=] and a [=buffer=].

  - For {{GPUTextureDimension/2d}} textures, data is copied between one or multiple contiguous [=images=] and [=array layers=].
  - For {{GPUTextureDimension/3d}} textures, data is copied between one or multiple contiguous [=images=] and depth [=slices=].

Issue: Define images more precisely. In particular, define them as being comprised of [=texel blocks=].

Issue: Define the exact copy semantics, by reference to common algorithms shared by the copy methods.

<dl dfn-type=dict-member dfn-for=GPUBufferCopyView>
    : <dfn>bytesPerRow</dfn>
    ::
        The stride, in bytes, between the beginning of each row of [=texel blocks=] and the subsequent row.

    : <dfn>rowsPerImage</dfn>
    ::
        {{GPUBufferCopyView/rowsPerImage}} &divide; [=texel block height=] &times;
        {{GPUBufferCopyView/bytesPerRow}} is the stride, in bytes, between the beginning of each [=image=]
        of data and the subsequent [=image=].
</dl>

<div algorithm class=validusage>

<dfn abstract-op>GPUBufferCopyView Valid Usage</dfn>

Given a {{GPUBufferCopyView}} |bufferCopyView|, the following validation rules apply:
  - |bufferCopyView|.{{GPUBufferCopyView/buffer}} must be a [=valid=] {{GPUBuffer}}.
  - |bufferCopyView|.{{GPUBufferCopyView/bytesPerRow}} must be a multiple of 256.

</div>

### <dfn dictionary>GPUTextureCopyView</dfn> ### {#gpu-texture-copy-view}

<script type=idl>
dictionary GPUTextureCopyView {
    required GPUTexture texture;
    GPUIntegerCoordinate mipLevel = 0;
    GPUOrigin3D origin = {};
};
</script>

A {{GPUTextureCopyView}} is a view of a sub-region of one or multiple contiguous [=texture=] [=subresources=] with the initial
offset {{GPUOrigin3D}} in texels, used when copying data from or to a {{GPUTexture}}.

  * {{GPUTextureCopyView/origin}}: If unspecified, defaults to `[0, 0, 0]`.

<div algorithm class=validusage>

<dfn abstract-op>GPUTextureCopyView Valid Usage</dfn>

  Given a {{GPUTextureCopyView}} |textureCopyView|, let
  - |blockWidth| be the [=texel block width=] of |textureCopyView|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[format]]}}.
  - |blockHeight| be the [=texel block height=] of |textureCopyView|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[format]]}}.

  The following validation rules apply:
  - |textureCopyView|.{{GPUTextureCopyView/texture}} must be a [=valid=] {{GPUTexture}}.
  - |textureCopyView|.{{GPUTextureCopyView/mipLevel}} must be less than the {{GPUTexture/[[mipLevelCount]]}} of
    |textureCopyView|.{{GPUTextureCopyView/texture}}.
  - |textureCopyView|.{{GPUTextureCopyView/origin}}.[=Origin3D/x=] must be a multiple of |blockWidth|.
  - |textureCopyView|.{{GPUTextureCopyView/origin}}.[=Origin3D/y=] must be a multiple of |blockHeight|.

</div>

Issue(gpuweb/gpuweb#69): Define the copies with {{GPUTextureDimension/1d}} and {{GPUTextureDimension/3d}} textures.

### <dfn dictionary>GPUImageBitmapCopyView</dfn> ### {#gpu-image-bitmap-copy-view}

<script type=idl>
dictionary GPUImageBitmapCopyView {
    required ImageBitmap imageBitmap;
    GPUOrigin2D origin = {};
};
</script>

  * {{GPUImageBitmapCopyView/origin}}: If unspecified, defaults to `[0, 0]`.

### <dfn method for=GPUCommandEncoder>copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)</dfn> ### {#GPUCommandEncoder-copyBufferToBuffer}

<div algorithm="GPUCommandEncoder.copyBufferToBuffer">

  **Arguments:**
    - {{GPUBuffer}} |source|
    - {{GPUSize64}} |sourceOffset|
    - {{GPUBuffer}} |destination|
    - {{GPUSize64}} |destinationOffset|
    - {{GPUSize64}} |size|

  **Returns:** void

  Encode a command into the {{GPUCommandEncoder}} that copies |size| bytes of data from the |sourceOffset| of a {{GPUBuffer}} |source| to the |destinationOffset| of another {{GPUBuffer}} |destination|.

  <div class=validusage dfn-for=GPUCommandEncoder.copyBufferToBuffer>
        <dfn abstract-op>Valid Usage</dfn>

        Given a {{GPUCommandEncoder}} |encoder| and the arguments {{GPUBuffer}} |source|, {{GPUSize64}} |sourceOffset|, {{GPUBuffer}} |destination|, {{GPUSize64}} |destinationOffset|, {{GPUSize64}} |size|, the following validation rules apply:

          - |encoder| must be a [=valid=] {{GPUCommandEncoder}}.
          - |encoder|.{{GPUCommandEncoder/copyBufferToBuffer()}} must not be called when a {{GPURenderPassEncoder}} is active on |encoder|.
          - |encoder|.{{GPUCommandEncoder/copyBufferToBuffer()}} must not be called when a {{GPUComputePassEncoder}} is active on |encoder|.
          - |source| must be a [=valid=] {{GPUBuffer}}.
          - |destination| must be a [=valid=] {{GPUBuffer}}.
          - The {{GPUBuffer/[[usage]]}} of |source| must contain {{GPUBufferUsage/COPY_SRC}}.
          - The {{GPUBuffer/[[usage]]}} of |destination| must contain {{GPUBufferUsage/COPY_DST}}.
          - |size| must be a multiple of 4.
          - |sourceOffset| must be a multiple of 4.
          - |destinationOffset| must be a multiple of 4.
          - (|sourceOffset| + |size|) must not overflow a {{GPUSize64}}.
          - (|destinationOffset| + |size|) must not overflow a {{GPUSize64}}.
          - The {{GPUBuffer/[[size]]}} of |source| must be greater than or equal to (|sourceOffset| + |size|).
          - The {{GPUBuffer/[[size]]}} of |destination| must be greater than or equal to (|destinationOffset| + |size|).
          - If |source| and |destination| are the same buffer, the copy range from |sourceOffset| to (|sourceOffset| + |size|) must not overlap with the copy range from |destinationOffset| to (|destinationOffset| + |size|).

        Issue(gpuweb/gpuweb#21): Define the state machine for GPUCommandEncoder.

        Issue(gpuweb/gpuweb#69): figure out how to handle overflows in the spec.
    </div>
</div>

### Copy Between Buffer and Texture ### {#copy-between-buffer-texture}

WebGPU provides {{GPUCommandEncoder/copyBufferToTexture()}} for buffer-to-texture copies and
{{GPUCommandEncoder/copyTextureToBuffer()}} for texture-to-buffer copies.

The following definitions and validation rules apply to both {{GPUCommandEncoder/copyBufferToTexture()}}
and {{GPUCommandEncoder/copyTextureToBuffer()}}.

[=textureCopyView subresource size=] and [=Valid Texture Copy Range=] also applies to
{{GPUCommandEncoder/copyTextureToTexture()}}.

<div algorithm="textureCopyView subresource size">

<dfn dfn>textureCopyView subresource size</dfn>

  **Arguments:**
    - {{GPUTextureCopyView}} |textureCopyView|

  **Returns:**
    - {{GPUExtent3D}}

  The [=textureCopyView subresource size=] of |textureCopyView| is calculated as follows:

  Its [=Extent3D/width=], [=Extent3D/height=] and [=Extent3D/depth=] are the width, height, and depth, respectively,
  of the [=physical size=] of |textureCopyView|.{{GPUTextureCopyView/texture}} [=subresource=] at [=mipmap level=]
  |textureCopyView|.{{GPUTextureCopyView/mipLevel}}.

</div>

<div algorithm class=validusage>

<dfn dfn>Valid Buffer Copy Range</dfn>

Given a {{GPUBufferCopyView}} |bufferCopyView|, a {{GPUTextureFormat}} |format| and a {{GPUExtent3D}}
|copySize|, let
  - |blockWidth| be the [=texel block width=] of |format|.
  - |blockHeight| be the [=texel block height=] of |format|.
  - |blockSize| be the [=texel block size=] of |format|.
  - |bytesInACompleteRow| be |blockSize| &times; |copySize|.[=Extent3D/width=] &div; |blockWidth|.
  - |bytesInACompleteImage| be |bytesInACompleteRow| &times; |copySize|.[=Extent3D/height=] &div; |blockHeight|.
  - |requiredBytesInCopy| be calculated with the following algorithm assuming all the parameters are [=valid=]:
    ```
    if (copySize.width == 0 || copySize.height == 0 || copySize.depth == 0) {
        requiredBytesInCopy = 0;
    } else {
        GPUSize64 texelBlockRowsPerImage = bufferCopyView.rowsPerImage / blockHeight;
        GPUSize64 bytesPerImage = bufferCopyView.bytesPerRow * texelBlockRowsPerImage;
        GPUSize64 bytesInLastSlice =
            bufferCopyView.bytesPerRow * (copySize.height / blockHeight - 1) + (copySize.width / blockWidth * blockSize);
        requiredBytesInCopy = bytesPerImage * (copySize.depth - 1) + bytesInLastSlice;
    }
    ```

  The following validation rules apply:

  For the copy being in-bounds:
  - If |bufferCopyView|.{{GPUBufferCopyView/rowsPerImage}} is not 0, it must be greater than or equal to
    |copySize|.[=Extent3D/height=].
  - (|bufferCopyView|.{{GPUBufferCopyView/offset}} + |requiredBytesInCopy|) must not overflow a {{GPUSize64}}.
  - (|bufferCopyView|.{{GPUBufferCopyView/offset}} + |requiredBytesInCopy|) must be smaller than or equal to
    |bufferCopyView|.{{GPUBufferCopyView/buffer}}.{{GPUBuffer/[[size]]}}.

  For the texel block alignments:
  - |bufferCopyView|.{{GPUBufferCopyView/rowsPerImage}} must be a multiple of |blockHeight|.
  - |bufferCopyView|.{{GPUBufferCopyView/offset}} must be a multiple of |blockSize|.

  For other members in |bufferCopyView|:
  - If |copySize|.[=Extent3D/height=] is greater than 1:
    - |bufferCopyView|.{{GPUBufferCopyView/bytesPerRow}} must be greater than or equal to the number of |bytesInACompleteRow|.
  - If |copySize|.[=Extent3D/depth=] is greater than 1:
    - |bufferCopyView|.{{GPUBufferCopyView/rowsPerImage}} must be greater than or equal to the number of |bytesInACompleteImage|.

</div>

<div algorithm class=validusage>

<dfn dfn>Valid Texture Copy Range</dfn>

Given a {{GPUTextureCopyView}} |textureCopyView| and a {{GPUExtent3D}} |copySize|, let
  - |blockWidth| be the [=texel block width=] of |textureCopyView|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[format]]}}.
  - |blockHeight| be the [=texel block height=] of |textureCopyView|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[format]]}}.

The following validation rules apply:

  - If the {{GPUTexture/[[dimension]]}} of |textureCopyView|.{{GPUTextureCopyView/texture}} is
    {{GPUTextureDimension/1d}}:
    - Both |copySize|.[=Extent3D/height=] and [=Extent3D/depth=] must be 1.
  - If the {{GPUTexture/[[dimension]]}} of |textureCopyView|.{{GPUTextureCopyView/texture}} is
    {{GPUTextureDimension/2d}}:
     -  (|textureCopyView|.{{GPUTextureCopyView/origin}}.[=Origin3D/x=] + |copySize|.[=Extent3D/width=]),
        (|textureCopyView|.{{GPUTextureCopyView/origin}}.[=Origin3D/y=] + |copySize|.[=Extent3D/height=]), and
        (|textureCopyView|.{{GPUTextureCopyView/origin}}.[=Origin3D/z=] + |copySize|.[=Extent3D/depth=])
        must be less than or equal to the
        [=Extent3D/width=], [=Extent3D/height=], and [=Extent3D/depth=], respectively,
        of the [=textureCopyView subresource size=] of |textureCopyView|.
  - |copySize|.[=Extent3D/width=] must be a multiple of |blockWidth|.
  - |copySize|.[=Extent3D/height=] must be a multiple of |blockHeight|.

</div>

Issue(gpuweb/gpuweb#69): Define the copies with {{GPUTextureDimension/1d}} and
{{GPUTextureDimension/3d}} textures.

Issue(gpuweb/gpuweb#537): Additional restrictions on rowsPerImage if needed.

Issue(gpuweb/gpuweb#652): Define the copies with {{GPUTextureFormat/"depth24plus"}} and
{{GPUTextureFormat/"depth24plus-stencil8"}}.

#### <dfn method for=GPUCommandEncoder>copyBufferToTexture(source, destination, copySize)</dfn> #### {#GPUCommandEncoder-copyBufferToTexture}

<div algorithm="GPUCommandEncoder.copyBufferToTexture">

  **Arguments:**
    - {{GPUBufferCopyView}} |source|
    - {{GPUTextureCopyView}} |destination|
    - {{GPUExtent3D}} |copySize|

  **Returns:** void

  Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of a
  {{GPUBuffer}} to a sub-region of one or multiple continuous {{GPUTexture}} [=subresources=].

  |source| and |copySize| define the region of the source buffer.

  |destination| and |copySize| define the region of the destination texture [=subresource=].

</div>

<div algorithm class=validusage>

<dfn abstract-op>copyBufferToTexture Valid Usage</dfn>

Given a {{GPUCommandEncoder}} |encoder| and the arguments {{GPUBufferCopyView}} |source|,
{{GPUTextureCopyView}} |destination| and {{GPUExtent3D}} |copySize|, the following validation rules apply:

  For |encoder|:
  - |encoder|.{{GPUCommandEncoder/copyBufferToTexture()}} must not be called when a {{GPURenderPassEncoder}}
    is active on |encoder|.
  - |encoder|.{{GPUCommandEncoder/copyBufferToTexture()}} must not be called when a {{GPUComputePassEncoder}}
    is active on |encoder|.

  For |source|:
  - |source| must be [=valid=].
  - |source|.{{GPUBufferCopyView/buffer}}.{{GPUBuffer/[[usage]]}} must contain {{GPUBufferUsage/COPY_SRC}}.

  For |destination|:
  - |destination| must be [=valid=].
  - |destination|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[textureUsage]]}} must contain
    {{GPUTextureUsage/COPY_DST}}.
  - |destination|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[sampleCount]]}} must be 1.

  For the copy ranges:
  - [=Valid Buffer Copy Range=] applies to |source|, |destination|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[format]]}}
    and |copySize|.
  - [=Valid Texture Copy Range=] applies to |destination| and |copySize|.

</div>

#### <dfn method for=GPUCommandEncoder>copyTextureToBuffer(source, destination, copySize)</dfn> #### {#GPUCommandEncoder-copyTextureToBuffer}

<div algorithm="GPUCommandEncoder.copyTextureToBuffer">

  **Arguments:**
    - {{GPUTextureCopyView}} |source|
    - {{GPUBufferCopyView}} |destination|
    - {{GPUExtent3D}} |copySize|

  **Returns:** void

  Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of one or multiple continuous
  {{GPUTexture}} [=subresources=]to a sub-region of a {{GPUBuffer}}.

  |source| and |copySize| define the region of the source texture [=subresource=].

  |destination| and |copySize| define the region of the destination buffer.

</div>

<div algorithm class=validusage>

<dfn abstract-op>copyTextureToBuffer Valid Usage</dfn>

Given a {{GPUCommandEncoder}} |encoder| and the arguments {{GPUTextureCopyView}} |source|,
{{GPUBufferCopyView}} |destination|, {{GPUExtent3D}} |copySize|, the following validation rules apply:

  For |encoder|:
  - |encoder|.{{GPUCommandEncoder/copyTextureToBuffer()}} must not be called when a {{GPURenderPassEncoder}}
    is active on |encoder|.
  - |encoder|.{{GPUCommandEncoder/copyTextureToBuffer()}} must not be called when a {{GPUComputePassEncoder}}
    is active on |encoder|.

  For |source|:
  - |source| must be [=valid=].
  - |source|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[textureUsage]]}} must contain
    {{GPUTextureUsage/COPY_SRC}}.
  - |source|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[sampleCount]]}} must be 1.

  For |destination|:
  - |destination| must be [=valid=].
  - |destination|.{{GPUBufferCopyView/buffer}}.{{GPUBuffer/[[usage]]}} must contain {{GPUBufferUsage/COPY_DST}}.

  For the copy ranges:
  - [=Valid Buffer Copy Range=] applies to |destination|, |source|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[format]]}}
    and |copySize|.
  - [=Valid Texture Copy Range=] applies to |source| and |copySize|.

</div>

### <dfn method for=GPUCommandEncoder>copyTextureToTexture(source, destination, copySize)</dfn> ### {#GPUCommandEncoder-copyTextureToTexture}

<div algorithm="GPUCommandEncoder.copyTextureToTexture">

  **Arguments:**
    - {{GPUTextureCopyView}} |source|
    - {{GPUTextureCopyView}} |destination|
    - {{GPUExtent3D}} |copySize|

  **Returns:** void

  Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of one
  or multiple contiguous {{GPUTexture}} [=subresources=] to another sub-region of one or
  multiple continuous {{GPUTexture}} [=subresources=].

  |source| and |copySize| define the region of the source texture [=subresources=].

  |destination| and |copySize| define the region of the destination texture [=subresources=].

</div>

<div algorithm class=validusage>

<dfn abstract-op>copyTextureToTexture Valid Usage</dfn>

Given a {{GPUCommandEncoder}} |encoder| and the arguments {{GPUTextureCopyView}} |source|,
{{GPUTextureCopyView}} |destination|, {{GPUExtent3D}} |copySize|, let:

  - A |copy of the whole subresource| be the command |encoder|.{{GPUCommandEncoder/copyTextureToTexture()}} whose parameters |source|, |destination| and |copySize| meet the following conditions:
    - The [=textureCopyView subresource size=] of |source| must be equal to |copySize|.
    - The [=textureCopyView subresource size=] of |destination| must be equal to |copySize|.

The following validation rules apply:

  For |encoder|:
  - |encoder|.{{GPUCommandEncoder/copyTextureToTexture()}} must not be called when a {{GPURenderPassEncoder}}
    is active on |encoder|.
  - |encoder|.{{GPUCommandEncoder/copyTextureToTexture()}} must not be called when a {{GPUComputePassEncoder}}
    is active on |encoder|.

  For |source|:
  - |source| must be [=valid=].
  - |source|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[textureUsage]]}} must contain
    {{GPUTextureUsage/COPY_SRC}}.

  For |destination|:
  - |destination| must be [=valid=].
  - |destination|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[textureUsage]]}} must contain
    {{GPUTextureUsage/COPY_DST}}.

  For the texture {{GPUTexture/[[sampleCount]]}}:
  - |source|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[sampleCount]]}} must be equal to |destination|.
    {{GPUTextureCopyView/texture}}.{{GPUTexture/[[sampleCount]]}}.
  - If |source|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[sampleCount]]}} is greater than 1:
    - The copy with |source|, |destination| and |copySize| must be a |copy of the whole subresource|.

  For the texture {{GPUTexture/[[format]]}}:
  - |source|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[format]]}} must be equal to |destination|.
    {{GPUTextureCopyView/texture}}.{{GPUTexture/[[format]]}}.
  - If |source|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[format]]}} is a depth-stencil format:
    - The copy with |source|, |destination| and |copySize| must be a |copy of the whole subresource|.

  For the copy ranges:
  - [=Valid Texture Copy Range=] applies to |source| and |copySize|.
  - [=Valid Texture Copy Range=] applies to |destination| and |copySize|.
  - The [$set of subresources for texture copy$](|source|, |copySize|) and
     the  [$set of subresources for texture copy$](|destination|, |copySize|) must be disjoint.

</div>

<div algorithm>
    The <dfn abstract-op>set of subresources for texture copy</dfn>(|textureCopyView|, |copySize|)
    is the set containing:

      - If |textureCopyView|.{{GPUTextureCopyView/texture}}.{{GPUTexture/[[dimension]]}}
        is {{GPUTextureDimension/"2d"}}:
          - For each |arrayLayer| of the |copySize|.[=Extent3D/depth=] [=array layers=]
            starting at |textureCopyView|.{{GPUTextureCopyView/origin}}.[=Origin3D/z=]:
              - The [=subresource=] of |textureCopyView|.{{GPUTextureCopyView/texture}} at
                [=mipmap level=] |textureCopyView|.{{GPUTextureCopyView/mipLevel}} and
                [=array layer=] |arrayLayer|.
      - Otherwise:
          - The [=subresource=] of |textureCopyView|.{{GPUTextureCopyView/texture}} at
            [=mipmap level=] |textureCopyView|.{{GPUTextureCopyView/mipLevel}}.
</div>


## Programmable Passes ## {#programmable-passes}

<script type=idl>

interface mixin GPUProgrammablePassEncoder {
    void setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      optional sequence<GPUBufferDynamicOffset> dynamicOffsets = []);

    void setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      Uint32Array dynamicOffsetsData,
                      GPUSize64 dynamicOffsetsDataStart,
                      GPUSize32 dynamicOffsetsDataLength);

    void pushDebugGroup(DOMString groupLabel);
    void popDebugGroup();
    void insertDebugMarker(DOMString markerLabel);

    void beginPipelineStatisticsQuery(GPUQuerySet querySet, GPUSize32 queryIndex);
    void endPipelineStatisticsQuery(GPUQuerySet querySet, GPUSize32 queryIndex);
};
</script>

Debug groups in a {{GPUCommandEncoder}} or {{GPUProgrammablePassEncoder}}
must be well nested.


# Compute Passes # {#compute-passes}

## GPUComputePassEncoder ## {#compute-pass-encoder}

<script type=idl>
interface GPUComputePassEncoder {
    void setPipeline(GPUComputePipeline pipeline);
    void dispatch(GPUSize32 x, optional GPUSize32 y = 1, optional GPUSize32 z = 1);
    void dispatchIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);

    void endPass();
};
GPUComputePassEncoder includes GPUObjectBase;
GPUComputePassEncoder includes GPUProgrammablePassEncoder;
</script>

### Creation ### {#compute-pass-encoder-creation}

<script type=idl>
dictionary GPUComputePassDescriptor : GPUObjectDescriptorBase {
};
</script>


# Render Passes # {#render-passes}

## GPURenderPassEncoder ## {#render-pass-encoder}

<script type=idl>
interface mixin GPURenderEncoderBase {
    void setPipeline(GPURenderPipeline pipeline);

    void setIndexBuffer(GPUBuffer buffer, optional GPUSize64 offset = 0, optional GPUSize64 size = 0);
    void setVertexBuffer(GPUIndex32 slot, GPUBuffer buffer, optional GPUSize64 offset = 0, optional GPUSize64 size = 0);

    void draw(GPUSize32 vertexCount, optional GPUSize32 instanceCount = 1,
              optional GPUSize32 firstVertex = 0, optional GPUSize32 firstInstance = 0);
    void drawIndexed(GPUSize32 indexCount, optional GPUSize32 instanceCount = 1,
                     optional GPUSize32 firstIndex = 0,
                     optional GPUSignedOffset32 baseVertex = 0,
                     optional GPUSize32 firstInstance = 0);

    void drawIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
    void drawIndexedIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
};

interface GPURenderPassEncoder {
    void setViewport(float x, float y,
                     float width, float height,
                     float minDepth, float maxDepth);

    void setScissorRect(GPUIntegerCoordinate x, GPUIntegerCoordinate y,
                        GPUIntegerCoordinate width, GPUIntegerCoordinate height);

    void setBlendColor(GPUColor color);
    void setStencilReference(GPUStencilValue reference);

    void beginOcclusionQuery(GPUSize32 queryIndex);
    void endOcclusionQuery(GPUSize32 queryIndex);

    void executeBundles(sequence<GPURenderBundle> bundles);
    void endPass();
};
GPURenderPassEncoder includes GPUObjectBase;
GPURenderPassEncoder includes GPUProgrammablePassEncoder;
GPURenderPassEncoder includes GPURenderEncoderBase;
</script>

  * {{GPURenderEncoderBase/setIndexBuffer()}}/{{GPURenderEncoderBase/setVertexBuffer()}}:
      * If `size` is zero, the remaining size (after `offset`) of the {{GPUBuffer}} is used.

  * In indirect draw calls, the base instance field (inside the indirect
    buffer data) must be set to zero.

  * {{GPURenderPassEncoder/setScissorRect()}}:
      * An error is generated if `width` or `height` is not greater than 0.

When a {{GPURenderPassEncoder}} is created, it has the following default state:
  * Viewport:
      * `x, y` = `0.0, 0.0`
      * `width, height` = the dimensions of the pass's render targets
      * `minDepth, maxDepth` = `0.0, 1.0`
  * Scissor rectangle:
      * `x, y` = `0, 0`
      * `width, height` = the dimensions of the pass's render targets

When a {{GPURenderBundle}} is executed, it does not inherit the pass's pipeline,
bind groups, or vertex or index buffers. After a {{GPURenderBundle}} has executed,
the pass's pipeline, bind groups, and vertex and index buffers are cleared. If zero
{{GPURenderBundle}}s are executed, the command buffer state is unchanged.

### Creation ### {#render-pass-encoder-creation}

<script type=idl>
dictionary GPURenderPassDescriptor : GPUObjectDescriptorBase {
    required sequence<GPURenderPassColorAttachmentDescriptor> colorAttachments;
    GPURenderPassDepthStencilAttachmentDescriptor depthStencilAttachment;
    GPUQuerySet occlusionQuerySet;
};
</script>

#### Color Attachments #### {#color-attachments}

<script type=idl>
dictionary GPURenderPassColorAttachmentDescriptor {
    required GPUTextureView attachment;
    GPUTextureView resolveTarget;

    required (GPULoadOp or GPUColor) loadValue;
    GPUStoreOp storeOp = "store";
};
</script>

#### Depth/Stencil Attachments #### {#depth-stencil-attachments}

<script type=idl>
dictionary GPURenderPassDepthStencilAttachmentDescriptor {
    required GPUTextureView attachment;

    required (GPULoadOp or float) depthLoadValue;
    required GPUStoreOp depthStoreOp;

    required (GPULoadOp or GPUStencilValue) stencilLoadValue;
    required GPUStoreOp stencilStoreOp;
};
</script>

### Load &amp; Store Operations ### {#load-and-store-ops}

<script type=idl>
enum GPULoadOp {
    "load"
};
</script>

<script type=idl>
enum GPUStoreOp {
    "store",
    "clear"
};
</script>


# Bundles # {#bundles}

## GPURenderBundle ## {#render-bundle}

<script type=idl>
interface GPURenderBundle {
};
GPURenderBundle includes GPUObjectBase;
</script>

### Creation ### {#render-bundle-creation}

<script type=idl>
dictionary GPURenderBundleDescriptor : GPUObjectDescriptorBase {
};
</script>

<script type=idl>
interface GPURenderBundleEncoder {
    GPURenderBundle finish(optional GPURenderBundleDescriptor descriptor = {});
};
GPURenderBundleEncoder includes GPUObjectBase;
GPURenderBundleEncoder includes GPUProgrammablePassEncoder;
GPURenderBundleEncoder includes GPURenderEncoderBase;
</script>

### Encoding ### {#render-bundle-encoding}

<script type=idl>
dictionary GPURenderBundleEncoderDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUTextureFormat> colorFormats;
    GPUTextureFormat depthStencilFormat;
    GPUSize32 sampleCount = 1;
};
</script>


# Queues # {#queues}

<script type=idl>
interface GPUQueue {
    void submit(sequence<GPUCommandBuffer> commandBuffers);

    GPUFence createFence(optional GPUFenceDescriptor descriptor = {});
    void signal(GPUFence fence, GPUFenceValue signalValue);

    void writeBuffer(
        ArrayBuffer sourceData,
        GPUSize64 sourceOffset,
        GPUBuffer destination,
        GPUSize64 destinationOffset,
        GPUSize64 size);

    void copyImageBitmapToTexture(
        GPUImageBitmapCopyView source,
        GPUTextureCopyView destination,
        GPUExtent3D copySize);
};
GPUQueue includes GPUObjectBase;
</script>

<dl dfn-type="method" dfn-for="GPUQueue">
    : <dfn>writeBuffer(sourceData, sourceOffset, destination, destinationOffset, size)</dfn>
    ::
        Takes the `sourceData` contents of size `size`, starting from the byte offset `sourceOffset`,
        and schedules a write operation of these contents to the `destination` buffer on the
        [=Queue timeline=] starting at `destinationOffset`.
        Any subsequent modifications to `sourceData` do not affect what is written
        at the time that the scheduled operation runs.

        The operation throws {{OperationError}} if any of the following is true:
        - `destination` buffer isn't in the `"unmapped"` [=buffer state=].
        - `destinationOffset` is not a multiple of 4.
        - `size` is not a positive multiple of 4.
        - `sourceOffset + size` exceeds `sourceData.byteLength`.

        The operation does nothing and produces an error if any of the following is true:
        - `destination` buffer wasn't created with {{GPUBufferUsage/COPY_DST}} flag in {{GPUBufferDescriptor/usage}}.
        - `destination` buffer is destroyed
        - `destinationOffset + size` exceeds the {{GPUBufferDescriptor/size}} of the `destination` buffer.

    : <dfn>copyImageBitmapToTexture(source, destination, copySize)</dfn>
    ::
        Schedules a copy operation of the contents of an image bitmap into the destination texture.

        The operation throws {{OperationError}} if any of the following any of the following requirements are unmet:

        - {{GPUQueue/copyImageBitmapToTexture(source, destination, copySize)/copySize}}.[=Extent3D/depth=] must be `1`.

    : <dfn>submit(commandBuffers)</dfn>
    ::
        Schedules the execution of the command buffers by the GPU on this queue.

        Does nothing and produces an error if any of the following is true:

        - Any {{GPUBuffer}} referenced in any element of {{GPUQueue/submit(commandBuffers)/commandBuffers}} isn't in the `"unmapped"` [=buffer state=].
        - Any of the [=usage scopes=] contained in the command buffers fail the [=usage scope validation=].
</dl>

## GPUFence ## {#fence}

<script type=idl>
interface GPUFence {
    GPUFenceValue getCompletedValue();
    Promise<void> onCompletion(GPUFenceValue completionValue);
};
GPUFence includes GPUObjectBase;
</script>

### Creation ### {#fence-creation}

<script type=idl>
dictionary GPUFenceDescriptor : GPUObjectDescriptorBase {
    GPUFenceValue initialValue = 0;
};
</script>


Queries {#queries}
================

## QuerySet ## {#queryset}

<script type=idl>
interface GPUQuerySet {
    void destroy();
};
GPUQuerySet includes GPUObjectBase;
</script>

### Creation ### {#queryset-creation}

<script type=idl>
dictionary GPUQuerySetDescriptor : GPUObjectDescriptorBase {
    required GPUQueryType type;
    required GPUSize32 count;
    sequence<GPUPipelineStatisticName> pipelineStatistics = [];
};
</script>

<dl dfn-type=dict-member dfn-for=GPUQuerySetDescriptor>
    : <dfn>pipelineStatistics</dfn>
    ::
        The set of {{GPUPipelineStatisticName}} values in this sequence defines which pipeline statistics will be returned in the new query set.

    <div class=validusage dfn-for=GPUQuerySetDescriptor.pipelineStatistics>
      <dfn abstract-op>Valid Usage</dfn>
        1. |pipelineStatistics| is ignored if type is not {{GPUQueryType/pipeline-statistics}}.
        2. If {{GPUExtensionName/pipeline-statistics-query}} is not available, |type| must not be {{GPUQueryType/pipeline-statistics}}.
        3. If |type| is {{GPUQueryType/pipeline-statistics}},  |pipelineStatistics| must be a sequence of {{GPUPipelineStatisticName}} values which cannot be duplicated.
    </div>
</dl>

## QueryType ## {#querytype}

<script type=idl>
enum GPUQueryType {
    "occlusion",
    "pipeline-statistics"
};
</script>

## Pipeline Statistics Query ## {#pipeline-statistics}

<script type=idl>
enum GPUPipelineStatisticName {
    "vertex-shader-invocations",
    "clipper-invocations",
    "clipper-primitives-out",
    "fragment-shader-invocations",
    "compute-shader-invocations"
};
</script>

When resolving pipeline statistics query, each result is written into uint64, and the number and order of the results written to GPU buffer matches the number and order of {{GPUPipelineStatisticName}} specified in {{GPUQuerySetDescriptor/pipelineStatistics}}.


# Canvas Rendering &amp; Swap Chains # {#canvas-rendering}

<script type=idl>
interface GPUCanvasContext {
    GPUSwapChain configureSwapChain(GPUSwapChainDescriptor descriptor);

    Promise<GPUTextureFormat> getSwapChainPreferredFormat(GPUDevice device);
};
</script>

  * {{GPUCanvasContext/configureSwapChain()}}:
    Configures the swap chain for this canvas, and returns a new
    {{GPUSwapChain}} object representing it. Destroys any swapchain
    previously returned by `configureSwapChain`, including all of the
    textures it has produced.

<script type=idl>
dictionary GPUSwapChainDescriptor : GPUObjectDescriptorBase {
    required GPUDevice device;
    required GPUTextureFormat format;
    GPUTextureUsageFlags usage = 0x10;  // GPUTextureUsage.OUTPUT_ATTACHMENT
};
</script>

<script type=idl>
interface GPUSwapChain {
    GPUTexture getCurrentTexture();
};
GPUSwapChain includes GPUObjectBase;
</script>

In the "update the rendering [of the] `Document`" step of the "Update the rendering" HTML processing
model, the contents of the {{GPUTexture}} most recently returned by
{{GPUSwapChain/getCurrentTexture()}} are used to update the rendering for the `canvas`, and it is as
if {{GPUTexture/destroy()}} were called on it (making it unusable elsewhere in WebGPU).

Before this drawing buffer is presented for compositing, the implementation shall ensure that all
rendering operations have been flushed to the drawing buffer.


# Errors &amp; Debugging # {#errors-and-debugging}

## Fatal Errors ## {#fatal-errors}

<script type=idl>
interface GPUDeviceLostInfo {
    readonly attribute DOMString message;
};

partial interface GPUDevice {
    readonly attribute Promise<GPUDeviceLostInfo> lost;
};
</script>


## Error Scopes ## {#error-scopes}

<script type=idl>
enum GPUErrorFilter {
    "none",
    "out-of-memory",
    "validation"
};
</script>

<script type=idl>
interface GPUOutOfMemoryError {
    constructor();
};

interface GPUValidationError {
    constructor(DOMString message);
    readonly attribute DOMString message;
};

typedef (GPUOutOfMemoryError or GPUValidationError) GPUError;
</script>

<script type=idl>
partial interface GPUDevice {
    void pushErrorScope(GPUErrorFilter filter);
    Promise<GPUError?> popErrorScope();
};
</script>

{{GPUDevice/popErrorScope()}} throws {{OperationError}} if there are no error scopes on the stack.
{{GPUDevice/popErrorScope()}} rejects with {{OperationError}} if the device is lost.

## Telemetry ## {#telemetry}

<script type=idl>
[
    Exposed=(Window, DedicatedWorker)
]
interface GPUUncapturedErrorEvent : Event {
    constructor(
        DOMString type,
        GPUUncapturedErrorEventInit gpuUncapturedErrorEventInitDict
    );
    [SameObject] readonly attribute GPUError error;
};

dictionary GPUUncapturedErrorEventInit : EventInit {
    required GPUError error;
};
</script>

<script type=idl>
partial interface GPUDevice {
    [Exposed=(Window, DedicatedWorker)]
    attribute EventHandler onuncapturederror;
};
</script>


# Type Definitions # {#type-definitions}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferDynamicOffset;
typedef [EnforceRange] unsigned long long GPUFenceValue;
typedef [EnforceRange] unsigned long GPUStencilValue;
typedef [EnforceRange] unsigned long GPUSampleMask;
typedef [EnforceRange] long GPUDepthBias;

typedef [EnforceRange] unsigned long long GPUSize64;
typedef [EnforceRange] unsigned long GPUIntegerCoordinate;
typedef [EnforceRange] unsigned long GPUIndex32;
typedef [EnforceRange] unsigned long GPUSize32;
typedef [EnforceRange] long GPUSignedOffset32;
</script>

## Colors &amp; Vectors ## {#colors-and-vectors}

<script type=idl>
dictionary GPUColorDict {
    required double r;
    required double g;
    required double b;
    required double a;
};
typedef (sequence<double> or GPUColorDict) GPUColor;
</script>

Note: `double` is large enough to precisely hold 32-bit signed/unsigned
integers and single-precision floats.

<script type=idl>
dictionary GPUOrigin2DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin2DDict) GPUOrigin2D;
</script>

<script type=idl>
dictionary GPUOrigin3DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
    GPUIntegerCoordinate z = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin3DDict) GPUOrigin3D;
</script>

An <dfn dfn>Origin3D</dfn> is a {{GPUOrigin3D}}.
[=Origin3D=] is a spec namespace for the following definitions:
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin3D accessors" dfn-for=Origin3D>
    For a given {{GPUOrigin3D}} value |origin|, depending on its type, the syntax:

      - |origin|.<dfn dfn>x</dfn> refers to
        either {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/x}}
        or the first item of the sequence.
      - |origin|.<dfn dfn>y</dfn> refers to
        either {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/y}}
        or the second item of the sequence.
      - |origin|.<dfn dfn>z</dfn> refers to
        either {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/z}}
        or the third item of the sequence.
</div>

<script type=idl>
dictionary GPUExtent3DDict {
    required GPUIntegerCoordinate width;
    required GPUIntegerCoordinate height;
    required GPUIntegerCoordinate depth;
};
typedef (sequence<GPUIntegerCoordinate> or GPUExtent3DDict) GPUExtent3D;
</script>

An <dfn dfn>Extent3D</dfn> is a {{GPUExtent3D}}.
[=Extent3D=] is a spec namespace for the following definitions:
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUExtent3D accessors" dfn-for=Extent3D>
    For a given {{GPUExtent3D}} value |extent|, depending on its type, the syntax:

      - |extent|.<dfn dfn>width</dfn> refers to
        either {{GPUExtent3DDict}}.{{GPUExtent3DDict/width}}
        or the first item of the sequence.
      - |extent|.<dfn dfn>height</dfn> refers to
        either {{GPUExtent3DDict}}.{{GPUExtent3DDict/height}}
        or the second item of the sequence.
      - |extent|.<dfn dfn>depth</dfn> refers to
        either {{GPUExtent3DDict}}.{{GPUExtent3DDict/depth}}
        or the third item of the sequence.
</div>

<script type=idl>
typedef sequence<(GPUBuffer or ArrayBuffer)> GPUMappedBuffer;
</script>

{{GPUMappedBuffer}} is always a sequence of 2 elements, of types {{GPUBuffer}}
and {{ArrayBuffer}}, respectively.


# Temporary usages of non-exported dfns # {#temp-dfn-usages}

Eventually all of these should disappear but they are useful to avoid warning while building the specification.

[=vertex buffer=]
