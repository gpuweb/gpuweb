<pre class='metadata'>
Title: WebGPU
Shortname: webgpu
Level: 1
Status: w3c/ED
Group: webgpu
URL: https://gpuweb.github.io/gpuweb

!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues">open issues</a>)

Editor: Dzmitry Malyshau, Mozilla https://www.mozilla.org, dmalyshau@mozilla.com
Editor: Justin Fan, Apple https://www.apple.com, justin_fan@apple.com
Editor: Kai Ninomiya, Google http://www.google.com, kainino@google.com
Abstract: WebGPU exposes an API for performing operations, such as rendering and computation, on a Graphics Processing Unit.
Markup Shorthands: markdown yes
Markup Shorthands: dfn yes
Markup Shorthands: idl yes
Markup Shorthands: css no
Assume Explicit For: yes
</pre>

<pre class="link-defaults">
spec:html;
    type:interface; text:Navigator
</pre>

<pre class='anchors'>
spec: ECMA-262; urlPrefix: https://tc39.github.io/ecma262/#
    type: dfn
        text: agent; url: agent
        text: surrounding agent; url: surrounding-agent
        text: agent cluster; url: sec-agent-clusters
spec: webidl; urlPrefix: https://heycam.github.io/webidl/#
    type: dfn
        text: resolve; url: resolve
spec: web-apis; urlPrefix: https://html.spec.whatwg.org/multipage/webappapis.html#
    type: dfn
        text: cross-origin isolated; url: cross-origin-isolated
</pre>

<style>
/* Make <dl> blocks more distinct from their surroundings. */
dl:not(.switch) {
    border-left: thin solid #f3e48c;
    padding-left: .5em;
}

/* <p> by default has these margins. Update ul/ol/dl to match,
 * since they are also put in places where paragraphs go. */
p, ul, ol, dl {
    margin: 1em 0;
}

/* Box for Valid Usage requirements. */
div.validusage {
    padding: .5em;
    border: thin solid #88e !important;
    border-radius: .5em;
}
/*
 * If the Valid Usage requirements are the first child of a *-timeline block give it a larger top
 * margin to prevent the block labels from overlapping.
 */
.content-timeline>.validusage:first-child,
.device-timeline>.validusage:first-child,
.queue-timeline>.validusage:first-child {
    margin-top: 1.5em;
}

/*
 * Boxes for steps that occur on a particular timeline.
 */
div.content-timeline, div.device-timeline, div.queue-timeline {
    padding: .5em;
    border-radius: .5em;
}
.content-timeline {
    background: rgba(0, 255, 0, 0.05);
    background: var(--tint-green);
}
.device-timeline {
    background: rgba(255, 0, 0, 0.05);
    background: var(--tint-red);
}
.queue-timeline {
    background: rgba(255, 0, 255, 0.05);
    background: var(--tint-purple);
}

/*
 * Stylistic labels, for clarity of presentation of these blocks.
 *
 * NOTE: This text is non-accessible and non-selectable; surrounding
 * text must also explain the context.
 */
.validusage, .content-timeline, .device-timeline, .queue-timeline {
    position: relative;
}
.validusage::before,
.content-timeline::before,
.device-timeline::before,
.queue-timeline::before {
    font-weight: bold;
    font-style: italic;
    font-size: 130%;
    color: rgba(0, 0, 0, 0.15);
    color: var(--watermark-text);
    position: absolute;
    right: .3em;
    top: -.1em;
}
.validusage::before {
    content: "Valid Usage";
}
.content-timeline::before {
    content: "Content Timeline";
}
.device-timeline::before {
    content: "Device Timeline";
}
.queue-timeline::before {
    content: "Queue Timeline";
}

/*
 * Ensure that argumentdef blocks don't overflow algorithm section borders. This is made far harder
 * than it needs to be because the top-level W3C stylesheet has several @media + min-width variants
 * that mark themselves as !important and then proceed to do the wrong thing.
 */
@media screen and (min-width: 78em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
@media screen and (min-width: 90em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
.algorithm .overlarge {
    margin-right: auto !important;
}

/*
 * The default algorithm style has a caption that doesn't suit this spec's
 * formatting particularly well. Hide it.
 */
.algorithm .argumentdef {
    margin-top: 0;
}
.algorithm .argumentdef>caption {
    display: none;
}

/*
 * Add vertical lines to demarcate multi-column cells.
 */
table.data td[colspan] {
    border-left-style: dotted;
    border-right-style: dotted;
}

table.data.no-colspan-center td[colspan],
table.data.no-colspan-center th[colspan] {
    text-align: unset;
}

table.data tr.row-continuation td,
table.data tr.row-continuation th {
    border-top: none;
}

/*
 * Sticky table headers.
 */
.overlarge {
    /* position: sticky doesn't work inside scrollable elements. */
    overflow-x: unset;
}
thead.stickyheader th, th.stickyheader {
    position: sticky;
    top: 0;
    background: #f8f8f8;
    background: var(--stickyheader-background);
}

/*
 * Darkmode colors
 */
:root {
    --watermark-text: rgba(0, 0, 0, 15%);
    --stickyheader-background: #f8f8f8;
    --tint-red: rgba(255, 0, 0, 6%);
    --tint-green: rgba(0, 255, 0, 10%);
    --tint-blue: rgba(0, 0, 255, 5%);
    --tint-purple: rgba(255, 0, 255, 5%);
}
@media (prefers-color-scheme:dark) {
    :root {
        --watermark-text: rgba(255, 255, 255, 25%);
        --stickyheader-background: #181818;
        --tint-red: rgba(255, 0, 0, 20%);
        --tint-green: rgba(0, 255, 0, 18%);
        --tint-blue: rgba(0, 130, 255, 24%);
        --tint-purple: rgba(255, 0, 255, 22%);
    }
}

</style>


# Introduction # {#intro}

*This section is non-normative.*

[Graphics Processing Units](https://en.wikipedia.org/wiki/Graphics_processing_unit), or GPUs for short,
have been essential in enabling rich rendering and computational applications in personal computing.
WebGPU is an API that exposes the capabilities of GPU hardware for the Web.
The API is designed from the ground up to efficiently map to the
[Vulkan](https://www.khronos.org/vulkan/),
[Direct3D 12](https://docs.microsoft.com/en-us/windows/win32/direct3d12/what-is-directx-12-),
and [Metal](https://developer.apple.com/metal/) native GPU APIs.
WebGPU is not related to [WebGL](https://www.khronos.org/webgl/) and does not explicitly target OpenGL ES.

WebGPU sees physical GPU hardware as {{GPUAdapter}}s. It provides a connection to an adapter via
{{GPUDevice}}, which manages resources, and the device's {{GPUQueue}}s, which execute commands.
{{GPUDevice}} may have its own memory with high-speed access to the processing units.
{{GPUBuffer}} and {{GPUTexture}} are the <dfn dfn>physical resources</dfn> backed by GPU memory.
{{GPUCommandBuffer}} and {{GPURenderBundle}} are containers for user-recorded commands.
{{GPUShaderModule}} contains [=shader=] code. The other resources,
such as {{GPUSampler}} or {{GPUBindGroup}}, configure the way [=physical resources=] are used by the GPU.

GPUs execute commands encoded in {{GPUCommandBuffer}}s by feeding data through a [=pipeline=],
which is a mix of fixed-function and programmable stages. Programmable stages execute
<dfn dfn>shaders</dfn>, which are special programs designed to run on GPU hardware.
Most of the state of a [=pipeline=] is defined by
a {{GPURenderPipeline}} or a {{GPUComputePipeline}} object. The state not included
in these [=pipeline=] objects is set during encoding with commands,
such as {{GPUCommandEncoder/beginRenderPass()}} or {{GPURenderPassEncoder/setBlendColor()}}.


# Malicious use considerations # {#malicious-use}

*This section is non-normative.* It describes the risks associated with exposing this API on the Web.

## Security ## {#security}

The security requirements for WebGPU are the same as ever for the web, and are likewise non-negotiable.
The general approach is strictly validating all the commands before they reach GPU,
ensuring that a page can only work with its own data.

### CPU-based undefined behavior ### {#security-cpu-ub}

A WebGPU implementation translates the workloads issued by the user into API commands specific
to the target platform. Native APIs specify the valid usage for the commands
(for example, see [vkCreateDescriptorSetLayout](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateDescriptorSetLayout.html))
and generally don't guarantee any outcome if the valid usage rules are not followed.
This is called "undefined behavior", and it can be exploited by an attacker to access memory
they don't own, or force the driver to execute arbitrary code.

In order to disallow insecure usage, the range of allowed WebGPU behaviors is defined for any input.
An implementation has to validate all the input from the user and only reach the driver
with the valid workloads. This document specifies all the error conditions and handling semantics.
For example, specifying the same buffer with intersecting ranges in both "source" and "destination"
of {{GPUCommandEncoder/copyBufferToBuffer()}} results in {{GPUCommandEncoder}}
generating an error, and no other operation occurring.

See [[#errors-and-debugging]] for more information about error handling.

## GPU-based undefined behavior ## {#security-gpu-ub}

WebGPU [=shader=]s are executed by the compute units inside GPU hardware. In native APIs,
some of the shader instructions may result in undefined behavior on the GPU.
In order to address that, the shader instruction set and its defined behaviors are
strictly defined by WebGPU. When a shader is provided to {{GPUDevice/createShaderModule()}},
the WebGPU implementation has to validate it
before doing any translation (to platform-specific shaders) or transformation passes.

## Uninitialized data ## {#security-uninitialized}

Generally, allocating new memory may expose the leftover data of other applications running on the system.
In order to address that, WebGPU conceptually initializes all the resources to zero, although in practice
an implementation may skip this step if it sees the developer initializing the contents manually.
This includes variables and shared workgroup memory inside shaders.

The precise mechanism of clearing the workgroup memory can differ between platforms.
If the native API does not provide facilities to clear it, the WebGPU implementation transforms the compute
shader to first do a clear across all invocations, synchronize them, and continue executing developer's code.

## Out-of-bounds access in shaders ## {#security-shader}

[=Shader=]s can access [=physical resource=]s either directly
(for example, as a {{GPUBufferBindingType/"uniform"}} {{GPUBufferBinding}}), or via <dfn dfn>texture unit</dfn>s,
which are fixed-function hardware blocks that handle texture coordinate conversions.
Validation on the API side can only guarantee that all the inputs to the shader are provided and
they have the correct usage and types.
The host API side can not guarantee that the data is accessed within bounds
if the [=texture unit=]s are not involved.

Issue: define the host API distinct from the shader API

In order to prevent the shaders from accessing GPU memory an application doesn't own,
the WebGPU implementation may enable a special mode (called "robust buffer access") in the driver
that guarantees that the access is limited to buffer bounds.

Alternatively, an implementation may transform the shader code by inserting manual bounds checks.
When this path is taken, the out-of-bound checks only apply to array indexing. They aren't needed
for plain field access of shader structures due to the {{GPUBufferBindingLayout/minBindingSize}}
validation on the host side.

If the shader attempts to load data outside of [=physical resource=] bounds,
the implementation is allowed to:
  1. return a value at a different location within the resource bounds
  2. return a value vector of "(0, 0, 0, X)" with any "X"
  3. partially discard the draw or dispatch call

If the shader attempts to write data outside of [=physical resource=] bounds,
the implementation is allowed to:
  1. write the value to a different location within the resource bounds
  2. discard the write operation
  3. partially discard the draw or dispatch call

## Invalid data ## {#security-invalid-data}

When uploading [floating-point](https://en.wikipedia.org/wiki/IEEE_754) data from CPU to GPU,
or generating it on the GPU, we may end up with a binary representation that doesn't correspond
to a valid number, such as infinity or NaN (not-a-number). The GPU behavior in this case is
subject to the accuracy of the GPU hardware implementation of the IEEE-754 standard.
WebGPU guarantees that introducing invalid floating-point numbers would only affect the results
of arithmetic computations and will not have other side effects.

### Driver bugs ### {#security-driver-bugs}

GPU drivers are subject to bugs like any other software. If a bug occurs, an attacker
could possibly exploit the incorrect behavior of the driver to get access to unprivileged data.
In order to reduce the risk, the WebGPU working group will coordinate with GPU vendors
to integrate the WebGPU Conformance Test Suite (CTS) as part of their driver testing process,
like it was done for WebGL.
WebGPU implementations are expected to have workarounds for some of the discovered bugs,
and disable WebGPU on drivers with known bugs that can't be worked around.

### Timing attacks ### {#security-timing}

WebGPU is designed for multi-threaded use via Web Workers. As such, it is designed not to open
the users to modern high-precision timing attacks. Some of the objects,
like {{GPUBuffer}} or {{GPUQueue}}, have shared state which can be simultaneously accessed.
This allows race conditions to occur, similar to those of accessing a `SharedArrayBuffer`
from multiple Web Workers, which makes the thread scheduling observable.

WebGPU addresses this by limiting the ability to deserialize (or share) objects only to
the [=agents=] inside the [=agent cluster=], and only if
the [cross-origin isolated](https://web.dev/coop-coep/) policies are in place.
This restriction matches the [mitigations](https://hacks.mozilla.org/2020/07/safely-reviving-shared-memory/)
against the malicious `SharedArrayBuffer` use. Similarly, the user agent may also
serialize the [=agents=] sharing any handles to prevent any concurrency entirely.

In the end, the attack surface for races on shared state in WebGPU will be
a small subset of the `SharedArrayBuffer` attacks.

WebGPU also specifies the {{GPUFeatureName/"timestamp-query"}} feature, which
provides high precision timing of GPU operations. The feature is optional, and a WebGPU
implementation may limit its exposure only to those scenarios that are trusted. Alternatively,
the timing query results could be processed by a compute shader and aligned to a lower precision.

### Row hammer attacks ### {#security-rowhammer}

[Row hammer](https://en.wikipedia.org/wiki/Row_hammer) is a class of attacks that exploit the
leaking of states in DRAM cells. It could be used [on GPU](https://www.vusec.net/projects/glitch/).
WebGPU does not have any specific mitigations in place, and relies on platform-level solutions,
such as reduced memory refresh intervals.

## Denial of service ## {#security-dos}

WebGPU applications have access to GPU memory and compute units. A WebGPU implementation may limit
the available GPU memory to an application, in order to keep other applications responsive.
For GPU processing time, a WebGPU implementation may set up "watchdog" timer that makes sure an
application doesn't cause GPU unresponsiveness for more than a few seconds.
These measures are similar to those used in WebGL.

## Workload identification ## {#security-workload-identification}

WebGPU provides access to constrained global resources shared between different programs
(and web pages) running on the same machine. An application can try to indirectly probe
how constrained these global resources are, in order to reason about workloads performed
by other open web pages, based on the patterns of usage of these shared resources.
These issues are generally analogous to issues with Javascript,
such as system memory and CPU execution throughput. WebGPU does not provide any additional
mitigations for this.

### Memory resources ### {#security-memory-resources}

WebGPU exposes fallible allocations from machine-global memory heaps, such as VRAM.
This allows for probing the size of the system's remaining available memory
(for a given heap type) by attempting to allocate and watching for allocation failures.

GPUs internally have one or more (typically only two) heaps of memory
shared by all running applications. When a heap is depleted, WebGPU would fail to create a resource.
This is observable, which may allow a malicious application to guess what heaps
are used by other applications, and how much they allocate from them.

### Computation resources ### {#security-computation-resources}

If one site uses WebGPU at the same time as another, it may observe the increase
in time it takes to process some work. For example, if a site constantly submits
compute workloads and tracks completion of work on the queue,
it may observe that something else also started using the GPU.

A GPU has many parts that can be tested independently, such as the arithmetic units,
texture sampling units, atomic units, etc. A malicious application may sense when
some of these units are stressed, and attempt to guess the workload of another
application by analyzing the stress patterns. This is analogous to the realities
of CPU execution of Javascript.

## Privacy ## {#security-privacy}

### Machine-specific limits ### {#security-machine-limits}

WebGPU can expose a lot of detail on the underlying GPU architecture and the device geometry.
This includes available physical adapters, many limits on the GPU and CPU resources
that could be used (such as the maximum texture size), and any optional hardware-specific
capabilities that are available.

User agents are not obligated to expose the real hardware limits, they are in full contol of
how much the machine specifics are exposed. One strategy to reduce fingeprinting is binning
all the target platforms into a few number of bins. In general, the privacy impact of exposing
the hardware limits matches the one of WebGL.

The [=limit/default=] limits are also deliberately high enough
to allow most application to work without requesting higher limits.
All the usage of the API is validated according to the requested limits,
so the actual hardware capabilities are not exposed to the users by accident.

### Machine-specific artifacts ### {#security-machine-artifacts}

There are some machine-specific rasterization/precision artifacts and performance differences
that can be observed roughly in the same way as in WebGL. This applies to rasterization coverage
and patterns, interpolation precision of the varyings between shader stages, compute unit scheduling,
and more aspects of execution.

Generally, rasterization and precision fingerprints are identical across most or all
of the devices of each vendor. Performance differences are relatively intractable,
but also relatively low-signal (as with JS execution performance).

Privacy-critical applications and user agents should utilize software implementations to eliminate such artifacts.

### Machine-specific performance ### {#security-machine-performance}

Another factor for differentiating users is measuring the performance of specific
operations on the GPU. Even with low precision timing, repeated execution of an operation
can show if the user's machine is fast at specific workloads.
This is a fairly common vector (present in both WebGL and Javascript),
but it's also low-signal and relatively intractable to truly normalize.

WebGPU compute pipelines expose access to GPU unobstructed by the fixed-function hardware.
This poses an additional risk for unique device fingerprinting. User agents can take steps
to dissociate logical GPU invocations with actual compute units to reduce this risk.

# Fundamentals # {#fundamentals}

## Conventions ## {#api-conventions}

### Dot Syntax ### {#dot-syntax}

In this specification, the `.` ("dot") syntax, common in programming languages, is used.
The phrasing "`Foo.Bar`" means "the `Bar` member of the value (or interface) `Foo`."

For example, where `buffer` is a {{GPUBuffer}}, `buffer.[[device]].[[adapter]]` means
"the `[[adapter]]` internal slot of the `[[device]]` internal slot of `buffer`.

### Internal Objects ### {#webgpu-internal-objects}

An <dfn dfn>internal object</dfn> is a conceptual, non-exposed WebGPU object.
[=Internal objects=] track the state of an API object and hold any underlying implementation.
If the state of a particular [=internal object=] can change in parallel from multiple [=agents=],
those changes are always atomic with respect to all [=agents=].

Note: An "[=agent=]" refers to a JavaScript "thread" (i.e. main thread, or Web Worker).

### WebGPU Interfaces ### {#webgpu-interfaces}

A <dfn dfn>WebGPU interface</dfn> is an exposed interface which encapsulates an [=internal object=].
It provides the interface through which the [=internal object=]'s state is changed.

As a matter of convention, if a [=WebGPU interface=] is referred to as [=invalid=],
it means that the [=internal object=] it encapsulates is [=invalid=].

Any interface which includes {{GPUObjectBase}} is a [=WebGPU interface=].

<script type=idl>
interface mixin GPUObjectBase {
    attribute USVString? label;
};
</script>

{{GPUObjectBase}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>label</dfn>
    ::
        A label which can be used by development tools (such as error/warning messages,
        browser developer tools, or platform debugging utilities) to identify the underlying
        [=internal object=] to the developer.
        It has no specified format, and therefore cannot be reliably machine-parsed.

        In any given situation, the user agent may or may not choose to use this label.
</dl>

{{GPUObjectBase}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>\[[device]]</dfn>, of type [=device=], readonly
    ::
        An internal slot holding the [=device=] which owns the [=internal object=].
</dl>

### Object Descriptors ### {#object-descriptors}

An <dfn dfn>object descriptor</dfn> holds the information needed to create an object,
which is typically done via one of the `create*` methods of {{GPUDevice}}.

<script type=idl>
dictionary GPUObjectDescriptorBase {
    USVString label;
};
</script>

{{GPUObjectDescriptorBase}} has the following members:

<dl dfn-type=dict-member dfn-for=GPUObjectDescriptorBase>
    : <dfn>label</dfn>
    ::
        The initial value of {{GPUObjectBase/label|GPUObjectBase.label}}.
</dl>

## Invalid Internal Objects &amp; Contagious Invalidity ## {#invalidity}

If an object is successfully created, it is <dfn dfn>valid</dfn> at that moment.
An [=internal object=] may be <dfn dfn>invalid</dfn>.
It may become [=invalid=] during its lifetime, but it will never become valid again.

Issue: Consider separating "invalid" from "destroyed".
This would let validity be immutable, and only operations involving devices, buffers, and textures
(e.g. submit, map) would check those objects' `[[destroyed]]` state (explicitly).

<div class=note>
    [=Invalid=] objects result from a number of situations, including:

      - If there is an error in the creation of an object, it is immediately invalid.
        This can happen, for example, if the [=object descriptor=] doesn't describe a valid
        object, or if there is not enough memory to allocate a resource.
      - If an object is explicitly destroyed (e.g. {{GPUBuffer/destroy()|GPUBuffer.destroy()}}),
        it becomes invalid.
      - If the [=device=] that owns an object is lost, the object becomes invalid.
</div>

<div algorithm>
    To determine if a given {{GPUObjectBase}} |object| is <dfn abstract-op>valid to use with</dfn>
    a |targetObject|, run the following steps:

        1. If any of the following conditions are unsatisfied return `false`:
            <div class=validusage>
                - |object| is [=valid=]
                - If |targetObject| is a {{GPUDevice}} |object|.{{GPUObjectBase/[[device]]}} is |targetObject|.
                - Otherwise |object|.{{GPUObjectBase/[[device]]}} is |targetObject|.{{GPUObjectBase/[[device]]}}.
            </div>
        1. Return `true`.
</div>

## Coordinate Systems ## {#coordinate-systems}

WebGPU's coordinate systems match DirectX and Metal's coordinate systems in a graphics pipeline.
  - Y-axis is up in normalized device coordinate (NDC): point(-1.0, -1.0) in NDC is located at the bottom-left corner of NDC.
    In addition, x and y in NDC should be between -1.0 and 1.0 inclusive, while z in NDC should be between 0.0 and 1.0 inclusive.
    Vertices out of this range in NDC will not introduce any errors, but they will be clipped.
  - Y-axis is down in framebuffer coordinate, viewport coordinate and fragment/pixel coordinate:
    origin(0, 0) is located at the top-left corner in these coordinate systems.
  - Window/present coordinate matches framebuffer coordinate.
  - UV of origin(0, 0) in texture coordinate represents the first texel (the lowest byte) in texture memory.


## Programming Model ## {#programming-model}

### Timelines ### {#programming-model-timelines}

*This section is non-normative.*

A computer system with a user agent at the front-end and GPU at the back-end
has components working on different timelines in parallel:

: <dfn dfn>Content timeline</dfn>
:: Associated with the execution of the Web script.
    It includes calling all methods described by this specification.

    <div class=content-timeline>
        Steps executed on the content timeline look like this.
    </div>

: <dfn dfn>Device timeline</dfn>
:: Associated with the GPU device operations
    that are issued by the user agent.
    It includes creation of adapters, devices, and GPU resources
    and state objects, which are typically synchronous operations from the point
    of view of the user agent part that controls the GPU,
    but can live in a separate OS process.

    <div class=device-timeline>
        Steps executed on the device timeline look like this.
    </div>

: <dfn dfn>Queue timeline</dfn>
:: Associated with the execution of operations
    on the compute units of the GPU. It includes actual draw, copy,
    and compute jobs that run on the GPU.

    <div class=queue-timeline>
        Steps executed on the queue timeline look like this.
    </div>

In this specification, asynchronous operations are used when the result value
depends on work that happens on any timeline other than the [=Content timeline=].
They are represented by callbacks and promises in JavaScript.

<div class="example">
{{GPUComputePassEncoder/dispatch(x, y, z)|GPUComputePassEncoder.dispatch()}}:

  1. User encodes a `dispatch` command by calling a method of the
    {{GPUComputePassEncoder}} which happens on the [=Content timeline=].
  2. User issues {{GPUQueue/submit(commandBuffers)|GPUQueue.submit()}} that hands over
    the {{GPUCommandBuffer}} to the user agent, which processes it
    on the [=Device timeline=] by calling the OS driver to do a low-level submission.
  3. The submit gets dispatched by the GPU invocation scheduler onto the
    actual compute units for execution, which happens on the [=Queue timeline=].

</div>
<div class="example">
{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer()}}:

  1. User fills out a {{GPUBufferDescriptor}} and creates a {{GPUBuffer}} with it,
    which happens on the [=Content timeline=].
  2. User agent creates a low-level buffer on the [=Device timeline=].

</div>
<div class="example">
{{GPUBuffer/mapAsync()|GPUBuffer.mapAsync()}}:

  1. User requests to map a {{GPUBuffer}} on the [=Content timeline=] and
    gets a promise in return.
  2. User agent checks if the buffer is currently used by the GPU
    and makes a reminder to itself to check back when this usage is over.
  3. After the GPU operating on [=Queue timeline=] is done using the buffer,
    the user agent maps it to memory and [=resolves=] the promise.

</div>

### Memory Model ### {#programming-model-memory}

*This section is non-normative.*

Once a {{GPUDevice}} has been obtained during an application initialization routine,
we can describe the <dfn dfn>WebGPU platform</dfn> as consisting of the following layers:
  1. User agent implementing the specification.
  2. Operating system with low-level native API drivers for this device.
  3. Actual CPU and GPU hardware.

Each layer of the [=WebGPU platform=] may have different memory types
that the user agent needs to consider when implementing the specification:
  - The script-owned memory, such as an {{ArrayBuffer}} created by the script,
    is generally not accessible by a GPU driver.
  - A user agent may have different processes responsible for running
    the content and communication to the GPU driver.
    In this case, it uses inter-process shared memory to transfer data.
  - Dedicated GPUs have their own memory with high bandwidth,
    while integrated GPUs typically share memory with the system.

Most [=physical resources=] are allocated in the memory of type
that is efficient for computation or rendering by the GPU.
When the user needs to provide new data to the GPU,
the data may first need to cross the process boundary in order to reach
the user agent part that communicates with the GPU driver.
Then it may need to be made visible to the driver,
which sometimes requires a copy into driver-allocated staging memory.
Finally, it may need to be transferred to the dedicated GPU memory,
potentially changing the internal layout into one
that is most efficient for GPUs to operate on.

All of these transitions are done by the WebGPU implementation of the user agent.

Note: This example describes the worst case, while in practice
the implementation may not need to cross the process boundary,
or may be able to expose the driver-managed memory directly to
the user behind an `ArrayBuffer`, thus avoiding any data copies.

### Multi-Threading ### {#programming-model-multi-threading}

### Resource Usages ### {#programming-model-resource-usages}

A [=physical resource=] can be used on GPU with an <dfn dfn>internal usage</dfn>:
<dl dfn-type=dfn dfn-for="internal usage">
    : <dfn>input</dfn>
    :: Buffer with input data for draw or dispatch calls. Preserves the contents.
        Allowed by buffer {{GPUBufferUsage/INDEX}}, buffer {{GPUBufferUsage/VERTEX}}, or buffer {{GPUBufferUsage/INDIRECT}}.
    : <dfn>constant</dfn>
    ::  Resource bindings that are constant from the shader point of view. Preserves the contents.
        Allowed by buffer {{GPUBufferUsage/UNIFORM}} or texture {{GPUTextureUsage/SAMPLED}}.
    : <dfn>storage</dfn>
    ::  Read-write storage resource binding.
        Allowed by buffer {{GPUBufferUsage/STORAGE}}.
    : <dfn>storage-read</dfn>
    ::  Read-only storage resource bindings. Preserves the contents.
        Allowed by buffer {{GPUBufferUsage/STORAGE}} or texture {{GPUTextureUsage/STORAGE}}.
    : <dfn>storage-write</dfn>
    ::  Write-only storage resource bindings.
        Allowed by texture {{GPUTextureUsage/STORAGE}}.
    : <dfn>attachment</dfn>
    :: Texture used as an output attachment in a render pass.
        Allowed by texture {{GPUTextureUsage/RENDER_ATTACHMENT}}.
    : <dfn>attachment-read</dfn>
    ::  Texture used as a read-only attachment in a render pass. Preserves the contents.
        Allowed by texture {{GPUTextureUsage/RENDER_ATTACHMENT}}.
</dl>

Textures may consist of separate [=mipmap levels=] and [=array layers=],
which can be used differently at any given time.
Each such <dfn dfn>texture subresource</dfn> is uniquely identified by a
[=texture=], [=mipmap level=], and
(for {{GPUTextureDimension/2d}} textures only) [=array layer=],
and [=aspect=].

We define <dfn dfn>subresource</dfn> to be either a whole buffer, or a [=texture subresource=].

<div algorithm="compatible usage list">
Some [=internal usages=] are compatible with others. A [=subresource=] can be in a state
that combines multiple usages together. We consider a list |U| to be
a <dfn dfn>compatible usage list</dfn> if (and only if) it satisfies any of the following rules:
    - Each usage in |U| is [=internal usage/input=], [=internal usage/constant=], [=internal usage/storage-read=], or [=internal usage/attachment-read=].
    - Each usage in |U| is [=internal usage/storage=].
    - Each usage in |U| is [=internal usage/storage-write=].
    - |U| contains exactly one element: [=internal usage/attachment=].
</div>

Enforcing that the usages are only combined into a [=compatible usage list=]
allows the API to limit when data races can occur in working with memory.
That property makes applications written against
WebGPU more likely to run without modification on different platforms.

Generally, when an implementation processes an operation that uses a [=subresource=]
in a different way than its current usage allows, it schedules a transition of the resource
into the new state. In some cases, like within an open {{GPURenderPassEncoder}}, such a
transition is impossible due to the hardware limitations.
We define these places as <dfn dfn>usage scopes</dfn>.

The **main usage rule** is, for any one [=subresource=], its list of [=internal usages=]
within one [=usage scope=] must be a [=compatible usage list=].

For example, binding the same buffer for [=internal usage/storage=] as well as for
[=internal usage/input=] within the same {{GPURenderPassEncoder}} would put the encoder
as well as the owning {{GPUCommandEncoder}} into the error state.
This combination of usages does not make a [=compatible usage list=].

Note: race condition of multiple writable storage buffer/texture usages in a single [=usage scope=] is allowed.

The [=subresources=] of textures included in the views provided to
{{GPURenderPassColorAttachment/view|GPURenderPassColorAttachment.view}} and
{{GPURenderPassColorAttachment/resolveTarget|GPURenderPassColorAttachment.resolveTarget}}
are considered to be used as [=internal usage/attachment=] for the [=usage scope=] of this render pass.

The <dfn dfn>physical size</dfn> of a [=texture subresource=] is the dimension of the
[=texture subresource=] in texels that includes the possible extra paddings
to form complete [=texel blocks=] in the [=subresource=].

  - For pixel-based {{GPUTextureFormat|GPUTextureFormats}}, the [=physical size=] is always equal to the size of the [=texture subresource=]
    used in the sampling hardwares.
  - [=Textures=] in block-based compressed {{GPUTextureFormat|GPUTextureFormats}} always have a [=mipmap level=] 0 whose {{GPUTexture/[[textureSize]]}}
    is a multiple of the [=texel block size=], but the lower mipmap levels might not be the multiple of the [=texel block size=] and can
    have paddings.

<div class="example">
Considering a {{GPUTexture}} in BC format whose {{GPUTexture/[[textureSize]]}} is {60, 60, 1}, when sampling
the {{GPUTexture}} at [=mipmap level=] 2, the sampling hardware uses {15, 15, 1} as the size of the [=texture subresource=],
while its [=physical size=] is {16, 16, 1} as the block-compression algorithm can only operate on 4x4 [=texel blocks=].
</div>

### Synchronization ### {#programming-model-synchronization}

For each [=subresource=] of a [=physical resource=], its set of
[=internal usage=] flags is tracked on the [=Queue timeline=].

Issue: This section will need to be revised to support multiple queues.

On the [=Queue timeline=], there is an ordered sequence of [=usage scopes=].
For the duration of each scope, the set of [=internal usage=] flags of any given
[=subresource=] is constant.
A [=subresource=] may transition to new usages at the boundaries between [=usage scope=]s.

This specification defines the following [=usage scopes=]:

- Outside of a pass (in {{GPUCommandEncoder}}), each (non-state-setting) command is one usage scope
    (e.g. {{GPUCommandEncoder/copyBufferToTexture()}}).
- In a compute pass, each dispatch command ({{GPUComputePassEncoder/dispatch()}} or
    {{GPUComputePassEncoder/dispatchIndirect()}}) is one usage scope.
    A subresource is "used" in the usage scope if it's accessible by the command.
    Within a dispatch, every subresource in every currently bound {{GPUBindGroup}}
    is "used" in the usage scope.
    State-setting compute pass commands, like
    {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}},
    do not contribute directly to a usage scope; they instead change the
    state that is checked in dispatch commands.
- One render pass is one usage scope.
    A subresource is "used" in the usage scope if it's referenced by any
    (state-setting or non-state-setting) command. For example, in
    {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}},
    every subresource in `bindGroup` is "used" in the render pass's usage scope.

Issue: The above should probably talk about [=GPU commands=]. But we don't have a way to
reference specific GPU commands (like dispatch) yet.

<div class=note>
    The above rules mean the following example resource usages **are**
    included in [=usage scope validation=]:

    - In a render pass, subresources used in any
        {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup()}}
        call, regardless of whether the currently bound pipeline's
        shader or layout actually depends on these bindings,
        or the bind group is shadowed by another 'set' call.
    - A buffer used in any {{GPURenderEncoderBase/setVertexBuffer()|setVertexBuffer()}}
        call, regardless of whether any draw call depends on this buffer,
        or this buffer is shadowed by another 'set' call.
    - A buffer used in any {{GPURenderEncoderBase/setIndexBuffer()|setIndexBuffer()}}
        call, regardless of whether any draw call depends on this buffer,
        or this buffer is shadowed by another 'set' call.
    - A texture subresource used as a color attachment, resolve attachment, or
        depth/stencil attachment in {{GPURenderPassDescriptor}} by
        {{GPUCommandEncoder/beginRenderPass()|beginRenderPass()}},
        regardless of whether the shader actually depends on these attachments.
    - Resources used in bind group entries with visibility 0, or visible only
        to the compute stage but used in a render pass (or vice versa).
</div>

During command encoding, every usage of a subresource is recorded in one of the
[=usage scopes=] in the command buffer.
For each [=usage scope=], the implementation performs
<dfn dfn>usage scope validation</dfn> by composing the list of all
[=internal usage=] flags of each [=subresource=] used in the [=usage scope=].
If any of those lists is not a [=compatible usage list=],
{{GPUCommandEncoder/finish()|GPUCommandEncoder.finish()}}
generates a {{GPUValidationError}} in the current error scope.


## Core Internal Objects ## {#core-internal-objects}

### Adapters ### {#adapters}

An <dfn dfn>adapter</dfn> represents an implementation of WebGPU on the system.
Each adapter identifies both an instance of a hardware accelerator (e.g. GPU or CPU) and
an instance of a browser's implementation of WebGPU on top of that accelerator.

If an [=adapter=] becomes unavailable, it becomes [=invalid=].
Once invalid, it never becomes valid again.
Any [=devices=] on the adapter, and [=internal objects=] owned by those devices,
also become invalid.

Note:
An [=adapter=] may be a physical display adapter (GPU), but it could also be
a software renderer.
A returned [=adapter=] could refer to different physical adapters, or to
different browser codepaths or system drivers on the same physical adapters.
Applications can hold onto multiple [=adapters=] at once (via {{GPUAdapter}})
(even if some are [=invalid=]),
and two of these could refer to different instances of the same physical
configuration (e.g. if the GPU was reset or disconnected and reconnected).

An [=adapter=] has the following internal slots:

<dl dfn-type=attribute dfn-for=adapter>
    : <dfn>\[[features]]</dfn>, of type [=ordered set=]&lt;{{GPUFeatureName}}&gt;, readonly
    ::
        The [=features=] which can be used to create devices on this adapter.

    : <dfn>\[[limits]]</dfn>, of type [=supported limits=], readonly
    ::
        The [=limit/better|best=] limits which can be used to create devices on this adapter.

        Each adapter limit must be the same or [=limit/better=] than its default value
        in [=supported limits=].
</dl>

[=Adapters=] are exposed via {{GPUAdapter}}.

### Devices ### {#devices}

A <dfn dfn>device</dfn> is the logical instantiation of an [=adapter=],
through which [=internal objects=] are created.
It can be shared across multiple [=agents=] (e.g. dedicated workers).

A [=device=] is the exclusive owner of all [=internal objects=] created from it:
when the [=device=] is lost, it and all objects created on it (directly, e.g.
{{GPUDevice/createTexture()}}, or indirectly, e.g. {{GPUTexture/createView()}}) become
[=invalid=].

Issue: Define "ownership".

A [=device=] has the following internal slots:

<dl dfn-type=attribute dfn-for=device>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        The [=adapter=] from which this device was created.

    : <dfn>\[[features]]</dfn>, of type [=ordered set=]&lt;{{GPUFeatureName}}&gt;, readonly
    ::
        The [=features=] which can be used on this device.
        No additional features can be used, even if the underlying [=adapter=] can support them.

    : <dfn>\[[limits]]</dfn>, of type [=supported limits=], readonly
    ::
        The limits which can be used on this device.
        No [=limit/better=] limits can be used, even if the underlying [=adapter=] can support them.
</dl>

Issue: [=device=] is already an internal concept. Having slots be marked as internal is redundant
and adds extra `[[`/`]]` in spec text. Consider removing the brackets.

<div algorithm>
    When <dfn dfn>a new device</dfn> |device| is created from [=adapter=] |adapter|
    with {{GPUDeviceDescriptor}} |descriptor|:

    - Set |device|.{{device/[[adapter]]}} to |adapter|.

    - Set |device|.{{device/[[features]]}} to the [=ordered set|set=] of values in
        |descriptor|.{{GPUDeviceDescriptor/nonGuaranteedFeatures}}.

    - Let |device|.{{device/[[limits]]}} be a [=supported limits=] object with the default values.
        For each (|key|, |value|) pair in |descriptor|.{{GPUDeviceDescriptor/nonGuaranteedLimits}}, set the
        member corresponding to |key| in |device|.{{device/[[limits]]}} to the value |value|.
</div>

[=Devices=] are exposed via {{GPUDevice}}.

## Optional Capabilities ## {#optional-capabilities}

WebGPU [=adapters=] and [=devices=] have <dfn dfn>capabilities</dfn>, which
describe WebGPU functionality that differs between different implementations,
typically due to hardware or system software constraints.
A [=capability=] is either a [=feature=] or a [=limit=].

### Features ### {#features}

A <dfn dfn>feature</dfn> is a set of optional WebGPU functionality that is not supported
on all implementations, typically due to hardware or system software constraints.

Each {{GPUAdapter}} exposes a set of available features.
Only those features may be requested in {{GPUAdapter/requestDevice()}}.

Functionality that is part of an feature may only be used if the feature
was requested at device creation. See the [[#feature-index|Feature Index]]
for a description of the functionality each feature enables.

### Limits ### {#limits}

Each <dfn dfn>limit</dfn> is a numeric limit on the usage of WebGPU on a device.

A <dfn dfn>supported limits</dfn> object has a value for every defined limit.
Each [=adapter=] has a set of [=supported limits=], and
[=devices=] are {{GPUDeviceDescriptor/nonGuaranteedLimits|created}} with specific [=supported limits=] in place.
The device limits are enforced regardless of the adapter's limits.

One limit value may be <dfn dfn for=limit>better</dfn> than another.
A [=limit/better=] limit value always relaxes validation, enabling strictly
more programs to be valid. For each limit, "better" is defined.

Note:
Setting "better" limits may not necessarily be desirable, as they may have a performance impact.
Because of this, and to improve portability across devices and implementations,
applications should generally request the "worst" limits that work for their content
(ideally, the default values).

Each limit also has a <dfn dfn for=limit>default</dfn> value.
Every [=adapter=] is guaranteed to support the default value or [=limit/better=].
The default is used if a value is not explicitly specified in {{GPUDeviceDescriptor/nonGuaranteedLimits}}.

<table class="data no-colspan-center" dfn-type=attribute dfn-for="supported limits">
    <thead>
        <tr><th>Limit name <th>Type <th>[=limit/Better=] <th>[=limit/Default=]
    </thead>

    <tr><td><dfn>maxTextureDimension1D</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8192
    <tr class=row-continuation><td colspan=4>
        The maximum allowed value for the {{GPUTextureDescriptor/size}}.[=Extent3D/width=]
        of a [=texture=] created with {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}}.

    <tr><td><dfn>maxTextureDimension2D</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8192
    <tr class=row-continuation><td colspan=4>
        The maximum allowed value for the {{GPUTextureDescriptor/size}}.[=Extent3D/width=] and {{GPUTextureDescriptor/size}}.[=Extent3D/height=]
        of a [=texture=] created with {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"2d"}}.

    <tr><td><dfn>maxTextureDimension3D</dfn>
        <td>{{GPUSize32}} <td>Higher <td>2048
    <tr class=row-continuation><td colspan=4>
        The maximum allowed value for the {{GPUTextureDescriptor/size}}.[=Extent3D/width=], {{GPUTextureDescriptor/size}}.[=Extent3D/height=] and {{GPUTextureDescriptor/size}}.[=Extent3D/depth=]
        of a [=texture=] created with {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"3d"}}.

    <tr><td><dfn>maxTextureArrayLayers</dfn>
        <td>{{GPUSize32}} <td>Higher <td>2048
    <tr class=row-continuation><td colspan=4>
        The maximum allowed value for the {{GPUTextureDescriptor/size}}.[=Extent3D/depth=]
        of a [=texture=] created with {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}} or {{GPUTextureDimension/"2d"}}.

    <tr><td><dfn>maxBindGroups</dfn>
        <td>{{GPUSize32}} <td>Higher <td>4
    <tr class=row-continuation><td colspan=4>
        The maximum number of {{GPUBindGroupLayout|GPUBindGroupLayouts}}
        allowed in {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

    <tr><td><dfn>maxDynamicUniformBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8
    <tr class=row-continuation><td colspan=4>
        The maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - [$layout entry binding type$] is {{GPUBufferBindingType/"uniform"}}, and
          - {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

    <tr><td><dfn>maxDynamicStorageBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>Higher <td>4
    <tr class=row-continuation><td colspan=4>
        The maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - [$layout entry binding type$] is {{GPUBufferBindingType/"storage"}}, and
          - {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

    <tr><td><dfn>maxSampledTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16
    <tr class=row-continuation><td colspan=4>
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - {{GPUBindGroupLayoutEntry/texture}} is not `undefined`, and
          - {{GPUBindGroupLayoutEntry/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

    <tr><td><dfn>maxSamplersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16
    <tr class=row-continuation><td colspan=4>
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - [=Binding member=] is {{GPUBindGroupLayoutEntry/sampler}}, and
          - {{GPUBindGroupLayoutEntry/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

    <tr><td><dfn>maxStorageBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>4
    <tr class=row-continuation><td colspan=4>
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - [$layout entry binding type$] is {{GPUBufferBindingType/"storage"}}, and
          - {{GPUBindGroupLayoutEntry/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

    <tr><td><dfn>maxStorageTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>4
    <tr class=row-continuation><td colspan=4>
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - [=Binding member=] is {{GPUBindGroupLayoutEntry/storageTexture}}, and
          - {{GPUBindGroupLayoutEntry/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

    <tr><td><dfn>maxUniformBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>Higher <td>12
    <tr class=row-continuation><td colspan=4>
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/entries}} for which:

          - [$layout entry binding type$] is {{GPUBufferBindingType/"uniform"}}, and
          - {{GPUBindGroupLayoutEntry/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

    <tr><td><dfn>maxUniformBufferBindingSize</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16384
    <tr class=row-continuation><td colspan=4>
        The maximum {{GPUBufferBinding}}.{{GPUBufferBinding/size}} for bindings for which the
        [$layout entry binding type$] is {{GPUBufferBindingType/"uniform"}}.

    <tr><td><dfn>maxStorageBufferBindingSize</dfn>
        <td>{{GPUSize32}} <td>Higher <td> 134217728 (128 MiB)
    <tr class=row-continuation><td colspan=4>
        The maximum {{GPUBufferBinding}}.{{GPUBufferBinding/size}} for bindings for which the
        [$layout entry binding type$] is {{GPUBufferBindingType/"storage"}} or {{GPUBufferBindingType/"read-only-storage"}}.

    <tr><td><dfn>maxVertexBuffers</dfn>
        <td>{{GPUSize32}} <td>Higher <td>8
    <tr class=row-continuation><td colspan=4>
        The maximum number of {{GPUVertexState/buffers}}
        when creating a {{GPURenderPipeline}}.

    <tr><td><dfn>maxVertexAttributes</dfn>
        <td>{{GPUSize32}} <td>Higher <td>16
    <tr class=row-continuation><td colspan=4>
        The maximum number of {{GPUVertexBufferLayout/attributes}}
        in total across {{GPUVertexState/buffers}}
        when creating a {{GPURenderPipeline}}.

    <tr><td><dfn>maxVertexBufferArrayStride</dfn>
        <td>{{GPUSize32}} <td>Higher <td>2048
    <tr class=row-continuation><td colspan=4>
        The maximum allowed {{GPUVertexBufferLayout/arrayStride}}
        when creating a {{GPURenderPipeline}}.
</table>

#### <dfn interface>GPUAdapterLimits</dfn> #### {#gpu-adapterlimits}

{{GPUAdapterLimits}} exposes the [=limits=] supported by an adapter.
See {{GPUAdapter/limits|GPUAdapter.limits}}.

<script type=idl>
interface GPUAdapterLimits {
    readonly attribute GPUSize32 maxTextureDimension1D;
    readonly attribute GPUSize32 maxTextureDimension2D;
    readonly attribute GPUSize32 maxTextureDimension3D;
    readonly attribute GPUSize32 maxTextureArrayLayers;
    readonly attribute GPUSize32 maxBindGroups;
    readonly attribute GPUSize32 maxDynamicUniformBuffersPerPipelineLayout;
    readonly attribute GPUSize32 maxDynamicStorageBuffersPerPipelineLayout;
    readonly attribute GPUSize32 maxSampledTexturesPerShaderStage;
    readonly attribute GPUSize32 maxSamplersPerShaderStage;
    readonly attribute GPUSize32 maxStorageBuffersPerShaderStage;
    readonly attribute GPUSize32 maxStorageTexturesPerShaderStage;
    readonly attribute GPUSize32 maxUniformBuffersPerShaderStage;
    readonly attribute GPUSize32 maxUniformBufferBindingSize;
    readonly attribute GPUSize32 maxStorageBufferBindingSize;
    readonly attribute GPUSize32 maxVertexBuffers;
    readonly attribute GPUSize32 maxVertexAttributes;
    readonly attribute GPUSize32 maxVertexBufferArrayStride;
};
</script>

#### <dfn interface>GPUAdapterFeatures</dfn> #### {#gpu-adapterfeatures}

{{GPUAdapterFeatures}} is a [=setlike=] interface. Its [=set entries=] are
the {{GPUFeatureName}} values of the [=features=] supported by an adapter.

<script type=idl>
interface GPUAdapterFeatures {
    readonly setlike<GPUFeatureName>;
};
</script>


# Initialization # {#initialization}

## Examples ## {#initialization-examples}

Issue:
Need a robust example like the one in ErrorHandling.md, which handles all situations.
Possibly also include a simple example with no handling.

## navigator.gpu ## {#navigator-gpu}

A {{GPU}} object is available via `navigator.gpu` on the {{Window}}:

<script type=idl>
[Exposed=Window]
partial interface Navigator {
    [SameObject] readonly attribute GPU gpu;
};
</script>

... as well as on dedicated workers:

<script type=idl>
[Exposed=DedicatedWorker]
partial interface WorkerNavigator {
    [SameObject] readonly attribute GPU gpu;
};
</script>

## GPU ## {#gpu-interface}

<dfn interface>GPU</dfn> is the entry point to WebGPU.

<script type=idl>
[Exposed=(Window, DedicatedWorker)]
interface GPU {
    Promise<GPUAdapter?> requestAdapter(optional GPURequestAdapterOptions options = {});
};
</script>

{{GPU}} has the following methods:

<dl dfn-type=method dfn-for=GPU>
    : <dfn>requestAdapter(options)</dfn>
    ::
        Requests an [=adapter=] from the user agent.
        The user agent chooses whether to return an adapter, and, if so,
        chooses according to the provided options.

        <div algorithm=GPU.requestAdapter>
            **Called on:** {{GPU}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPU/requestAdapter(options)">
                |options|: Criteria used to select the adapter.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPUAdapter}}?&gt;

            1. Let |promise| be [=a new promise=].
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If the user agent chooses to return an adapter:

                        1. The user agent chooses an [=adapter=] |adapter| according to the rules in
                            [[#adapter-selection]] and the criteria in |options|.

                        1. |promise| [=resolves=] with a new {{GPUAdapter}} encapsulating |adapter|.

                    1. Otherwise, |promise| [=resolves=] with `null`.
                </div>
            1. Return |promise|.

            <!-- If we add ways to make invalid adapter requests (aside from those
                 that violate IDL rules), specify that they reject the promise. -->
        </div>
</dl>

### Adapter Selection ### {#adapter-selection}

<dfn dictionary>GPURequestAdapterOptions</dfn>
provides hints to the user agent indicating what
configuration is suitable for the application.

<script type=idl>
dictionary GPURequestAdapterOptions {
    GPUPowerPreference powerPreference;
};
</script>

<script type=idl>
enum GPUPowerPreference {
    "low-power",
    "high-performance"
};
</script>

{{GPURequestAdapterOptions}} has the following members:

<dl dfn-type=dict-member dfn-for=GPURequestAdapterOptions>
    : <dfn>powerPreference</dfn>
    ::
        Optionally provides a hint indicating what class of [=adapter=] should be selected from
        the system's available adapters.

        The value of this hint may influence which adapter is chosen, but it must not
        influence whether an adapter is returned or not.

        Note:
        The primary utility of this hint is to influence which GPU is used in a multi-GPU system.
        For instance, some laptops have a low-power integrated GPU and a high-performance
        discrete GPU.

        Note:
        Depending on the exact hardware configuration, such as battery status and attached displays
        or removable GPUs, the user agent may select different [=adapters=] given the same power
        preference.
        Typically, given the same hardware configuration and state and
        `powerPreference`, the user agent is likely to select the same adapter.

        It must be one of the following values:

        <dl dfn-type=enum-value dfn-for=GPUPowerPreference>
            : `undefined` (or not present)
            ::
                Provides no hint to the user agent.

            : <dfn>"low-power"</dfn>
            ::
                Indicates a request to prioritize power savings over performance.

                Note:
                Generally, content should use this if it is unlikely to be constrained by drawing
                performance; for example, if it renders only one frame per second, draws only relatively
                simple geometry with simple shaders, or uses a small HTML canvas element.
                Developers are encouraged to use this value if their content allows, since it may
                significantly improve battery life on portable devices.

            : <dfn>"high-performance"</dfn>
            ::
                Indicates a request to prioritize performance over power consumption.

                Note:
                By choosing this value, developers should be aware that, for [=devices=] created on the
                resulting adapter, user agents are more likely to force device loss, in order to save
                power by switching to a lower-power adapter.
                Developers are encouraged to only specify this value if they believe it is absolutely
                necessary, since it may significantly decrease battery life on portable devices.
        </dl>
</dl>

## <dfn interface>GPUAdapter</dfn> ## {#gpu-adapter}

A {{GPUAdapter}} encapsulates an [=adapter=],
and describes its capabilities ([=features=] and [=limits=]).

To get a {{GPUAdapter}}, use {{GPU/requestAdapter()}}.

<script type=idl>
interface GPUAdapter {
    readonly attribute DOMString name;
    [SameObject] readonly attribute GPUAdapterFeatures features;
    [SameObject] readonly attribute GPUAdapterLimits limits;

    Promise<GPUDevice?> requestDevice(optional GPUDeviceDescriptor descriptor = {});
};
</script>

{{GPUAdapter}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>name</dfn>
    ::
        A human-readable name identifying the adapter.
        The contents are implementation-defined.

    : <dfn>features</dfn>
    ::
        The set of values in `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[features]]}}.

    : <dfn>limits</dfn>
    ::
        The limits in `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[limits]]}}.
</dl>

{{GPUAdapter}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        The [=adapter=] to which this {{GPUAdapter}} refers.
</dl>

{{GPUAdapter}} has the following methods:

<dl dfn-type=method dfn-for=GPUAdapter>
    : <dfn>requestDevice(descriptor)</dfn>
    ::
        Requests a [=device=] from the [=adapter=].

        <div algorithm=GPUAdapter.requestDevice>
            **Called on:** {{GPUAdapter}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUAdapter/requestDevice(descriptor)">
                |descriptor|: Description of the {{GPUDevice}} to request.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPUDevice}}?&gt;

            1. Let |promise| be [=a new promise=].
            1. Let |adapter| be |this|.{{GPUAdapter/[[adapter]]}}.
            1. Issue the following steps to the [=Device timeline=]:
                <div class=device-timeline>
                    1. If any of the following requirements are unmet,
                        [=reject=] |promise| with a {{TypeError}} and stop.

                        <div class=validusage>
                            - The set of values in |descriptor|.{{GPUDeviceDescriptor/nonGuaranteedFeatures}}
                                must be a subset of those in |adapter|.{{adapter/[[features]]}}.

                            - Each key in |descriptor|.{{GPUDeviceDescriptor/nonGuaranteedLimits}}
                                must be the name of a member of [=supported limits=].
                        </div>

                    1. If any of the following requirements are unmet,
                        [=reject=] |promise| with an {{OperationError}} and stop.

                        <div class=validusage>
                            - For each type of limit in [=supported limits=], the value of that
                                limit in |descriptor|.{{GPUDeviceDescriptor/nonGuaranteedLimits}}
                                must be no [=limit/better=] than the value of that limit in
                                |adapter|.{{adapter/[[limits]]}}.
                        </div>

                    1. If the user agent cannot fulfill the request,
                        [=resolve=] |promise| to `null` and stop.

                    1. [=Resolve=] |promise| to a new {{GPUDevice}} object encapsulating
                        [=a new device=] with the capabilities described by |descriptor|.
                </div>
            1. Return |promise|.

        </div>
</dl>

### <dfn dictionary>GPUDeviceDescriptor</dfn> ### {#gpudevicedescriptor}

{{GPUDeviceDescriptor}} describes a device request.

<script type=idl>
dictionary GPUDeviceDescriptor : GPUObjectDescriptorBase {
    sequence<GPUFeatureName> nonGuaranteedFeatures = [];
    record<DOMString, GPUSize32> nonGuaranteedLimits = {};
};
</script>

{{GPUDeviceDescriptor}} has the following members:

<dl dfn-type=dict-member dfn-for=GPUDeviceDescriptor>
    : <dfn>nonGuaranteedFeatures</dfn>
    ::
        The set of {{GPUFeatureName}} values in this sequence defines the exact set of
        [=features=] that must be enabled on the device.

    : <dfn>nonGuaranteedLimits</dfn>
    ::
        Defines the exact [=limits=] that must be enabled on the device.
        Each key must be the name of a member of [=supported limits=].

        <!-- If we ever need limit types other than GPUSize32, we can change the value type to
        `double` or `any` in the future and write out the type conversion explicitly (by reference
        to WebIDL spec). Or change the entire type to `any` and add back a `dictionary GPULimits`
        and define the conversion of the whole object by reference to WebIDL. -->
</dl>

#### <dfn enum>GPUFeatureName</dfn> #### {#gpufeaturename}

Each {{GPUFeatureName}} identifies a set of functionality which, if available,
allows additional usages of WebGPU that would have otherwise been invalid.

<script type=idl>
enum GPUFeatureName {
    "depth-clamping",
    "depth24unorm-stencil8",
    "depth32float-stencil8",
    "pipeline-statistics-query",
    "texture-compression-bc",
    "timestamp-query",
};
</script>

## <dfn interface>GPUDevice</dfn> ## {#gpu-device}

A {{GPUDevice}} encapsulates a [=device=] and exposes
the functionality of that device.

{{GPUDevice}} is the top-level interface through which [=WebGPU interfaces=] are created.

To get a {{GPUDevice}}, use {{GPUAdapter/requestDevice()}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker), Serializable]
interface GPUDevice : EventTarget {
    [SameObject] readonly attribute GPUAdapter adapter;
    readonly attribute FrozenArray<GPUFeatureName> features;
    readonly attribute object limits;

    [SameObject] readonly attribute GPUQueue queue;

    undefined destroy();

    GPUBuffer createBuffer(GPUBufferDescriptor descriptor);
    GPUTexture createTexture(GPUTextureDescriptor descriptor);
    GPUSampler createSampler(optional GPUSamplerDescriptor descriptor = {});

    GPUBindGroupLayout createBindGroupLayout(GPUBindGroupLayoutDescriptor descriptor);
    GPUPipelineLayout createPipelineLayout(GPUPipelineLayoutDescriptor descriptor);
    GPUBindGroup createBindGroup(GPUBindGroupDescriptor descriptor);

    GPUShaderModule createShaderModule(GPUShaderModuleDescriptor descriptor);
    GPUComputePipeline createComputePipeline(GPUComputePipelineDescriptor descriptor);
    GPURenderPipeline createRenderPipeline(GPURenderPipelineDescriptor descriptor);
    Promise<GPUComputePipeline> createComputePipelineAsync(GPUComputePipelineDescriptor descriptor);
    Promise<GPURenderPipeline> createRenderPipelineAsync(GPURenderPipelineDescriptor descriptor);

    GPUCommandEncoder createCommandEncoder(optional GPUCommandEncoderDescriptor descriptor = {});
    GPURenderBundleEncoder createRenderBundleEncoder(GPURenderBundleEncoderDescriptor descriptor);

    GPUQuerySet createQuerySet(GPUQuerySetDescriptor descriptor);
};
GPUDevice includes GPUObjectBase;
</script>

{{GPUDevice}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>adapter</dfn>
    ::
        The {{GPUAdapter}} from which this device was created.

    : <dfn>features</dfn>
    ::
        A sequence containing the {{GPUFeatureName}} values of the features
        supported by the device (i.e. the ones with which it was created).

        Issue: Should this be {{GPUAdapterFeatures}} (which would be renamed to
        GPUSupportedFeatures)?

    : <dfn>limits</dfn>
    ::
        Exposes the limits supported by the device
        (which are exactly the ones with which it was created).

        Issue: Should this be an `interface GPUSupportedLimits`?

    : <dfn>queue</dfn>
    ::
        The primary {{GPUQueue}} for this device.
</dl>

{{GPUDevice}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>\[[device]]</dfn>, of type [=device=], readonly
    ::
        The [=device=] that this {{GPUDevice}} refers to.
</dl>

{{GPUDevice}} has the methods listed in its WebIDL definition above.
Those not defined here are defined elsewhere in this document.

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>destroy()</dfn>
    ::
        Destroys the [=device=].

        <div algorithm=GPUDevice.destroy()>
            **Called on:** {{GPUDevice}} |this|.

            1. Make |this|.{{GPUDevice/[[device]]}} [=invalid=].
            1. Resolve {{GPUDevice/lost}}, on every {{GPUDevice}} associated with
                |this|.{{GPUDevice/[[device]]}}, with a {{GPUDeviceLostInfo}} with
                {{GPUDeviceLostInfo/reason}} {{GPUDeviceLostReason/"destroyed"}}
                and an implementation-defined {{GPUDeviceLostInfo/message}}.

            Issue: Probably centralize this better with other device loss triggering, once added.
        </div>

        Note:
        This prevents any further operations on the device.
        Implementations can free resource allocations immediately.
        Outstanding asynchronous operations will fail, so implementations can abort them early.
</dl>

{{GPUDevice}} objects are [=serializable objects=].

<div algorithm>
    <dfn abstract-op>The steps to serialize a GPUDevice object</dfn>,
    given |value|, |serialized|, and |forStorage|, are:
     1. Set |serialized|.agentCluster to be the [=surrounding agent=]'s [=agent cluster=].
     1. If |serialized|.agentCluster's [=cross-origin isolated=] is false, throw a "{{DataCloneError}}".
     1. If |forStorage| is `true`, throw a "{{DataCloneError}}".
     1. Set |serialized|.device to the value of |value|.{{GPUDevice/[[device]]}}.
</div>

<div algorithm>
    <dfn abstract-op>The steps to deserialize a GPUDevice object</dfn>,
    given |serialized| and |value|, are:
     1. If |serialized|.agentCluster is not the [=surrounding agent=]'s [=agent cluster=], throw a "{{DataCloneError}}".
     1. Set |value|.{{GPUDevice/[[device]]}} to |serialized|.device.
</div>

Issue: `GPUDevice` doesn't really need the cross-origin policy restriction.
It should be usable from multiple agents regardless. Once we describe the serialization
of buffers, textures, and queues - the COOP+COEP logic should be moved in there.

# Buffers # {#buffers}

## <dfn interface>GPUBuffer</dfn> ## {#buffer-interface}

Issue: define <dfn dfn>buffer</dfn> (internal object)

A {{GPUBuffer}} represents a block of memory that can be used in GPU operations.
Data is stored in linear layout, meaning that each byte of the allocation can be
addressed by its offset from the start of the {{GPUBuffer}}, subject to alignment
restrictions depending on the operation. Some {{GPUBuffer|GPUBuffers}} can be
mapped which makes the block of memory accessible via an {{ArrayBuffer}} called
its mapping.

{{GPUBuffer|GPUBuffers}} are created via
{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer(descriptor)}}
that returns a new buffer in the [=buffer state/mapped=] or [=buffer state/unmapped=] state.

<script type=idl>
[Serializable]
interface GPUBuffer {
    Promise<undefined> mapAsync(GPUMapModeFlags mode, optional GPUSize64 offset = 0, optional GPUSize64 size);
    ArrayBuffer getMappedRange(optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined unmap();

    undefined destroy();
};
GPUBuffer includes GPUObjectBase;
</script>

{{GPUBuffer}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBuffer">
    : <dfn>\[[size]]</dfn> of type {{GPUSize64}}.
    ::
        The length of the {{GPUBuffer}} allocation in bytes.

    : <dfn>\[[usage]]</dfn> of type {{GPUBufferUsageFlags}}.
    ::
        The allowed usages for this {{GPUBuffer}}.

    : <dfn>\[[state]]</dfn> of type [=buffer state=].
    ::
        The current state of the {{GPUBuffer}}.

    : <dfn>\[[mapping]]</dfn> of type {{ArrayBuffer}} or {{Promise}} or `null`.
    ::
        The mapping for this {{GPUBuffer}}. The {{ArrayBuffer}} isn't directly accessible
        and is instead accessed through views into it, called the mapped ranges, that are
        stored in {{GPUBuffer/[[mapped_ranges]]}}

        Issue(gpuweb/gpuweb#605): Specify {{GPUBuffer/[[mapping]]}} in term of `DataBlock` similarly
        to `AllocateArrayBuffer`?

    : <dfn>\[[mapping_range]]</dfn> of type [=list=]&lt;[=Number=]&gt; or `null`.
    ::
        The range of this {{GPUBuffer}} that is mapped.

    : <dfn>\[[mapped_ranges]]</dfn> of type [=list=]&lt;{{ArrayBuffer}}&gt; or `null`.
    ::
        The {{ArrayBuffer}}s returned via {{GPUBuffer/getMappedRange}} to the application. They are tracked
        so they can be detached when {{GPUBuffer/unmap}} is called.

    : <dfn>\[[map_mode]]</dfn> of type {{GPUMapModeFlags}}.
    ::
        The {{GPUMapModeFlags}} of the last call to {{GPUBuffer/mapAsync()}} (if any).
</dl>

Issue: {{GPUBuffer/[[usage]]}} is differently named from {{GPUTexture/[[textureUsage]]}}.
We should make it consistent.

Each {{GPUBuffer}} has a current <dfn dfn>buffer state</dfn> on the [=Content timeline=]
which is one of the following:

 - "<dfn dfn for="buffer state">mapped</dfn>" where the {{GPUBuffer}} is
     available for CPU operations on its content.
 - "<dfn dfn for="buffer state">mapped at creation</dfn>" where the {{GPUBuffer}} was
     just created and is available for CPU operations on its content.
 - "<dfn dfn for="buffer state">mapping pending</dfn>" where the {{GPUBuffer}} is
     being made available for CPU operations on its content.
 - "<dfn dfn for="buffer state">unmapped</dfn>" where the {{GPUBuffer}} is
     available for GPU operations.
 - "<dfn dfn for="buffer state">destroyed</dfn>" where the {{GPUBuffer}} is
     no longer available for any operations except {{GPUBuffer/destroy}}.

Note:
{{GPUBuffer/[[size]]}} and {{GPUBuffer/[[usage]]}} are immutable once the
{{GPUBuffer}} has been created.

<div class=note>
   Note: {{GPUBuffer}} has a state machine with the following states.
    ({{GPUBuffer/[[mapping]]}}, {{GPUBuffer/[[mapping_range]]}},
    and {{GPUBuffer/[[mapped_ranges]]}} are `null` when not specified.)

     - [=buffer state/unmapped=] and [=buffer state/destroyed=].
     - [=buffer state/mapped=] or [=buffer state/mapped at creation=] with an
        {{ArrayBuffer}} typed {{GPUBuffer/[[mapping]]}}, a sequence of two
        numbers in {{GPUBuffer/[[mapping_range]]}} and a sequence of {{ArrayBuffer}}
        in {{GPUBuffer/[[mapped_ranges]]}}
     - [=buffer state/mapping pending=] with a {{Promise}} typed {{GPUBuffer/[[mapping]]}}.
</div>

{{GPUBuffer}} is {{Serializable}}. It is a reference to an internal buffer
object, and {{Serializable}} means that the reference can be *copied* between
realms (threads/workers), allowing multiple realms to access it concurrently.
Since {{GPUBuffer}} has internal state (mapped, destroyed), that state is
internally-synchronized - these state changes occur atomically across realms.

## Buffer Creation ## {#buffer-creation}

### {{GPUBufferDescriptor}} ### {#GPUBufferDescriptor}

This specifies the options to use in creating a {{GPUBuffer}}.

<script type=idl>
dictionary GPUBufferDescriptor : GPUObjectDescriptorBase {
    required GPUSize64 size;
    required GPUBufferUsageFlags usage;
    boolean mappedAtCreation = false;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUBufferDescriptor</dfn>(device, descriptor)
        1. If device is lost return `false`.
        1. If any of the bits of |descriptor|'s {{GPUBufferDescriptor/usage}} aren't present in this device's [[allowed buffer usages]] return `false`.
        1. If both the {{GPUBufferUsage/MAP_READ}} and {{GPUBufferUsage/MAP_WRITE}} bits of |descriptor|'s {{GPUBufferDescriptor/usage}} attribute are set, return `false`.
        1. Return `true`.
</div>

## Buffer Usage ## {#buffer-usage}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferUsageFlags;
interface GPUBufferUsage {
    const GPUFlagsConstant MAP_READ      = 0x0001;
    const GPUFlagsConstant MAP_WRITE     = 0x0002;
    const GPUFlagsConstant COPY_SRC      = 0x0004;
    const GPUFlagsConstant COPY_DST      = 0x0008;
    const GPUFlagsConstant INDEX         = 0x0010;
    const GPUFlagsConstant VERTEX        = 0x0020;
    const GPUFlagsConstant UNIFORM       = 0x0040;
    const GPUFlagsConstant STORAGE       = 0x0080;
    const GPUFlagsConstant INDIRECT      = 0x0100;
    const GPUFlagsConstant QUERY_RESOLVE = 0x0200;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBuffer(descriptor)</dfn>
    ::
        Creates a {{GPUBuffer}}.

        <div algorithm=GPUDevice.createBuffer>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createBuffer(descriptor)">
                |descriptor|: Description of the {{GPUBuffer}} to create.
            </pre>

            **Returns:** {{GPUBuffer}}

            1. If any of the following conditions are unsatisfied, return an error buffer and stop.
                <div class=validusage>
                    - |this| is a [=valid=] {{GPUDevice}}.
                    - |descriptor|.{{GPUBufferDescriptor/usage}} is a subset of |this|.[[allowed buffer usages]].
                    - If |descriptor|.{{GPUBufferDescriptor/usage}} contains {{GPUBufferUsage/MAP_READ}}:
                        - |descriptor|.{{GPUBufferDescriptor/usage}} contains no other flags
                            except {{GPUBufferUsage/COPY_DST}}.
                    - If |descriptor|.{{GPUBufferDescriptor/usage}} contains {{GPUBufferUsage/MAP_WRITE}}:
                        - |descriptor|.{{GPUBufferDescriptor/usage}} contains no other flags
                            except {{GPUBufferUsage/COPY_SRC}}.
                    - If |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} is `true`:
                        - |descriptor|.{{GPUBufferDescriptor/size}} is a multiple of 4.

                    Issue(gpuweb/gpuweb#605): Explain that the resulting error buffer can still be mapped at creation.

                    Issue(gpuweb/gpuweb#605): Explain what are a {{GPUDevice}}'s `[[allowed buffer usages]]`.
                </div>

            1. Let |b| be a new {{GPUBuffer}} object.
            1. Set |b|.{{GPUBuffer/[[size]]}} to |descriptor|.{{GPUBufferDescriptor/size}}.
            1. Set |b|.{{GPUBuffer/[[usage]]}} to |descriptor|.{{GPUBufferDescriptor/usage}}.
            1. If |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} is `true`:

                1. Set |b|.{{GPUBuffer/[[mapping]]}} to a new {{ArrayBuffer}} of size |b|.{{GPUBuffer/[[size]]}}.
                1. Set |b|.{{GPUBuffer/[[mapping_range]]}} to `[0, descriptor.size]`.
                1. Set |b|.{{GPUBuffer/[[mapped_ranges]]}} to `[]`.
                1. Set |b|.{{GPUBuffer/[[state]]}} to [=buffer state/mapped at creation=].

                Else:

                1. Set |b|.{{GPUBuffer/[[mapping]]}} to `null`.
                1. Set |b|.{{GPUBuffer/[[mapping_range]]}} to `null`.
                1. Set |b|.{{GPUBuffer/[[mapped_ranges]]}} to `null`.
                1. Set |b|.{{GPUBuffer/[[state]]}} to [=buffer state/unmapped=].

            1. Set each byte of |b|'s allocation to zero.
            1. Return |b|.

            Note: it is valid to set {{GPUBufferDescriptor/mappedAtCreation}} to `true` without {{GPUBufferUsage/MAP_READ}}
            or {{GPUBufferUsage/MAP_WRITE}} in {{GPUBufferDescriptor/usage}}. This can be used to set the buffer's
            initial data.

        </div>

</dl>

## Buffer Destruction ## {#buffer-destruction}

An application that no longer requires a {{GPUBuffer}} can choose to lose
access to it before garbage collection by calling {{GPUBuffer/destroy()}}.

Note: This allows the user agent to reclaim the GPU memory associated with the {{GPUBuffer}}
once all previously submitted operations using it are complete.

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>destroy()</dfn>
    ::
        Destroys the {{GPUBuffer}}.

        <div algorithm=GPUBuffer.destroy>
            **Called on:** {{GPUBuffer}} |this|.

            **Returns:** {{undefined}}

            1. If the |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapped=] or [=buffer state/mapped at creation=]:
                1. Run the steps to unmap |this|.

            1. Set |this|.{{GPUBuffer/[[state]]}} to [=buffer state/destroyed=].

            Issue: Handle error buffers once we have a description of the error monad.
        </div>
</dl>

## Buffer Mapping ## {#buffer-mapping}

An application can request to map a {{GPUBuffer}} so that they can access its
content via {{ArrayBuffer}}s that represent part of the {{GPUBuffer}}'s
allocations. Mapping a {{GPUBuffer}} is requested asynchronously with
{{GPUBuffer/mapAsync()}} so that the user agent can ensure the GPU
finished using the {{GPUBuffer}} before the application can access its content.
Once the {{GPUBuffer}} is mapped the application can synchronously ask for access
to ranges of its content with {{GPUBuffer/getMappedRange}}. A mapped {{GPUBuffer}}
cannot be used by the GPU and must be unmapped using {{GPUBuffer/unmap}} before
work using it can be submitted to the [=Queue timeline=].

Issue(gpuweb/gpuweb#605): Add client-side validation that a mapped buffer can
  only be unmapped and destroyed on the worker on which it was mapped. Likewise
  {{GPUBuffer/getMappedRange}} can only be called on that worker.

<script type=idl>
typedef [EnforceRange] unsigned long GPUMapModeFlags;
interface GPUMapMode {
    const GPUFlagsConstant READ  = 0x0001;
    const GPUFlagsConstant WRITE = 0x0002;
};
</script>

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>mapAsync(mode, offset, size)</dfn>
    ::
        Maps the given range of the {{GPUBuffer}} and resolves the returned {{Promise}} when the
        {{GPUBuffer}}'s content is ready to be accessed with {{GPUBuffer/getMappedRange()}}.

        <div algorithm=GPUBuffer.mapAsync>
            **Called on:** {{GPUBuffer}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUBuffer/mapAsync(mode, offset, size)">
                |mode|: Whether the buffer should be mapped for reading or writing.
                |offset|: Offset in bytes into the buffer to the start of the range to map.
                |size|: Size in bytes of the range to map.
            </pre>

            **Returns:** {{Promise}}&lt;{{undefined}}&gt;

            Issue(gpuweb/gpuweb#605): Handle error buffers once we have a description of the error monad.

            1. If |size| is unspecified:
                1. Let |rangeSize| be max(0, |this|.{{GPUBuffer/[[size]]}} - |offset|).

                Otherwise, let |rangeSize| be |size|.

            1. If any of the following conditions are unsatisfied:
                <div class=validusage>
                    - |this| is a [=valid=] {{GPUBuffer}}.
                    - |offset| is a multiple of 8.
                    - |rangeSize| is a multiple of 4.
                    - |offset| + |rangeSize| is less or equal to |this|.{{GPUBuffer/[[size]]}}
                    - |this|.{{GPUBuffer/[[state]]}} is [=buffer state/unmapped=]
                    - |mode| contains exactly one of {{GPUMapMode/READ}} or {{GPUMapMode/WRITE}}.
                    - If |mode| contains {{GPUMapMode/READ}} then |this|.{{GPUBuffer/[[usage]]}} must contain {{GPUBufferUsage/MAP_READ}}.
                    - If |mode| contains {{GPUMapMode/WRITE}} then |this|.{{GPUBuffer/[[usage]]}} must contain {{GPUBufferUsage/MAP_WRITE}}.

                    Issue: Do we validate that |mode| contains only valid flags?
                </div>

                Then:
                1. Record a validation error on the current scope.
                1. Return [=a promise rejected with=] an {{OperationError}} on the [=Device timeline=].

            1. Let |p| be a new {{Promise}}.
            1. Set |this|.{{GPUBuffer/[[mapping]]}} to |p|.
            1. Set |this|.{{GPUBuffer/[[state]]}} to [=buffer state/mapping pending=].
            1. Set |this|.{{GPUBuffer/[[map_mode]]}} to |mode|.
            1. Enqueue an operation on the default queue's [=Queue timeline=] that will execute the following:
                <div class=queue-timeline>
                    1. If |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapping pending=]:

                        1. Let |m| be a new {{ArrayBuffer}} of size |rangeSize|.
                        1. Set the content of |m| to the content of |this|'s allocation starting at offset |offset| and for |rangeSize| bytes.
                        1. Set |this|.{{GPUBuffer/[[mapping]]}} to |m|.
                        1. Set |this|.{{GPUBuffer/[[state]]}} to [=buffer state/mapped=].
                        1. Set |this|.{{GPUBuffer/[[mapping_range]]}} to <code>[|offset|, |offset| + |rangeSize|]</code>.
                        1. Set |this|.{{GPUBuffer/[[mapped_ranges]]}} to `[]`.

                    1. Resolve |p|.
                </div>
            1. Return |p|.
        </div>

    : <dfn>getMappedRange(offset, size)</dfn>
    ::
        Returns a {{ArrayBuffer}} with the contents of the {{GPUBuffer}} in the given mapped range.

        <div algorithm=GPUBuffer.getMappedRange>
            **Called on:** {{GPUBuffer}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUBuffer/getMappedRange(offset, size)">
                |offset|: Offset in bytes into the buffer to return buffer contents from.
                |size|: Size in bytes of the {{ArrayBuffer}} to return.
            </pre>

            **Returns:** {{ArrayBuffer}}

            1. If |size| is unspecified:
                1. Let |rangeSize| be max(0, |this|.{{GPUBuffer/[[size]]}} - |offset|).

                Otherwise, let |rangeSize| be |size|.

            1. If any of the following conditions are unsatisfied, throw an {{OperationError}} and stop.
                <div class=validusage>
                    - |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapped=] or [=buffer state/mapped at creation=].
                    - |offset| is a multiple of 8.
                    - |rangeSize| is a multiple of 4.
                    - |offset| is greater than or equal to |this|.{{GPUBuffer/[[mapping_range]]}}[0].
                    - |offset| + |rangeSize| is less than or equal to |this|.{{GPUBuffer/[[mapping_range]]}}[1].
                    - [|offset|, |offset| + |rangeSize|) does not overlap another range in |this|.{{GPUBuffer/[[mapped_ranges]]}}.

                    Note: It is always valid to get mapped ranges of a {{GPUBuffer}} that is
                    [=buffer state/mapped at creation=], even if it is [=invalid=], because
                    the [=Content timeline=] might not know it is invalid.

                    Issue: Consider aligning mapAsync offset to 8 to match this.
                </div>

            1. Let |m| be a new {{ArrayBuffer}} of size |rangeSize| pointing at the content
                of |this|.{{GPUBuffer/[[mapping]]}} at offset |offset| - |this|.{{GPUBuffer/[[mapping_range]]}}[0].

            1. [=list/Append=] |m| to |this|.{{GPUBuffer/[[mapped_ranges]]}}.

            1. Return |m|.
        </div>

    : <dfn>unmap()</dfn>
    ::
        Unmaps the mapped range of the {{GPUBuffer}} and makes it's contents available for use by the
        GPU again.

        <div algorithm=GPUBuffer.unmap>
            **Called on:** {{GPUBuffer}} |this|.

            **Returns:** {{undefined}}

            1. If any of the following conditions are unsatisfied, generate a validation
                error and stop.
                <div class=validusage>
                    - |this|.{{GPUBuffer/[[state]]}} is not [=buffer state/unmapped=]
                    - |this|.{{GPUBuffer/[[state]]}} is not [=buffer state/destroyed=]

                    Note: It is valid to unmap an error {{GPUBuffer}} that is
                        [=buffer state/mapped at creation=] because the [=Content timeline=]
                        might not know it is an error {{GPUBuffer}}.
                </div>

            1. If |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapping pending=]:

                1. [=Reject=] {{GPUBuffer/[[mapping]]}} with an {{AbortError}}.
                1. Set |this|.{{GPUBuffer/[[mapping]]}} to `null`.

            1. If |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapped=] or [=buffer state/mapped at creation=]:

                1. If one of the two following conditions holds:

                    - |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapped at creation=]
                    - |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapped=] and |this|.{{GPUBuffer/[[map_mode]]}} contains {{GPUMapMode/WRITE}}

                    Then:
                    1. Enqueue an operation on the default queue's [=Queue timeline=] that updates the |this|.{{GPUBuffer/[[mapping_range]]}}
                        of |this|'s allocation to the content of |this|.{{GPUBuffer/[[mapping]]}}.

                1. Detach each {{ArrayBuffer}} in |this|.{{GPUBuffer/[[mapped_ranges]]}} from its content.
                1. Set |this|.{{GPUBuffer/[[mapping]]}} to `null`.
                1. Set |this|.{{GPUBuffer/[[mapping_range]]}} to `null`.
                1. Set |this|.{{GPUBuffer/[[mapped_ranges]]}} to `null`.

            1. Set |this|.{{GPUBuffer/[[state]]}} to [=buffer state/unmapped=].

            Note: When a {{GPUBufferUsage/MAP_READ}} buffer (not currently mapped at creation) is
                unmapped, any local modifications done by the application to the mapped ranges
                {{ArrayBuffer}} are discarded and will not affect the content of follow-up mappings.
        </div>
</dl>

# Textures and Texture Views # {#textures}

Issue: define <dfn dfn>texture</dfn> (internal object)

Issue: define <dfn dfn>mipmap level</dfn>, <dfn dfn>array layer</dfn>, <dfn dfn>aspect</dfn>, <dfn dfn>slice</dfn> (concepts)

## <dfn interface>GPUTexture</dfn> ## {#texture-interface}

<script type=idl>
[Serializable]
interface GPUTexture {
    GPUTextureView createView(optional GPUTextureViewDescriptor descriptor = {});

    undefined destroy();
};
GPUTexture includes GPUObjectBase;
</script>

{{GPUTexture}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUTexture">
    : <dfn>\[[textureSize]]</dfn> of type {{GPUExtent3D}}.
    ::
        The size of the {{GPUTexture}} in texels in [=mipmap level=] 0.

    : <dfn>\[[mipLevelCount]]</dfn> of type {{GPUIntegerCoordinate}}.
    ::
        The total number of the mipmap levels of the {{GPUTexture}}.

    : <dfn>\[[sampleCount]]</dfn> of type {{GPUSize32}}.
    ::
        The number of samples in each texel of the {{GPUTexture}}.

    : <dfn>\[[dimension]]</dfn> of type {{GPUTextureDimension}}.
    ::
        The dimension of the {{GPUTexture}}.

    : <dfn>\[[format]]</dfn> of type {{GPUTextureFormat}}.
    ::
        The format of the {{GPUTexture}}.

    : <dfn>\[[textureUsage]]</dfn> of type {{GPUTextureUsageFlags}}.
    ::
        The allowed usages for this {{GPUTexture}}.

</dl>

### Texture Creation ### {#texture-creation}

<script type=idl>
dictionary GPUTextureDescriptor : GPUObjectDescriptorBase {
    required GPUExtent3D size;
    GPUIntegerCoordinate mipLevelCount = 1;
    GPUSize32 sampleCount = 1;
    GPUTextureDimension dimension = "2d";
    required GPUTextureFormat format;
    required GPUTextureUsageFlags usage;
};
</script>

<script type=idl>
enum GPUTextureDimension {
    "1d",
    "2d",
    "3d",
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUTextureUsageFlags;
interface GPUTextureUsage {
    const GPUFlagsConstant COPY_SRC          = 0x01;
    const GPUFlagsConstant COPY_DST          = 0x02;
    const GPUFlagsConstant SAMPLED           = 0x04;
    const GPUFlagsConstant STORAGE           = 0x08;
    const GPUFlagsConstant RENDER_ATTACHMENT = 0x10;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createTexture(descriptor)</dfn>
    ::
        Creates a {{GPUTexture}}.

        <div algorithm=GPUDevice.createTexture>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createTexture(descriptor)">
                descriptor: Description of the {{GPUTexture}} to create.
            </pre>

            **Returns:** {{GPUTexture}}

            Issue: Describe {{GPUDevice/createTexture()}} algorithm steps.
        </div>
</dl>

### Texture Destruction ### {#texture-destruction}

An application that no longer requires a {{GPUTexture}} can choose to lose access to it before
garbage collection by calling {{GPUTexture/destroy()}}.

Note: This allows the user agent to reclaim the GPU memory associated with the {{GPUTexture}} once
all previously submitted operations using it are complete.

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>destroy()</dfn>
    ::
        Destroys the {{GPUTexture}}.

        <div algorithm=GPUTexture.destroy>
            **Called on:** {{GPUTexture}} this.

            **Returns:** {{undefined}}

            Issue: Describe {{GPUTexture/destroy()}} algorithm steps.
        </div>
</dl>

## <dfn interface>GPUTextureView</dfn> ## {#gpu-textureview}

<script type=idl>
interface GPUTextureView {
};
GPUTextureView includes GPUObjectBase;
</script>

{{GPUTextureView}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUTextureView">
    : <dfn>\[[texture]]</dfn>
    ::
        The {{GPUTexture}} into which this is a view.

    : <dfn>\[[descriptor]]</dfn>
    ::
        The {{GPUTextureViewDescriptor}} describing this texture view.

        All optional fields of {{GPUTextureViewDescriptor}} are defined.
</dl>

### Texture View Creation ### {#texture-view-creation}

<script type=idl>
dictionary GPUTextureViewDescriptor : GPUObjectDescriptorBase {
    GPUTextureFormat format;
    GPUTextureViewDimension dimension;
    GPUTextureAspect aspect = "all";
    GPUIntegerCoordinate baseMipLevel = 0;
    GPUIntegerCoordinate mipLevelCount;
    GPUIntegerCoordinate baseArrayLayer = 0;
    GPUIntegerCoordinate arrayLayerCount;
};
</script>

<script type=idl>
enum GPUTextureViewDimension {
    "1d",
    "2d",
    "2d-array",
    "cube",
    "cube-array",
    "3d"
};
</script>

<script type=idl>
enum GPUTextureAspect {
    "all",
    "stencil-only",
    "depth-only"
};
</script>

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>createView(descriptor)</dfn>
    ::
        Creates a {{GPUTextureView}}.

        <div algorithm=GPUTexture.createView>
            **Called on:** {{GPUTexture}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUTexture/createView(descriptor)">
                |descriptor|: Description of the {{GPUTextureView}} to create.
            </pre>

            **Returns:** |view|, of type {{GPUTextureView}}.

            1. Set |descriptor| to the result of [$resolving GPUTextureViewDescriptor defaults$] with |descriptor|.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |this| is [=valid=]
                            - If the |descriptor|.{{GPUTextureViewDescriptor/aspect}} is
                                <dl class="switch">
                                    : {{GPUTextureAspect/"stencil-only"}}
                                    :: |this|.{{GPUTexture/[[format]]}} is a [[#depth-formats|depth-stencil format]]
                                        which contains a stencil aspect.

                                    : {{GPUTextureAspect/"depth-only"}}
                                    :: |this|.{{GPUTexture/[[format]]}} is a [[#depth-formats|depth-stencil format]]
                                        which contains a depth aspect.
                                </dl>
                            - |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} is &gt; 0.
                            - |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}} +
                                |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} is &le;
                                |this|.{{GPUTexture/[[mipLevelCount]]}}.
                            - If |this|.{{GPUTexture/[[dimension]]}} is
                                <dl class="switch">
                                    : {{GPUTextureDimension/"1d"}}
                                    :: Let |arrayCount| be |this|.{{GPUTexture/[[textureSize]]}}.[=Extent3D/depth=].

                                    : {{GPUTextureDimension/"2d"}}
                                    :: Let |arrayCount| be |this|.{{GPUTexture/[[textureSize]]}}.[=Extent3D/depth=].

                                    : {{GPUTextureDimension/"3d"}}
                                    :: Let |arrayCount| be `1`.
                                </dl>
                            - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} is &gt; 0.
                            - |descriptor|.{{GPUTextureViewDescriptor/baseArrayLayer}} +
                                |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} is &le;
                                |arrayCount|.
                            - |descriptor|.{{GPUTextureViewDescriptor/format}} is |this|.{{GPUTexture/[[format]]}}
                                or is a [=compatible texture format=] with |this|.{{GPUTexture/[[format]]}}.
                            - If |descriptor|.{{GPUTextureViewDescriptor/dimension}} is
                                <dl class="switch">
                                    : {{GPUTextureViewDimension/"1d"}}
                                    :: |this|.{{GPUTexture/[[dimension]]}} is {{GPUTextureDimension/"1d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} is `1`.

                                    : {{GPUTextureViewDimension/"2d"}}
                                    :: |this|.{{GPUTexture/[[dimension]]}} is {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} is `1`.

                                    : {{GPUTextureViewDimension/"2d-array"}}
                                    :: |this|.{{GPUTexture/[[dimension]]}} is {{GPUTextureDimension/"2d"}}.

                                    : {{GPUTextureViewDimension/"cube"}}
                                    :: |this|.{{GPUTexture/[[dimension]]}} is {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} is `6`.
                                    :: |this|.{{GPUTexture/[[textureSize]]}}.[=Extent3D/width=] is
                                        |this|.{{GPUTexture/[[textureSize]]}}.[=Extent3D/height=].

                                    : {{GPUTextureViewDimension/"cube-array"}}
                                    :: |this|.{{GPUTexture/[[dimension]]}} is {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} is a multiple of `6`.
                                    :: |this|.{{GPUTexture/[[textureSize]]}}.[=Extent3D/width=] is
                                        |this|.{{GPUTexture/[[textureSize]]}}.[=Extent3D/height=].

                                    : {{GPUTextureViewDimension/"3d"}}
                                    :: |this|.{{GPUTexture/[[dimension]]}} is {{GPUTextureDimension/"3d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} is `1`.
                                </dl>
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                            1. Create a new [=invalid=] {{GPUTextureView}} and return the result.

                    1. Let |view| be a new {{GPUTextureView}} object.
                    1. Set |view|.{{GPUTextureView/[[texture]]}} to |this|.
                    1. Set |view|.{{GPUTextureView/[[descriptor]]}} to |descriptor|.
                    1. Return |view|.
                </div>
        </div>
</dl>

Issue: Define what it means to be a <dfn dfn>compatible texture format</dfn> with another texture format.

<div algorithm>
    When <dfn abstract-op>resolving GPUTextureViewDescriptor defaults</dfn> for {{GPUTextureViewDescriptor}}
    |descriptor| run the following steps:

    1. Let |resolved| be a copy of |descriptor|.
    1. If |resolved|.{{GPUTextureViewDescriptor/format}} is `undefined`,
        set |resolved|.{{GPUTextureViewDescriptor/format}} to |texture|.{{GPUTexture/[[format]]}}.
    1. If |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} is `undefined`,
        set |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} to |texture|.{{GPUTexture/[[mipLevelCount]]}}
        &minus; {{GPUTextureViewDescriptor/baseMipLevel}}.
    1. If |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} is `undefined`,
        set |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} to
        |texture|.{{GPUTexture/[[textureSize]]}}.[=Extent3D/depth=] &minus;
        {{GPUTextureViewDescriptor/baseArrayLayer}}.
    1. If |resolved|.{{GPUTextureViewDescriptor/dimension}} is `undefined`:
        - If |texture|.{{GPUTexture/[[dimension]]}} is {{GPUTextureDimension/"1d"}},
            set |resolved|.{{GPUTextureViewDescriptor/dimension}} to {{GPUTextureViewDimension/"1d"}}.
        - If |texture|.{{GPUTexture/[[dimension]]}} is {{GPUTextureDimension/"2d"}}:
            - If |texture|.{{GPUTexture/[[textureSize]]}}.[=Extent3D/depth=] is greater than `1`
                and |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} is greater than `1`,
                set |resolved|.{{GPUTextureViewDescriptor/dimension}} to {{GPUTextureViewDimension/"2d-array"}}.
            - Otherwise, set |resolved|.{{GPUTextureViewDescriptor/dimension}} to {{GPUTextureViewDimension/"2d"}}.
        - If |texture|.{{GPUTexture/[[dimension]]}} is {{GPUTextureDimension/"3d"}},
            set |resolved|.{{GPUTextureViewDescriptor/dimension}} to {{GPUTextureViewDimension/"3d"}}.
    1. Return |resolved|.
</div>

## Texture Formats ## {#texture-formats}

The name of the format specifies the order of components, bits per component,
and data type for the component.

  * `r`, `g`, `b`, `a` = red, green, blue, alpha
  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

If the format has the `-srgb` suffix, then sRGB conversions from gamma to linear
and vice versa are applied during the reading and writing of color values in the
shader. Compressed texture formats are provided by [=features=]. Their naming
should follow the convention here, with the texture name as a prefix. e.g.
`etc2-rgba8unorm`.

The <dfn dfn>texel block</dfn> is a single addressable element of the textures in pixel-based {{GPUTextureFormat}}s,
and a single compressed block of the textures in block-based compressed {{GPUTextureFormat}}s.

The <dfn dfn>texel block width</dfn> and <dfn dfn>texel block height</dfn> specifies the dimension of one [=texel block=].
  - For pixel-based {{GPUTextureFormat}}s, the [=texel block width=] and [=texel block height=] are always 1.
  - For block-based compressed {{GPUTextureFormat}}s, the [=texel block width=] is the number of texels in each row of one [=texel block=],
    and the [=texel block height=] is the number of texel rows in one [=texel block=].

The <dfn dfn>texel block size</dfn> of a {{GPUTextureFormat}} is the number of bytes to store one [=texel block=].
The [=texel block size=] of each {{GPUTextureFormat}} is constant except for {{GPUTextureFormat/"stencil8"}}, {{GPUTextureFormat/"depth24plus"}}, and {{GPUTextureFormat/"depth24plus-stencil8"}}.

<script type=idl>
enum GPUTextureFormat {
    // 8-bit formats
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",

    // 16-bit formats
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",

    // 32-bit formats
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    // Packed 32-bit formats
    "rgb9e5ufloat",
    "rgb10a2unorm",
    "rg11b10ufloat",

    // 64-bit formats
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",

    // 128-bit formats
    "rgba32uint",
    "rgba32sint",
    "rgba32float",

    // Depth and stencil formats
    "stencil8",
    "depth16unorm",
    "depth24plus",
    "depth24plus-stencil8",
    "depth32float",

    // BC compressed formats usable if "texture-compression-bc" is both
    // supported by the device/user agent and enabled in requestDevice.
    "bc1-rgba-unorm",
    "bc1-rgba-unorm-srgb",
    "bc2-rgba-unorm",
    "bc2-rgba-unorm-srgb",
    "bc3-rgba-unorm",
    "bc3-rgba-unorm-srgb",
    "bc4-r-unorm",
    "bc4-r-snorm",
    "bc5-rg-unorm",
    "bc5-rg-snorm",
    "bc6h-rgb-ufloat",
    "bc6h-rgb-float",
    "bc7-rgba-unorm",
    "bc7-rgba-unorm-srgb",

    // "depth24unorm-stencil8" feature
    "depth24unorm-stencil8",

    // "depth32float-stencil8" feature
    "depth32float-stencil8",
};
</script>

The depth aspect of the {{GPUTextureFormat/"depth24plus"}}) and {{GPUTextureFormat/"depth24plus-stencil8"}})
formats may be implemented as either a 24-bit unsigned normalized value ("depth24unorm")
or a 32-bit IEEE 754 floating point value ("depth32float").

Issue: add something on GPUAdapter(?) that gives an estimate of the bytes per texel of "stencil8"

The {{GPUTextureFormat/stencil8}}) format may be implemented as
either a real "stencil8", or "depth24stencil8", where the depth aspect is
hidden and inaccessible.

Note:
While the precision of depth32float is strictly higher than the precision of
depth24unorm for all values in the representable range (0.0 to 1.0),
note that the set of representable values is not exactly the same:
for depth24unorm, 1 ULP has a constant value of 1 / (2<sup>24</sup> &minus; 1);
for depth32float, 1 ULP has a variable value no greater than 1 / (2<sup>24</sup>).

Issue: {{GPUTextureFormat/"rgb9e5ufloat"}} cannot be used as a color attachment.

# Samplers # {#samplers}

## <dfn interface>GPUSampler</dfn> ## {#sampler-interface}

A {{GPUSampler}} encodes transformations and filtering information that can
be used in a shader to interpret texture resource data.

{{GPUSampler|GPUSamplers}} are created via {{GPUDevice/createSampler(descriptor)|GPUDevice.createSampler(optional descriptor)}}
that returns a new sampler object.

<script type=idl>
interface GPUSampler {
};
GPUSampler includes GPUObjectBase;
</script>

{{GPUSampler}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUSampler">
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUSamplerDescriptor}}, readonly
    ::
        The {{GPUSamplerDescriptor}} with which the {{GPUSampler}} was created.

    : <dfn>\[[isComparison]]</dfn> of type {{boolean}}.
    ::
        Whether the {{GPUSampler}} is used as a comparison sampler.

    : <dfn>\[[isFiltering]]</dfn> of type {{boolean}}.
    ::
        Whether the {{GPUSampler}} weights multiple samples of a texture.
</dl>

## Sampler Creation ## {#sampler-creation}

### {{GPUSamplerDescriptor}} ### {#GPUSamplerDescriptor}

A {{GPUSamplerDescriptor}} specifies the options to use to create a {{GPUSampler}}.

<script type=idl>
dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
    GPUAddressMode addressModeU = "clamp-to-edge";
    GPUAddressMode addressModeV = "clamp-to-edge";
    GPUAddressMode addressModeW = "clamp-to-edge";
    GPUFilterMode magFilter = "nearest";
    GPUFilterMode minFilter = "nearest";
    GPUFilterMode mipmapFilter = "nearest";
    float lodMinClamp = 0;
    float lodMaxClamp = 0xffffffff; // TODO: What should this be? Was Number.MAX_VALUE.
    GPUCompareFunction compare;
    [Clamp] unsigned short maxAnisotropy = 1;
};
</script>

- {{GPUSamplerDescriptor/addressModeU}}, {{GPUSamplerDescriptor/addressModeV}},
    and {{GPUSamplerDescriptor/addressModeW}} specify the address modes for the texture width,
    height, and depth coordinates, respectively.
- {{GPUSamplerDescriptor/magFilter}} specifies the sampling behavior when the sample footprint
    is smaller than or equal to one texel.
- {{GPUSamplerDescriptor/minFilter}} specifies the sampling behavior when the sample footprint
    is larger than one texel.
- {{GPUSamplerDescriptor/mipmapFilter}} specifies behavior for sampling between two mipmap levels.
- {{GPUSamplerDescriptor/lodMinClamp}} and {{GPUSamplerDescriptor/lodMaxClamp}} specify the minimum and
    maximum levels of detail, respectively, used internally when sampling a texture.
- If {{GPUSamplerDescriptor/compare}} is provided, the sampler will be a comparison sampler with the specified
    {{GPUCompareFunction}}.
- {{GPUSamplerDescriptor/maxAnisotropy}} specifies the maximum anisotropy value clamp used by the sampler.

    Note: most implementations support {{GPUSamplerDescriptor/maxAnisotropy}} values in range between 1 and 16, inclusive.

Issue: explain how LOD is calculated and if there are differences here between platforms.
Issue: explain what anisotropic sampling is

{{GPUAddressMode}} describes the behavior of the sampler if the sample footprint extends beyond
the bounds of the sampled texture.

Issue: Describe a "sample footprint" in greater detail.

<script type=idl>
enum GPUAddressMode {
    "clamp-to-edge",
    "repeat",
    "mirror-repeat"
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUAddressMode>
    : <dfn>"clamp-to-edge"</dfn>
    ::
        Texture coordinates are clamped between 0.0 and 1.0, inclusive.

    : <dfn>"repeat"</dfn>
    ::
        Texture coordinates wrap to the other side of the texture.

    : <dfn>"mirror-repeat"</dfn>
    ::
        Texture coordinates wrap to the other side of the texture, but the texture is flipped
        when the integer part of the coordinate is odd.
</dl>

{{GPUFilterMode}} describes the behavior of the sampler if the sample footprint does not exactly
match one texel.

<script type=idl>
enum GPUFilterMode {
    "nearest",
    "linear"
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUFilterMode>
    : <dfn>"nearest"</dfn>
    ::
        Return the value of the texel nearest to the texture coordinates.

    : <dfn>"linear"</dfn>
    ::
        Select two texels in each dimension and return a linear interpolation between their values.
</dl>

{{GPUCompareFunction}} specifies the behavior of a comparison sampler. If a comparison sampler is
used in a shader, an input value is compared to the sampled texture value, and the result of this
comparison test (0.0f for pass, or 1.0f for fail) is used in the filtering operation.

Issue: describe how filtering interacts with comparison sampling.

<script type=idl>
enum GPUCompareFunction {
    "never",
    "less",
    "equal",
    "less-equal",
    "greater",
    "not-equal",
    "greater-equal",
    "always"
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUCompareFunction>
    : <dfn>"never"</dfn>
    ::
        Comparison tests never pass.

    : <dfn>"less"</dfn>
    ::
        A provided value passes the comparison test if it is less than the sampled value.

    : <dfn>"equal"</dfn>
    ::
        A provided value passes the comparison test if it is equal to the sampled value.

    : <dfn>"less-equal"</dfn>
    ::
        A provided value passes the comparison test if it is less than or equal to the sampled value.

    : <dfn>"greater"</dfn>
    ::
        A provided value passes the comparison test if it is greater than the sampled value.

    : <dfn>"not-equal"</dfn>
    ::
        A provided value passes the comparison test if it is not equal to the sampled value.

    : <dfn>"greater-equal"</dfn>
    ::
        A provided value passes the comparison test if it is greater than or equal to the sampled value.

    : <dfn>"always"</dfn>
    ::
        Comparison tests always pass.
</dl>

<div algorithm>
    <dfn abstract-op>validating GPUSamplerDescriptor</dfn>(device, descriptor)
    **Arguments:**
        - {{GPUDevice}} |device|
        - {{GPUSamplerDescriptor}} |descriptor|

    **Returns:** {{boolean}}

    Return `true` if and only if all of the following conditions are satisfied:
        - |device| is valid.
        - |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}} is greater than or equal to 0.
        - |descriptor|.{{GPUSamplerDescriptor/lodMaxClamp}} is greater than or equal to
            |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}}.
        - |descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}} is greater than or equal to 1.
        - When |descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}} is greater than 1,
            |descriptor|.{{GPUSamplerDescriptor/magFilter}}, |descriptor|.{{GPUSamplerDescriptor/minFilter}},
            and |descriptor|.{{GPUSamplerDescriptor/mipmapFilter}} must be equal to {{GPUFilterMode/"linear"}}.
</div>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createSampler(descriptor)</dfn>
    ::
        Creates a {{GPUBindGroupLayout}}.

    <div algorithm=GPUDevice.createSampler>
        **Called on:** {{GPUDevice}} this.

        **Arguments:**
        <pre class=argumentdef for="GPUDevice/createSampler(descriptor)">
            |descriptor|: Description of the {{GPUSampler}} to create.
        </pre>

        **Returns:** {{GPUSampler}}

        1. Let |s| be a new {{GPUSampler}} object.
        1. Set |s|.{{GPUSampler/[[descriptor]]}} to |descriptor|.
        1. Set |s|.{{GPUSampler/[[isComparison]]}} to `false` if the {{GPUSamplerDescriptor/compare}} attribute
                of |s|.{{GPUSampler/[[descriptor]]}} is `null` or undefined. Otherwise, set it to `true`.
        1. Set |s|.{{GPUSampler/[[isFiltering]]}} to `false` if none of {{GPUSamplerDescriptor/minFilter}},
            {{GPUSamplerDescriptor/magFilter}}, or {{GPUSamplerDescriptor/mipmapFilter}} has the value of
            {{GPUFilterMode/"linear"}}. Otherwise, set it to `true`.
        1. Return |s|.

        <div class=validusage dfn-for=GPUDevice.createSampler>
            <dfn abstract-op>Valid Usage</dfn>
            - If |descriptor| is not `null` or undefined:
                - If [$validating GPUSamplerDescriptor$](this, |descriptor|) returns `false`:
                    1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                    1. Create a new [=invalid=] {{GPUSampler}} and return the result.
        </div>
    </div>
</dl>

# Resource Binding # {#bindings}

## <dfn interface>GPUBindGroupLayout</dfn> ## {#bind-group-layout}

A {{GPUBindGroupLayout}} defines the interface between a set of resources bound in a {{GPUBindGroup}} and their accessibility in shader stages.

<script type=idl>
[Serializable]
interface GPUBindGroupLayout {
};
GPUBindGroupLayout includes GPUObjectBase;
</script>

### Creation ### {#bind-group-layout-creation}

A {{GPUBindGroupLayout}} is created via {{GPUDevice/createBindGroupLayout()|GPUDevice.createBindGroupLayout()}}.

<script type=idl>
dictionary GPUBindGroupLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayoutEntry> entries;
};
</script>

A {{GPUBindGroupLayoutEntry}} describes a single shader resource binding to be included in a {{GPUBindGroupLayout}}.

<script type=idl>
typedef [EnforceRange] unsigned long GPUShaderStageFlags;
interface GPUShaderStage {
    const GPUFlagsConstant VERTEX   = 0x1;
    const GPUFlagsConstant FRAGMENT = 0x2;
    const GPUFlagsConstant COMPUTE  = 0x4;
};

dictionary GPUBindGroupLayoutEntry {
    required GPUIndex32 binding;
    required GPUShaderStageFlags visibility;

    GPUBufferBindingLayout buffer;
    GPUSamplerBindingLayout sampler;
    GPUTextureBindingLayout texture;
    GPUStorageTextureBindingLayout storageTexture;
};
</script>

{{GPUBindGroupLayoutEntry}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUBindGroupLayoutEntry>
    : <dfn>binding</dfn>
    ::
        A unique identifier for a resource binding within a
        {{GPUBindGroupLayoutEntry}}, a corresponding {{GPUBindGroupEntry}},
        and the {{GPUShaderModule}}s.

    : <dfn>visibility</dfn>
    ::
        A bitset of the members of {{GPUShaderStage}}.
        Each set bit indicates that a {{GPUBindGroupLayoutEntry}}'s resource
        will be accessible from the associated shader stage.

    : <dfn>buffer</dfn>
    ::
        When not `undefined` indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUBufferBinding}}.

    : <dfn>sampler</dfn>
    ::
        When not `undefined` indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUSampler}}.

    : <dfn>texture</dfn>
    ::
        When not `undefined` indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUTextureView}}.

    : <dfn>storageTexture</dfn>
    ::
        When not `undefined` indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUTextureView}}.
</dl>

The [=binding member=] of a {{GPUBindGroupLayoutEntry}} is determined by which member of the {{GPUBindGroupLayoutEntry}}
is defined: {{GPUBindGroupLayoutEntry/buffer}}, {{GPUBindGroupLayoutEntry/sampler}},
{{GPUBindGroupLayoutEntry/texture}}, or {{GPUBindGroupLayoutEntry/storageTexture}}. Only one may be
defined for any given {{GPUBindGroupLayoutEntry}}. Each member has an associated {{GPUBindingResource}}
type and each [=binding type=] has an associated [=internal usage=], given by this table:

<table class="data" style="white-space: nowrap">
    <thead>
        <tr>
            <th><dfn dfn>Binding member</dfn>
            <th><dfn dfn lt="Binding Resource Type">Resource type</dfn>
            <th><dfn dfn>Binding type</dfn><br>
            <th><dfn dfn>Binding usage</dfn>
    </thead>
    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/buffer}}
        <td rowspan=3>{{GPUBufferBinding}}
        <td>{{GPUBufferBindingType/"uniform"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUBufferBindingType/"storage"}}
        <td>[=internal usage/storage=]
    <tr>
        <td>{{GPUBufferBindingType/"read-only-storage"}}
        <td>[=internal usage/storage-read=]

    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/sampler}}
        <td rowspan=3>{{GPUSampler}}
        <td>{{GPUSamplerBindingType/"filtering"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUSamplerBindingType/"non-filtering"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUSamplerBindingType/"comparison"}}
        <td>[=internal usage/constant=]

    <tr>
        <td rowspan=5>{{GPUBindGroupLayoutEntry/texture}}
        <td rowspan=5>{{GPUTextureView}}
        <td>{{GPUTextureSampleType/"float"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUTextureSampleType/"depth"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUTextureSampleType/"sint"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUTextureSampleType/"uint"}}
        <td>[=internal usage/constant=]

    <tr>
        <td rowspan=2>{{GPUBindGroupLayoutEntry/storageTexture}}
        <td rowspan=2>{{GPUTextureView}}
        <td>{{GPUStorageTextureAccess/"read-only"}}
        <td>[=internal usage/storage-read=]
    <tr>
        <td>{{GPUStorageTextureAccess/"write-only"}}
        <td>[=internal usage/storage-write=]
</table>

<div algorithm>
    To get the <dfn abstract-op>layout entry binding type</dfn> in a given {{GPUBindGroupLayoutEntry}} |entry|:

    1. If |entry|.{{GPUBindGroupLayoutEntry/buffer}} is not `undefined`:
        1. Return |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}}.
    1. If |entry|.{{GPUBindGroupLayoutEntry/sampler}} is not `undefined`:
        1. Return |entry|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}}.
    1. If |entry|.{{GPUBindGroupLayoutEntry/texture}} is not `undefined`:
        1. Return |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}.
    1. If |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} is not `undefined`:
        1. Return |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/access}}.
</div>

<script type=idl>
enum GPUBufferBindingType {
    "uniform",
    "storage",
    "read-only-storage",
};

dictionary GPUBufferBindingLayout {
    GPUBufferBindingType type = "uniform";
    boolean hasDynamicOffset = false;
    GPUSize64 minBindingSize = 0;
};
</script>

{{GPUBufferBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUBufferBindingLayout>
    : <dfn>type</dfn>
    ::
        Indicates the type required for buffers bound to this bindings.

    : <dfn>hasDynamicOffset</dfn>
    ::
        Indicates whether this binding requires a dynamic offset.

    : <dfn>minBindingSize</dfn>
    ::
        May be used to indicate the minimum buffer binding size.
</dl>

<script type=idl>
enum GPUSamplerBindingType {
    "filtering",
    "non-filtering",
    "comparison",
};

dictionary GPUSamplerBindingLayout {
    GPUSamplerBindingType type = "filtering";
};
</script>

{{GPUSamplerBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUSamplerBindingLayout>
    : <dfn>type</dfn>
    ::
        Indicates the required type of a sampler bound to this bindings.
</dl>

<script type=idl>
enum GPUTextureSampleType {
  "float",
  "unfilterable-float",
  "depth",
  "sint",
  "uint",
};

dictionary GPUTextureBindingLayout {
    GPUTextureSampleType sampleType = "float";
    GPUTextureViewDimension viewDimension = "2d";
    boolean multisampled = false;
};
</script>

Issue(https://github.com/gpuweb/gpuweb/issues/851): consider making {{GPUTextureBindingLayout/sampleType}}
truly optional.

{{GPUTextureBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUTextureBindingLayout>
    : <dfn>sampleType</dfn>
    ::
        Indicates the type required for texture views bound to this binding.

    : <dfn>viewDimension</dfn>
    ::
        Indicates the required {{GPUTextureViewDescriptor/dimension}} for texture views bound to
        this binding.

        Note:
            This enables Metal-based WebGPU implementations to back the respective bind groups with
            `MTLArgumentBuffer` objects that are more efficient to bind at run-time.

    : <dfn>multisampled</dfn>
    ::
        Inicates whether or not texture views bound to this binding must be multisampled.
</dl>

<script type=idl>
enum GPUStorageTextureAccess {
    "read-only",
    "write-only",
};

dictionary GPUStorageTextureBindingLayout {
    required GPUStorageTextureAccess access;
    required GPUTextureFormat format;
    GPUTextureViewDimension viewDimension = "2d";
};
</script>

Issue(https://github.com/gpuweb/gpuweb/issues/851): consider making {{GPUStorageTextureBindingLayout/format}}
truly optional.

{{GPUStorageTextureBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUStorageTextureBindingLayout>
    : <dfn>access</dfn>
    ::
        Indicates whether texture views bound to this binding will be bound for read-only or
        write-only access.

    : <dfn>format</dfn>
    ::
        The required {{GPUTextureViewDescriptor/format}} of texture views bound to this binding.

    : <dfn>viewDimension</dfn>
    ::
        Indicates the required {{GPUTextureViewDescriptor/dimension}} for texture views bound to
        this binding.

        Note:
            This enables Metal-based WebGPU implementations to back the respective bind groups with
            `MTLArgumentBuffer` objects that are more efficient to bind at run-time.
</dl>

A {{GPUBindGroupLayout}} object has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBindGroupLayout">
    : <dfn>\[[entryMap]]</dfn> of type [=ordered map=]&lt;{{GPUSize32}}, {{GPUBindGroupLayoutEntry}}&gt.
    ::
        The map of binding indices pointing to the {{GPUBindGroupLayoutEntry}}s,
        which this {{GPUBindGroupLayout}} describes.

    : <dfn>\[[dynamicOffsetCount]]</dfn> of type {{GPUSize32}}.
    ::
        The number of buffer bindings with dynamic offsets in this {{GPUBindGroupLayout}}.
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroupLayout(descriptor)</dfn>
    ::
        Creates a {{GPUBindGroupLayout}}.

        <div algorithm=GPUDevice.createBindGroupLayout>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createBindGroupLayout(descriptor)">
                |descriptor|: Description of the {{GPUBindGroupLayout}} to create.
            </pre>

            **Returns:** {{GPUBindGroupLayout}}

            1. Let |layout| be a new valid {{GPUBindGroupLayout}} object.
            1. Let |limits| be |this|.{{GPUDevice/[[device]]}}.{{device/[[limits]]}}.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |this| is a [=valid=] {{GPUDevice}}.
                            - The {{GPUBindGroupLayoutEntry/binding}} of each entry in |descriptor| is unique.
                            - For each shader stage, the number of entries in |descriptor| with a [$layout entry binding type$] of
                                {{GPUBufferBindingType/"uniform"}} &le;
                                |limits|.{{supported limits/maxUniformBuffersPerShaderStage}}.
                            - For each shader stage, the number of entries in |descriptor| with a [$layout entry binding type$] of
                                {{GPUBufferBindingType/"storage"}} &le;
                                |limits|.{{supported limits/maxStorageBuffersPerShaderStage}}.
                            - For each shader stage, the number of entries in |descriptor| with a [=binding member=] of
                                {{GPUBindGroupLayoutEntry/texture}} &le;
                                |limits|.{{supported limits/maxSampledTexturesPerShaderStage}}.
                            - For each shader stage, the number of entries in |descriptor| with a [=binding member=] of
                                {{GPUBindGroupLayoutEntry/storageTexture}} &le;
                                |limits|.{{supported limits/maxStorageTexturesPerShaderStage}}.
                            - For each shader stage, the number of entries in |descriptor| with a [=binding member=] of
                                {{GPUBindGroupLayoutEntry/sampler}} &le;
                                |limits|.{{supported limits/maxSamplersPerShaderStage}}.
                            - The number of entries in |descriptor| with a [$layout entry binding type$] of
                                {{GPUBufferBindingType/"uniform"}} and {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} `true` &le;
                                |limits|.{{supported limits/maxDynamicUniformBuffersPerPipelineLayout}}.
                            - The number of entries in |descriptor| with a [$layout entry binding type$] of
                                {{GPUBufferBindingType/"storage"}} and {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} `true` &le;
                                |limits|.{{supported limits/maxDynamicStorageBuffersPerPipelineLayout}}.

                            - For each {{GPUBindGroupLayoutEntry}} |bindingDescriptor| in |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}}:
                                - Let |bufferLayout| be |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}
                                - Let |samplerLayout| be |bindingDescriptor|.{{GPUBindGroupLayoutEntry/sampler}}
                                - Let |textureLayout| be |bindingDescriptor|.{{GPUBindGroupLayoutEntry/texture}}
                                - Let |storageTextureLayout| be |bindingDescriptor|.{{GPUBindGroupLayoutEntry/storageTexture}}

                                - Exactly one of |bufferLayout|, |samplerLayout|, |textureLayout|,
                                    or |storageTextureLayout| are not `undefined`.

                                - If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/visibility}} includes
                                    {{GPUShaderStage/VERTEX}}:
                                    - The [$layout entry binding type$] of |bindingDescriptor| is not
                                        {{GPUBufferBindingType/"storage"}} or {{GPUStorageTextureAccess/"write-only"}}.

                                - If the |textureLayout| is not `undefined` and
                                    |textureLayout|.{{GPUTextureBindingLayout/multisampled}} is `true`:
                                    - |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} is
                                        {{GPUTextureViewDimension/"2d"}}.
                                    - |textureLayout|.{{GPUTextureBindingLayout/sampleType}} is not
                                        {{GPUTextureSampleType/"float"}}.

                                - If |storageTextureLayout| is not `undefined`:
                                    - |storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}} is not
                                        {{GPUTextureViewDimension/"cube"}} or {{GPUTextureViewDimension/"cube-array"}}.
                                    - |storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}} must be a format
                                        which can support storage usage.
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |layout| [=invalid=] and return |layout|.

                    1. Set |layout|.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}} to the number of
                        entries in |descriptor| where {{GPUBindGroupLayoutEntry/buffer}} is not `undefined` and
                        {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`.
                    1. For each {{GPUBindGroupLayoutEntry}} |bindingDescriptor| in
                        |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}}:
                        1. Insert |bindingDescriptor| into |layout|.{{GPUBindGroupLayout/[[entryMap]]}}
                            with the key of |bindingDescriptor|.{{GPUBindGroupLayoutEntry/binding}}.
                </div>
            1. Return |layout|.

        </div>
</dl>

### Compatibility ### {#bind-group-compatibility}

<div algorithm>
Two {{GPUBindGroupLayout}} objects |a| and |b| are considered <dfn dfn>group-equivalent</dfn>
if and only if, for any binding number |binding|, one of the following conditions is satisfied:
    - it's missing from both |a|.{{GPUBindGroupLayout/[[entryMap]]}} and |b|.{{GPUBindGroupLayout/[[entryMap]]}}.
    - |a|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|] == |b|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|]
</div>

If bind groups layouts are [=group-equivalent=] they can be interchangeably used in all contents.

## <dfn interface>GPUBindGroup</dfn> ## {#gpu-bind-group}

A {{GPUBindGroup}} defines a set of resources to be bound together in a group
    and how the resources are used in shader stages.

<script type=idl>
interface GPUBindGroup {
};
GPUBindGroup includes GPUObjectBase;
</script>

### Bind Group Creation ### {#bind-group-creation}

A {{GPUBindGroup}} is created via {{GPUDevice/createBindGroup()|GPUDevice.createBindGroup()}}.

<script type=idl>
dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
    required GPUBindGroupLayout layout;
    required sequence<GPUBindGroupEntry> entries;
};
</script>

A {{GPUBindGroupEntry}} describes a single resource to be bound in a {{GPUBindGroup}}.

<script type=idl>
typedef (GPUSampler or GPUTextureView or GPUBufferBinding) GPUBindingResource;

dictionary GPUBindGroupEntry {
    required GPUIndex32 binding;
    required GPUBindingResource resource;
};
</script>

<script type=idl>
dictionary GPUBufferBinding {
    required GPUBuffer buffer;
    GPUSize64 offset = 0;
    GPUSize64 size;
};
</script>

  * {{GPUBufferBinding/size}}: If undefined, specifies the range starting at
      {{GPUBufferBinding/offset}} and ending at the end of the buffer.

A {{GPUBindGroup}} object has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBindGroup">
    : <dfn>\[[layout]]</dfn> of type {{GPUBindGroupLayout}}.
    ::
        The {{GPUBindGroupLayout}} associated with this {{GPUBindGroup}}.

    : <dfn>\[[entries]]</dfn> of type sequence<{{GPUBindGroupEntry}}>.
    ::
        The set of {{GPUBindGroupEntry}}s this {{GPUBindGroup}} describes.

    : <dfn>\[[usedResources]]</dfn> of type [=ordered map=]&lt;[=subresource=], [=list=]&lt;[=internal usage=]&gt;&gt;.
    ::
        The set of buffer and texture [=subresource=]s used by this bind group,
        associated with lists of the [=internal usage=] flags.
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroup(descriptor)</dfn>
    ::
        Creates a {{GPUBindGroup}}.

        <div algorithm=GPUDevice.createBindGroup>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createBindGroup(descriptor)">
                |descriptor|: Description of the {{GPUBindGroup}} to create.
            </pre>

            **Returns:** {{GPUBindGroup}}

            1. Let |bindGroup| be a new valid {{GPUBindGroup}} object.
            1. Let |limits| be |this|.{{GPUDevice/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxUniformBufferBindingSize}}.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |this| is a [=valid=] {{GPUDevice}}.
                            - |descriptor|.{{GPUBindGroupDescriptor/layout}} is [$valid to use with$] |this|.
                            - The number of {{GPUBindGroupLayoutDescriptor/entries}} of
                                |descriptor|.{{GPUBindGroupDescriptor/layout}} is exactly equal to
                                the number of |descriptor|.{{GPUBindGroupDescriptor/entries}}.

                            For each {{GPUBindGroupEntry}} |bindingDescriptor| in
                                |descriptor|.{{GPUBindGroupDescriptor/entries}}:
                                - Let |resource| be |bindingDescriptor|.{{GPUBindGroupEntry/resource}}.
                                - There is exactly one {{GPUBindGroupLayoutEntry}} |layoutBinding|
                                    in |descriptor|.{{GPUBindGroupDescriptor/layout}}.{{GPUBindGroupLayoutDescriptor/entries}}
                                    such that |layoutBinding|.{{GPUBindGroupLayoutEntry/binding}} equals to
                                    |bindingDescriptor|.{{GPUBindGroupEntry/binding}}.

                                - If the defined [=binding member=] for |layoutBinding| is
                                    <dl class="switch">
                                        : {{GPUBindGroupLayoutEntry/sampler}}
                                        ::
                                            - |resource| is a {{GPUSampler}}.
                                            - |resource| is [$valid to use with$] |this|.
                                            - If the [$layout entry binding type$] of |layoutBinding| is
                                                <dl class="switch">
                                                    : {{GPUSamplerBindingType/"filtering"}}
                                                    :: |resource|.{{GPUSampler/[[isComparison]]}} is `false`.

                                                    : {{GPUSamplerBindingType/"non-filtering"}}
                                                    ::
                                                        |resource|.{{GPUSampler/[[isFiltering]]}} is `false`.
                                                        |resource|.{{GPUSampler/[[isComparison]]}} is `false`.

                                                    : {{GPUSamplerBindingType/"comparison"}}
                                                    :: |resource|.{{GPUSampler/[[isComparison]]}} is `true`.
                                                </dl>

                                        : {{GPUBindGroupLayoutEntry/texture}}
                                        ::
                                            - |resource| is a {{GPUTextureView}}.
                                            - |resource| is [$valid to use with$] |this|.
                                            - Let |texture| be |resource|.{{GPUTextureView/[[texture]]}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}}
                                                is equal to |resource|'s {{GPUTextureViewDescriptor/dimension}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}
                                                is compatible with |resource|'s {{GPUTextureViewDescriptor/format}}.
                                            - |texture|'s {{GPUTextureDescriptor/usage}} includes {{GPUTextureUsage/SAMPLED}}.
                                            - If |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}}
                                                is `true`, |texture|'s {{GPUTextureDescriptor/sampleCount}}
                                                &gt; `1`, Otherwise |texture|'s {{GPUTextureDescriptor/sampleCount}} is `1`.

                                        : {{GPUBindGroupLayoutEntry/storageTexture}}
                                        ::
                                            - |resource| is a {{GPUTextureView}}.
                                            - |resource| is [$valid to use with$] |this|.
                                            - Let |texture| be |resource|.{{GPUTextureView/[[texture]]}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}}
                                                is equal to |resource|'s {{GPUTextureViewDescriptor/dimension}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}
                                                is equal to |resource|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}.
                                            - |texture|'s {{GPUTextureDescriptor/usage}} includes {{GPUTextureUsage/STORAGE}}.

                                        :  {{GPUBindGroupLayoutEntry/buffer}}
                                        ::
                                            - |resource| is a {{GPUBufferBinding}}.
                                            - |resource|.{{GPUBufferBinding/buffer}} is [$valid to use with$] |this|.
                                            - The bound part designated by |resource|.{{GPUBufferBinding/offset}} and
                                                |resource|.{{GPUBufferBinding/size}} resides inside the buffer.
                                            - If |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                                                is not `undefined`:
                                                - The effective binding size, that is either explict in
                                                    |resource|.{{GPUBufferBinding/size}} or derived from
                                                    |resource|.{{GPUBufferBinding/offset}} and the full
                                                    size of the buffer, is greater than or equal to
                                                    |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}.

                                            - If |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} is
                                                <dl class="switch">
                                                    : {{GPUBufferBindingType/"uniform"}}
                                                    :: |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}}
                                                        includes {{GPUBufferUsage/UNIFORM}}.
                                                    :: |resource|.{{GPUBufferBinding/size}} &le;
                                                        |limits|.{{supported limits/maxUniformBufferBindingSize}}.
                                                    :: Issue: This validation should take into account the default when  {{GPUBufferBinding/size}} is not set.
                                                        Also should {{GPUBufferBinding/size}} default to the `buffer.byteLength - offset` or
                                                        `min(buffer.byteLength - offset, limits.maxUniformBufferBindingSize)`?

                                                    : {{GPUBufferBindingType/"storage"}} or
                                                        {{GPUBufferBindingType/"read-only-storage"}}
                                                    :: |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}}
                                                        includes {{GPUBufferUsage/STORAGE}}.
                                                    :: |resource|.{{GPUBufferBinding/size}} &le;
                                                        |limits|.{{supported limits/maxStorageBufferBindingSize}}.
                                                </dl>

                                    </dl>

                        </div>

                        Issue: define the association between texture formats and component types

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |bindGroup| [=invalid=] and return |bindGroup|.

                    1. Let |bindGroup|.{{GPUBindGroup/[[layout]]}} =
                        |descriptor|.{{GPUBindGroupDescriptor/layout}}.
                    1. Let |bindGroup|.{{GPUBindGroup/[[entries]]}} =
                        |descriptor|.{{GPUBindGroupDescriptor/entries}}.
                    1. Let |bindGroup|.{{GPUBindGroup/[[usedResources]]}} = {}.

                    1. For each {{GPUBindGroupEntry}} |bindingDescriptor| in
                        |descriptor|.{{GPUBindGroupDescriptor/entries}}:
                        1. Let |internalUsage| be the [=binding usage=] for |layoutBinding|.
                        1. Each [=subresource=] seen by |resource| is added to {{GPUBindGroup/[[usedResources]]}} as |internalUsage|.
                </div>
            1. Return |bindGroup|.

            Issue: define the "effective buffer binding size" separately.
        </div>
</dl>

## <dfn interface>GPUPipelineLayout</dfn> ## {#pipeline-layout}

A {{GPUPipelineLayout}} defines the mapping between resources of all {{GPUBindGroup}} objects set up during command encoding in {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}}, and the shaders of the pipeline set by {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}} or {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}}.

The full binding address of a resource can be defined as a trio of:
  1. shader stage mask, to which the resource is visible
  2. bind group index
  3. binding number

The components of this address can also be seen as the binding space of a pipeline. A {{GPUBindGroup}} (with the corresponding {{GPUBindGroupLayout}}) covers that space for a fixed bind group index. The contained bindings need to be a superset of the resources used by the shader at this bind group index.

<script type=idl>
[Serializable]
interface GPUPipelineLayout {
};
GPUPipelineLayout includes GPUObjectBase;
</script>

{{GPUPipelineLayout}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUPipelineLayout">
    : <dfn>\[[bindGroupLayouts]]</dfn> of type [=list=]&lt;{{GPUBindGroupLayout}}&gt;.
    ::
        The {{GPUBindGroupLayout}} objects provided at creation in {{GPUPipelineLayoutDescriptor/bindGroupLayouts|GPUPipelineLayoutDescriptor.bindGroupLayouts}}.
</dl>

Note: using the same {{GPUPipelineLayout}} for many {{GPURenderPipeline}} or {{GPUComputePipeline}} pipelines guarantees that the user agent doesn't need to rebind any resources internally when there is a switch between these pipelines.

<div class="example">
{{GPUComputePipeline}} object X was created with {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, B, C. {{GPUComputePipeline}} object Y was created with {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, D, C. Supposing the command encoding sequence has two dispatches:

  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(0, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(2, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(X)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(Y)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}

In this scenario, the user agent would have to re-bind the group slot 2 for the second dispatch, even though neither the {{GPUBindGroupLayout}} at index 2 of {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGrouplayouts}}, or the {{GPUBindGroup}} at slot 2, change.
</div>

Issue: should this example and the note be moved to some "best practices" document?

Note: the expected usage of the {{GPUPipelineLayout}} is placing the most common and the least frequently changing bind groups at the "bottom" of the layout, meaning lower bind group slot numbers, like 0 or 1. The more frequently a bind group needs to change between draw calls, the higher its index should be. This general guideline allows the user agent to minimize state changes between draw calls, and consequently lower the CPU overhead.

### Creation ### {#pipeline-layout-creation}

A {{GPUPipelineLayout}} is created via {{GPUDevice/createPipelineLayout()|GPUDevice.createPipelineLayout()}}.

<script type=idl>
dictionary GPUPipelineLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayout> bindGroupLayouts;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createPipelineLayout(descriptor)</dfn>
    ::
        Creates a {{GPUPipelineLayout}}.

        <div algorithm=GPUDevice.createPipelineLayout>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createPipelineLayout(descriptor)">
                |descriptor|: Description of the {{GPUPipelineLayout}} to create.
            </pre>

            **Returns:** {{GPUPipelineLayout}}

            1. If any of the following conditions are unsatisfied:
                <div class=validusage>
                    - |this| is a [=valid=] {{GPUDevice}}.
                    - There are
                        |this|.{{GPUDevice/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}
                        or fewer elements in
                        |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}.
                    - Every {{GPUBindGroupLayout}} in |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
                        is [$valid to use with$] |this|.
                </div>

                Then:
                    1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                    1. Create a new [=invalid=] {{GPUPipelineLayout}} and return the result.

            1. Let |pl| be a new {{GPUPipelineLayout}} object.
            1. Set the |pl|.{{GPUPipelineLayout/[[bindGroupLayouts]]}} to
                |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}.
            1. Return |pl|.

            Issue: there will be more limits applicable to the whole pipeline layout.
        </div>
</dl>

Note: two {{GPUPipelineLayout}} objects are considered equivalent for any usage
if their internal {{GPUPipelineLayout/[[bindGroupLayouts]]}} sequences contain
{{GPUBindGroupLayout}} objects that are [=group-equivalent=].

# Shader Modules # {#shader-modules}

## <dfn interface>GPUShaderModule</dfn> ## {#shader-module}

<script type=idl>
enum GPUCompilationMessageType {
    "error",
    "warning",
    "info"
};

[Serializable]
interface GPUCompilationMessage {
    readonly attribute DOMString message;
    readonly attribute GPUCompilationMessageType type;
    readonly attribute unsigned long long lineNum;
    readonly attribute unsigned long long linePos;
};

[Serializable]
interface GPUCompilationInfo {
    readonly attribute FrozenArray<GPUCompilationMessage> messages;
};

[Serializable]
interface GPUShaderModule {
    Promise<GPUCompilationInfo> compilationInfo();
};
GPUShaderModule includes GPUObjectBase;
</script>

{{GPUShaderModule}} is {{Serializable}}. It is a reference to an internal
shader module object, and {{Serializable}} means that the reference can be
*copied* between realms (threads/workers), allowing multiple realms to access
it concurrently. Since {{GPUShaderModule}} is immutable, there are no race
conditions.

### Shader Module Creation ### {#shader-module-creation}

<script type=idl>
dictionary GPUShaderModuleDescriptor : GPUObjectDescriptorBase {
    required USVString code;
    object sourceMap;
};
</script>

{{GPUShaderModuleDescriptor/sourceMap}}, if defined, MAY be interpreted as a
source-map-v3 format. (https://sourcemaps.info/spec.html)
Source maps are optional, but serve as a standardized way to support dev-tool
integration such as source-language debugging.

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createShaderModule(descriptor)</dfn>
    ::
        Creates a {{GPUShaderModule}}.

        <div algorithm=GPUDevice.createShaderModule>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createShaderModule(descriptor)">
                descriptor: Description of the {{GPUShaderModule}} to create.
            </pre>

            **Returns:** {{GPUShaderModule}}

            Issue: Describe {{GPUDevice/createShaderModule()}} algorithm steps.
        </div>
</dl>

### Shader Module Compilation Information ### {#shader-module-compilation-information}

<dl dfn-type=method dfn-for=GPUShaderModule>
    : <dfn>compilationInfo()</dfn>
    ::
        Returns any messages generated during the {{GPUShaderModule}}'s compilation.

        <div algorithm=GPUShaderModule.compilationInfo>
            **Called on:** {{GPUShaderModule}} this.

            **Returns:** {{Promise}}&lt;{{GPUCompilationInfo}}&gt;

            Issue: Describe {{GPUShaderModule/compilationInfo()}} algorithm steps.
        </div>
</dl>

# Pipelines # {#pipelines}

A <dfn dfn>pipeline</dfn>, be it {{GPUComputePipeline}} or {{GPURenderPipeline}},
represents the complete function done by a combination of the GPU hardware, the driver,
and the user agent, that process the input data in the shape of bindings and vertex buffers,
and produces some output, like the colors in the output render targets.

Structurally, the [=pipeline=] consists of a sequence of programmable stages (shaders)
and fixed-function states, such as the blending modes.

Note: Internally, depending on the target platform,
the driver may convert some of the fixed-function states into shader code,
and link it together with the shaders provided by the user.
This linking is one of the reason the object is created as a whole.

This combination state is created as a single object
(by {{GPUDevice/createComputePipeline(descriptor)|GPUDevice.createComputePipeline()}} or {{GPUDevice/createRenderPipeline(descriptor)|GPUDevice.createRenderPipeline()}}),
and switched as one
(by {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}} or {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}} correspondingly).

## Base pipelines ## {#pipeline-base}

<script type=idl>
dictionary GPUPipelineDescriptorBase : GPUObjectDescriptorBase {
    GPUPipelineLayout layout;
};

interface mixin GPUPipelineBase {
    GPUBindGroupLayout getBindGroupLayout(unsigned long index);
};
</script>

{{GPUPipelineBase}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUPipelineBase">
    : <dfn>\[[layout]]</dfn> of type `GPUPipelineLayout`.
    ::
        The definition of the layout of resources which can be used with `this`.
</dl>

{{GPUPipelineBase}} has the following methods:

<dl dfn-type=method dfn-for=GPUPipelineBase>
    : <dfn>getBindGroupLayout(index)</dfn>
    ::
        Gets a {{GPUBindGroupLayout}} that is compatible with the {{GPUPipelineBase}}'s
        {{GPUBindGroupLayout}} at `index`.

        <div algorithm=GPUPipelineBase.getBindGroupLayout>
            **Called on:** {{GPUPipelineBase}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUPipelineBase/getBindGroupLayout(index)">
                |index|: Index into the pipeline layout's {{GPUPipelineLayout/[[bindGroupLayouts]]}}
                    sequence.
            </pre>

            **Returns:** {{GPUBindGroupLayout}}

            1. If |index| &ge;
                |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}:
                1. Throw a {{RangeError}}.

            1. If |this| is not [=valid=]:
                1. Return a new error {{GPUBindGroupLayout}}.

            1. Return a new {{GPUBindGroupLayout}} object that references the same internal object as
                |this|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|index|].

            Issue: Specify this more properly once we have internal objects for {{GPUBindGroupLayout}}.
                Alternatively only spec is as a new internal objects that's [=group-equivalent=]

            Note: Only returning new {{GPUBindGroupLayout}} objects ensures no synchronization is necessary
                between the [=Content timeline=] and the [=Device timeline=].
        </div>
</dl>

### Default pipeline layout ### {#default-pipeline-layout}

A {{GPUPipelineBase}} object that was created without a {{GPUPipelineDescriptorBase/layout}}
has a default layout created and used instead.

<div algorithm="default pipeline layout creation">

    1. Let |groupDescs| be a sequence of |device|.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}
        new {{GPUBindGroupLayoutDescriptor}} objects.
    1. For each |groupDesc| in |groupDescs|:

        1. Set |groupDesc|.{{GPUBindGroupLayoutDescriptor/entries}} to an empty sequence.

    1. For each {{GPUProgrammableStage}} |stageDesc| in the descriptor used to create the pipeline:

        1. Let |stageInfo| be the "reflection information" for |stageDesc|.

            Issue: Define the reflection information concept so that this spec can interface with the WGSL
                spec and get information what the interface is for a {{GPUShaderModule}} for a specific
                entrypoint.

        1. Let |shaderStage| be the {{GPUShaderStageFlags}} for |stageDesc|.{{GPUProgrammableStage/entryPoint}}
            in |stageDesc|.{{GPUProgrammableStage/module}}.
        1. For each resource |resource| in |stageInfo|'s resource interface:

            1. Let |group| be |resource|'s "group" decoration.
            1. Let |binding| be |resource|'s "binding" decoration.
            1. Let |entry| be a new {{GPUBindGroupLayoutEntry}}.
            1. Set |entry|.{{GPUBindGroupLayoutEntry/binding}} to |binding|.
            1. Set |entry|.{{GPUBindGroupLayoutEntry/visibility}} to |shaderStage|.
            1. If |resource| is for a sampler binding:

                1. Let |samplerLayout| be a new {{GPUSamplerBindingLayout}}.
                1. Set |entry|.{{GPUBindGroupLayoutEntry/sampler}} to |samplerLayout|.

            1. If |resource| is for a comparison sampler binding:

                1. Let |samplerLayout| be a new {{GPUSamplerBindingLayout}}.
                1. Set |samplerLayout|.{{GPUSamplerBindingLayout/type}} to {{GPUSamplerBindingType/"comparison"}}.
                1. Set |entry|.{{GPUBindGroupLayoutEntry/sampler}} to |samplerLayout|.

            1. If |resource| is for a buffer binding:

                1. Let |bufferLayout| be a new {{GPUBufferBindingLayout}}.

                1. Set |bufferLayout|.{{GPUBufferBindingLayout/minBindingSize}} to |resource|'s minimum buffer binding size.

                    Issue: link to a definition for "minimum buffer binding size" in the "reflection information".

                1. If |resource| is for a read-only storage buffer:

                    1. Set |bufferLayout|.{{GPUBufferBindingLayout/type}} to {{GPUBufferBindingType/"read-only-storage"}}.

                1. If |resource| is for a storage buffer:

                    1. Set |bufferLayout|.{{GPUBufferBindingLayout/type}} to {{GPUBufferBindingType/"storage"}}.

                1. Set |entry|.{{GPUBindGroupLayoutEntry/buffer}} to |bufferLayout|.

            1. If |resource| is for a sampled texture binding:

                1. Let |textureLayout| be a new {{GPUTextureBindingLayout}}.

                1. Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to |resource|'s component type.
                1. Set |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} to |resource|'s dimension.
                1. If |resource| is for a multisampled texture:

                    1. Set |textureLayout|.{{GPUTextureBindingLayout/multisampled}} to `true`.

                1. Set |entry|.{{GPUBindGroupLayoutEntry/texture}} to |textureLayout|.

            1. If |resource| is for a storage texture binding:

                1. Let |storageTextureLayout| be a new {{GPUStorageTextureBindingLayout}}.
                1. Set |storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}} to |resource|'s format.
                1. Set |storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}} to |resource|'s dimension.

                1. If |resource| is for a read-only storage texture:

                    1. Set |storageTextureLayout|.{{GPUStorageTextureBindingLayout/access}} to {{GPUStorageTextureAccess/"read-only"}}.

                1. If |resource| is for a write-only storage texture:

                    1. Set |storageTextureLayout|.{{GPUStorageTextureBindingLayout/access}} to {{GPUStorageTextureAccess/"write-only"}}.

                1. Set |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} to |storageTextureLayout|.

            1. If |groupDescs|[|group|] has an entry |previousEntry| with {{GPUBindGroupLayoutEntry/binding}} equal to |binding|:

                1. If |entry| has different {{GPUBindGroupLayoutEntry/visibility}} than |previousEntry|:

                    1. Add the bits set in |entry|.{{GPUBindGroupLayoutEntry/visibility}} into |previousEntry|.{{GPUBindGroupLayoutEntry/visibility}}

                1. If |resource| is for a buffer binding and |entry| has greater
                    {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                    than |previousEntry|:

                    1. Set |previousEntry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        to |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}.

                1. If any other property is unequal between |entry| and |previousEntry|:

                    1. Return `null` (which will cause the creation of the pipeline to fail).

            1. Else

                1. Append |entry| to |groupDescs|[|group|].

    1. Let |groupLayouts| be a new sequence.
    1. For each |groupDesc| in |groupDescs|:

        1. Append |device|.{{GPUDevice/createBindGroupLayout()}}(|groupDesc|) to |groupLayouts|.

    1. Let |desc| be a new {{GPUPipelineLayoutDescriptor}}.
    1. Set |desc|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} to |groupLayouts|.
    1. Return |device|.{{GPUDevice/createPipelineLayout()}}(|desc|).

    Issue: This fills the pipeline layout with empty bindgroups. Revisit once the behavior of empty bindgroups is specified.

</div>

### <dfn dictionary>GPUProgrammableStage</dfn> ### {#GPUProgrammableStage}

<script type=idl>
dictionary GPUProgrammableStage {
    required GPUShaderModule module;
    required USVString entryPoint;
};
</script>

A {{GPUProgrammableStage}} describes the entry point in the user-provided
{{GPUShaderModule}} that controls one of the programmable stages of a [=pipeline=].

<div algorithm>
    <dfn abstract-op>validating GPUProgrammableStage</dfn>(stage, descriptor, layout)
        **Arguments:**
            - {{GPUShaderStage}} |stage|
            - {{GPUProgrammableStage}} |descriptor|
            - {{GPUPipelineLayout}} |layout|

        Return `true` if all of the following conditions are satisfied:

            - The |descriptor|.{{GPUProgrammableStage/module}} is [=valid=] {{GPUShaderModule}}.
            - The |descriptor|.{{GPUProgrammableStage/module}} contains
                an entry point at |stage| named |descriptor|.{{GPUProgrammableStage/entryPoint}}.
            - For each |binding| that is [=statically used=] by the shader entry point,
                the [$validating shader binding$](|binding|, |layout|) returns `true`.
            - For each texture sampling shader call that is [=statically used=] by the entry point:
                1. Let |texture| be the {{GPUBindGroupLayoutEntry}} corresponding to the sampled texture in the call.
                1. Let |sampler| be the {{GPUBindGroupLayoutEntry}} corresponding to the used sampler in the call.
                1. One of the following conditions is `false`:
                    - |texture|.{{GPUTextureBindingLayout/sampleType}} is {{GPUTextureSampleType/"unfilterable-float"}}:
                    - |sampler|.{{GPUSamplerBindingLayout/type}} is {{GPUSamplerBindingType/"filtering"}}.

</div>

<div algorithm>
    <dfn abstract-op>validating shader binding</dfn>(binding, layout)
    **Arguments:**
        - shader |binding|, reflected from the shader module
        - {{GPUPipelineLayout}} |layout|

    Consider the shader |binding| annotation of |bindIndex| for the
    binding index and |bindGroup| for the bind group index.

    Return `true` if all of the following conditions are satisfied:

        - |layout|.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|bindGroup|] contains
            a {{GPUBindGroupLayoutEntry}} |entry| whose |entry|.{{GPUBindGroupLayoutEntry/binding}} == |bindIndex|.
        - If the defined [=binding member=] for |entry| is:
            <dl class=switch>
                : {{GPUBindGroupLayoutEntry/buffer}}
                :: If |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} is:
                    <dl class=switch>
                        : {{GPUBufferBindingType/"uniform"}}
                        :: The |binding| is a uniform buffer.
                        : {{GPUBufferBindingType/"storage"}}
                        :: The |binding| is a storage buffer.
                        : {{GPUBufferBindingType/"read-only-storage"}}
                        :: The |binding| is a read-only storage buffer.
                    </dl>
                :: If |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}} is not `0`:
                    - If the last field of the corresponding structure defined in the shader has an unbounded array type,
                        then the value of |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        must be greater than or equal to the byte offset of that field plus the stride of the unbounded array.
                    - If the corresponding shader structure doesn't end with an unbounded array type,
                        then the value of |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        must be greater than or equal to the size of the structure.

                : {{GPUBindGroupLayoutEntry/sampler}}
                :: If |entry|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} is:
                    <dl class=switch>
                        : {{GPUSamplerBindingType/"filtering"}}
                        :: the |binding| is a non-comparison sampler
                        : {{GPUSamplerBindingType/"non-filtering"}}
                        :: the |binding| is a non-comparison sampler
                        : {{GPUSamplerBindingType/"comparison"}}
                        :: the |binding| is a comparison sampler
                    </dl>

                : {{GPUBindGroupLayoutEntry/texture}}
                :: If |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}} is:
                    <dl class=switch>
                        : `true`
                        :: the |binding| is a multisampled texture.
                        : `false`
                        :: The |binding| is a sampled texture with a sample count of 1.
                    </dl>
                :: The component type of the texture matches
                    |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}.
                :: The shader view dimension of the texture matches
                    |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}}.

                : {{GPUBindGroupLayoutEntry/storageTexture}}
                :: If |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/access}} is:
                    <dl class=switch>
                        : {{GPUStorageTextureAccess/"read-only"}}
                        :: The |binding| is a read-only storage texture.
                        : {{GPUStorageTextureAccess/"write-only"}}
                        :: The |binding| is a writable storage texture.
                    </dl>
                :: The format of the storage texture matches
                    |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}.
                :: The shader view dimension of the storage texture matches
                    |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}}.

            </dl>
</div>

A resource binding is considered to be <dfn dfn>statically used</dfn> by a shader entry point
if and only if it's reachable by the control flow graph of the shader module,
starting at the entry point.

## <dfn interface>GPUComputePipeline</dfn> ## {#compute-pipeline}

A {{GPUComputePipeline}} is a kind of [=pipeline=] that controls the compute shader stage,
and can be used in {{GPUComputePassEncoder}}.

Compute inputs and outputs are all contained in the bindings,
according to the given {{GPUPipelineLayout}}.
The outputs correspond to {{GPUBindGroupLayoutEntry/buffer}} bindings with a type of {{GPUBufferBindingType/"storage"}}
and {{GPUBindGroupLayoutEntry/storageTexture}} bindings with a type of {{GPUStorageTextureAccess/"write-only"}}.

Stages of a compute [=pipeline=]:
  1. Compute shader

<script type=idl>
[Serializable]
interface GPUComputePipeline {
};
GPUComputePipeline includes GPUObjectBase;
GPUComputePipeline includes GPUPipelineBase;
</script>

### Creation ### {#compute-pipeline-creation}

<script type=idl>
dictionary GPUComputePipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStage compute;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createComputePipeline(descriptor)</dfn>
    ::
        Creates a {{GPUComputePipeline}}.

        <div algorithm=GPUDevice.createComputePipeline>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createComputePipeline(descriptor)">
                |descriptor|: Description of the {{GPUComputePipeline}} to create.
            </pre>

            **Returns:** {{GPUComputePipeline}}

            If any of the following conditions are unsatisfied:
                <div class=validusage>
                    - |this| is a [=valid=] {{GPUDevice}}.
                    - |descriptor|.{{GPUPipelineDescriptorBase/layout}} is [$valid to use with$] |this|.
                    - [$validating GPUProgrammableStage$]({{GPUShaderStage/COMPUTE}},
                        |descriptor|.{{GPUComputePipelineDescriptor/compute}},
                        |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
                </div>

            Then:
                1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                1. Create a new [=invalid=] {{GPUComputePipeline}} and return the result.
        </div>

    : <dfn>createComputePipelineAsync(descriptor)</dfn>
    ::
        Creates a {{GPUComputePipeline}}. The returned {{Promise}} resolves when the created pipeline
        is ready to be used without additional delay.

        If pipeline creation fails, the returned {{Promise}} resolves to an [=invalid=]
        {{GPUComputePipeline}} object.

        Note: Use of this method is preferred whenever possible, as it prevents blocking the
        [=queue timeline=] work on pipeline compilation.

        <div algorithm=GPUDevice.createComputePipelineAsync>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createComputePipelineAsync(descriptor)">
                |descriptor|: Description of the {{GPUComputePipeline}} to create.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPUComputePipeline}}&gt;

            1. Let |promise| be [=a new promise=].
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. Let |pipeline| be a new {{GPUComputePipeline}} created as if
                        |this|.{{GPUDevice/createComputePipeline()}} was called with |descriptor|;

                    1. When |pipeline| is ready to be used, [=resolve=] |promise| with |pipeline|.
                </div>
            1. Return |promise|.
        </div>
</dl>

## <dfn interface>GPURenderPipeline</dfn> ## {#render-pipeline}

A {{GPURenderPipeline}} is a kind of [=pipeline=] that controls the vertex
and fragment shader stages, and can be used in {{GPURenderPassEncoder}}
as well as {{GPURenderBundleEncoder}}.

Render [=pipeline=] inputs are:
  - bindings, according to the given {{GPUPipelineLayout}}
  - vertex and index buffers, described by {{GPUVertexState}}
  - the color attachments, described by {{GPUColorTargetState}}
  - optionally, the depth-stencil attachment, described by {{GPUDepthStencilState}}

Render [=pipeline=] outputs are:
  - {{GPUBindGroupLayoutEntry/buffer}} bindings with a {{GPUBufferBindingLayout/type}} of {{GPUBufferBindingType/"storage"}}
  - {{GPUBindGroupLayoutEntry/storageTexture}} bindings with a {{GPUStorageTextureBindingLayout/access}} of {{GPUStorageTextureAccess/"write-only"}}
  - the color attachments, described by {{GPUColorTargetState}}
  - optionally, depth-stencil attachment, described by {{GPUDepthStencilState}}

A render [=pipeline=] is comprised of the following <dfn dfn>render stages</dfn>:
  1. Vertex fetch, controlled by {{GPUVertexState/buffers|GPUVertexState.buffers}}
  2. Vertex shader, controlled by {{GPUVertexState}}
  3. Primitive assembly, controlled by {{GPUPrimitiveState}}
  4. Rasterization, controlled by {{GPUPrimitiveState}}, {{GPUDepthStencilState}}, and {{GPUMultisampleState}}
  5. Fragment shader, controlled by {{GPUFragmentState}}
  6. Stencil test and operation, controlled by {{GPUDepthStencilState}}
  7. Depth test and write, controlled by {{GPUDepthStencilState}}
  8. Output merging, controlled by {{GPUFragmentState/targets|GPUFragmentState.targets}}

Issue: we need a deeper description of these stages

<script type=idl>
[Serializable]
interface GPURenderPipeline {
};
GPURenderPipeline includes GPUObjectBase;
GPURenderPipeline includes GPUPipelineBase;
</script>

{{GPURenderPipeline}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPURenderPipeline>
    : <dfn>\[[descriptor]]</dfn>, of type {{GPURenderPipelineDescriptor}}
    ::
        The {{GPURenderPipelineDescriptor}} describing this pipeline.

        All optional fields of {{GPURenderPipelineDescriptor}} are defined.

    : <dfn>\[[strip_index_format]]</dfn>, of type {{GPUIndexFormat}}?
    ::
        The format index data this pipeline requires if using a strip primitive topology,
        initially `undefined`.
</dl>

### Creation ### {#render-pipeline-creation}

<script type=idl>
dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUVertexState vertex;
    GPUPrimitiveState primitive = {};
    GPUDepthStencilState depthStencil;
    GPUMultisampleState multisample = {};
    GPUFragmentState fragment;
};
</script>

A {{GPURenderPipelineDescriptor}} describes the state of a render [=pipeline=] by
configuring each of the [=render stages=].

<div algorithm>
    <dfn abstract-op>render</dfn>(descriptor, drawCall, indexBuffer, vertexBuffers, bindGroups)
        **Arguments:**
            - |descriptor|: Description of the current {{GPURenderPipeline}}.
            - |drawCall|: The draw call parameters.
            - |indexBuffer|: Currently bound index buffer via {{GPURenderEncoderBase/setIndexBuffer()}}.
            - |vertexBuffers|: [=list=]&lt;vertex buffer&gt; bound by {{GPURenderEncoderBase/setVertexBuffer()}}.
            - |bindGroups|: [=list=]&lt;{{GPUBindGroup}}&gt; bound by {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}}.

        Issue: define somewhere what a render pass state is?

        1. Resolve indices.
            The pipeline builds a list of vertices to process for each instance.
            If |drawCall| is an indexed draw call:
                - for |i| in range 0 .. |drawCall|.indexCount (non-inclusive):
                    1. let |vertexIndex| be [$fetch index$](|i| + |drawCall|.firstIndex, |indexBuffer|.buffer, |indexBuffer|.offset, |indexBuffer|.format) + |drawCall|.baseVertex
                    1. append |vertexIndex| to the |vertexList|
            Otherwise:
                - initialize the |vertexList| with |drawCall|.vertexCount integers
                - assign the |vertexList| item |i| to be |drawCall|.firstVertex + |i|

            Note: in case of indirect draw calls, the `indexCount`, `vertexCount`,
            and other properties of |drawCall| are read from the indirect buffer
            instead of the draw command itself.

            Issue: specify indirect commands better.

        1. Process vertices. Each vertex |vertexIndex| in the |vertexList|,
            in each instance of index |rawInstanceIndex|, is processed independently.
            The |rawInstanceIndex| is in range from 0 to |drawCall|.instanceCount - 1, inclusive.
            This processing happens in parallel, and any side effects, such as
            writes into {{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}} bindings,
            may happen in any order.
            1. Let |instanceIndex| be |rawInstanceIndex| + |drawCall|.baseInstance.
            1. For each non-`null` |vertexBufferLayout| in the list of
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}:
                1. Let |i| be the index of the buffer layout in this list.
                1. Let |vertexBuffer| and |vertexBufferOffset| be the buffer and offset in |vertexBuffers| bindings at slot |i|
                1. Let |vertexElementIndex| be dependent on |vertexBufferLayout|.{{GPUVertexBufferLayout/stepMode}}:
                    <dl class="switch">
                        : {{GPUInputStepMode/"vertex"}}
                        :: |vertexIndex|
                        : {{GPUInputStepMode/"instance"}}
                        :: |instanceIndex|
                    </dl>
                1. For each |attributeDesc| in |vertexBufferLayout|.{{GPUVertexBufferLayout/attributes}}:
                    1. Let |attributeOffset| be |vertexBufferOffset| +
                        |vertexElementIndex| * |vertexBufferLayout|.{{GPUVertexBufferLayout/arrayStride}} +
                        |attributeDesc|.{{GPUVertexAttribute/offset}}.
                    1. Load the attribute |data| of format |attributeDesc|.{{GPUVertexAttribute/format}}
                        from |vertexBuffer| starting at offset |attributeOffset|.
                    1. Convert the |data| into a shader-visible format.
                        <div class="example">
                            An attribute of type {{GPUVertexFormat/"uchar2norm"}} will be converted from
                            2 bytes of fixed-point unsigned 8-bit integers into 2 floating-point values
                            as `vec2<f32>` in WGSL.
                        </div>
                    1. Bind the |data| to vertex shader input
                        location |attributeDesc|.{{GPUVertexAttribute/shaderLocation}}.
            1. For each {{GPUBindGroup}} group at |index| in |bindGroups|:
                1. For each resource {{GPUBindingResource}} in the bind group:
                    1. Let |entry| be the corresponding {{GPUBindGroupLayoutEntry}} for this resource.
                    1. If |entry|.{{GPUBindGroupLayoutEntry}}.visibility includes {{GPUShaderStage/VERTEX}}:
                        - Bind the resource to the shader under group |index| and binding {{GPUBindGroupLayoutEntry/binding|GPUBindGroupLayoutEntry.binding}}.
            1. Set the shader builtins:
                - Set the `VertexIndex` builtin, if any, to |vertexIndex|.
                - Set the `InstanceIndex` builtin, if any, to |instanceIndex|.
            1. Invoke vertex shader entry point described by |descriptor|.{{GPURenderPipelineDescriptor/vertex}}.

                Note: The target platform caches the results of vertex shader invocations.
                There is no guarantee that any |vertexIndex| that repeats more than once will
                result in multiple invocations. Similarly, there is no guarantee that a single |vertexIndex|
                will only be processed once.

        1. Assemble primitives.
            For each instance, the primitives get assembled from the vertices that have been
            processed by the shaders, based on the |vertexList|.

            1. First, if |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/stripIndexFormat}} is not `null`
                (which means the primitive topology is a strip), and the |drawCall| is indexed,
                the |vertexList| is split into sub-lists
                using the maximum value of this index format as a separator.

                Example: a |vertexList| with values `[1, 2, 65535, 4, 5, 6]` of type {{GPUIndexFormat/"uint16"}}
                will be split in sub-lists `[1, 2]` and `[4, 5, 6]`.

            1. For each of the sub-lists |vl|, primitive generation is done according to the
                |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}:
                <dl class="switch">
                    : {{GPUPrimitiveTopology/"line-list"}}
                    ::
                        Line primitives are composed from (|vl|.0, |vl|.1),
                        then (|vl|.2, |vl|.3), then (|vl|.4 to |vl|.5), etc.
                        Each subsequent primitive takes 2 vertices.

                    : {{GPUPrimitiveTopology/"line-strip"}}
                    ::
                        Line primitives are composed from (|vl|.0, |vl|.1),
                        then (|vl|.1, |vl|.2), then (|vl|.2, |vl|.3), etc.
                        Each subsequent primitive takes 1 vertex.

                    : {{GPUPrimitiveTopology/"triangle-list"}}
                    ::
                        Triangle primitives are composed from (|vl|.0, |vl|.1, |vl|.2),
                        then (|vl|.3, |vl|.4, |vl|.5), then (|vl|.6, |vl|.7, |vl|.8), etc.
                        Each subsequent primitive takes 3 vertices.

                    : {{GPUPrimitiveTopology/"triangle-strip"}}
                    ::
                        Triangle primitives are composed from (|vl|.0, |vl|.1, |vl|.2),
                        then (|vl|.2, |vl|.1, |vl|.3), then (|vl|.2, |vl|.3, |vl|.4),
                        then (|vl|.4, |vl|.3, |vl|.5), etc.
                        Each subsequent primitive takes 1 vertices.
                </dl>

                Issue: should this be defined more formally?

                Any incomplete primitives are dropped.

        1. Rasterize.
            Rasterization is a hardware processing stage that maps the
            generated primitives to the actual screen.
            Issue: fill out the section
        1. Process fragments.
            Issue: fill out the section
        1. Process depth/stencil.
            Issue: fill out the section
        1. Write pixels.
            Issue: fill out the section
</div>

<div algorithm>
    <dfn abstract-op>fetch index</dfn>(i, buffer, offset, format)
        **Arguments:**
            - |i|: Index of a vertex index to fetch.
            - |buffer|: {{GPUBuffer}} containing index data.
            - |offset|: Base offset into the |buffer|.
            - |format|: {{GPUIndexFormat}} of the index.

        Let |stride| be defined by the |format|:
        <dl class="switch">
            : {{GPUIndexFormat/"uint16"}}
            :: 2
            : {{GPUIndexFormat/"uint32"}}
            :: 4
        </dl>
        Interpret the data in |buffer| starting with |offset| + |i| * |stride|
        of size |stride| bytes as an unsigned integer and return it.
</div>

- {{GPURenderPipelineDescriptor/vertex}} describes
    the vertex shader entry point of the [=pipeline=] and its input buffer layouts.
- {{GPURenderPipelineDescriptor/primitive}} describes the
    the primitive-related properties of the [=pipeline=].
- {{GPURenderPipelineDescriptor/depthStencil}} describes
    the optional depth-stencil properties, including the testing, operations, and bias.
- {{GPURenderPipelineDescriptor/multisample}} describes
    the multi-sampling properties of the [=pipeline=].
- {{GPURenderPipelineDescriptor/fragment}} describes
    the fragment shader entry point of the [=pipeline=] and its output colors.
    If it's `null`, the [[#no-color-output]] mode is enabled.

### No Color Output ### {#no-color-output}

In no-color-output mode, [=pipeline=] does not produce any color attachment outputs.

The [=pipeline=] still performs rasterization and produces depth values
based on the vertex position output. The depth testing and stencil operations can still be used.

### Alpha to Coverage ### {#alpha-to-coverage}

In alpha-to-coverage mode, an additional <dfn dfn>alpha-to-coverage mask</dfn>
of MSAA samples is generated based on the |alpha| component of the
fragment shader output value of the {{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}[0].

The algorithm of producing the extra mask is platform-dependent and can vary for different pixels.
It guarantees that:
  - if |alpha| is 0.0 or less, the result is 0x0
  - if |alpha| is 1.0 or greater, the result is 0xFFFFFFFF
  - if |alpha| is greater than some other |alpha1|,
    then the produced sample mask has at least as many bits set to 1 as the mask for |alpha1|

### Sample Masking ### {#sample-masking}

The <dfn dfn>final sample mask</dfn> for a pixel is computed as:
[=rasterization mask=] & {{GPUMultisampleState/mask}} & [=shader-output mask=].

Only the lower {{GPUMultisampleState/count}} bits of the mask are considered.

If the least-significant bit at position |N| of the [=final sample mask=] has value of "0",
the sample color outputs (corresponding to sample |N|) to all attachments of the fragment shader are discarded.
Also, no depth test or stencil operations are executed on the relevant samples of the depth-stencil attachment.

Note: the color output for sample |N| is produced by the fragment shader execution
with SV_SampleIndex == |N| for the current pixel.
If the fragment shader doesn't use this semantics, it's only executed once per pixel.

The <dfn dfn>rasterization mask</dfn> is produced by the rasterization stage,
based on the shape of the rasterized polygon. The samples incuded in the shape get the relevant
bits 1 in the mask.

The <dfn dfn>shader-output mask</dfn> takes the output value of SV_Coverage semantics in the fragment shader.
If the semantics is not [=statically used=] by the shader, and {{GPUMultisampleState/alphaToCoverageEnabled}}
is enabled, the [=shader-output mask=] becomes the [=alpha-to-coverage mask=]. Otherwise, it defaults to 0xFFFFFFFF.

Issue: link to the semantics of SV_SampleIndex and SV_Coverage in WGSL spec.

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderPipeline(descriptor)</dfn>
    ::
        Creates a {{GPURenderPipeline}}.

        <div algorithm=GPUDevice.createRenderPipeline>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createRenderPipeline(descriptor)">
                |descriptor|: Description of the {{GPURenderPipeline}} to create.
            </pre>

            **Returns:** {{GPURenderPipeline}}

            1. Let |pipeline| be a new valid {{GPURenderPipeline}} object.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |this| is a [=valid=] {{GPUDevice}}.
                            - |descriptor|.{{GPUPipelineDescriptorBase/layout}} is [$valid to use with$] |this|.
                            - [$validating GPURenderPipelineDescriptor$](|descriptor|, |this|) succeeds.
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |pipeline| [=invalid=].

                    1. Set |pipeline|.{{GPURenderPipeline/[[descriptor]]}} to |descriptor|.
                    1. Set |pipeline|.{{GPURenderPipeline/[[strip_index_format]]}} to
                        |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/stripIndexFormat}}.

                </div>
            1. Return |pipeline|.

            Issue: need description of the render states.
        </div>

    : <dfn>createRenderPipelineAsync(descriptor)</dfn>
    ::
        Creates a {{GPURenderPipeline}}. The returned {{Promise}} resolves when the created pipeline
        is ready to be used without additional delay.

        If pipeline creation fails, the returned {{Promise}} resolves to an [=invalid=]
        {{GPURenderPipeline}} object.

        Note: Use of this method is preferred whenever possible, as it prevents blocking the
        [=queue timeline=] work on pipeline compilation.

        <div algorithm=GPUDevice.createRenderPipelineAsync>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createRenderPipelineAsync(descriptor)">
                |descriptor|: Description of the {{GPURenderPipeline}} to create.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPURenderPipeline}}&gt;

            1. Let |promise| be [=a new promise=].
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. Let |pipeline| be a new {{GPURenderPipeline}} created as if
                        |this|.{{GPUDevice/createRenderPipeline()}} was called with |descriptor|;

                    1. When |pipeline| is ready to be used, [=resolve=] |promise| with |pipeline|.
                </div>
            1. Return |promise|.
        </div>
</dl>

<div algorithm>
    <dfn abstract-op>validating GPURenderPipelineDescriptor</dfn>(descriptor, device)
        **Arguments:**
            - {{GPURenderPipelineDescriptor}} |descriptor|
            - {{GPUDevice}} |device|

        Return `true` if all of the following conditions are satisfied:

            - [$validating GPUProgrammableStage$]({{GPUShaderStage/VERTEX}},
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}},
                |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
            - [$validating GPUVertexState$](|device|, |descriptor|.{{GPURenderPipelineDescriptor/vertex}},
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}}) succeeds.
            - If |descriptor|.{{GPURenderPipelineDescriptor/fragment}} is not `null`:
                - [$validating GPUProgrammableStage$]({{GPUShaderStage/FRAGMENT}},
                    |descriptor|.{{GPURenderPipelineDescriptor/fragment}},
                    |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
                - [$validating GPUFragmentState$](|descriptor|.{{GPURenderPipelineDescriptor/fragment}}) succeeds.
                - If the output SV_Coverage semantics is [=statically used=] by
                    |descriptor|.{{GPURenderPipelineDescriptor/fragment}}:
                    - |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/alphaToCoverageEnabled}} is `false`.
            - [$validating GPUPrimitiveState$](|descriptor|.{{GPURenderPipelineDescriptor/primitive}}) succeeds.
            - if |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}} is not `null`:
                - [$validating GPUDepthStencilState$](|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}, |device|.{{device/[[features]]}}) succeeds.
            - [$validating GPUMultisampleState$](|descriptor|.{{GPURenderPipelineDescriptor/multisample}}) succeeds.
</div>

Issue: validate interface matching rules between VS and FS.

Issue: should we validate that `cullMode` is none for points and lines?

Issue: define what "compatible" means for render target formats.

Issue: need a proper limit for the maximum number of color targets.

### Primitive State ### {#primitive-state}

<script type=idl>
enum GPUPrimitiveTopology {
    "point-list",
    "line-list",
    "line-strip",
    "triangle-list",
    "triangle-strip"
};
</script>

<script type=idl>
dictionary GPUPrimitiveState {
    GPUPrimitiveTopology topology = "triangle-list";
    GPUIndexFormat stripIndexFormat;
    GPUFrontFace frontFace = "ccw";
    GPUCullMode cullMode = "none";
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUPrimitiveState</dfn>(|descriptor|)
        **Arguments:**
            - {{GPUPrimitiveState}} |descriptor|

        Return `true` if all of the following conditions are satisfied:
            - If |descriptor|.{{GPUPrimitiveState/topology}} is:
                <dl class="switch">
                    : {{GPUPrimitiveTopology/"line-strip"}} or
                        {{GPUPrimitiveTopology/"triangle-strip"}}
                    :: |descriptor|.{{GPUPrimitiveState/stripIndexFormat}} is not `undefined`
                    : Otherwise
                    :: |descriptor|.{{GPUPrimitiveState/stripIndexFormat}} is `undefined`
                </dl>
</div>

<script type=idl>
enum GPUFrontFace {
    "ccw",
    "cw"
};
</script>

<script type=idl>
enum GPUCullMode {
    "none",
    "front",
    "back"
};
</script>

### Multisample State ### {#multisample-state}

<script type=idl>
dictionary GPUMultisampleState {
    GPUSize32 count = 1;
    GPUSampleMask mask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUMultisampleState</dfn>(|descriptor|)
        **Arguments:**
            - {{GPUMultisampleState}} |descriptor|

        Return `true` if all of the following conditions are satisfied:
            - If |descriptor|.{{GPUMultisampleState/alphaToCoverageEnabled}} is `true`:
                - |descriptor|.{{GPUMultisampleState/count}} is greater than 1.
</div>

### Fragment State ### {#fragment-state}

<script type=idl>
dictionary GPUFragmentState: GPUProgrammableStage {
    required sequence<GPUColorTargetState> targets;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUFragmentState</dfn>(|descriptor|)
        Return `true` if all of the following conditions are satisfied:

            - |descriptor|.{{GPUFragmentState/targets}}.length is less than or equal to 4.
            - For each |colorState| layout descriptor in the list |descriptor|.{{GPUFragmentState/targets}}:
                - |colorState|.{{GPUColorTargetState/format}} is listed in {#plain-color-formats}
                    with {{GPUTextureUsage/RENDER_ATTACHMENT}} capability.
                - |colorState|.{{GPUColorTargetState/blend}} is either `undefined`,
                    or the |colorState|.{{GPUColorTargetState/format}} is filterable
                    according to the {#plain-color-formats} table.
                - |colorState|.{{GPUColorTargetState/writeMask}} is less than 16.
                - |descriptor|.{{GPUProgrammableStage/module}} contains an output variable
                    that is [=statically used=] by |descriptor|.{{GPUProgrammableStage/entryPoint}},
                    and has a type that is compatible with |colorState|.{{GPUColorTargetState/format}}.
</div>

Issue: define the area of reach for "statically used" things of `GPUProgrammableStage`

### Color Target State ### {#color-target-state}

<script type=idl>
dictionary GPUColorTargetState {
    required GPUTextureFormat format;

    GPUBlendState blend;
    GPUColorWriteFlags writeMask = 0xF;  // GPUColorWrite.ALL
};
</script>

<script type=idl>
dictionary GPUBlendState {
    required GPUBlendComponent color;
    required GPUBlendComponent alpha;
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUColorWriteFlags;
interface GPUColorWrite {
    const GPUFlagsConstant RED   = 0x1;
    const GPUFlagsConstant GREEN = 0x2;
    const GPUFlagsConstant BLUE  = 0x4;
    const GPUFlagsConstant ALPHA = 0x8;
    const GPUFlagsConstant ALL   = 0xF;
};
</script>

#### Blend State #### {#blend-state}

<script type=idl>
dictionary GPUBlendComponent {
    GPUBlendFactor srcFactor = "one";
    GPUBlendFactor dstFactor = "zero";
    GPUBlendOperation operation = "add";
};
</script>

<script type=idl>
enum GPUBlendFactor {
    "zero",
    "one",
    "src-color",
    "one-minus-src-color",
    "src-alpha",
    "one-minus-src-alpha",
    "dst-color",
    "one-minus-dst-color",
    "dst-alpha",
    "one-minus-dst-alpha",
    "src-alpha-saturated",
    "blend-color",
    "one-minus-blend-color"
};
</script>

<script type=idl>
enum GPUBlendOperation {
    "add",
    "subtract",
    "reverse-subtract",
    "min",
    "max"
};
</script>

### Depth/Stencil State ### {#depth-stencil-state}

<script type=idl>
dictionary GPUDepthStencilState {
    required GPUTextureFormat format;

    boolean depthWriteEnabled = false;
    GPUCompareFunction depthCompare = "always";

    GPUStencilFaceState stencilFront = {};
    GPUStencilFaceState stencilBack = {};

    GPUStencilValue stencilReadMask = 0xFFFFFFFF;
    GPUStencilValue stencilWriteMask = 0xFFFFFFFF;

    GPUDepthBias depthBias = 0;
    float depthBiasSlopeScale = 0;
    float depthBiasClamp = 0;

    // Enable depth clamping (requires "depth-clamping" feature)
    boolean clampDepth = false;
};
</script>

<script type=idl>
dictionary GPUStencilFaceState {
    GPUCompareFunction compare = "always";
    GPUStencilOperation failOp = "keep";
    GPUStencilOperation depthFailOp = "keep";
    GPUStencilOperation passOp = "keep";
};
</script>

<script type=idl>
enum GPUStencilOperation {
    "keep",
    "zero",
    "replace",
    "invert",
    "increment-clamp",
    "decrement-clamp",
    "increment-wrap",
    "decrement-wrap"
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUDepthStencilState</dfn>(descriptor, features)
    **Arguments:**
        - {{GPUDepthStencilState}} |descriptor|
        - [=list=]&lt;{{GPUFeatureName}}&gt; |features|

    Return `true`, if and only if, all of the following conditions are satisfied:

        - |descriptor|.{{GPUDepthStencilState/format}} is listed in {#depth-formats}.
        - if |descriptor|.{{GPUDepthStencilState/depthWriteEnabled}} is `true` or
            |descriptor|.{{GPUDepthStencilState/depthCompare}} is not {{GPUCompareFunction/"always"}}:
            - |descriptor|.{{GPUDepthStencilState/format}} must have a depth component.
        - if |descriptor|.{{GPUDepthStencilState/stencilFront}} or
            |descriptor|.{{GPUDepthStencilState/stencilBack}} are not default values:
            - |descriptor|.{{GPUDepthStencilState/format}} must have a stencil component.
        - If |descriptor|.{{GPUDepthStencilState/clampDepth}} is `true`:
            - |features| must [=list/contain=] {{GPUFeatureName/"depth-clamping"}}.

    Issue: how can this algorithm support depth/stencil formats that are added in extensions?
</div>

### Vertex State ### {#vertex-state}

<script type=idl>
enum GPUIndexFormat {
    "uint16",
    "uint32"
};
</script>

The index format determines both the data type of index values in a buffer and, when used with
strip primitive topologies ({{GPUPrimitiveTopology/"line-strip"}} or
{{GPUPrimitiveTopology/"triangle-strip"}}) also specifies the primitive restart value. The
<dfn dfn>primitive restart value</dfn> indicates which index value indicates that a new primitive
should be started rather than continuing to construct the triangle strip with the prior indexed
vertices.

{{GPUPrimitiveState}}s that specify a strip primitive topology must specify a
{{GPUPrimitiveState/stripIndexFormat}} so that the [=primitive restart value=] that will be used
is known at pipeline creation time. {{GPUPrimitiveState}}s that specify a list primitive
topology must set {{GPUPrimitiveState/stripIndexFormat}} to `undefined`, and will use the index
format passed to {{GPURenderEncoderBase/setIndexBuffer()}} when rendering.

<table class="data">
  <thead>
    <tr>
      <th>Index format</th>
      <th>Primitive restart value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>{{GPUIndexFormat/"uint16"}}</td>
      <td>0xFFFF</td>
    </tr>
    <tr>
      <td>{{GPUIndexFormat/"uint32"}}</td>
      <td>0xFFFFFFFF</td>
    </tr>
  </tbody>
</table>

#### Vertex Formats #### {#vertex-formats}

The name of the format specifies the data type of the component, the number of
values, and whether the data is normalized.

  * `uchar` = unsigned 8-bit value
  * `char` = signed 8-bit value
  * `ushort` = unsigned 16-bit value
  * `short` = signed 16-bit value
  * `half` = half-precision 16-bit floating point value
  * `float` = 32-bit floating point value
  * `uint` = unsigned 32-bit integer value
  * `int` = signed 32-bit integer value

If no number of values is given in the name, a single value is provided.
If the format has the `-bgra` suffix, it means the values are arranged as
blue, green, red and alpha values.

<script type=idl>
enum GPUVertexFormat {
    "uchar2",
    "uchar4",
    "char2",
    "char4",
    "uchar2norm",
    "uchar4norm",
    "char2norm",
    "char4norm",
    "ushort2",
    "ushort4",
    "short2",
    "short4",
    "ushort2norm",
    "ushort4norm",
    "short2norm",
    "short4norm",
    "half2",
    "half4",
    "float",
    "float2",
    "float3",
    "float4",
    "uint",
    "uint2",
    "uint3",
    "uint4",
    "int",
    "int2",
    "int3",
    "int4"
};
</script>

<script type=idl>
enum GPUInputStepMode {
    "vertex",
    "instance"
};
</script>

<script type=idl>
dictionary GPUVertexState: GPUProgrammableStage {
    sequence<GPUVertexBufferLayout?> buffers = [];
};
</script>

A <dfn dfn>vertex buffer</dfn> is, conceptually, a view into buffer memory as an *array of structures*.
{{GPUVertexBufferLayout/arrayStride}} is the stride, in bytes, between *elements* of that array.
Each element of a vertex buffer is like a *structure* with a memory layout defined by its
{{GPUVertexBufferLayout/attributes}}, which describe the *members* of the structure.

Each {{GPUVertexAttribute}} describes its
{{GPUVertexAttribute/format}} and its
{{GPUVertexAttribute/offset}}, in bytes, within the structure.

Each attribute appears as a separate input in a vertex shader, each bound by a numeric *location*,
which is specified by {{GPUVertexAttribute/shaderLocation}}.
Every location must be unique within the {{GPUVertexState}}.

<script type=idl>
dictionary GPUVertexBufferLayout {
    required GPUSize64 arrayStride;
    GPUInputStepMode stepMode = "vertex";
    required sequence<GPUVertexAttribute> attributes;
};
</script>

<script type=idl>
dictionary GPUVertexAttribute {
    required GPUVertexFormat format;
    required GPUSize64 offset;

    required GPUIndex32 shaderLocation;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUVertexBufferLayout</dfn>(device, descriptor, vertexStage)
    **Arguments:**
        - {{GPUDevice}} |device|
        - {{GPUVertexBufferLayout}} |descriptor|
        - {{GPUProgrammableStage}} |vertexStage|

    Return `true`, if and only if, all of the following conditions are satisfied:

        - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} &le;
            |device|.{{GPUDevice/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}.
        - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} is a multiple of 4.
        - For each attribute |attrib| in the list |descriptor|.{{GPUVertexBufferLayout/attributes}}:
            - If |descriptor|.{{GPUVertexBufferLayout/arrayStride}} is zero:
                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                    |device|.{{GPUDevice/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}.

                Otherwise:
                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                    |descriptor|.{{GPUVertexBufferLayout/arrayStride}}.
            - |attrib|.{{GPUVertexAttribute/offset}} is a multiple of the size of one component of
                |attrib|.{{GPUVertexAttribute/format}}.
        - For every vertex attribute in the shader reflection of |vertexStage|.{{GPUProgrammableStage/module}}
            that is know to be [=statically used=] by |vertexStage|.{{GPUProgrammableStage/entryPoint}},
            there is a corresponding |attrib| element of |descriptor|.{{GPUVertexBufferLayout/attributes}} for which
            all of the following are true:
            - The shader format is |attrib|.{{GPUVertexAttribute/format}}.
            - The shader location is |attrib|.{{GPUVertexAttribute/shaderLocation}}.
</div>

<div algorithm>
    <dfn abstract-op>validating GPUVertexState</dfn>(device, descriptor)
    **Arguments:**
        - {{GPUDevice}} |device|
        - {{GPUVertexState}} |descriptor|

    Return `true`, if and only if, all of the following conditions are satisfied:

        - |descriptor|.{{GPUVertexState/buffers}}.length is less than or equal to
            |device|.{{GPUDevice/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}.
        - Each |vertexBuffer| layout descriptor in the list |descriptor|.{{GPUVertexState/buffers}}
            passes [$validating GPUVertexBufferLayout$](|device|, |vertexBuffer|, |descriptor|)
        - The sum of |vertexBuffer|.{{GPUVertexBufferLayout/attributes}}.length,
            over every |vertexBuffer| in |descriptor|.{{GPUVertexState/buffers}},
            is less than or equal to
            |device|.{{GPUDevice/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}}.
        - Each |attrib| in the union of all {{GPUVertexAttribute}}
            across |descriptor|.{{GPUVertexState/buffers}} has a distinct
            |attrib|.{{GPUVertexAttribute/shaderLocation}} value.

        Issue: are the {{GPUVertexAttribute/shaderLocation}} arbitrary or should they be less than
        {{supported limits/maxVertexAttributes}}?
</div>

# Command Buffers # {#command-buffers}

Command buffers are pre-recorded lists of [=GPU commands=] that can be submitted to a {{GPUQueue}}
for execution. Each <dfn dfn>GPU command</dfn> represents a task to be performed on the GPU, such as
setting state, drawing, copying resources, etc.

## <dfn interface>GPUCommandBuffer</dfn> ## {#command-buffer}

<script type=idl>
interface GPUCommandBuffer {
    readonly attribute Promise<double> executionTime;
};
GPUCommandBuffer includes GPUObjectBase;
</script>

{{GPUCommandBuffer}} has the following attributes:

<dl dfn-type=attribute dfn-for="GPUCommandBuffer">
    : <dfn>executionTime</dfn> of type Promise<{{double}}>, readonly
    ::
        The total time, in seconds, that the GPU took to execute this command buffer.

        Note:
        If {{GPUCommandEncoderDescriptor/measureExecutionTime}} is `true`,
        this resolves after the command buffer executes.
        Otherwise, this rejects with an {{OperationError}}.

        <div class=issue>
            Specify the creation and resolution of the promise.

            In {{GPUCommandEncoder/finish()}}, it should be specified that a
            new promise is created and stored in this attribute.
            The promise starts rejected if {{GPUCommandEncoderDescriptor/measureExecutionTime}}
            is `false`. If the finish() fails, then the promise resolves to 0.

            In {{GPUQueue/submit()}}, it should be specified that (if
            {{GPUCommandEncoderDescriptor/measureExecutionTime}} is set), work
            is issued to read back the execution time, and, when that completes,
            the promise is resolved with that value.
            If the submit() fails, then the promise resolves to 0.
        </div>
</dl>

{{GPUCommandBuffer}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUCommandBuffer">
    : <dfn>\[[command_list]]</dfn> of type [=list=]&lt;[=GPU command=]&gt;.
    ::
        A [=list=] of [=GPU commands=] to be executed on the [=Queue timeline=] when this command
        buffer is submitted.
</dl>

### Creation ### {#command-buffer-creation}

<script type=idl>
dictionary GPUCommandBufferDescriptor : GPUObjectDescriptorBase {
};
</script>


# Command Encoding # {#command-encoding}

## <dfn interface>GPUCommandEncoder</dfn> ## {#command-encoder}

<script type=idl>
interface GPUCommandEncoder {
    GPURenderPassEncoder beginRenderPass(GPURenderPassDescriptor descriptor);
    GPUComputePassEncoder beginComputePass(optional GPUComputePassDescriptor descriptor = {});

    undefined copyBufferToBuffer(
        GPUBuffer source,
        GPUSize64 sourceOffset,
        GPUBuffer destination,
        GPUSize64 destinationOffset,
        GPUSize64 size);

    undefined copyBufferToTexture(
        GPUImageCopyBuffer source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined copyTextureToBuffer(
        GPUImageCopyTexture source,
        GPUImageCopyBuffer destination,
        GPUExtent3D copySize);

    undefined copyTextureToTexture(
        GPUImageCopyTexture source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined pushDebugGroup(USVString groupLabel);
    undefined popDebugGroup();
    undefined insertDebugMarker(USVString markerLabel);

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined resolveQuerySet(
        GPUQuerySet querySet,
        GPUSize32 firstQuery,
        GPUSize32 queryCount,
        GPUBuffer destination,
        GPUSize64 destinationOffset);

    GPUCommandBuffer finish(optional GPUCommandBufferDescriptor descriptor = {});
};
GPUCommandEncoder includes GPUObjectBase;
</script>

{{GPUCommandEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUCommandEncoder">
    : <dfn>\[[command_list]]</dfn> of type [=list=]&lt;[=GPU command=]&gt;.
    ::
        A [=list=] of [=GPU command=] to be executed on the [=Queue timeline=] when the
        {{GPUCommandBuffer}} this encoder produces is submitted.

    : <dfn>\[[state]]</dfn> of type {{encoder state}}.
    ::
        The current state of the {{GPUCommandEncoder}}, initially set to {{encoder state/open}}.

    : <dfn>\[[debug_group_stack]]</dfn> of type [=stack=]&lt;{{USVString}}&gt;.
    ::
        A stack of active debug group labels.
</dl>

Each {{GPUCommandEncoder}} has a current <dfn dfn-type="enum">encoder state</dfn> on the [=Content timeline=]
which may be one of the following:

<dl dfn-type="enum-value" dfn-for="encoder state">
    : "<dfn>open</dfn>"
    ::
        Indicates the {{GPUCommandEncoder}} is available to begin new operations. The {{GPUCommandEncoder/[[state]]}} is
        {{encoder state/open}} any time the {{GPUCommandEncoder}} is [=valid=] and has no active
        {{GPURenderPassEncoder}} or {{GPUComputePassEncoder}}.

    : "<dfn>encoding a render pass</dfn>"
    ::
        Indicates the {{GPUCommandEncoder}} has an active {{GPURenderPassEncoder}}. The
        {{GPUCommandEncoder/[[state]]}} becomes {{encoder state/encoding a render pass}} once
        {{GPUCommandEncoder/beginRenderPass()}} is called sucessfully until {{GPURenderPassEncoder/endPass()}} is called
        on the returned {{GPURenderPassEncoder}}, at which point the {{GPUCommandEncoder/[[state]]}}
        (if the encoder is still valid) reverts to {{encoder state/open}}.

    : "<dfn>encoding a compute pass</dfn>"
    ::
        Indicates the {{GPUCommandEncoder}} has an active {{GPUComputePassEncoder}}.  The
        {{GPUCommandEncoder/[[state]]}} becomes {{encoder state/encoding a compute pass}} once
        {{GPUCommandEncoder/beginComputePass()}} is called sucessfully until {{GPUComputePassEncoder/endPass()}} is
        called on the returned {{GPUComputePassEncoder}}, at which point the {{GPUCommandEncoder/[[state]]}}
        (if the encoder is still valid) reverts to {{encoder state/open}}.

    : "<dfn>closed</dfn>"
    ::
        Indicates the {{GPUCommandEncoder}} is no longer available for any operations. The
        {{GPUCommandEncoder/[[state]]}} becomes {{encoder state/closed}} once {{GPUCommandEncoder/finish()}} is called
        or the {{GPUCommandEncoder}} otherwise becomes [=invalid=].
</dl>

### Creation ### {#command-encoder-creation}

<script type=idl>
dictionary GPUCommandEncoderDescriptor : GPUObjectDescriptorBase {
    boolean measureExecutionTime = false;

    // TODO: reusability flag?
};
</script>

<dl dfn-type=dict-member dfn-for=GPUCommandEncoderDescriptor>
    : <dfn>measureExecutionTime</dfn>
    ::
        Enable measurement of the GPU execution time of the entire command buffer.
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createCommandEncoder(descriptor)</dfn>
    ::
        Creates a {{GPUCommandEncoder}}.

        <div algorithm=GPUDevice.createCommandEncoder>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createCommandEncoder(descriptor)">
                descriptor: Description of the {{GPUCommandEncoder}} to create.
            </pre>

            **Returns:** {{GPUCommandEncoder}}

            Issue: Describe {{GPUDevice/createCommandEncoder()}} algorithm steps.
        </div>
</dl>

## Pass Encoding ## {#command-encoder-pass-encoding}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>beginRenderPass(descriptor)</dfn>
    ::
        Begins encoding a render pass described by |descriptor|.

        <div algorithm=GPUCommandEncoder.beginRenderPass>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/beginRenderPass(descriptor)">
                |descriptor|: Description of the {{GPURenderPassEncoder}} to create.
            </pre>

            **Returns:** {{GPURenderPassEncoder}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                        - |descriptor| meets the
                            [$GPURenderPassDescriptor/GPURenderPassDescriptor Valid Usage$] rules.
                    </div>
                1. Set |this|.{{GPUCommandEncoder/[[state]]}} to {{encoder state/encoding a render pass}}.
                1. For each |colorAttachment| in |descriptor|.{{GPURenderPassDescriptor/colorAttachments}}:
                    1. The [=texture subresource=] seen by |colorAttachment|.{{GPURenderPassColorAttachment/view}}
                        is considered to be used as [=internal usage/attachment=] for the
                        duration of the render pass.
                1. Let |depthStencilAttachment| be |descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}.
                1. If |depthStencilAttachment| is not `null`:
                    1. if |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}} and
                        {{GPURenderPassDepthStencilAttachment/stencilReadOnly}} are set
                        1. The [=texture subresources=] seen by |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}
                            are considered to be used as [=internal usage/attachment-read=] for the duration of the render pass.
                    1. Else, the [=texture subresource=] seen by |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}
                        is considered to be used as [=internal usage/attachment=] for the duration of the render pass.
            </div>

            Issue: specify the behavior of read-only depth/stencil
            Issue: Enqueue attachment loads (with loadOp clear).
        </div>

    : <dfn>beginComputePass(descriptor)</dfn>
    ::
        Begins encoding a compute pass described by |descriptor|.

        <div algorithm=GPUCommandEncoder.beginComputePass>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/beginComputePass(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPUComputePassEncoder}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                    </div>
                1. Set |this|.{{GPUCommandEncoder/[[state]]}} to {{encoder state/encoding a compute pass}}.
            </div>
        </div>
</dl>

## Copy Commands ## {#copy-commands}

### <dfn dictionary>GPUImageDataLayout</dfn> ### {#gpu-image-data-layout}

<script type=idl>
dictionary GPUImageDataLayout {
    GPUSize64 offset = 0;
    GPUSize32 bytesPerRow;
    GPUSize32 rowsPerImage;
};
</script>

A {{GPUImageDataLayout}} is a layout of <dfn dfn>images</dfn> within some linear memory.
It's used when copying data between a [=texture=] and a [=buffer=], or when scheduling a
write into a [=texture=] from the {{GPUQueue}}.

  - For {{GPUTextureDimension/2d}} textures, data is copied between one or multiple contiguous [=images=] and [=array layers=].
  - For {{GPUTextureDimension/3d}} textures, data is copied between one or multiple contiguous [=images=] and depth [=slices=].

Operations that copy between byte arrays and textures always work with rows of [=texel blocks=],
which we'll call <dfn dfn>block row</dfn>s. It's not possible to update only a part of a [=texel block=].

Issue: Define images more precisely. In particular, define them as being comprised of [=texel blocks=].

Issue: Define the exact copy semantics, by reference to common algorithms shared by the copy methods.

<dl dfn-type=dict-member dfn-for=GPUImageDataLayout>
    : <dfn>bytesPerRow</dfn>
    ::
        The stride, in bytes, between the beginning of each [=block row=] and the subsequent [=block row=].

        Required if there are multiple [=block rows=] (i.e. the height or depth is more than one block).

    : <dfn>rowsPerImage</dfn>
    ::
        Number of [=block rows=] per single [=image=] of the [=texture=].
        {{GPUImageDataLayout/rowsPerImage}} &times;
        {{GPUImageDataLayout/bytesPerRow}} is the stride, in bytes, between the beginning of each [=image=] of data and the subsequent [=image=].

        Required if there are multiple [=images=] (i.e. the depth is more than one).
</dl>

### <dfn dictionary>GPUImageCopyBuffer</dfn> ### {#gpu-image-copy-buffer}

<script type=idl>
dictionary GPUImageCopyBuffer : GPUImageDataLayout {
    required GPUBuffer buffer;
};
</script>

A {{GPUImageCopyBuffer}} contains the actual [=texture=] data placed in a [=buffer=] according to {{GPUImageDataLayout}}.

<div algorithm class=validusage>
<dfn abstract-op>validating GPUImageCopyBuffer</dfn>

  **Arguments:**
    - {{GPUImageCopyBuffer}} |imageCopyBuffer|

  **Returns:** {{boolean}}

  Return `true` if and only if all of the following conditions are satisfied:
    - |imageCopyBuffer|.{{GPUImageCopyBuffer/buffer}} must be a [=valid=] {{GPUBuffer}}.
    - |imageCopyBuffer|.{{GPUImageDataLayout/bytesPerRow}} must be a multiple of 256.

</div>

### <dfn dictionary>GPUImageCopyTexture</dfn> ### {#gpu-image-copy-texture}

<script type=idl>
dictionary GPUImageCopyTexture {
    required GPUTexture texture;
    GPUIntegerCoordinate mipLevel = 0;
    GPUOrigin3D origin = {};
    GPUTextureAspect aspect = "all";
};
</script>

A {{GPUImageCopyTexture}} is a view of a sub-region of one or multiple contiguous [=texture subresources=] with the initial
offset {{GPUOrigin3D}} in texels, used when copying data from or to a {{GPUTexture}}.

  * {{GPUImageCopyTexture/origin}}: If unspecified, defaults to `[0, 0, 0]`.

<div algorithm class=validusage>
<dfn abstract-op>validating GPUImageCopyTexture</dfn>

  **Arguments:**
    - {{GPUImageCopyTexture}} |imageCopyTexture|
    - {{GPUExtent3D}} |copySize|

  **Returns:** {{boolean}}

  Let:
  - |blockWidth| be the [=texel block width=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}.
  - |blockHeight| be the [=texel block height=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}.

  Return `true` if and only if all of the following conditions apply:
  - |imageCopyTexture|.{{GPUImageCopyTexture/texture}} must be a [=valid=] {{GPUTexture}}.
  - |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}} must be less than the {{GPUTexture/[[mipLevelCount]]}} of
    |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.
  - |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/x=] must be a multiple of |blockWidth|.
  - |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/y=] must be a multiple of |blockHeight|.
  - The [=imageCopyTexture subresource size=] of |imageCopyTexture| is equal to |copySize| if either of
      the following conditions is true:
        - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}} is a depth-stencil format.
        - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[sampleCount]]}} is greater than 1.

</div>

Issue(gpuweb/gpuweb#69): Define the copies with {{GPUTextureDimension/1d}} and {{GPUTextureDimension/3d}} textures.

### <dfn dictionary>GPUImageCopyImageBitmap</dfn> ### {#gpu-image-copy-image-bitmap-copy}

<script type=idl>
dictionary GPUImageCopyImageBitmap {
    required ImageBitmap imageBitmap;
    GPUOrigin2D origin = {};
};
</script>

  * {{GPUImageCopyImageBitmap/origin}}: If unspecified, defaults to `[0, 0]`.

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)</dfn>
    ::
        Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of a
        {{GPUBuffer}} to a sub-region of another {{GPUBuffer}}.

        <div algorithm=GPUCommandEncoder.copyBufferToBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)">
                |source|: The {{GPUBuffer}} to copy from.
                |sourceOffset|: Offset in bytes into |source| to begin copying from.
                |destination|: The {{GPUBuffer}} to copy to.
                |destinationOffset|: Offset in bytes into |destination| to place the copied data.
                |size|: Bytes to copy.
            </pre>

            **Returns:** {{undefined}}

            If any of the following conditions are unsatisfied, generate a validation error and stop.
            <div class=validusage>
                - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                - |source| is [$valid to use with$] |this|.
                - |destination| is [$valid to use with$] |this|.
                - |source|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/COPY_SRC}}.
                - |destination|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/COPY_DST}}.
                - |size| is a multiple of 4.
                - |sourceOffset| is a multiple of 4.
                - |destinationOffset| is a multiple of 4.
                - (|sourceOffset| + |size|) does not overflow a {{GPUSize64}}.
                - (|destinationOffset| + |size|) does not overflow a {{GPUSize64}}.
                - |source|.{{GPUBuffer/[[size]]}} is greater than or equal to (|sourceOffset| + |size|).
                - |destination|.{{GPUBuffer/[[size]]}} is greater than or equal to (|destinationOffset| + |size|).
                - |source| and |destination| are not the same {{GPUBuffer}}.
            </div>

            Issue(gpuweb/gpuweb#21): Define the state machine for GPUCommandEncoder.

            Issue(gpuweb/gpuweb#69): figure out how to handle overflows in the spec.
        </div>
</dl>

### Copy Between Buffer and Texture ### {#copy-between-buffer-texture}

WebGPU provides {{GPUCommandEncoder/copyBufferToTexture()}} for buffer-to-texture copies and
{{GPUCommandEncoder/copyTextureToBuffer()}} for texture-to-buffer copies.

The following definitions and validation rules apply to both {{GPUCommandEncoder/copyBufferToTexture()}}
and {{GPUCommandEncoder/copyTextureToBuffer()}}.

[=imageCopyTexture subresource size=] and [=Valid Texture Copy Range=] also applies to
{{GPUCommandEncoder/copyTextureToTexture()}}.

<div algorithm="imageCopyTexture subresource size">

<dfn dfn>imageCopyTexture subresource size</dfn>

  **Arguments:**
    - {{GPUImageCopyTexture}} |imageCopyTexture|

  **Returns:** {{GPUExtent3D}}

  The [=imageCopyTexture subresource size=] of |imageCopyTexture| is calculated as follows:

  Its [=Extent3D/width=], [=Extent3D/height=] and [=Extent3D/depth=] are the width, height, and depth, respectively,
  of the [=physical size=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}} [=subresource=] at [=mipmap level=]
  |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}.

</div>

Issue: define this as an algorithm with (texture, mipmapLevel) parameters and use the call syntax instead of referring to the definition by label.

<div algorithm>
    <dfn abstract-op>validating linear texture data</dfn>(layout, byteSize, format, copyExtent)

    **Arguments:**
    : {{GPUImageDataLayout}} |layout|
    :: Layout of the linear texture data.
    : {{GPUSize64}} |byteSize|
    :: Total size of the linear data, in bytes.
    : {{GPUTextureFormat}} |format|
    :: Format of the texture.
    : {{GPUExtent3D}} |copyExtent|
    :: Extent of the texture to copy.

    1. Let |blockWidth|, |blockHeight|, and |blockSize| be the
        [=texel block width=], [=texel block height|height=], and
        [=texel block size|size=] of |format|.

    1. It is assumed that |copyExtent|.[=Extent3D/width=] is a multiple of |blockWidth|
        and |copyExtent|.[=Extent3D/height=] is a multiple of |blockHeight|. Let:
            - |widthInBlocks| be |copyExtent|.[=Extent3D/width=] &divide; |blockWidth|.
            - |heightInBlocks| be |copyExtent|.[=Extent3D/height=] &divide; |blockHeight|.
            - |bytesInLastRow| be |blockSize| &times; |widthInBlocks|.

    1. Fail if the following conditions are not satisfied:
        <div class=validusage>
            - If |heightInBlocks| &gt; 1,
                |layout|.{{GPUImageDataLayout/bytesPerRow}} must be specified.
            - If |copyExtent|.[=Extent3D/depth=] &gt; 1,
                |layout|.{{GPUImageDataLayout/bytesPerRow}} and
                |layout|.{{GPUImageDataLayout/rowsPerImage}} must be specified.
            - If specified, |layout|.{{GPUImageDataLayout/bytesPerRow}}
                must be greater than or equal to |bytesInLastRow|.
            - If specified, |layout|.{{GPUImageDataLayout/rowsPerImage}}
                must be greater than or equal to |heightInBlocks|.
        </div>

    1. Let |requiredBytesInCopy| be 0.

    1. If |copyExtent|.[=Extent3D/depth=] &gt; 1:
        1. Let |bytesPerImage| be
            |layout|.{{GPUImageDataLayout/bytesPerRow}} &times;
            |layout|.{{GPUImageDataLayout/rowsPerImage}}.
        1. Let |bytesBeforeLastImage| be
            |bytesPerImage| &times; (|copyExtent|.[=Extent3D/depth=] &minus; 1).
        1. Add |bytesBeforeLastImage| to |requiredBytesInCopy|.

    1. If |copyExtent|.[=Extent3D/depth=] &gt; 0:

        1. If |heightInBlocks| &gt; 1, add
            |layout|.{{GPUImageDataLayout/bytesPerRow}} &times;
            (|heightInBlocks| &minus; 1)
            to |requiredBytesInCopy|.

        1. If |heightInBlocks| &gt; 0, add
            |bytesInLastRow| to |requiredBytesInCopy|.

    1. Fail if the following conditions are not satisfied:
        <div class=validusage>
            - |layout|.{{GPUImageDataLayout/offset}} + |requiredBytesInCopy| &le; |byteSize|.
        </div>
</div>

<div algorithm class=validusage>

<dfn dfn>Valid Texture Copy Range</dfn>

Given a {{GPUImageCopyTexture}} |imageCopyTexture| and a {{GPUExtent3D}} |copySize|, let
  - |blockWidth| be the [=texel block width=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}.
  - |blockHeight| be the [=texel block height=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}.

The following validation rules apply:

  - If the {{GPUTexture/[[dimension]]}} of |imageCopyTexture|.{{GPUImageCopyTexture/texture}} is
    {{GPUTextureDimension/1d}}:
    - Both |copySize|.[=Extent3D/height=] and [=Extent3D/depth=] must be 1.
  - If the {{GPUTexture/[[dimension]]}} of |imageCopyTexture|.{{GPUImageCopyTexture/texture}} is
    {{GPUTextureDimension/2d}}:
     -  (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/x=] + |copySize|.[=Extent3D/width=]),
        (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/y=] + |copySize|.[=Extent3D/height=]), and
        (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/z=] + |copySize|.[=Extent3D/depth=])
        must be less than or equal to the
        [=Extent3D/width=], [=Extent3D/height=], and [=Extent3D/depth=], respectively,
        of the [=imageCopyTexture subresource size=] of |imageCopyTexture|.
  - |copySize|.[=Extent3D/width=] must be a multiple of |blockWidth|.
  - |copySize|.[=Extent3D/height=] must be a multiple of |blockHeight|.

</div>

Issue(gpuweb/gpuweb#69): Define the copies with {{GPUTextureDimension/1d}} and
{{GPUTextureDimension/3d}} textures.

Issue(gpuweb/gpuweb#537): Additional restrictions on rowsPerImage if needed.

Issue(gpuweb/gpuweb#652): Define the copies with {{GPUTextureFormat/"depth24plus"}},
{{GPUTextureFormat/"depth24plus-stencil8"}}, and {{GPUTextureFormat/"stencil8"}}.

Issue: convert "Valid Texture Copy Range" into an algorithm with parameters, similar to "validating linear texture data"

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToTexture(source, destination, copySize)</dfn>
    ::
        Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of a
        {{GPUBuffer}} to a sub-region of one or multiple continuous [=texture subresources=].

        <div algorithm=GPUCommandEncoder.copyBufferToTexture>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyBufferToTexture(source, destination, copySize)">
                |source|: Combined with |copySize|, defines the region of the source buffer.
                |destination|: Combined with |copySize|, defines the region of the destination [=texture subresource=].
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            If any of the following conditions are unsatisfied, generate a validation error and stop.
            <div class=validusage>
                - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                - [$validating GPUImageCopyBuffer$](|source|) returns `true`.
                - |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[usage]]}} contains
                    {{GPUBufferUsage/COPY_SRC}}.
                - [$validating GPUImageCopyTexture$](|destination|, |copySize|) returns `true`.
                - |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[textureUsage]]}} contains
                    {{GPUTextureUsage/COPY_DST}}.
                - |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[sampleCount]]}} is 1.
                - If |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}} is a depth-stencil format:
                    - |destination|.{{GPUImageCopyTexture/aspect}} must refer to a single copyable aspect of
                        |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}.
                        See [[#depth-formats|depth-formats]].
                - [=Valid Texture Copy Range=] applies to |destination| and |copySize|.
                - |source|.{{GPUImageDataLayout/offset}} is a multiple of the [=texel block size=]
                    of |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}.
                - [$validating linear texture data$](|source|,
                    |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[size]]}},
                    |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}},
                    |copySize|) succeeds.
            </div>
        </div>

    : <dfn>copyTextureToBuffer(source, destination, copySize)</dfn>
    ::
        Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of one or
        multiple continuous [=texture subresources=]to a sub-region of a {{GPUBuffer}}.

        <div algorithm=GPUCommandEncoder.copyTextureToBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyTextureToBuffer(source, destination, copySize)">
                |source|: Combined with |copySize|, defines the region of the source [=texture subresources=].
                |destination|: Combined with |copySize|, defines the region of the destination buffer.
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            If any of the following conditions are unsatisfied, generate a validation error and stop.
            <div class=validusage>
                - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                - [$validating GPUImageCopyTexture$](|source|, |copySize|) returns `true`.
                - |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[textureUsage]]}} contains
                    {{GPUTextureUsage/COPY_SRC}}.
                - |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[sampleCount]]}} is 1.
                - If |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}} is a depth-stencil format:
                    - |source|.{{GPUImageCopyTexture/aspect}} must refer to a single copyable aspect of
                        |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}.
                        See [[#depth-formats|depth-formats]].
                - [$validating GPUImageCopyBuffer$](|destination|) returns `true`.
                - |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[usage]]}} contains
                    {{GPUBufferUsage/COPY_DST}}.
                - [=Valid Texture Copy Range=] applies to |source| and |copySize|.
                - |destination|.{{GPUImageDataLayout/offset}} is a multiple of the [=texel block size=]
                    of |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}.
                - [$validating linear texture data$](|destination|,
                    |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[size]]}},
                    |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}},
                    |copySize|) succeeds.
            </div>
        </div>

    : <dfn>copyTextureToTexture(source, destination, copySize)</dfn>
    ::
        Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of one
        or multiple contiguous [=texture subresources=] to another sub-region of one or
        multiple continuous [=texture subresources=].

        <div algorithm=GPUCommandEncoder.copyTextureToTexture>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyTextureToTexture(source, destination, copySize)">
                |source|: Combined with |copySize|, defines the region of the source [=texture subresources=].
                |destination|: Combined with |copySize|, defines the region of the destination [=texture subresources=].
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                <div class=validusage>
                    - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                    - [$validating GPUImageCopyTexture$](|source|, |copySize|) returns `true`.
                    - |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[textureUsage]]}} contains
                        {{GPUTextureUsage/COPY_SRC}}.
                    - [$validating GPUImageCopyTexture$](|destination|, |copySize|) returns `true`.
                    - |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[textureUsage]]}} contains
                        {{GPUTextureUsage/COPY_DST}}.
                    - |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[sampleCount]]}} is equal to |destination|.
                        {{GPUImageCopyTexture/texture}}.{{GPUTexture/[[sampleCount]]}}.
                    - |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}} is equal to |destination|.
                        {{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}.
                    - If |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}} is a depth-stencil format:
                        - |source|.{{GPUImageCopyTexture/aspect}} and |destination|.{{GPUImageCopyTexture/aspect}}
                            must both refer to all aspects of |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}
                            and |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}, respectively.
                    - [=Valid Texture Copy Range=] applies to |source| and |copySize|.
                    - [=Valid Texture Copy Range=] applies to |destination| and |copySize|.
                    - The [$set of subresources for texture copy$](|source|, |copySize|) and
                        the [$set of subresources for texture copy$](|destination|, |copySize|) is disjoint.
                </div>
        </div>
</dl>

<div algorithm>
    The <dfn abstract-op>set of subresources for texture copy</dfn>(|imageCopyTexture|, |copySize|)
    is the set containing:

      - If |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[dimension]]}}
        is {{GPUTextureDimension/"2d"}}:
          - For each |arrayLayer| of the |copySize|.[=Extent3D/depth=] [=array layers=]
            starting at |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/z=]:
              - The [=subresource=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}} at
                [=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}} and
                [=array layer=] |arrayLayer|.
      - Otherwise:
          - The [=subresource=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}} at
            [=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}.
</div>

## Debug Markers ## {#command-encoder-debug-markers}

Both command encoders and programmable pass encoders provide methods to apply debug labels to groups
of commands or insert a single label into the command sequence. Debug groups can be nested to create
a hierarchy of labeled commands. These labels may be passed to the native API backends for tooling,
may be used by the user agent's internal tooling, or may be a no-op when such tooling is not
available or applicable.

Debug groups in a {{GPUCommandEncoder}} or {{GPUProgrammablePassEncoder}}
must be well nested.

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>pushDebugGroup(groupLabel)</dfn>
    ::
        Marks the beginning of a labeled group of commands for the {{GPUCommandEncoder}}.

        <div algorithm=GPUCommandEncoder.pushDebugGroup>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/pushDebugGroup(groupLabel)">
                |groupLabel|: The label for the command group.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                - If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                    </div>
                - [=stack/Push=] |groupLabel| onto |this|.{{GPUCommandEncoder/[[debug_group_stack]]}}.
            </div>
        </div>

    : <dfn>popDebugGroup()</dfn>
    ::
        Marks the end of a labeled group of commands for the {{GPUCommandEncoder}}.

        <div algorithm=GPUCommandEncoder.popDebugGroup>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                - If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                        - |this|.{{GPUCommandEncoder/[[debug_group_stack]]}}'s [=stack/size=] is greater than 0.
                    </div>
                - [=stack/Pop=] an entry off |this|.{{GPUCommandEncoder/[[debug_group_stack]]}}.
            </div>
        </div>

    : <dfn>insertDebugMarker(markerLabel)</dfn>
    ::
        Marks the end of a labeled group of commands for the {{GPUCommandEncoder}}.

        <div algorithm=GPUCommandEncoder.insertDebugMarker>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/insertDebugMarker(markerLabel)">
                markerLabel: The label to insert.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                - If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                    </div>
            </div>
        </div>
</dl>

## Queries ## {#command-encoder-queries}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        Writes a timestamp value into |querySet| when all previous commands have completed executing.

        <div algorithm=GPUCommandEncoder.writeTimestamp>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/writeTimestamp(querySet, queryIndex)">
                |querySet|: The query set that will store the timestamp values.
                |queryIndex|: The index of the query in the query set.
            </pre>

            **Returns:** {{undefined}}

            If any of the following conditions are unsatisfied, generate a validation error and stop.
            <div class=validusage>
                - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                - |querySet| is [$valid to use with$] |this|.
                - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}} is {{GPUQueryType/timestamp}}.
                - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}.
            </div>

            Issue: Describe {{GPUCommandEncoder/writeTimestamp()}} algorithm steps.
        </div>

    : <dfn>resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)</dfn>
    ::

        <div algorithm=GPUCommandEncoder.resolveQuerySet>
            **Called on:** {{GPUCommandEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)">
                querySet:
                firstQuery:
                queryCount:
                destination:
                destinationOffset:
            </pre>

            **Returns:** {{undefined}}

            If any of the following conditions are unsatisfied, generate a {{GPUValidationError}} and stop.
            <div class=validusage>
                - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                - |querySet| is [$valid to use with$] |this|.
                - |destination| is [$valid to use with$] |this|.
                - |destination|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/QUERY_RESOLVE}}.
                - |firstQuery| is less than the number of queries in |querySet|.
                - (|firstQuery| + |queryCount|) is less than or equal to the number of queries in |querySet|.
                - |destinationOffset| is a multiple of 8.
                - |destinationOffset| + 8 &times; |queryCount| &le; |destination|.{{GPUBuffer/[[size]]}}.
            </div>

            Issue: Describe {{GPUCommandEncoder/resolveQuerySet()}} algorithm steps.
        </div>
</dl>

## Finalization ## {#command-encoder-finalization}

A {{GPUCommandBuffer}} containing the commands recorded by the {{GPUCommandEncoder}} can be created
by calling {{GPUCommandEncoder/finish()}}. Once {{GPUCommandEncoder/finish()}} has been called the
command encoder can no longer be used.

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        Completes recording of the commands sequence and returns a corresponding {{GPUCommandBuffer}}.

        <div algorithm=GPUCommandEncoder.finish>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/finish(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPUCommandBuffer}}

            1. Let |commandBuffer| be a new {{GPUCommandBuffer}}.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied, generate a validation
                        error and stop.
                        <div class=validusage>
                            - |this| is [=valid=].
                            - |this|.{{GPUCommandEncoder/[[debug_group_stack]]}}'s [=stack/size=] is 0.
                            - |this|.{{GPUCommandEncoder/[[state]]}} is {{encoder state/open}}.
                            - Every [=usage scope=] contained in |this| satisfies the [=usage scope validation=].
                        </div>

                    1. Set |this|.{{GPUCommandEncoder/[[state]]}} to {{encoder state/closed}}.
                    1. Let |commandBuffer|.{{GPUCommandBuffer/[[command_list]]}} be a [=list/clone=]
                        of |this|.{{GPUCommandEncoder/[[command_list]]}}.
                </div>

            1. Return |commandBuffer|.
        </div>
</dl>

# Programmable Passes # {#programmable-passes}

<script type=idl>

interface mixin GPUProgrammablePassEncoder {
    undefined setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      optional sequence<GPUBufferDynamicOffset> dynamicOffsets = []);

    undefined setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      Uint32Array dynamicOffsetsData,
                      GPUSize64 dynamicOffsetsDataStart,
                      GPUSize32 dynamicOffsetsDataLength);

    undefined pushDebugGroup(USVString groupLabel);
    undefined popDebugGroup();
    undefined insertDebugMarker(USVString markerLabel);
};
</script>

{{GPUProgrammablePassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUProgrammablePassEncoder">
    : <dfn>\[[command_encoder]]</dfn> of type {{GPUCommandEncoder}}.
    ::
        The {{GPUCommandEncoder}} that created this programmable pass.

    : <dfn>\[[debug_group_stack]]</dfn> of type [=stack=]&lt;{{USVString}}&gt;.
    ::
        A stack of active debug group labels.

    : <dfn>\[[bind_groups]]</dfn>, of type [=ordered map=]&lt;{{GPUIndex32}}, {{GPUBindGroup}}&gt;
    ::
        The current {{GPUBindGroup}} for each index, initially empty.
</dl>

## Bind Groups ## {#programmable-passes-bind-groups}

<dl dfn-type=method dfn-for=GPUProgrammablePassEncoder>
    : <dfn>setBindGroup(index, bindGroup, dynamicOffsets)</dfn>
    ::
        Sets the current {{GPUBindGroup}} for the given index.

        <div algorithm=GPUProgrammablePassEncoder.setBindGroup>
            **Called on:** {{GPUProgrammablePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)">
                |index|: The index to set the bind group at.
                |bindGroup|: Bind group to use for subsequent render or compute commands.

                <!--The overload appears to be confusing bikeshed, and it ends up expecting this to
                define the arguments for the 5-arg variant of the method, despite the "for"
                explicitly pointing at the 3-arg variant.-->
                <!--|dynamicOffsets|: Array containing buffer offsets in bytes for each entry in
                    |bindGroup| marked as {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}.-->
            </pre>

            Issue: Resolve bikeshed conflict when using `argumentdef` with overloaded functions that prevents us from
                defining |dynamicOffsets|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |bindGroup| is [$valid to use with$] |this|.
                        - |index| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}.
                        - |dynamicOffsets|.length is
                            |bindGroup|.{{GPUBindGroup/[[layout]]}}.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}}.

                        - [$Iterate over each dynamic binding offset$] in |bindGroup| and
                            run the following steps for each |bufferBinding|, |minBindingSize|,
                            and |dynamicOffsetIndex|:

                            - Let |bufferDynamicOffset| be |dynamicOffsets|[|dynamicOffsetIndex|].
                            - |bufferBinding|.{{GPUBufferBinding/offset}} + |bufferDynamicOffset| +
                                |minBindingSize| &le;
                                |bufferBinding|.{{GPUBufferBinding/buffer}}.{{GPUBuffer/[[size]]}}.
                    </div>
                1. Set |this|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index|] to be |bindGroup|.
            </div>
        </div>

    : <dfn>setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)</dfn>
    ::
        Sets the current {{GPUBindGroup}} for the given index, specifying dynamic offsets as a subset
        of a {{Uint32Array}}.

        <div algorithm=GPUProgrammablePassEncoder.setBindGroup2>
            **Called on:** {{GPUProgrammablePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)">
                |index|: The index to set the bind group at.
                |bindGroup|: Bind group to use for subsequent render or compute commands.
                |dynamicOffsetsData|: Array containing buffer offsets in bytes for each entry in
                    |bindGroup| marked as {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}.
                |dynamicOffsetsDataStart|: Offset in elements into |dynamicOffsetsData| where the
                    buffer offset data begins.
                |dynamicOffsetsDataLength|: Number of buffer offsets to read from |dynamicOffsetsData|.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |bindGroup| is [$valid to use with$] |this|.
                        - |index| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}.
                        - |dynamicOffsetsDataLength| is
                            |bindGroup|.{{GPUBindGroup/[[layout]]}}.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}}.
                        - |dynamicOffsetsDataStart| + |dynamicOffsetsDataLength| &le; |dynamicOffsetsData|.length.

                        - [$Iterate over each dynamic binding offset$] in |bindGroup| and
                            run the following steps for each |bufferBinding|, |minBindingSize|,
                            and |dynamicOffsetIndex|:

                            - Let |bufferDynamicOffset| be
                                |dynamicOffsetsData|[|dynamicOffsetIndex| + |dynamicOffsetsDataStart|].
                            - |bufferBinding|.{{GPUBufferBinding/offset}} + |bufferDynamicOffset| +
                                |minBindingSize| &le;
                                |bufferBinding|.{{GPUBufferBinding/buffer}}.{{GPUBuffer/[[size]]}}.
                    </div>
                1. Set |this|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index|] to be |bindGroup|.
            </div>
        </div>
</dl>

<div algorithm>
    To <dfn abstract-op>Iterate over each dynamic binding offset</dfn> in a given {{GPUBindGroup}} |bindGroup|
    with a given list of |steps| to be executed for each dynamic offset:

    1. Let |dynamicOffsetIndex| be `0`.
    1. Let |layout| be |bindGroup|.{{GPUBindGroup/[[layout]]}}.
    1. For each {{GPUBindGroupEntry}} |entry| in |bindGroup|.{{GPUBindGroup/[[entries]]}}:
        1. Let |bindingDescriptor| be the {{GPUBindGroupLayoutEntry}} at
            |layout|.{{GPUBindGroupLayout/[[entryMap]]}}[|entry|.{{GPUBindGroupEntry/binding}}]:
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}} is not `undefined` and
            |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`:
            1. Let |bufferBinding| be |entry|.{{GPUBindGroupEntry/resource}}.
            1. Let |minBindingSize| be |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}.
            1. Call |steps| with |bufferBinding|, |minBindingSize|, and |dynamicOffsetIndex|.
            1. Let |dynamicOffsetIndex| be |dynamicOffsetIndex| + `1`
</div>

<div algorithm>
    <dfn abstract-op>Validate encoder bind groups</dfn>(encoder, pipeline)

    **Arguments:**
    : {{GPUProgrammablePassEncoder}} |encoder|
    :: Encoder who's bind groups are being validated.
    : {{GPUPipelineBase}} |pipeline|
    :: Pipline to validate |encoder|s bind groups are compatible with.

    If any of the following conditions are unsatisfied, return `false`:
        <div class=validusage>
            - |pipeline| must not be `null`.
            - For each pair of ({{GPUIndex32}} |index|, {{GPUBindGroupLayout}} |bindGroupLayout|) in
                |pipeline|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}.
                - Let |bindGroup| be |encoder|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index|].
                - |bindGroup| must not be `null`.
                - |bindGroup|.{{GPUBindGroup/[[layout]]}} must be [=group-equivalent=] with |bindGroupLayout|.

            Issue: Check buffer bindings against `minBindingSize` if present.
        </div>

    Otherwise return `true`.
</div>

## Debug Markers ## {#programmable-passes-debug-markers}

Debug marker methods for programmable pass encoders provide the same functionality as
[[#command-encoder-debug-markers|command encoder debug markers]] while recording a programmable
pass.

<dl dfn-type=method dfn-for=GPUProgrammablePassEncoder>
    : <dfn>pushDebugGroup(groupLabel)</dfn>
    ::
        Marks the beginning of a labeled group of commands for the {{GPUProgrammablePassEncoder}}.

        <div algorithm=GPUProgrammablePassEncoder.pushDebugGroup>
            **Called on:** {{GPUProgrammablePassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/pushDebugGroup(groupLabel)">
                |groupLabel|: The label for the command group.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. [=stack/Push=] |groupLabel| onto |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}.
            </div>
        </div>

    : <dfn>popDebugGroup()</dfn>
    ::
        Marks the end of a labeled group of commands for the {{GPUProgrammablePassEncoder}}.

        <div algorithm=GPUProgrammablePassEncoder.popDebugGroup>
            **Called on:** {{GPUProgrammablePassEncoder}} |this|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}'s [=stack/size=] is greater than 0.
                    </div>
                1. [=stack/Pop=] an entry off of |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}.
            </div>
        </div>

    : <dfn>insertDebugMarker(markerLabel)</dfn>
    ::
        Inserts a single debug marker label into the {{GPUProgrammablePassEncoder}}'s commands sequence.

        <div algorithm=GPUProgrammablePassEncoder.insertDebugMarker>
            **Called on:** {{GPUProgrammablePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/insertDebugMarker(markerLabel)">
                markerLabel: The label to insert.
            </pre>

            **Returns:** {{undefined}}
        </div>
</dl>

# Compute Passes # {#compute-passes}

## <dfn interface>GPUComputePassEncoder</dfn> ## {#compute-pass-encoder}

<script type=idl>
interface GPUComputePassEncoder {
    undefined setPipeline(GPUComputePipeline pipeline);
    undefined dispatch(GPUSize32 x, optional GPUSize32 y = 1, optional GPUSize32 z = 1);
    undefined dispatchIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);

    undefined beginPipelineStatisticsQuery(GPUQuerySet querySet, GPUSize32 queryIndex);
    undefined endPipelineStatisticsQuery();

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined endPass();
};
GPUComputePassEncoder includes GPUObjectBase;
GPUComputePassEncoder includes GPUProgrammablePassEncoder;
</script>

{{GPUComputePassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUComputePassEncoder">
    : <dfn>\[[pipeline]]</dfn>, of type {{GPUComputePipeline}}
    ::
        The current {{GPUComputePipeline}}, initially `null`.
</dl>

### Creation ### {#compute-pass-encoder-creation}

<script type=idl>
dictionary GPUComputePassDescriptor : GPUObjectDescriptorBase {
};
</script>

### Dispatch ### {#compute-pass-encoder-dispatch}

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        Sets the current {{GPUComputePipeline}}.

        <div algorithm="GPUComputePassEncoder.setPipeline">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/setPipeline(pipeline)">
                |pipeline|: The compute pipeline to use for subsequent dispatch commands.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |pipeline| is [$valid to use with$] |this|.
                    </div>
                1. Set |this|.{{GPUComputePassEncoder/[[pipeline]]}} to be |pipeline|.
            </div>
        </div>

    : <dfn>dispatch(x, y, z)</dfn>
    ::
        Dispatch work to be performed with the current {{GPUComputePipeline}}.

        <div algorithm="GPUComputePassEncoder.dispatch">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/dispatch(x, y, z)">
                |x|: X dimension of the grid of workgroups to dispatch.
                |y|: Y dimension of the grid of workgroups to dispatch.
                |z|: Z dimension of the grid of workgroups to dispatch.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - [$Validate encoder bind groups$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})
                            is `true`.
                    </div>

                1. [=list/Append=] a [=GPU command=] to
                    |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandEncoder/[[command_list]]}}
                    that captures the {{GPUComputePassEncoder}} state of |this| as |passState| and,
                    when executed, issues the following steps on the appropriate [=Queue timeline=]:
                    <div class=queue-timeline>
                        1. Dispatch a grid of workgroups with dimensions [|x|, |y|, |z|] with
                            |passState|.{{GPUComputePassEncoder/[[pipeline]]}} using
                            |passState|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}.
                    </div>
            </div>
        </div>

    : <dfn>dispatchIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        Dispatch work to be performed with the current {{GPUComputePipeline}} using parameters read
        from a {{GPUBuffer}}.

        The <dfn dfn for=>indirect dispatch parameters</dfn> encoded in the buffer must be a tightly
        packed block of **three 32-bit unsigned integer values (12 bytes total)**, given in the same
        order as the arguments for {{GPUComputePassEncoder/dispatch()}}. For example:

        ```js
        let dispatchIndirectParameters = new Uint32Array(3);
        dispatchIndirectParameters[0] = x;
        dispatchIndirectParameters[1] = y;
        dispatchIndirectParameters[2] = z;
        ```

        <div algorithm="GPUComputePassEncoder.dispatchIndirect">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/dispatchIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: Buffer containing the [=indirect dispatch parameters=].
                |indirectOffset|: Offset in bytes into |indirectBuffer| where the dispatch data begins.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - [$Validate encoder bind groups$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})
                            is `true`.
                        - |indirectBuffer| is [$valid to use with$] |this|.
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect dispatch parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}.
                        - |indirectOffset| is a multiple of 4.
                    </div>
                1. Add |indirectBuffer| to the [=usage scope=] as {{GPUBufferUsage/INDIRECT}}.
            </div>
        </div>
</dl>

### Queries ### {#compute-pass-encoder-queries}

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>beginPipelineStatisticsQuery(querySet, queryIndex)</dfn>
    ::

        <div algorithm="GPUComputePassEncoder.beginPipelineStatisticsQuery">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/beginPipelineStatisticsQuery(querySet, queryIndex)">
                querySet:
                queryIndex:
            </pre>

            **Returns:** {{undefined}}

            Issue: Describe {{GPUComputePassEncoder/beginPipelineStatisticsQuery()}} algorithm steps.
        </div>

    : <dfn>endPipelineStatisticsQuery()</dfn>
    ::

        <div algorithm="GPUComputePassEncoder.endPipelineStatisticsQuery">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Returns:** {{undefined}}

            Issue: Describe {{GPUComputePassEncoder/endPipelineStatisticsQuery()}} algorithm steps.
        </div>

    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        Writes a timestamp value into |querySet| when all previous commands have completed executing.

        <div algorithm="GPUComputePassEncoder.writeTimestamp">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/writeTimestamp(querySet, queryIndex)">
                |querySet|: The query set that will store the timestamp values.
                |queryIndex|: The index of the query in the query set.
            </pre>

            **Returns:** {{undefined}}

            If any of the following conditions are unsatisfied, generate a validation error and stop.
            <div class=validusage>
                - |querySet| is [$valid to use with$] |this|.
                - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}} is {{GPUQueryType/timestamp}}.
                - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}.
            </div>

            Issue: Describe {{GPUComputePassEncoder/writeTimestamp()}} algorithm steps.
        </div>
</dl>

### Finalization ### {#compute-pass-encoder-finalization}

The compute pass encoder can be ended by calling {{GPUComputePassEncoder/endPass()}} once the user
has finished recording commands for the pass. Once {{GPUComputePassEncoder/endPass()}} has been
called the compute pass encoder can no longer be used.

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>endPass()</dfn>
    ::
        Completes recording of the compute pass commands sequence.

        <div algorithm="GPUComputePassEncoder.endPass">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}'s [=stack/size=] is 0.

                        Issue: Add remaining validation.
                    </div>
            </div>
        </div>
</dl>

# Render Passes # {#render-passes}

## <dfn interface>GPURenderPassEncoder</dfn> ## {#render-pass-encoder}

<script type=idl>
interface mixin GPURenderEncoderBase {
    undefined setPipeline(GPURenderPipeline pipeline);

    undefined setIndexBuffer(GPUBuffer buffer, GPUIndexFormat indexFormat, optional GPUSize64 offset = 0, optional GPUSize64 size = 0);
    undefined setVertexBuffer(GPUIndex32 slot, GPUBuffer buffer, optional GPUSize64 offset = 0, optional GPUSize64 size = 0);

    undefined draw(GPUSize32 vertexCount, optional GPUSize32 instanceCount = 1,
              optional GPUSize32 firstVertex = 0, optional GPUSize32 firstInstance = 0);
    undefined drawIndexed(GPUSize32 indexCount, optional GPUSize32 instanceCount = 1,
                     optional GPUSize32 firstIndex = 0,
                     optional GPUSignedOffset32 baseVertex = 0,
                     optional GPUSize32 firstInstance = 0);

    undefined drawIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
    undefined drawIndexedIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
};

interface GPURenderPassEncoder {
    undefined setViewport(float x, float y,
                     float width, float height,
                     float minDepth, float maxDepth);

    undefined setScissorRect(GPUIntegerCoordinate x, GPUIntegerCoordinate y,
                        GPUIntegerCoordinate width, GPUIntegerCoordinate height);

    undefined setBlendColor(GPUColor color);
    undefined setStencilReference(GPUStencilValue reference);

    undefined beginOcclusionQuery(GPUSize32 queryIndex);
    undefined endOcclusionQuery();

    undefined beginPipelineStatisticsQuery(GPUQuerySet querySet, GPUSize32 queryIndex);
    undefined endPipelineStatisticsQuery();

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined executeBundles(sequence<GPURenderBundle> bundles);
    undefined endPass();
};
GPURenderPassEncoder includes GPUObjectBase;
GPURenderPassEncoder includes GPUProgrammablePassEncoder;
GPURenderPassEncoder includes GPURenderEncoderBase;
</script>

  * In indirect draw calls, the base instance field (inside the indirect
    buffer data) must be set to zero.

{{GPURenderEncoderBase}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPURenderEncoderBase">
    : <dfn>\[[pipeline]]</dfn>, of type {{GPURenderPipeline}}
    ::
        The current {{GPURenderPipeline}}, initially `null`.

    : <dfn>\[[index_buffer]]</dfn>, of type {{GPUBuffer}}
    ::
        The current buffer to read index data from, initially `null`.

    : <dfn>\[[index_format]]</dfn>, of type {{GPUIndexFormat}}
    ::
        The format of the index data in {{GPURenderEncoderBase/[[index_buffer]]}}.

    : <dfn>\[[vertex_buffers]]</dfn>, of type [=ordered map=]&lt;slot, {{GPUBuffer}}&gt;
    ::
        The current {{GPUBuffer}}s to read vertex data from for each slot, initially empty.
</dl>

{{GPURenderPassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPURenderPassEncoder">
    : <dfn>\[[attachment_size]]</dfn>
    ::
        Set to the following extents:
            - `width, height` = the dimensions of the pass's render attachments
</dl>

When a {{GPURenderPassEncoder}} is created, it has the following default state:
  * Viewport:
      * `x, y` = `0.0, 0.0`
      * `width, height` = the dimensions of the pass's render targets
      * `minDepth, maxDepth` = `0.0, 1.0`
  * Scissor rectangle:
      * `x, y` = `0, 0`
      * `width, height` = the dimensions of the pass's render targets

### Creation ### {#render-pass-encoder-creation}

<script type=idl>
dictionary GPURenderPassDescriptor : GPUObjectDescriptorBase {
    required sequence<GPURenderPassColorAttachment> colorAttachments;
    GPURenderPassDepthStencilAttachment depthStencilAttachment;
    GPUQuerySet occlusionQuerySet;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDescriptor>
    : <dfn>colorAttachments</dfn>
    ::
        The set of {{GPURenderPassColorAttachment}} values in this sequence defines which
        color attachments will be output to when executing this render pass.

    : <dfn>depthStencilAttachment</dfn>
    ::
        The {{GPURenderPassDepthStencilAttachment}} value that defines the depth/stencil
        attachment that will be output to and tested against when executing this render pass.

    : <dfn>occlusionQuerySet</dfn>
    ::
        Issue: Describe this dictionary member
</dl>

<div class=validusage dfn-for=GPURenderPassDescriptor>
    <dfn abstract-op>GPURenderPassDescriptor Valid Usage</dfn>

    Given a {{GPURenderPassDescriptor}} |this| the following validation rules apply:

    1. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length must be less than or equal to the
        [=maximum color attachments=].
    1. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length must greater than `0` or
        |this|.{{GPURenderPassDescriptor/depthStencilAttachment}} must not be `null`.
    1. For each |colorAttachment| in |this|.{{GPURenderPassDescriptor/colorAttachments}}:

        1. |colorAttachment| must meet the [$GPURenderPassColorAttachment/GPURenderPassColorAttachment Valid Usage$] rules.

    1. If |this|.{{GPURenderPassDescriptor/depthStencilAttachment}} is not `null`:

        1. |this|.{{GPURenderPassDescriptor/depthStencilAttachment}} must meet the [$GPURenderPassDepthStencilAttachment/GPURenderPassDepthStencilAttachment Valid Usage$] rules.

    1. Each {{GPURenderPassColorAttachment/view}} in |this|.{{GPURenderPassDescriptor/colorAttachments}}
        and |this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}},
        if present, must have all have the same {{GPUTexture/[[sampleCount]]}}.

    1. The dimensions of the [=subresource=]s seen by each {{GPURenderPassColorAttachment/view}} in |this|.{{GPURenderPassDescriptor/colorAttachments}}
        and |this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}},
        if present, must match.

    Issue: Define <dfn for=>maximum color attachments</dfn>

    Issue(gpuweb/gpuweb#503): support for no attachments
</div>

#### Color Attachments #### {#color-attachments}

<script type=idl>
dictionary GPURenderPassColorAttachment {
    required GPUTextureView view;
    GPUTextureView resolveTarget;

    required (GPULoadOp or GPUColor) loadValue;
    GPUStoreOp storeOp = "store";
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassColorAttachment>
    : <dfn>view</dfn>
    ::
        A {{GPUTextureView}} describing the texture [=subresource=] that will be output to for this
        color attachment.

    : <dfn>resolveTarget</dfn>
    ::
        A {{GPUTextureView}} describing the texture [=subresource=] that will receive the resolved
        output for this color attachment if {{GPURenderPassColorAttachment/view}} is
        multisampled.

    : <dfn>loadValue</dfn>
    ::
        If a {{GPULoadOp}}, indicates the load operation to perform on
        {{GPURenderPassColorAttachment/view}} prior to executing the render pass.
        If a {{GPUColor}}, indicates the value to clear {{GPURenderPassColorAttachment/view}}
        to prior to executing the render pass.

    : <dfn>storeOp</dfn>
    ::
        The store operation to perform on {{GPURenderPassColorAttachment/view}}
        after executing the render pass.
</dl>

<div class=validusage dfn-for=GPURenderPassColorAttachment>
    <dfn abstract-op>GPURenderPassColorAttachment Valid Usage</dfn>

    Given a {{GPURenderPassColorAttachment}} |this| the following validation rules
    apply:

    1. |this|.{{GPURenderPassColorAttachment/view}} must have a renderable color format.
    1. |this|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[textureUsage]]}}
        must contain {{GPUTextureUsage/RENDER_ATTACHMENT}}.
    1. |this|.{{GPURenderPassColorAttachment/view}} must be a view of a single [=subresource=].
    1. If |this|.{{GPURenderPassColorAttachment/resolveTarget}} is not `null`:

        1. |this|.{{GPURenderPassColorAttachment/view}} must be multisampled.
        1. |this|.{{GPURenderPassColorAttachment/resolveTarget}} must not be multisampled.
        1. |this|.{{GPURenderPassColorAttachment/resolveTarget}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[textureUsage]]}}
            must contain {{GPUTextureUsage/RENDER_ATTACHMENT}}.
        1. |this|.{{GPURenderPassColorAttachment/resolveTarget}} must be a view of a single [=subresource=].

        1. The dimensions of the [=subresource=]s seen by |this|.{{GPURenderPassColorAttachment/resolveTarget}}
            and |this|.{{GPURenderPassColorAttachment/view}} must match.
        1. |this|.{{GPURenderPassColorAttachment/resolveTarget}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[format]]}}
            must match |this|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[format]]}}.
        1. Issue: Describe any remaining resolveTarget validation

    Issue: Describe the remaining validation rules for this type.
</div>

#### Depth/Stencil Attachments #### {#depth-stencil-attachments}

<script type=idl>
dictionary GPURenderPassDepthStencilAttachment {
    required GPUTextureView view;

    required (GPULoadOp or float) depthLoadValue;
    required GPUStoreOp depthStoreOp;
    boolean depthReadOnly = false;

    required (GPULoadOp or GPUStencilValue) stencilLoadValue;
    required GPUStoreOp stencilStoreOp;
    boolean stencilReadOnly = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDepthStencilAttachment>
    : <dfn>view</dfn>
    ::
        A {{GPUTextureView}} describing the texture [=subresource=] that will be output to
        and read from for this depth/stencil attachment.

    : <dfn>depthLoadValue</dfn>
    ::
        If a {{GPULoadOp}}, indicates the load operation to perform on
        {{GPURenderPassDepthStencilAttachment/view}}'s depth component prior to
        executing the render pass.
        If a `float`, indicates the value to clear {{GPURenderPassDepthStencilAttachment/view}}'s
        depth component to prior to executing the render pass.

    : <dfn>depthStoreOp</dfn>
    ::
        The store operation to perform on {{GPURenderPassDepthStencilAttachment/view}}'s
        depth component after executing the render pass.

    : <dfn>depthReadOnly</dfn>
    ::
        Indicates that the depth component of {{GPURenderPassDepthStencilAttachment/view}}
        is read only.

    : <dfn>stencilLoadValue</dfn>
    ::
        If a {{GPULoadOp}}, indicates the load operation to perform on
        {{GPURenderPassDepthStencilAttachment/view}}'s stencil component prior to
        executing the render pass.
        If a {{GPUStencilValue}}, indicates the value to clear
        {{GPURenderPassDepthStencilAttachment/view}}'s stencil component to prior to
        executing the render pass.

    : <dfn>stencilStoreOp</dfn>
    ::
        The store operation to perform on {{GPURenderPassDepthStencilAttachment/view}}'s
        stencil component after executing the render pass.

    : <dfn>stencilReadOnly</dfn>
    ::
        Indicates that the stencil component of {{GPURenderPassDepthStencilAttachment/view}}
        is read only.
</dl>

<div class=validusage dfn-for=GPURenderPassDepthStencilAttachment>
    <dfn abstract-op>GPURenderPassDepthStencilAttachment Valid Usage</dfn>

    Given a {{GPURenderPassDepthStencilAttachment}} |this| the following validation
    rules apply:

    1. |this|.{{GPURenderPassDepthStencilAttachment/view}} must have a renderable
        depth-and/or-stencil format.
    1. |this|.{{GPURenderPassDepthStencilAttachment/view}} must be a view of a
        single [=texture subresource=].
    1. |this|.{{GPURenderPassDepthStencilAttachment/view}}.{{GPUTexture/[[textureUsage]]}}
        must contain {{GPUTextureUsage/RENDER_ATTACHMENT}}.
    1. |this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}} is `true`,
        |this|.{{GPURenderPassDepthStencilAttachment/depthLoadValue}} must be
        {{GPULoadOp/"load"}} and |this|.{{GPURenderPassDepthStencilAttachment/depthStoreOp}}
        must be {{GPUStoreOp/"store"}}.
    1. |this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}} is `true`,
        |this|.{{GPURenderPassDepthStencilAttachment/stencilLoadValue}} must be
        {{GPULoadOp/"load"}} and |this|.{{GPURenderPassDepthStencilAttachment/stencilStoreOp}}
        must be {{GPUStoreOp/"store"}}.

    Issue: Describe the remaining validation rules for this type.
</div>

#### Load &amp; Store Operations #### {#load-and-store-ops}

<script type=idl>
enum GPULoadOp {
    "load"
};
</script>

<script type=idl>
enum GPUStoreOp {
    "store",
    "clear"
};
</script>

### Drawing ### {#render-pass-encoder-drawing}

<dl dfn-type=method dfn-for=GPURenderEncoderBase>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        Sets the current {{GPURenderPipeline}}.

        <div algorithm="GPURenderEncoderBase.setPipeline">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setPipeline(pipeline)">
                |pipeline|: The render pipeline to use for subsequent drawing commands.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |pipeline| is [$valid to use with$] |this|.

                        Issue: Validate that |pipeline| is compatible with the render pass descriptor.
                    </div>
                1. Set |this|.{{GPURenderEncoderBase/[[pipeline]]}} to be |pipeline|.
            </div>
        </div>

    : <dfn>setIndexBuffer(buffer, indexFormat, offset, size)</dfn>
    ::
        Sets the current index buffer.

        <div algorithm="GPURenderEncoderBase.setIndexBuffer">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setIndexBuffer(buffer, indexFormat, offset, size)">
                |buffer|: Buffer containing index data to use for subsequent drawing commands.
                |indexFormat|: Format of the index data contained in |buffer|.
                |offset|: Offset in bytes into |buffer| where the index data begins.
                |size|: Size in bytes of the index data in |buffer|.
                    If `0`, |buffer|.{{GPUBuffer/[[size]]}} - |offset| is used.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |buffer| is [$valid to use with$] |this|.
                        - |buffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/INDEX}}.
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/[[size]]}}.
                    </div>
                1. Add |buffer| to the [=usage scope=] as [=internal usage/input=].
                1. Set |this|.{{GPURenderEncoderBase/[[index_buffer]]}} to be |buffer|.
                1. Set |this|.{{GPURenderEncoderBase/[[index_format]]}} to be |indexFormat|.
            </div>
        </div>

    : <dfn>setVertexBuffer(slot, buffer, offset, size)</dfn>
    ::
        Sets the current vertex buffer for the given slot.

        <div algorithm="GPURenderEncoderBase.setVertexBuffer">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setVertexBuffer(slot, buffer, offset, size)">
                |slot|: The vertex buffer slot to set the vertex buffer for.
                |buffer|: Buffer containing vertex data to use for subsequent drawing commands.
                |offset|: Offset in bytes into |buffer| where the vertex data begins.
                |size|: Size in bytes of the vertex data in |buffer|.
                    If `0`, |buffer|.{{GPUBuffer/[[size]]}} - |offset| is used.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |buffer| is [$valid to use with$] |this|.
                        - |buffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/VERTEX}}.
                        - |slot| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}.
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/[[size]]}}.
                    </div>
                1. Add |buffer| to the [=usage scope=] as [=internal usage/input=].
                1. Set |this|.{{GPURenderEncoderBase/[[vertex_buffers]]}}[|slot|] to be |buffer|.
            </div>
        </div>

    : <dfn>draw(vertexCount, instanceCount, firstVertex, firstInstance)</dfn>
    ::
        Draws primitives.

        <div algorithm="GPURenderEncoderBase.draw">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/draw(vertexCount, instanceCount, firstVertex, firstInstance)">
                vertexCount: The number of vertices to draw.
                instanceCount: The number of instances to draw.
                firstVertex: Offset into the vertex buffers, in vertices, to begin drawing from.
                firstInstance: First instance to draw.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                <div class=validusage>
                    - It is [$valid to draw$] with |this|.
                </div>
            </div>
        </div>

    : <dfn>drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)</dfn>
    ::
        Draws indexed primitives.

        <div algorithm="GPURenderEncoderBase.drawIndexed">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)">
                indexCount: The number of indices to draw.
                instanceCount: The number of instances to draw.
                firstIndex: Offset into the index buffer, in indices, begin drawing from.
                baseVertex: Added to each index value before indexing into the vertex buffers.
                firstInstance: First instance to draw.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                <div class=validusage>
                    - It is [$valid to draw indexed$] with |this|.
                </div>
            </div>
        </div>

    : <dfn>drawIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        Draws primitives using parameters read from a {{GPUBuffer}}.

        The <dfn dfn for=>indirect draw parameters</dfn> encoded in the buffer must be a tightly
        packed block of **four 32-bit unsigned integer values (16 bytes total)**, given in the same
        order as the arguments for {{GPURenderEncoderBase/draw()}}. For example:

        ```js
        let drawIndirectParameters = new Uint32Array(4);
        drawIndirectParameters[0] = vertexCount;
        drawIndirectParameters[1] = instanceCount;
        drawIndirectParameters[2] = firstVertex;
        drawIndirectParameters[3] = firstInstance;
        ```

        <div algorithm="GPURenderEncoderBase.drawIndirect">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: Buffer containing the [=indirect draw parameters=].
                |indirectOffset|: Offset in bytes into |indirectBuffer| where the drawing data begins.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - It is [$valid to draw$] with |this|.
                        - |indirectBuffer| is [$valid to use with$] |this|.
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect draw parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}.
                        - |indirectOffset| is a multiple of 4.
                    </div>
                1. Add |indirectBuffer| to the [=usage scope=] as [=internal usage/input=].
            </div>
        </div>

    : <dfn>drawIndexedIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        Draws indexed primitives using parameters read from a {{GPUBuffer}}.

        The <dfn dfn for=>indirect drawIndexed parameters</dfn> encoded in the buffer must be a
        tightly packed block of **five 32-bit unsigned integer values (20 bytes total)**, given in
        the same order as the arguments for {{GPURenderEncoderBase/drawIndexed()}}. For example:

        ```js
        let drawIndexedIndirectParameters = new Uint32Array(5);
        drawIndexedIndirectParameters[0] = indexCount;
        drawIndexedIndirectParameters[1] = instanceCount;
        drawIndexedIndirectParameters[2] = firstIndex;
        drawIndexedIndirectParameters[3] = baseVertex;
        drawIndexedIndirectParameters[4] = firstInstance;
        ```

        <div algorithm="GPURenderEncoderBase.drawIndexedIndirect">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndexedIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: Buffer containing the [=indirect drawIndexed parameters=].
                |indirectOffset|: Offset in bytes into |indirectBuffer| where the drawing data begins.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - It is [$valid to draw indexed$] with |this|.
                        - |indirectBuffer| is [$valid to use with$] |this|.
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect drawIndexed parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}.
                        - |indirectOffset| is a multiple of 4.
                    </div>
                1. Add |indirectBuffer| to the [=usage scope=] as [=internal usage/input=].
            </div>
        </div>
</dl>

<div algorithm>
    To determine if it's <dfn abstract-op>valid to draw</dfn> with {{GPURenderEncoderBase}} |encoder|
    run the following steps:

    If any of the following conditions are unsatisfied, return `false`:
        <div class=validusage>
            - [$Validate encoder bind groups$](|encoder|, |encoder|.{{GPURenderEncoderBase/[[pipeline]]}})
                must be `true`.

            - Let |pipelineDescriptor| be |encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.
            - For each {{GPUIndex32}} |slot| `0` to
                |pipelineDescriptor|.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.length:
                - |encoder|.{{GPURenderEncoderBase/[[vertex_buffers]]}}[|slot|] must not be `null`.
        </div>

    Otherwise return `true`.
</div>

<div algorithm>
    To determine if it's <dfn abstract-op>valid to draw indexed</dfn> with {{GPURenderEncoderBase}} |encoder|
    run the following steps:

    If any of the following conditions are unsatisfied, return `false`:
        <div class=validusage>
            - It must be [$valid to draw$] with |encoder|.

            - |encoder|.{{GPURenderEncoderBase/[[index_buffer]]}} must not be `null`.
            - Let |stripIndexFormat| be |encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[strip_index_format]]}}.
            - If |stripIndexFormat| is not `undefined`:
                - |encoder|.{{GPURenderEncoderBase/[[index_format]]}} must be |stripIndexFormat|.
        </div>

    Otherwise return `true`.
</div>

### Rasterization state ### {#render-pass-encoder-rasterization-state}

The {{GPURenderPassEncoder}} has several methods which affect how draw commands are rasterized to
attachments used by this encoder.

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>setViewport(x, y, width, height, minDepth, maxDepth)</dfn>
    ::
        Sets the viewport used during the rasterization stage to linearly map from normalized device
        coordinates to viewport coordinates.

        <div algorithm="GPURenderPassEncoder.setViewport">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setViewport(x, y, width, height, minDepth, maxDepth)">
                |x|: Minimum X value of the viewport in pixels.
                |y|: Minimum Y value of the viewport in pixels.
                |width|: Width of the viewport in pixels.
                |height|: Height of the viewport in pixels.
                |minDepth|: Minimum depth value of the viewport.
                |maxDepth|: Maximum depth value of the viewport.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |x| is greater than or equal to `0`.
                        - |y| is greater than or equal to `0`.
                        - |width| is greater than or equal to `0`.
                        - |height| is greater than or equal to `0`.
                        - |x| + |width| is less than or equal to
                            |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width.
                        - |y| + |height| is less than or equal to
                            |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height.
                        - |minDepth| is greater than or equal to `0.0` and less than or equal to `1.0`.
                        - |maxDepth| is greater than or equal to `0.0` and less than or equal to `1.0`.
                        - |maxDepth| is greater than |minDepth|.
                    </div>
                1. Set the viewport to the extents |x|, |y|, |width|, |height|, |minDepth|, and |maxDepth|.
            </div>

            Issue: Allowed for GPUs to use fixed point or rounded viewport coordinates
        </div>

    : <dfn>setScissorRect(x, y, width, height)</dfn>
    ::
        Sets the scissor rectangle used during the rasterization stage.
        After transformation into viewport coordinates any fragments which fall outside the scissor
        rectangle will be discarded.

        <div algorithm="GPURenderPassEncoder.setScissorRect">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setScissorRect(x, y, width, height)">
                |x|: Minimum X value of the scissor rectangle in pixels.
                |y|: Minimum Y value of the scissor rectangle in pixels.
                |width|: Width of the scissor rectangle in pixels.
                |height|: Height of the scissor rectangle in pixels.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |x|+|width| is less than or equal to
                            |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width.
                        - |y|+|height| is less than or equal to
                            |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height.
                    </div>
                1. Set the scissor rectangle to the extents |x|, |y|, |width|, and |height|.
            </div>
        </div>

    : <dfn>setBlendColor(color)</dfn>
    ::
        Sets the constant blend color and alpha values used with {{GPUBlendFactor/"blend-color"}}
        and {{GPUBlendFactor/"one-minus-blend-color"}} {{GPUBlendFactor}}s.

        <div algorithm="GPURenderPassEncoder.setBlendColor">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setBlendColor(color)">
                color: The color to use when blending.
            </pre>
        </div>

    : <dfn>setStencilReference(reference)</dfn>
    ::
        Sets the stencil reference value used during stencil tests with the the
        {{GPUStencilOperation/"replace"}} {{GPUStencilOperation}}.

        <div algorithm="GPURenderPassEncoder.setStencilReference">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setStencilReference(reference)">
                reference: The stencil reference value.
            </pre>
        </div>
</dl>

### Queries ### {#render-pass-encoder-queries}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>beginOcclusionQuery(queryIndex)</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.beginOcclusionQuery">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/beginOcclusionQuery(queryIndex)">
                queryIndex:
            </pre>

            **Returns:** {{undefined}}

            Issue: Describe {{GPURenderPassEncoder/beginOcclusionQuery()}} algorithm steps.
        </div>

    : <dfn>endOcclusionQuery()</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.endOcclusionQuery">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Returns:** {{undefined}}

            Issue: Describe {{GPURenderPassEncoder/endOcclusionQuery()}} algorithm steps.
        </div>

    : <dfn>beginPipelineStatisticsQuery(querySet, queryIndex)</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.beginPipelineStatisticsQuery">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/beginPipelineStatisticsQuery(querySet, queryIndex)">
                querySet:
                queryIndex:
            </pre>

            **Returns:** {{undefined}}

            Issue: Describe {{GPURenderPassEncoder/beginPipelineStatisticsQuery()}} algorithm steps.
        </div>

    : <dfn>endPipelineStatisticsQuery()</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.endPipelineStatisticsQuery">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Returns:** {{undefined}}

            Issue: Describe {{GPURenderPassEncoder/endPipelineStatisticsQuery()}} algorithm steps.
        </div>

    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        Writes a timestamp value into |querySet| when all previous commands have completed executing.

        <div algorithm="GPURenderPassEncoder.writeTimestamp">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/writeTimestamp(querySet, queryIndex)">
                querySet: The query set that will store the timestamp values.
                queryIndex: The index of the query in the query set.
            </pre>

            **Returns:** {{undefined}}

            If any of the following conditions are unsatisfied, generate a validation error and stop.
            <div class=validusage>
                - |querySet| is [$valid to use with$] |this|.
                - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}} is {{GPUQueryType/timestamp}}.
                - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}.
                - The query in |querySet| at index |queryIndex| has not been written earlier in this render pass.
            </div>

            Issue: Describe {{GPURenderPassEncoder/writeTimestamp()}} algorithm steps.
        </div>
</dl>

### Bundles ### {#render-pass-encoder-bundles}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>executeBundles(bundles)</dfn>
    ::
        Executes the commands previously recorded into the given {{GPURenderBundle}}s as part of
        this render pass.

        When a {{GPURenderBundle}} is executed, it does not inherit the render pass's pipeline, bind
        groups, or vertex and index buffers. After a {{GPURenderBundle}} has executed, the render
        pass's pipeline, bind groups, and vertex and index buffers are cleared.

        Note: state is cleared even if zero {{GPURenderBundle|GPURenderBundles}} are executed.

        <div algorithm="GPURenderPassEncoder.executeBundles">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/executeBundles(bundles)">
                bundles: List of render bundles to execute.
            </pre>

            **Returns:** {{undefined}}

            Issue: Describe {{GPURenderPassEncoder/executeBundles()}} algorithm steps.
        </div>
</dl>

### Finalization ### {#render-pass-encoder-finalization}

The render pass encoder can be ended by calling {{GPURenderPassEncoder/endPass()}} once the user
has finished recording commands for the pass. Once {{GPURenderPassEncoder/endPass()}} has been
called the render pass encoder can no longer be used.

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>endPass()</dfn>
    ::
        Completes recording of the render pass commands sequence.

        <div algorithm="GPURenderPassEncoder.endPass">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |this|.{{GPUProgrammablePassEncoder/[[debug_group_stack]]}}'s [=stack/size=] is 0.

                        Issue: Add remaining validation.
                    </div>

                Issue: Enqueue the attachment stores (with storeOp clear).
            </div>
        </div>
</dl>

# Bundles # {#bundles}

## <dfn interface>GPURenderBundle</dfn> ## {#render-bundle}

<script type=idl>
interface GPURenderBundle {
};
GPURenderBundle includes GPUObjectBase;
</script>

### Creation ### {#render-bundle-creation}

<script type=idl>
dictionary GPURenderBundleDescriptor : GPUObjectDescriptorBase {
};
</script>

<script type=idl>
interface GPURenderBundleEncoder {
    GPURenderBundle finish(optional GPURenderBundleDescriptor descriptor = {});
};
GPURenderBundleEncoder includes GPUObjectBase;
GPURenderBundleEncoder includes GPUProgrammablePassEncoder;
GPURenderBundleEncoder includes GPURenderEncoderBase;
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderBundleEncoder(descriptor)</dfn>
    ::
        Creates a {{GPURenderBundleEncoder}}.

        <div algorithm=GPUDevice.createRenderBundleEncoder>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createRenderBundleEncoder(descriptor)">
                descriptor: Description of the {{GPURenderBundleEncoder}} to create.
            </pre>

            **Returns:** {{GPURenderBundleEncoder}}

            Issue: Describe {{GPUDevice/createRenderBundleEncoder()}} algorithm steps.
        </div>
</dl>

### Encoding ### {#render-bundle-encoding}

<script type=idl>
dictionary GPURenderBundleEncoderDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUTextureFormat> colorFormats;
    GPUTextureFormat depthStencilFormat;
    GPUSize32 sampleCount = 1;
};
</script>

### Finalization ### {#render-bundle-finalization}

<dl dfn-type=method dfn-for=GPURenderBundleEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        Completes recording of the render bundle commands sequence.

        <div algorithm="GPURenderBundleEncoder.finish">
            **Called on:** {{GPURenderBundleEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderBundleEncoder/finish(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPURenderBundle}}

            Issue: Describe {{GPURenderBundleEncoder/finish()}} algorithm steps.
        </div>
</dl>

# Queues # {#queues}

<script type=idl>
interface GPUQueue {
    undefined submit(sequence<GPUCommandBuffer> commandBuffers);

    Promise<undefined> onSubmittedWorkDone();

    undefined writeBuffer(
        GPUBuffer buffer,
        GPUSize64 bufferOffset,
        [AllowShared] BufferSource data,
        optional GPUSize64 dataOffset = 0,
        optional GPUSize64 size);

    undefined writeTexture(
      GPUImageCopyTexture destination,
      [AllowShared] BufferSource data,
      GPUImageDataLayout dataLayout,
      GPUExtent3D size);

    undefined copyImageBitmapToTexture(
        GPUImageCopyImageBitmap source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);
};
GPUQueue includes GPUObjectBase;
</script>

{{GPUQueue}} has the following methods:

<dl dfn-type=method dfn-for=GPUQueue>
    : <dfn>writeBuffer(buffer, bufferOffset, data, dataOffset, size)</dfn>
    ::
        Issues a write operation of the provided data into a {{GPUBuffer}}.

        <div algorithm=GPUQueue.writeBuffer>
            **Called on:** {{GPUQueue}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/writeBuffer(buffer, bufferOffset, data, dataOffset, size)">
                |buffer|: The buffer to write to.
                |bufferOffset|: Offset in bytes into |buffer| to begin writing at.
                |data|: Data to write into |buffer|.
                |dataOffset|: Offset in into |data| to begin writing from. Given in elements if
                    |data| is a `TypedArray` and bytes otherwise.
                |size|: Size of content to write from |data| to |buffer|. Given in elements if
                    |data| is a `TypedArray` and bytes otherwise.
            </pre>

            **Returns:** {{undefined}}

            1. If |data| is an {{ArrayBuffer}} or {{DataView}}, let the element type be "byte".
                Otherwise, |data| is a TypedArray; let the element type be the type of the TypedArray.
            1. Let |dataSize| be the size of |data|, in elements.
            1. If |size| is unspecified,
                let |contentsSize| be |dataSize| &minus; |dataOffset|.
                Otherwise, let |contentsSize| be |size|.
            1. If any of the following conditions are unsatisfied,
                throw {{OperationError}} and stop.
                <!-- Note: it's easiest to write the valid usage rules inline
                     here, because they depend on contentsSize above. -->
                <div class=validusage>
                    - |contentsSize| &ge; 0.
                    - |dataOffset| + |contentsSize| &le; |dataSize|.
                    - |contentsSize|, converted to bytes, is a multiple of 4 bytes.
                </div>
            1. Let |dataContents| be [=get a copy of the buffer source|a copy of the bytes held by the buffer source=].
            1. Let |contents| be the |contentsSize| elements of |dataContents| starting at
                an offset of |dataOffset| elements.
            1. Issue the following steps on the [=Queue timeline=] of |this|:
                <div class=queue-timeline>
                    1. If any of the following conditions are unsatisfied,
                        generate a validation error and stop.
                        <div class=validusage>
                            - |buffer| is [$valid to use with$] |this|.
                            - |buffer|.{{GPUBuffer/[[state]]}} is [=buffer state/unmapped=].
                            - |buffer|.{{GPUBuffer/[[usage]]}} includes {{GPUBufferUsage/COPY_DST}}.
                            - |bufferOffset|, converted to bytes, is a multiple of 4 bytes.
                            - |bufferOffset| + |contentsSize|, converted to bytes, &le; |buffer|.{{GPUBuffer/[[size]]}} bytes.
                        </div>
                    1. Write |contents| into |buffer| starting at |bufferOffset|.
                </div>
        </div>

    : <dfn>writeTexture(destination, data, dataLayout, size)</dfn>
    ::
        Issues a write operation of the provided data into a {{GPUTexture}}.

        <div algorithm=GPUQueue.writeTexture>
            **Called on:** {{GPUQueue}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/writeTexture(destination, data, dataLayout, size)">
                |destination|: The [=texture subresource=] and origin to write to.
                |data|: Data to write into |destination|.
                |dataLayout|: Layout of the content in |data|.
                |size|: Extents of the content to write from |data| to |destination|.
            </pre>

            **Returns:** {{undefined}}

            1. Let |dataBytes| be [=get a copy of the buffer source|a copy of the bytes held by the buffer source=] |data|.
            1. Let |dataByteSize| be the number of bytes in |dataBytes|.
            1. If any of the following conditions are unsatisfied,
                throw {{OperationError}} and stop.
                <div class=validusage>
                    - [$validating linear texture data$](|dataLayout|,
                        |dataByteSize|,
                        |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}},
                        |size|) succeeds.
                </div>
            1. Let |contents| be the contents of the [=images=] seen by
                viewing |dataBytes| with |dataLayout| and |size|.

                Issue: Specify more formally.
            1. Issue the following steps on the [=Queue timeline=] of |this|:
                <div class=queue-timeline>
                    1. If any of the following conditions are unsatisfied,
                        generate a validation error and stop.
                        <div class=validusage>
                            - [$validating GPUImageCopyTexture$](|destination|, |size|) returns `true`.
                            - |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[textureUsage]]}}
                                includes {{GPUTextureUsage/COPY_DST}}.
                            - |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[sampleCount]]}} is 1.
                            - [=Valid Texture Copy Range=](|destination|, |size|)
                                is satisfied.
                            - |destination|.{{GPUImageCopyTexture/aspect}} refers to a single copyable aspect
                                of |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}}.
                                See [[#depth-formats|depth-formats]].

                            Note: unlike
                            {{GPUCommandEncoder}}.{{GPUCommandEncoder/copyBufferToTexture()}},
                            there is no alignment requirement on
                            |dataLayout|.{{GPUImageDataLayout/bytesPerRow}}.
                        </div>
                    1. Write |contents| into |destination|.

                        Issue: Specify more formally.
                </div>
        </div>

    : <dfn>copyImageBitmapToTexture(source, destination, copySize)</dfn>
    ::
        Schedules a copy operation of the contents of an image bitmap into the destination texture.

        <div algorithm=GPUQueue.copyImageBitmapToTexture>
            **Called on:** {{GPUQueue}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/copyImageBitmapToTexture(source, destination, copySize)">
                |source|: {{ImageBitmap}} and origin to copy to |destination|.
                |destination|: The [=texture subresource=] and origin to write to.
                |copySize|: Extents of the content to write from |source| to |destination|.
            </pre>

            **Returns:** {{undefined}}

            If any of the following conditions are unsatisfied, throw an {{OperationError}} and stop.
            <div class=validusage>
                - |copySize|.[=Extent3D/depth=] is `1`.
                - |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[dimension]]}} is {{GPUTextureDimension/"2d"}}.
                - |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[format]]}} is one of the following:
                    - {{GPUTextureFormat/"rgba8unorm"}}
                    - {{GPUTextureFormat/"rgba8unorm-srgb"}}
                    - {{GPUTextureFormat/"bgra8unorm"}}
                    - {{GPUTextureFormat/"bgra8unorm-srgb"}}
                    - {{GPUTextureFormat/"rgb10a2unorm"}}
                    - {{GPUTextureFormat/"rgba16float"}}
                    - {{GPUTextureFormat/"rgba32float"}}
                    - {{GPUTextureFormat/"rg8unorm"}}
                    - {{GPUTextureFormat/"rg16float"}}
            </div>
        </div>

    : <dfn>submit(commandBuffers)</dfn>
    ::
        Schedules the execution of the command buffers by the GPU on this queue.

        <div algorithm=GPUQueue.submit>
            **Called on:** {{GPUQueue}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/submit(commandBuffers)">
                |commandBuffers|:
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                    <div class=validusage>
                        - Every {{GPUBuffer}} referenced in any element of |commandBuffers| is in the
                            `"unmapped"` [=buffer state=].
                    </div>

                1. Issue the following steps on the [=Queue timeline=] of |this|:
                    <div class=queue-timeline>
                        1. For each |commandBuffer| in |commandBuffers|:
                            1. Execute each command in |commandBuffer|.{{GPUCommandBuffer/[[command_list]]}}.
                    </div>
            </div>
        </div>

    : <dfn>onSubmittedWorkDone()</dfn>
    ::
        Returns a {{Promise}} that resolves once this queue finishes processing all the work submitted
        up to this moment.

        <div algorithm="GPUQueue.onSubmittedWorkDone">
            **Called on:** {{GPUQueue}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/onSubmittedWorkDone()">
            </pre>

            **Returns:** {{Promise}}&lt;{{undefined}}&gt;

            Issue: Describe {{GPUQueue/onSubmittedWorkDone()}} algorithm steps.
        </div>
</dl>

Queries {#queries}
================

## <dfn interface>GPUQuerySet</dfn> ## {#queryset}

<script type=idl>
interface GPUQuerySet {
    undefined destroy();
};
GPUQuerySet includes GPUObjectBase;
</script>

{{GPUQuerySet}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUQuerySet">
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUQuerySetDescriptor}}
    ::
        The {{GPUQuerySetDescriptor}} describing this query set.

        All optional fields of {{GPUTextureViewDescriptor}} are defined.
</dl>

### Creation ### {#queryset-creation}

A {{GPUQuerySetDescriptor}} specifies the options to use in creating a {{GPUQuerySet}}.

<script type=idl>
dictionary GPUQuerySetDescriptor : GPUObjectDescriptorBase {
    required GPUQueryType type;
    required GPUSize32 count;
    sequence<GPUPipelineStatisticName> pipelineStatistics = [];
};
</script>

<dl dfn-type=dict-member dfn-for=GPUQuerySetDescriptor>
    : <dfn>type</dfn>
    ::
        The type of queries managed by {{GPUQuerySet}}.

    : <dfn>count</dfn>
    ::
        The number of queries managed by {{GPUQuerySet}}.

    : <dfn>pipelineStatistics</dfn>
    ::
        The set of {{GPUPipelineStatisticName}} values in this sequence defines which pipeline statistics will be returned in the new query set.
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createQuerySet(descriptor)</dfn>
    ::
        Creates a {{GPUQuerySet}}.

        <div algorithm=GPUDevice.createQuerySet>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createQuerySet(descriptor)">
                descriptor: Description of the {{GPUQuerySet}} to create.
            </pre>

            **Returns:** {{GPUQuerySet}}

            If any of the following conditions are unsatisfied, return an error query set and stop.
            <div class=validusage>
                - |this| is a [=valid=] {{GPUDevice}}.
                - |descriptor|.{{GPUQuerySetDescriptor/type}} must not be {{GPUQueryType/pipeline-statistics}} if
                    {{GPUFeatureName/pipeline-statistics-query}} is not available.
                - |descriptor|.{{GPUQuerySetDescriptor/type}} must not be {{GPUQueryType/timestamp}} if
                    {{GPUFeatureName/timestamp-query}} is not available.
                - |descriptor|.{{GPUQuerySetDescriptor/count}} &le; 8192.
                - |descriptor|.{{GPUQuerySetDescriptor/pipelineStatistics}} must be undefined if |this|.{{GPUQuerySetDescriptor/type}}
                    is not {{GPUQueryType/pipeline-statistics}}, otherwise it must be a sequence of {{GPUPipelineStatisticName}} values
                    which cannot be duplicated.
            </div>

            Issue: Describe {{GPUDevice/createQuerySet()}} algorithm steps.
        </div>
</dl>

### Finalization ### {#queryset-finalization}

<dl dfn-type=method dfn-for=GPUQuerySet>
    : <dfn>destroy()</dfn>
    ::
        Destroys the {{GPUQuerySet}}.

        <div algorithm="GPUQuerySet.signal">
            **Called on:** {{GPUQuerySet}} this.

            **Returns:** {{undefined}}

            Issue: Describe {{GPUQuerySet/destroy()}} algorithm steps.
        </div>
</dl>

## QueryType ## {#querytype}

<script type=idl>
enum GPUQueryType {
    "occlusion",
    "pipeline-statistics",
    "timestamp"
};
</script>

## Pipeline Statistics Query ## {#pipeline-statistics}

<script type=idl>
enum GPUPipelineStatisticName {
    "vertex-shader-invocations",
    "clipper-invocations",
    "clipper-primitives-out",
    "fragment-shader-invocations",
    "compute-shader-invocations"
};
</script>

When resolving pipeline statistics query, each result is written into {{GPUSize64}}, and the number and order of the results written to GPU buffer matches the number and order of {{GPUPipelineStatisticName}} specified in {{GPUQuerySetDescriptor/pipelineStatistics}}.

The {{GPURenderPassEncoder/beginPipelineStatisticsQuery()}} and {{GPURenderPassEncoder/endPipelineStatisticsQuery()}} (on both {{GPUComputePassEncoder}} and {{GPURenderPassEncoder}}) cannot be nested. A pipeline statistics query must be ended before beginning another one.

Pipeline statistics query requires {{GPUFeatureName/pipeline-statistics-query}} is available on the device.

## Timestamp Query ## {#timestamp}

Timestamp query allows application to write timestamp values to a {{GPUQuerySet}} by calling {{GPURenderPassEncoder/writeTimestamp()}} on {{GPUComputePassEncoder}} or {{GPURenderPassEncoder}} or {{GPUCommandEncoder}}, and then resolve timestamp values in **nanoseconds** (type of {{GPUSize64}}) to a {{GPUBuffer}} (using {{GPUCommandEncoder/resolveQuerySet()}}).

Timestamp query requires {{GPUFeatureName/timestamp-query}} is available on the device.

Note: The timestamp values may be zero if the physical device reset timestamp counter, please ignore it and the following values.

Issue: Write normative text about timestamp value resets.

Issue: Because timestamp query provides high-resolution GPU timestamp, we need to decide what constraints, if any, are on its availability.

# Canvas Rendering &amp; Swap Chains # {#canvas-rendering}

<script type=idl>
interface GPUCanvasContext {
    GPUSwapChain configureSwapChain(GPUSwapChainDescriptor descriptor);

    GPUTextureFormat getSwapChainPreferredFormat(GPUAdapter adapter);
};
</script>

{{GPUCanvasContext}} has the following methods:

<dl dfn-type=method dfn-for=GPUCanvasContext>
    : <dfn>configureSwapChain(descriptor)</dfn>
    ::
        Configures the swap chain for this canvas, and returns a new
        {{GPUSwapChain}} object representing it. Destroys any swapchain
        previously returned by `configureSwapChain`, including all of the
        textures it has produced.

        <div algorithm="GPUCanvasContext.configureSwapChain">
            **Called on:** {{GPUCanvasContext}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCanvasContext/configureSwapChain(descriptor)">
                |descriptor|: Description of the {{GPUSwapChain}} to configure.
            </pre>

            **Returns:** {{GPUSwapChain}}

            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                        <div class=validusage>
                            - |descriptor|.{{GPUSwapChainDescriptor/device}} is a [=valid=] {{GPUDevice}}.
                            - [=Supported swap chain formats=] [=set/contains=] |descriptor|.{{GPUSwapChainDescriptor/format}}.
                        </div>

                    Issue: Describe remaining {{GPUCanvasContext/configureSwapChain()}} algorithm steps.
                </div>
        </div>

    : <dfn>getSwapChainPreferredFormat(adapter)</dfn>
    ::
        Returns an optimal {{GPUTextureFormat}} to use for swap chains with this context and the
        given device.

        <div algorithm="GPUCanvasContext.getSwapChainPreferredFormat">
            **Called on:** {{GPUCanvasContext}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUCanvasContext/getSwapChainPreferredFormat(adapter)">
                |adapter|: Adapter the swap chain format should be queried for.
            </pre>

            **Returns:** {{GPUTextureFormat}}

            <div class=content-timeline>
                1. Return an optimal {{GPUTextureFormat}} to use when creating a {{GPUSwapChain}}
                    with the given |adapter|. Must be one of the [=supported swap chain formats=].
            </div>
        </div>
</dl>

The <dfn dfn>supported swap chain formats</dfn> are a [=set=] of {{GPUTextureFormat}}s that must be
supported when specified as a {{GPUSwapChainDescriptor}}.{{GPUSwapChainDescriptor/format}} regardless
of the given {{GPUSwapChainDescriptor}}.{{GPUSwapChainDescriptor/device}}, initially set to:
&laquo;{{GPUTextureFormat/"bgra8unorm"}}, {{GPUTextureFormat/"bgra8unorm-srgb"}},
{{GPUTextureFormat/"rgba8unorm"}}, {{GPUTextureFormat/"rgba8unorm-srgb"}}&raquo;.

<script type=idl>
dictionary GPUSwapChainDescriptor : GPUObjectDescriptorBase {
    required GPUDevice device;
    required GPUTextureFormat format;
    GPUTextureUsageFlags usage = 0x10;  // GPUTextureUsage.RENDER_ATTACHMENT
};
</script>

<script type=idl>
interface GPUSwapChain {
    GPUTexture getCurrentTexture();
};
GPUSwapChain includes GPUObjectBase;
</script>

In the "update the rendering [of the] `Document`" step of the "Update the rendering" HTML processing
model, the contents of the {{GPUTexture}} most recently returned by
{{GPUSwapChain/getCurrentTexture()}} are used to update the rendering for the `canvas`, and it is as
if {{GPUTexture/destroy()}} were called on it (making it unusable elsewhere in WebGPU).

Before this drawing buffer is presented for compositing, the implementation shall ensure that all
rendering operations have been flushed to the drawing buffer.

<dl dfn-type=method dfn-for=GPUSwapChain>
    : <dfn>getCurrentTexture()</dfn>
    ::
        Get the {{GPUTexture}} that will be composited to the document by the {{GPUCanvasContext}}
        that created this swap chain next.

        <div algorithm="GPUSwapChain.getCurrentTexture">
            **Called on:** {{GPUSwapChain}} this.

            **Returns:** {{GPUTexture}}

            Issue: Describe {{GPUSwapChain/getCurrentTexture()}} algorithm steps.
        </div>
</dl>

# Errors &amp; Debugging # {#errors-and-debugging}

## Fatal Errors ## {#fatal-errors}

<script type=idl>
enum GPUDeviceLostReason {
    "destroyed",
};

interface GPUDeviceLostInfo {
    readonly attribute (GPUDeviceLostReason or undefined) reason;
    readonly attribute DOMString message;
};

partial interface GPUDevice {
    readonly attribute Promise<GPUDeviceLostInfo> lost;
};
</script>


## Error Scopes ## {#error-scopes}

<script type=idl>
enum GPUErrorFilter {
    "out-of-memory",
    "validation"
};
</script>

<script type=idl>
interface GPUOutOfMemoryError {
    constructor();
};

interface GPUValidationError {
    constructor(DOMString message);
    readonly attribute DOMString message;
};

typedef (GPUOutOfMemoryError or GPUValidationError) GPUError;
</script>

<script type=idl>
partial interface GPUDevice {
    undefined pushErrorScope(GPUErrorFilter filter);
    Promise<GPUError?> popErrorScope();
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>pushErrorScope(filter)</dfn>
    ::
        Issue: Define pushErrorScope.

    : <dfn>popErrorScope()</dfn>
    ::
        Issue: Define popErrorScope.

        Rejects with {{OperationError}} if:

        - The device is lost.
        - There are no error scopes on the stack.
</dl>

## Telemetry ## {#telemetry}

<script type=idl>
[
    Exposed=(Window, DedicatedWorker)
]
interface GPUUncapturedErrorEvent : Event {
    constructor(
        DOMString type,
        GPUUncapturedErrorEventInit gpuUncapturedErrorEventInitDict
    );
    [SameObject] readonly attribute GPUError error;
};

dictionary GPUUncapturedErrorEventInit : EventInit {
    required GPUError error;
};
</script>

<script type=idl>
partial interface GPUDevice {
    [Exposed=(Window, DedicatedWorker)]
    attribute EventHandler onuncapturederror;
};
</script>


# Type Definitions # {#type-definitions}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferDynamicOffset;
typedef [EnforceRange] unsigned long GPUStencilValue;
typedef [EnforceRange] unsigned long GPUSampleMask;
typedef [EnforceRange] long GPUDepthBias;

typedef [EnforceRange] unsigned long long GPUSize64;
typedef [EnforceRange] unsigned long GPUIntegerCoordinate;
typedef [EnforceRange] unsigned long GPUIndex32;
typedef [EnforceRange] unsigned long GPUSize32;
typedef [EnforceRange] long GPUSignedOffset32;

typedef unsigned long GPUFlagsConstant;
</script>

## Colors &amp; Vectors ## {#colors-and-vectors}

<script type=idl>
dictionary GPUColorDict {
    required double r;
    required double g;
    required double b;
    required double a;
};
typedef (sequence<double> or GPUColorDict) GPUColor;
</script>

Note: `double` is large enough to precisely hold 32-bit signed/unsigned
integers and single-precision floats.

<script type=idl>
dictionary GPUOrigin2DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin2DDict) GPUOrigin2D;
</script>

An <dfn dfn>Origin2D</dfn> is a {{GPUOrigin2D}}.
[=Origin2D=] is a spec namespace for the following definitions:
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin2D accessors" dfn-for=Origin2D>
    For a given {{GPUOrigin2D}} value |origin|, depending on its type, the syntax:

      - |origin|.<dfn dfn>x</dfn> refers to
        either {{GPUOrigin2DDict}}.{{GPUOrigin2DDict/x}}
        or the first item of the sequence or 0 if it isn't present.
      - |origin|.<dfn dfn>y</dfn> refers to
        either {{GPUOrigin2DDict}}.{{GPUOrigin2DDict/y}}
        or the second item of the sequence or 0 if it isn't present.
</div>

<script type=idl>
dictionary GPUOrigin3DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
    GPUIntegerCoordinate z = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin3DDict) GPUOrigin3D;
</script>

An <dfn dfn>Origin3D</dfn> is a {{GPUOrigin3D}}.
[=Origin3D=] is a spec namespace for the following definitions:
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin3D accessors" dfn-for=Origin3D>
    For a given {{GPUOrigin3D}} value |origin|, depending on its type, the syntax:

      - |origin|.<dfn dfn>x</dfn> refers to
        either {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/x}}
        or the first item of the sequence or 0 if it isn't present.
      - |origin|.<dfn dfn>y</dfn> refers to
        either {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/y}}
        or the second item of the sequence or 0 if it isn't present.
      - |origin|.<dfn dfn>z</dfn> refers to
        either {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/z}}
        or the third item of the sequence or 0 if it isn't presnet.
</div>

<script type=idl>
dictionary GPUExtent3DDict {
    GPUIntegerCoordinate width = 1;
    GPUIntegerCoordinate height = 1;
    GPUIntegerCoordinate depth = 1;
};
typedef (sequence<GPUIntegerCoordinate> or GPUExtent3DDict) GPUExtent3D;
</script>

An <dfn dfn>Extent3D</dfn> is a {{GPUExtent3D}}.
[=Extent3D=] is a spec namespace for the following definitions:
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUExtent3D accessors" dfn-for=Extent3D>
    For a given {{GPUExtent3D}} value |extent|, depending on its type, the syntax:

      - |extent|.<dfn dfn>width</dfn> refers to
        either {{GPUExtent3DDict}}.{{GPUExtent3DDict/width}}
        or the first item of the sequence or 1 if it isn't present.
      - |extent|.<dfn dfn>height</dfn> refers to
        either {{GPUExtent3DDict}}.{{GPUExtent3DDict/height}}
        or the second item of the sequence or 1 if it isn't present.
      - |extent|.<dfn dfn>depth</dfn> refers to
        either {{GPUExtent3DDict}}.{{GPUExtent3DDict/depth}}
        or the third item of the sequence or 1 if it isn't present.
</div>

# Feature Index # {#feature-index}

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>depth-clamping</dfn> ## {#depth-clamping}

Issue: Define functionality when the {{GPUFeatureName/"depth-clamping"}} [=feature=] is enabled.

**Feature Dictionary Values**

The following dictionary values are supported if and only if the {{GPUFeatureName/"depth-clamping"}}
[=feature=] is enabled, otherwise they must be set to their default values:

<dl>
    : {{GPUDepthStencilState}}
    ::
        * {{GPUDepthStencilState/clampDepth}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>depth24unorm-stencil8</dfn> ## {#depth24unorm-stencil8}

Allows for explicit creation of textures of format {{GPUTextureFormat/"depth24unorm-stencil8"}}.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"depth24unorm-stencil8"}}
[=feature=] is enabled:

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"depth24unorm-stencil8"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>depth32float-stencil8</dfn> ## {#depth32float-stencil8}

Allows for explicit creation of textures of format {{GPUTextureFormat/"depth32float-stencil8"}}.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"depth32float-stencil8"}}
[=feature=] is enabled:

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"depth32float-stencil8"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>pipeline-statistics-query</dfn> ## {#pipeline-statistics-query}

Issue: Define functionality when the {{GPUFeatureName/"pipeline-statistics-query"}} [=feature=] is enabled.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"pipeline-statistics-query"}}
[=feature=] is enabled:

<dl>
    : {{GPUQueryType}}
    ::
        * {{GPUQueryType/"pipeline-statistics"}}
</dl>


## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>texture-compression-bc</dfn> ## {#texture-compression-bc}

Allows for explicit creation of textures of BC compressed formats.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"texture-compression-bc"}}
[=feature=] is enabled:

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"bc1-rgba-unorm"}}
        * {{GPUTextureFormat/"bc1-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc2-rgba-unorm"}}
        * {{GPUTextureFormat/"bc2-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc3-rgba-unorm"}}
        * {{GPUTextureFormat/"bc3-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc4-r-unorm"}}
        * {{GPUTextureFormat/"bc4-r-snorm"}}
        * {{GPUTextureFormat/"bc5-rg-unorm"}}
        * {{GPUTextureFormat/"bc5-rg-snorm"}}
        * {{GPUTextureFormat/"bc6h-rgb-ufloat"}}
        * {{GPUTextureFormat/"bc6h-rgb-float"}}
        * {{GPUTextureFormat/"bc7-rgba-unorm"}}
        * {{GPUTextureFormat/"bc7-rgba-unorm-srgb"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>timestamp-query</dfn> ## {#timestamp-query}

Issue: Define functionality when the {{GPUFeatureName/"timestamp-query"}} [=feature=] is enabled.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"timestamp-query"}}
[=feature=] is enabled:

<dl>
    : {{GPUQueryType}}
    ::
        * {{GPUQueryType/"timestamp"}}
</dl>

# Appendices # {#appendices}

## Texture Format Capabilities ## {#texture-format-caps}

Issue: Add multisampling to the tables below.

### Plain color formats ### {#plain-color-formats}

All plain color formats support {{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}}, and {{GPUTextureUsage/SAMPLED}} usage.

Only formats with {{GPUTextureSampleType}} {{GPUTextureSampleType/"float"}} can be blended.

The {{GPUTextureUsage/STORAGE|GPUTextureUsage.STORAGE}} column specifies the support for {{GPUTextureUsage/STORAGE}}
usage in the core API, including both {{GPUStorageTextureAccess/"read-only"}} and {{GPUStorageTextureAccess/"write-only"}}.

<table class='data'>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>{{GPUTextureSampleType}}
            <th>{{GPUTextureUsage/RENDER_ATTACHMENT}}
            <th>{{GPUTextureUsage/STORAGE}}
    </thead>
    <tr><th class=stickyheader>8-bit per component<th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rgba8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr><th class=stickyheader>16-bit per component<th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/rgba16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr><th class=stickyheader>32-bit per component<th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/r32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/r32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}<!-- Metal -->
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
    <tr><th class=stickyheader>mixed component width<th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/rgb10a2unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg11b10ufloat}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>

</table>

### Depth/stencil formats ### {#depth-formats}

All depth formats support {{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}}, {{GPUTextureUsage/SAMPLED}}, and {{GPUTextureUsage/RENDER_ATTACHMENT}} usage. However, the source/destination is restricted based on the format.

None of the depth formats can be filtered.

<table class='data'>
    <thead>
        <tr>
            <th>Format
            <th>Bytes per texel
            <th>Aspect
            <th>{{GPUTextureSampleType}}
            <th>Copy aspect from Buffer
            <th>Copy aspect into Buffer
    </thead>
    <tr>
        <td>{{GPUTextureFormat/stencil8}}
        <td>1 &minus; 5
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth16unorm}}
        <td>2
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth24plus}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&cross;
    <tr>
        <td rowspan=2 style='white-space:nowrap'>{{GPUTextureFormat/depth24plus-stencil8}}
        <td rowspan=2>4 &minus; 8
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&cross;
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth32float}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=1>&cross;
        <td colspan=1>&checkmark;
</table>

Copies between depth textures can only happen within the following sets of formats:
  - {{GPUTextureFormat/stencil8}}, {{GPUTextureFormat/depth24plus-stencil8}} (stencil component), {{GPUTextureFormat/r8uint}}
  - {{GPUTextureFormat/depth16unorm}}, {{GPUTextureFormat/r16uint}}
  - {{GPUTextureFormat/depth24plus}}, {{GPUTextureFormat/depth24plus-stencil8}} (depth aspect)

The {{GPUTextureFormat/depth32float}} format can only the destination if copied from another texture of the same format. It can also be a source of copies into {{GPUTextureFormat/r32float}}.

Issue: clarify if `depth24plus-stencil8` is copyable into `depth24plus` in Metal.

### Packed formats ### {#packed-formats}

All packed texture formats support {{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}}, and {{GPUTextureUsage/SAMPLED}} usages. All of these formats have {{GPUTextureSampleType/"float"}} type and can be filtered on sampling.

<table class='data'>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>Bytes per block
            <th>{{GPUTextureSampleType}}
            <th>Block Size
            <th>[=Feature=]
    </thead>
    <tr>
        <td>{{GPUTextureFormat/rgb9e5ufloat}}
        <td>4
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>1 &times; 1
        <td>
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm}}
        <td rowspan=2>8
        <td rowspan=14>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=14>4 &times; 4
        <td rowspan=14>{{GPUFeatureName/texture-compression-bc}}
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc4-r-unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/bc4-r-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-ufloat}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-float}}
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm-srgb}}
</table>

## Temporary usages of non-exported dfns ## {#temp-dfn-usages}

[=Origin2D/x=] [=Origin2D/y=]

Eventually all of these should disappear but they are useful to avoid warning while building the specification.

[=vertex buffer=]
