<pre class='metadata'>
Title: WebGPU
Shortname: webgpu
Level: 1
Status: w3c/ED
Group: webgpu
URL: https://gpuweb.github.io/gpuweb

!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues">open issues</a>)

Editor: Dzmitry Malyshau, Mozilla https://www.mozilla.org, dmalyshau@mozilla.com
Editor: Justin Fan, Apple https://www.apple.com, justin_fan@apple.com
Editor: Kai Ninomiya, Google http://www.google.com, kainino@google.com
Abstract: WebGPU exposes an API for performing operations, such as rendering and computation, on a Graphics Processing Unit.
Markup Shorthands: markdown yes
Markup Shorthands: dfn yes
Markup Shorthands: idl yes
Markup Shorthands: css no
</pre>

<pre class='anchors'>
spec: ECMA-262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: agent; url: agent
spec: webidl; urlPrefix: https://heycam.github.io/webidl/#
    type: dfn
        text: resolve; url: resolve
</pre>

<style>
.validusage {
    border-color: #88e !important;
}
</style>


Introduction {#intro}
=====================

*This section is non-normative.*

[Graphics Processing Units](https://en.wikipedia.org/wiki/Graphics_processing_unit), or GPUs for short,
have been essential in enabling rich rendering and computational applications in personal computing.
WebGPU is an API that exposes the capabilities of GPU hardware for the Web.
The API is designed from the ground up to efficiently map to the
[Vulkan](https://www.khronos.org/vulkan/),
[Direct3D 12](https://docs.microsoft.com/en-us/windows/win32/direct3d12/what-is-directx-12-),
and [Metal](https://developer.apple.com/metal/) native GPU APIs.
WebGPU is not related to [WebGL](https://www.khronos.org/webgl/) and does not explicitly target OpenGL ES.

WebGPU sees physical GPU hardware as {{GPUAdapter}}s. It provides a connection to an adapter via
{{GPUDevice}}, which manages resources, and the device's {{GPUQueue}}s, which execute commands.
{{GPUDevice}} may have its own memory with high-speed access to the processing units.
{{GPUBuffer}} and {{GPUTexture}} are the <dfn dfn>physical resources</dfn> backed by GPU memory.
{{GPUCommandBuffer}} and {{GPURenderBundle}} are containers for user-recorded commands.
{{GPUShaderModule}} contains [=shader=] code. The other resources,
such as {{GPUSampler}} or {{GPUBindGroup}}, configure the way [=physical resources=] are used by the GPU.

GPUs execute commands encoded in {{GPUCommandBuffer}}s by feeding data through a <dfn>pipeline</dfn>,
which is a mix of fixed-function and programmable stages. Programmable stages execute
<dfn dfn>shaders</dfn>, which are special programs designed to run on GPU hardware.
Most of the state of a [=pipeline=] is defined by
a {{GPURenderPipeline}} or a {{GPUComputePipeline}} object. The state not included
in these [=pipeline=] objects is set during encoding with commands,
such as {{GPUCommandEncoder/beginRenderPass()}} or {{GPURenderPassEncoder/setBlendColor()}}.

Security considerations {#security}
=====================

## CPU-based undefined behavior ## {#security-cpu-ub}
A WebGPU implementation translates the workloads issued by the user into API commands specific
to the target platform. Native APIs specify the valid usage for the commands
(for example, see [vkCreateDescriptorSetLayout](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateDescriptorSetLayout.html))
and generally don't guarantee any outcome if the valid usage rules are not followed.
This is called "undefined behavior", and it can be exploited by an attacker to access memory
they don't own, or force the driver to execute arbitrary code.

In order to disallow insecure usage, the range of allowed WebGPU behaviors is defined for any input.
An implementation has to validate all the input from the user and only reach the driver
with the valid workloads. This document specifies all the error conditions and handling semantics.
For example, specifying the same buffer with intersecting ranges in both "source" and "destination"
of {{GPUCommandEncoder/copyBufferToBuffer()}} results in {{GPUCommandEncoder}}
generating an error, and no other operation occurring.

See [[#errors-and-debugging]] for more information about error handling.

## GPU-based undefined behavior ## {#security-gpu-ub}
WebGPU [=shader=]s are executed by the compute units inside GPU hardware. In native APIs,
some of the shader instructions may result in undefined behavior on the GPU.
In order to address that, the shader instruction set and its defined behaviors are
strictly defined by WebGPU. When a shader is provided, the WebGPU implementation has to validate it
before doing any translation (to platform-specific shaders) or transformation passes.

## Out-of-bounds access in shaders ## {#security-shader}
[=Shader=]s can access [=physical resource=]s either directly or via <dfn dfn>texture unit</dfn>s,
which are fixed-function hardware blocks that handle texture coordinate conversions.
Validation on the API side can only guarantee that all the inputs to the shader are provided and
they have the correct usage and types.
The API side can not guarantee that the data is accessed within bounds
if the [=texture unit=]s are not involved.

In order to prevent the shaders from accessing GPU memory an application doesn't own,
the WebGPU implementation may enable a special mode (called "robust buffer access") in the driver
that guarantees that the access is limited to buffer bounds.
Alternatively, an implementation may transform the shader code by inserting manual bounds checks.

If the shader attempts to load data outside of [=physical resource=] bounds,
the implementation is allowed to:
  1. return a value at a different location within the resource bounds
  2. return a value vector of "(0, 0, 0, X)" with any "X"
  3. partially discard the draw or dispatch call

If the shader attempts to write data outside of [=physical resource=] bounds,
the implementation is allowed to:
  1. write the value to a different location within the resource bounds
  2. discard the write operation
  3. partially discard the draw or dispatch call

## Invalid data ## {#security-invalid-data}
When uploading [floating-point](https://en.wikipedia.org/wiki/IEEE_754) data from CPU to GPU,
or generating it on the GPU, we may end up with a binary representation that doesn't correspond
to a valid number, such as infinity or NaN (not-a-number). The GPU behavior in this case is
subject to the accuracy of the GPU hardware implementation of the IEEE-754 standard.
WebGPU guarantees that introducing invalid floating-point numbers would only affect the results
of arithmetic computations and will not have other side effects.

## Driver bugs ## {#security-driver-bugs}
GPU drivers are subject to bugs like any other software. If a bug occurs, an attacker
could possibly exploit the incorrect behavior of the driver to get access to unprivileged data.
In order to reduce the risk, the WebGPU working group will coordinate with GPU vendors
to integrate the WebGPU Conformance Test Suite (CTS) as part of their driver testing process,
like it was done for WebGL.
WebGPU implementations are expected to have workarounds for some of the discovered bugs,
and support blacklisting particular drivers from using some of the native API backends.

## Timing attacks ## {#security-timing}
WebGPU is designed for multi-threaded use via Web Workers. Some of the objects,
like {{GPUBuffer}}, have shared state which can be simultaneously accessed.
This allows race conditions to occur, similar to those of accessing a SharedArrayBuffer
from multiple Web Workers, which makes the thread scheduling observable
and allows the creation of high-precision timers.
The theoretical attack vectors are a subset of those of SharedArrayBuffer.

## Denial of service ## {#security-dos}
WebGPU applications have access to GPU memory and compute units. A WebGPU implementation may limit
the available GPU memory to an application, in order to keep other applications responsive.
For GPU processing time, a WebGPU implementation may set up "watchdog" timer that makes sure an
application doesn't cause GPU unresponsiveness for more than a few seconds.
These measures are similar to those used in WebGL.

## Fingerprinting ## {#security-fingerprint}
WebGPU defines the required limits and capabilities of any {{GPUAdapter}}.
and encourages applications to target these standard limits. The actual result from
{{GPU/requestAdapter()}} may have [=better=] limits, and could be subject to fingerprinting.


Terminology &amp; Conventions {#terminology-and-conventions}
============================================================

## Dot Syntax ## {#dot-syntax}

In this specification, the `.` ("dot") syntax, common in programming languages, is used.
The phrasing "`Foo.Bar`" means "the `Bar` member of the value (or interface) `Foo`."

For example, where `buffer` is a {{GPUBuffer}}, `buffer.[[device]].[[adapter]]` means
"the `[[adapter]]` internal slot of the `[[device]]` internal slot of `buffer`.

## Coordinate Systems ## {#coordinate-systems}

WebGPU's coordinate systems match DirectX and Metal's coordinate systems in a graphics pipeline.
  - Y-axis is up in normalized device coordinate (NDC): point(-1.0, -1.0) in NDC is located at the bottom-left corner of NDC.
    In addition, x and y in NDC should be between -1.0 and 1.0 inclusive, while z in NDC should be between 0.0 and 1.0 inclusive.
    Vertices out of this range in NDC will not introduce any errors, but they will be clipped.
  - Y-axis is down in framebuffer coordinate, viewport coordinate and fragment/pixel coordinate:
    origin(0, 0) is located at the top-left corner in these coordinate systems.
  - Window/present coordinate matches framebuffer coordinate.
  - UV of origin(0, 0) in texture coordinate represents the first texel (the lowest byte) in texture memory.

## Internal Objects ## {#webgpu-internal-objects}

An <dfn dfn>internal object</dfn> is a conceptual, non-exposed WebGPU object.
[=Internal objects=] track the state of an API object and hold any underlying implementation.
If the state of a particular [=internal object=] can change in parallel from multiple [=agents=],
those changes are always atomic with respect to all [=agents=].

Note: An "[=agent=]" refers to a JavaScript "thread" (i.e. main thread, or Web Worker).

### Invalid Objects ### {#invalid-objects}

If an object is sucessfully created, it is <dfn dfn>valid</dfn> at that moment.
An [=internal object=] may be <dfn dfn>invalid</dfn>.
It may become [=invalid=] during its lifetime, but it will never become valid again.

<div class=note>
    [=Invalid=] objects result from a number of situations, including:

      - If there is an error in the creation of an object, it is immediately invalid.
        This can happen, for example, if the [=object descriptor=] doesn't describe a valid
        object, or if there is not enough memory to allocate a [=resource=].
      - If an object is explicitly destroyed (e.g. {{GPUBuffer/destroy()|GPUBuffer.destroy()}}),
        it becomes invalid.
      - If the [=device=] that owns an object is lost, the object becomes invalid.
</div>

## WebGPU Interfaces ## {#webgpu-interfaces}

A <dfn dfn>WebGPU interface</dfn> is an exposed interface which encapsulates an [=internal object=].
It provides the interface through which the [=internal object=]'s state is changed.

As a matter of convention, if a [=WebGPU interface=] is referred to as [=invalid=],
it means that the [=internal object=] it encapsulates is [=invalid=].

Any interface which includes {{GPUObjectBase}} is a [=WebGPU interface=].

<script type=idl>
interface mixin GPUObjectBase {
    attribute DOMString? label;
};
</script>

{{GPUObjectBase}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>label</dfn>
    ::
        A label which can be used by development tools (such as error/warning messages,
        browser developer tools, or platform debugging utilities) to identify the underlying
        [=internal object=] to the developer.
        It has no specified format, and therefore cannot be reliably machine-parsed.

        In any given situation, the user agent may or may not choose to use this label.
</dl>

{{GPUObjectBase}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>\[[device]]</dfn>, of type [=device=], readonly
    ::
        An internal slot holding the [=device=] which owns the [=internal object=].
</dl>

## Object Descriptors ## {#object-descriptors}

An <dfn dfn>object descriptor</dfn> holds the information needed to create an object,
which is typically done via one of the `create*` methods of {{GPUDevice}}.

<script type=idl>
dictionary GPUObjectDescriptorBase {
    DOMString label;
};
</script>

{{GPUObjectDescriptorBase}} has the following members:

<dl dfn-type=dict-member dfn-for=GPUObjectDescriptorBase>
    : <dfn>label</dfn>
    ::
        The initial value of {{GPUObjectBase/label|GPUObjectBase.label}}.
</dl>


Programming Model {#programming-model}
======================================

## Timelines ## {#programming-model-timelines}

*This section is non-normative.*

A computer system with a user agent at the front-end and GPU at the back-end
has components working on different timelines in parallel:

: <dfn dfn>Content timeline</dfn>
:: Associated with the execution of the Web script.
    It includes calling all methods described by this specification.

: <dfn dfn>Device timeline</dfn>
:: Associated with the GPU device operations
    that are issued by the user agent.
    It includes creation of adapters, devices, and GPU resources
    and state objects, which are typically synchronous operations from the point
    of view of the user agent part that controls the GPU,
    but can live in a separate OS process.

: <dfn dfn>Queue timeline</dfn>
:: Associated with the execution of operations
    on the compute units of the GPU. It includes actual draw, copy,
    and compute jobs that run on the GPU.

In this specification, asynchronous operations are used when the result value
depends on work that happens on any timeline other than the [=Content timeline=].
They are represented by callbacks and promises in JavaScript.

<div class="example">
{{GPUComputePassEncoder/dispatch(x, y, z)|GPUComputePassEncoder.dispatch()}}:

  1. User encodes a `dispatch` command by calling a method of the
    {{GPUComputePassEncoder}} which happens on the [=Content timeline=].
  2. User issues {{GPUQueue/submit(commandBuffers)|GPUQueue.submit()}} that hands over
    the {{GPUCommandBuffer}} to the user agent, which processes it
    on the [=Device timeline=] by calling the OS driver to do a low-level submission.
  3. The submit gets dispatched by the GPU thread scheduler onto the
    actual compute units for execution, which happens on the [=Queue timeline=].

</div>
<div class="example">
{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer()}}:

  1. User fills out a {{GPUBufferDescriptor}} and creates a {{GPUBuffer}} with it,
    which happens on the [=Content timeline=].
  2. User agent creates a low-level buffer on the [=Device timeline=].

</div>
<div class="example">
{{GPUBuffer/mapReadAsync()|GPUBuffer.mapReadAsync()}}:

  1. User requests to map a {{GPUBuffer}} on the [=Content timeline=] and
    gets a promise in return.
  2. User agent checks if the buffer is currently used by the GPU
    and makes a reminder to itself to check back when this usage is over.
  3. After the GPU operating on [=Queue timeline=] is done using the buffer,
    the user agent maps it to memory and [=resolves=] the promise.

</div>

## Memory ## {#programming-model-memory}

*This section is non-normative.*

Once a {{GPUDevice}} has been obtained during an application initialization routine,
we can describe the <dfn dfn>WebGPU platform</dfn> as consisting of the following layers:
  1. User agent implementing the specification.
  2. Operating system with low-level native API drivers for this device.
  3. Actual CPU and GPU hardware.

Each layer of the [=WebGPU platform=] may have different memory types
that the user agent needs to consider when implementing the specification:
  - The script-owned memory, such as an {{ArrayBuffer}} created by the script,
    is generally not accessible by a GPU driver.
  - A user agent may have different processes responsible for running
    the content and communication to the GPU driver.
    In this case, it uses inter-process shared memory to transfer data.
  - Dedicated GPUs have their own memory with high bandwidth,
    while integrated GPUs typically share memory with the system.

Most [=physical resources=] are allocated in the memory of type
that is efficient for computation or rendering by the GPU.
When the user needs to provide new data to the GPU,
the data may first need to cross the process boundary in order to reach
the user agent part that communicates with the GPU driver.
Then it may need to be made visible to the driver,
which sometimes requires a copy into driver-allocated staging memory.
Finally, it may need to be transferred to the dedicated GPU memory,
potentially changing the internal layout into one
that is most efficient for GPUs to operate on.

All of these transitions are done by the WebGPU implementation of the user agent.

Note: This example describes the worst case, while in practice
the implementation may not need to cross the process boundary,
or may be able to expose the driver-managed memory directly to
the user behind an `ArrayBuffer`, thus avoiding any data copies.

## Resource usage ## {#programming-model-resource-usage}

Buffers and textures can be used by the GPU in multiple ways,
which can be split into two groups:

: <dfn dfn>Read-only usage</dfn>s
:: Usages like
    {{GPUBufferUsage/VERTEX|GPUBufferUsage.VERTEX}} or
    {{GPUTextureUsage/SAMPLED|GPUTextureUsage.SAMPLED}}
    don't change the contents of a resource.

: <dfn dfn>Mutating usage</dfn>s
:: Usages like {{GPUBufferUsage/STORAGE|GPUBufferUsage.STORAGE}}
    do change the contents of a resource.

Issue(gpuweb/gpuweb#296): Consider merging all read-only usages.

Textures may consist of separate mipmap levels and array layers,
which can be used differently at any given time. For the matter of usage validation,
we'll call them <dfn dfn>subresources</dfn>.

The **main usage rule** is that any [=subresource=]
at any given time can only be in either:
  - a combination of [=read-only usage=]s
  - a single [=mutating usage=]

Enforcing this rule allows the API to limit when data races can occur
when working with memory. That property makes applications written against
WebGPU more likely to run without modification on different platforms.

Generally, when an implementation processes an operation that uses a [=subresource=]
in a different way than its current usage allows, it schedules a transition of the resource
into the new state. In some cases, like within an open {{GPURenderPassEncoder}}, such a
transition is impossible due to the hardware limitations.
We define these places as <dfn dfn>usage scopes</dfn>:
each [=subresource=] must not change usage within the [=usage scope=].

For example, binding the same buffer for {{GPUBufferUsage/STORAGE}} as well as for
{{GPUBufferUsage/VERTEX}} within the same {{GPURenderPassEncoder}} would put the encoder
as well as the owning {{GPUCommandEncoder}} into the error state. Since
{{GPUBufferUsage/STORAGE}} is the only [=mutating usage=] for a buffer
that is valid inside a render pass, if it's present,
this buffer can't be used in any other way within this pass.

The [=subresources=] of textures included in the views provided to
{{GPURenderPassColorAttachmentDescriptor/attachment|GPURenderPassColorAttachmentDescriptor.attachment}} and
{{GPURenderPassColorAttachmentDescriptor/resolveTarget|GPURenderPassColorAttachmentDescriptor.resolveTarget}}
are considered to have {{GPUTextureUsage/OUTPUT_ATTACHMENT}}
for the [=usage scope=] of this render pass.

Issue(gpuweb/gpuweb#514): Document read-only states for depth views.


Core Internal Objects {#core-internal-objects}
==============================================

## Adapters ## {#adapters}

An <dfn dfn>adapter</dfn> represents an implementation of WebGPU on the system.
Each adapter identifies both an instance of a hardware accelerator (e.g. GPU or CPU) and
an instance of a browser's implementation of WebGPU on top of that accelerator.

If an [=adapter=] becomes unavailable, it becomes [=invalid=].
Once invalid, it never becomes valid again.
Any [=devices=] on the adapter, and [=internal objects=] owned by those devices,
also become invalid.

Note:
An [=adapter=] may be a physical display adapter (GPU), but it could also be
a software renderer.
A returned [=adapter=] could refer to different physical adapters, or to
different browser codepaths or system drivers on the same physical adapters.
Applications can hold onto multiple [=adapters=] at once (via {{GPUAdapter}})
(even if some are [=invalid=]),
and two of these could refer to different instances of the same physical
configuration (e.g. if the GPU was reset or disconnected and reconnected).

An [=adapter=] has the following internal slots:

<dl dfn-type=attribute dfn-for=adapter>
    : <dfn>\[[extensions]]</dfn>, of type sequence<{{GPUExtensionName}}>, readonly
    ::
        The extensions which can be used to create devices on this adapter.

    : <dfn>\[[limits]]</dfn>, of type {{GPULimits}}, readonly
    ::
        The [=better|best=] limits which can be used to create devices on this adapter.

        Each adapter limit must be the same or [=better=] than its default value in {{GPULimits}}.
</dl>

[=Adapters=] are exposed via {{GPUAdapter}}.

## Devices ## {#devices}

A <dfn dfn>device</dfn> is the logical instantiation of an [=adapter=],
through which [=internal objects=] are created.
It can be shared across multiple [=agents=] (e.g. dedicated workers).

A [=device=] is the exclusive owner of all [=internal objects=] created from it:
when the [=device=] is lost, it and all objects created on it (directly, e.g.
{{GPUDevice/createTexture()}}, or indirectly, e.g. {{GPUTexture/createView()}}) become
[=invalid=].

Issue: Define "ownership".

A [=device=] has the following internal slots:

<dl dfn-type=attribute dfn-for=device>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        The [=adapter=] from which this device was created.

    : <dfn>\[[extensions]]</dfn>, of type sequence<{{GPUExtensionName}}>, readonly
    ::
        The extensions which can be used on this device.
        No additional extensions can be used, even if the underlying [=adapter=] can support them.

    : <dfn>\[[limits]]</dfn>, of type {{GPULimits}}, readonly
    ::
        The limits which can be used on this device.
        No [=better=] limits can be used, even if the underlying [=adapter=] can support them.
</dl>

<div algorithm>
    When <dfn dfn>a new device</dfn> |device| is created from [=adapter=] |adapter|
    with {{GPUDeviceDescriptor}} |descriptor|:

      - Set |device|.{{device/[[adapter]]}} to |adapter|.

      - Set |device|.{{device/[[extensions]]}} to |descriptor|.{{GPUDeviceDescriptor/extensions}}.

      - Set |device|.{{device/[[limits]]}} to |descriptor|.{{GPUDeviceDescriptor/limits}}.
</div>

[=Devices=] are exposed via {{GPUDevice}}.


Initialization {#initialization}
================================

## Examples ## {#initialization-examples}

Issue:
Need a robust example like the one in ErrorHandling.md, which handles all situations.
Possibly also include a simple example with no handling.

## navigator.gpu ## {#navigator-gpu}

A {{GPU}} object is available via `navigator.gpu` on the {{Window}}:

<script type=idl>
[Exposed=Window]
partial interface Navigator {
    [SameObject] readonly attribute GPU gpu;
};
</script>

... as well as on dedicated workers:

<script type=idl>
[Exposed=DedicatedWorker]
partial interface WorkerNavigator {
    [SameObject] readonly attribute GPU gpu;
};
</script>

## GPU ## {#gpu-interface}

<dfn interface>GPU</dfn> is the entry point to WebGPU.

<script type=idl>
[Exposed=(Window, DedicatedWorker)]
interface GPU {
    Promise<GPUAdapter> requestAdapter(optional GPURequestAdapterOptions options = {});
};
</script>

{{GPU}} has the methods defined by the following sections.

### <dfn method for=GPU>requestAdapter(options)</dfn> ### {#requestadapter}

<div algorithm=requestAdapter>
    **Arguments:**
      - optional {{GPURequestAdapterOptions}} |options| = {}

    **Returns:** |promise|, of type Promise<{{GPUAdapter}}>.

    Requests an [=adapter=] from the user agent.
    The user agent chooses whether to return an adapter, and, if so,
    chooses according to the provided |options|.

    Returns [=a new promise=], |promise|.
    On the [=Device timeline=], the following steps occur:

      - If the user agent chooses to return an adapter:

          - The user agent chooses an [=adapter=] |adapter| according to the rules in
            [[#adapter-selection]].

          - |promise| [=resolves=] with a new {{GPUAdapter}} encapsulating |adapter|.

      - Otherwise, |promise| [=rejects=] with an {{OperationError}}.
</div>

#### Adapter Selection #### {#adapter-selection}

<dfn dictionary>GPURequestAdapterOptions</dfn>
provides hints to the user agent indicating what
configuration is suitable for the application.

<script type=idl>
dictionary GPURequestAdapterOptions {
    GPUPowerPreference powerPreference;
};
</script>

<script type=idl>
enum GPUPowerPreference {
    "low-power",
    "high-performance"
};
</script>

{{GPURequestAdapterOptions}} has the following members:

<dl dfn-type=dict-member dfn-for=GPURequestAdapterOptions>
    : <dfn>powerPreference</dfn>
    ::
        Optionally provides a hint indicating what class of [=adapter=] should be selected from
        the system's available adapters.

        The value of this hint may influence which adapter is chosen, but it must not
        influence whether an adapter is returned or not.

        Note:
        The primary utility of this hint is to influence which GPU is used in a multi-GPU system.
        For instance, some laptops have a low-power integrated GPU and a high-performance
        discrete GPU.

        Note:
        Depending on the exact hardware configuration, such as battery status and attached displays
        or removable GPUs, the user agent may select different [=adapters=] given the same power
        preference.
        Typically, given the same hardware configuration and state and
        `powerPreference`, the user agent is likely to select the same adapter.

        It must be one of the following values:

        <dl dfn-type=enum-value dfn-for=GPUPowerPreference>
            : `undefined` (or not present)
            ::
                Provides no hint to the user agent.

            : <dfn>"low-power"</dfn>
            ::
                Indicates a request to prioritize power savings over performance.

                Note:
                Generally, content should use this if it is unlikely to be constrained by drawing
                performance; for example, if it renders only one frame per second, draws only relatively
                simple geometry with simple shaders, or uses a small HTML canvas element.
                Developers are encouraged to use this value if their content allows, since it may
                significantly improve battery life on portable devices.

            : <dfn>"high-performance"</dfn>
            ::
                Indicates a request to prioritize performance over power consumption.

                Note:
                By choosing this value, developers should be aware that, for [=devices=] created on the
                resulting adapter, user agents are more likely to force device loss, in order to save
                power by switching to a lower-power adapter.
                Developers are encouraged to only specify this value if they believe it is absolutely
                necessary, since it may significantly decrease battery life on portable devices.
        </dl>
</dl>

## <dfn interface>GPUAdapter</dfn> ## {#gpu-adapter}

A {{GPUAdapter}} encapsulates an [=adapter=],
and describes its capabilities (extensions and limits).

To get a {{GPUAdapter}}, use {{GPU/requestAdapter()}}.

<script type=idl>
interface GPUAdapter {
    readonly attribute DOMString name;
    readonly attribute FrozenArray<GPUExtensionName> extensions;
    //readonly attribute GPULimits limits; Don't expose higher limits for now.

    Promise<GPUDevice> requestDevice(optional GPUDeviceDescriptor descriptor = {});
};
</script>

{{GPUAdapter}} has:

  - These attributes:
    <dl dfn-type=attribute dfn-for=GPUAdapter>
        : <dfn>name</dfn>
        ::
            A human-readable name identifying the adapter.
            The contents are implementation-defined.

        : <dfn>extensions</dfn>
        ::
            Accessor for `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[extensions]]}}.
    </dl>

  - These internal slots:
    <dl dfn-type=attribute dfn-for=GPUAdapter>
        : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
        ::
            An internal slot holding the [=adapter=] to which this {{GPUAdapter}}
            refers.
    </dl>

  - The methods defined by the following sub-sections.

### <dfn method for=GPUAdapter>requestDevice(descriptor)</dfn> ### {#requestdevice}

<div algorithm=requestDevice>
    **Arguments:**
        - optional {{GPUDeviceDescriptor}} |descriptor| = {}

    **Returns:** |promise|, of type Promise<{{GPUDevice}}>.

    Requests a [=device=] from the [=adapter=].

    Returns [=a new promise=], |promise|.
    On the [=Device timeline=], the following steps occur:

      - If the user agent can fulfill the request and
        the [$requestDevice Valid Usage|valid usage$] rules are met:

          - |promise| [=resolves=] to a new {{GPUDevice}} object encapsulating
            [=a new device=] with the capabilities described by |descriptor|.

      - Otherwise, |promise| [=rejects=] with an {{OperationError}}.
</div>

<div algorithm class=validusage>
    <dfn abstract-op>requestDevice Valid Usage</dfn>

    Given an [=adapter=] |adapter| and a {{GPUDeviceDescriptor}} |descriptor|,
    the following validation rules apply:

      - The set of {{GPUExtensionName}} values in
        |descriptor|.{{GPUDeviceDescriptor/extensions}}
        must be a subset of those in |adapter|.{{adapter/[[extensions]]}}.

      - For each type of limit in {{GPULimits}}, the value of that limit in
        |descriptor|.{{GPUDeviceDescriptor/limits}}
        must be no [=better=] than the value of that limit in
        |adapter|.{{adapter/[[limits]]}}.
</div>

#### <dfn dictionary>GPUDeviceDescriptor</dfn> #### {#gpudevicedescriptor}

{{GPUDeviceDescriptor}} describes a device request.

<script type=idl>
dictionary GPUDeviceDescriptor : GPUObjectDescriptorBase {
    sequence<GPUExtensionName> extensions = [];
    GPULimits limits = {};
};
</script>

<dl dfn-type=dict-member dfn-for=GPUDeviceDescriptor>
    : <dfn>extensions</dfn>
    ::
        The set of {{GPUExtensionName}} values in this sequence defines the exact set of
        extensions that must be enabled on the device.

    : <dfn>limits</dfn>
    ::
        Defines the exact limits that must be enabled on the device.
</dl>

#### <dfn enum>GPUExtensionName</dfn> #### {#gpuextensionname}

Each {{GPUExtensionName}} identifies a set of functionality which, if available,
allows additional usages of WebGPU that would have otherwise been invalid.

<script type=idl>
enum GPUExtensionName {
    "texture-compression-bc"
};
</script>

<dl dfn-type=enum-value dfn-for=GPUExtensionName>
    : <dfn>"texture-compression-bc"</dfn>
    ::
        Issue: Write a spec section for this, and link to it.
</dl>

#### <dfn dictionary>GPULimits</dfn> #### {#gpulimits}

{{GPULimits}} describes various limits in the usage of WebGPU on a device.

One limit value may be <dfn dfn>better</dfn> than another.
For each limit, "better" is defined.

Note:
Setting "better" limits may not necessarily be desirable.
While they enable strictly more programs to be valid, they may have a performance impact.
Because of this, and to improve portability across devices and implementations,
applications should generally request the "worst" limits that work for their content.

<script type=idl>
dictionary GPULimits {
    GPUSize32 maxBindGroups = 4;
    GPUSize32 maxDynamicUniformBuffersPerPipelineLayout = 8;
    GPUSize32 maxDynamicStorageBuffersPerPipelineLayout = 4;
    GPUSize32 maxSampledTexturesPerShaderStage = 16;
    GPUSize32 maxSamplersPerShaderStage = 16;
    GPUSize32 maxStorageBuffersPerShaderStage = 4;
    GPUSize32 maxStorageTexturesPerShaderStage = 4;
    GPUSize32 maxUniformBuffersPerShaderStage = 12;
};
</script>

<dl dfn-type=dict-member dfn-for=GPULimits>
    : <dfn>maxBindGroups</dfn>
    ::
        The maximum number of {{GPUBindGroupLayout|GPUBindGroupLayouts}}
        allowed in {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxDynamicUniformBuffersPerPipelineLayout</dfn>
    ::
        The maximum number of {{GPUBindGroupLayoutDescriptor/bindings}} for which:

          - {{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/"uniform-buffer"}}, and
          - {{GPUBindGroupLayoutBinding/hasDynamicOffset}} is true,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxDynamicStorageBuffersPerPipelineLayout</dfn>
    ::
        The maximum number of {{GPUBindGroupLayoutDescriptor/bindings}} for which:

          - {{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/"storage-buffer"}}, and
          - {{GPUBindGroupLayoutBinding/hasDynamicOffset}} is true,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxSampledTexturesPerShaderStage</dfn>
    ::
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/bindings}} for which:

          - {{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/"sampled-texture"}}, and
          - {{GPUBindGroupLayoutBinding/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxSamplersPerShaderStage</dfn>
    ::
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/bindings}} for which:

          - {{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/"sampler"}}, and
          - {{GPUBindGroupLayoutBinding/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxStorageBuffersPerShaderStage</dfn>
    ::
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/bindings}} for which:

          - {{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/"storage-buffer"}}, and
          - {{GPUBindGroupLayoutBinding/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxStorageTexturesPerShaderStage</dfn>
    ::
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/bindings}} for which:

          - {{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/"readonly-storage-texture"}} or
            {{GPUBindingType/"writeonly-storage-texture"}}, and
          - {{GPUBindGroupLayoutBinding/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].

    : <dfn>maxUniformBuffersPerShaderStage</dfn>
    ::
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutDescriptor/bindings}} for which:

          - {{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/uniform-buffer}}, and
          - {{GPUBindGroupLayoutBinding/visibility}} includes `stage`,

        across all {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

        Higher is [=better=].
</dl>

## <dfn interface>GPUDevice</dfn> ## {#gpu-device}

A {{GPUDevice}} encapsulates a [=device=] and exposes
the functionality of that device.

{{GPUDevice}} is the top-level interface through which [=WebGPU interfaces=] are created.

To get a {{GPUDevice}}, use {{GPUAdapter/requestDevice()}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker), Serializable]
interface GPUDevice : EventTarget {
    [SameObject] readonly attribute GPUAdapter adapter;
    readonly attribute FrozenArray<GPUExtensionName> extensions;
    readonly attribute object limits;

    [SameObject] readonly attribute GPUQueue defaultQueue;

    GPUBuffer createBuffer(GPUBufferDescriptor descriptor);
    GPUMappedBuffer createBufferMapped(GPUBufferDescriptor descriptor);
    GPUTexture createTexture(GPUTextureDescriptor descriptor);
    GPUSampler createSampler(optional GPUSamplerDescriptor descriptor = {});

    GPUBindGroupLayout createBindGroupLayout(GPUBindGroupLayoutDescriptor descriptor);
    GPUPipelineLayout createPipelineLayout(GPUPipelineLayoutDescriptor descriptor);
    GPUBindGroup createBindGroup(GPUBindGroupDescriptor descriptor);

    GPUShaderModule createShaderModule(GPUShaderModuleDescriptor descriptor);
    GPUComputePipeline createComputePipeline(GPUComputePipelineDescriptor descriptor);
    GPURenderPipeline createRenderPipeline(GPURenderPipelineDescriptor descriptor);

    GPUCommandEncoder createCommandEncoder(optional GPUCommandEncoderDescriptor descriptor = {});
    GPURenderBundleEncoder createRenderBundleEncoder(GPURenderBundleEncoderDescriptor descriptor);
};
GPUDevice includes GPUObjectBase;
</script>

{{GPUDevice}} has:

  - These attributes:
    <dl dfn-type=attribute dfn-for=GPUDevice>
        : <dfn>adapter</dfn>
        ::
            The {{GPUAdapter}} from which this device was created.

        : <dfn>extensions</dfn>
        ::
            A sequence containing the {{GPUExtensionName}}s of the extensions
            supported by the device (i.e. the ones with which it was created).

        : <dfn>limits</dfn>
        ::
            A {{GPULimits}} object exposing the limits
            supported by the device (i.e. the ones with which it was created).
    </dl>

  - These internal slots:
    <dl dfn-type=attribute dfn-for=GPUDevice>
        : <dfn>\[[device]]</dfn>, of type [=device=], readonly
        ::
            The [=device=] that this {{GPUDevice}} refers to.
    </dl>

  - The methods listed in its WebIDL definition above,
    which are defined elsewhere in this document.

{{GPUDevice}} objects are [=serializable objects=].

<div algorithm>
    <dfn abstract-op>The steps to serialize a GPUDevice object</dfn>,
    given |value|, |serialized|, and |forStorage|, are:
     1. If |forStorage| is true, throw a "{{DataCloneError}}".
     1. Set |serialized|.device to the value of |value|.{{GPUDevice/[[device]]}}.
</div>

<div algorithm>
    <dfn abstract-op>The steps to deserialize a GPUDevice object</dfn>,
    given |serialized| and |value|, are:
     1. Set |value|.{{GPUDevice/[[device]]}} to |serialized|.device.
</div>


# {{GPUBuffer}} # {#GPUBuffer}

A {{GPUBuffer}} represents a block of memory that can be used in GPU operations.
Data is stored in linear layout, meaning that each byte of the allocation can be
addressed by its offset from the start of the {{GPUBuffer}}, subject to alignment
restrictions depending on the operation. Some {{GPUBuffer|GPUBuffers}} can be
mapped which makes the block of memory accessible via an {{ArrayBuffer}} called
its mapping.

{{GPUBuffer|GPUBuffers}} can be created via the following functions:

 - {{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer(descriptor)}}
     that returns a new buffer in the [=buffer state/unmapped=] state.
 - {{GPUDevice/createBufferMapped(descriptor)|GPUDevice.createBufferMapped(descriptor)}}
     that returns a new buffer in the [=buffer state/mapped for writing=] state and its
     mapping.

<script type=idl>
[Serializable]
interface GPUBuffer {
    Promise<ArrayBuffer> mapReadAsync();
    Promise<ArrayBuffer> mapWriteAsync();
    void unmap();

    void destroy();
};
GPUBuffer includes GPUObjectBase;
</script>

{{GPUBuffer}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBuffer">
    : <dfn>\[[size]]</dfn> of type {{GPUSize64}}.
    ::
        The length of the {{GPUBuffer}} allocation in bytes.

    : <dfn>\[[usage]]</dfn> of type {{GPUBufferUsageFlags}}.
    ::
        The allowed usages for this {{GPUBuffer}}.

    : <dfn>\[[state]]</dfn> of type [=buffer state=].
    ::
        The current state of the {{GPUBuffer}}.

    : <dfn>\[[mapping]]</dfn> of type {{ArrayBuffer}} or {{Promise}} or `null`.
    ::
        The mapping for this {{GPUBuffer}}.
</dl>

Each {{GPUBuffer}} has a current <dfn dfn>buffer state</dfn> on the [=Content timeline=]
which is one of the following:

 - "<dfn dfn for="buffer state">mapped for reading</dfn>" where the {{GPUBuffer}} is
     available for CPU operations reading its content.
 - "<dfn dfn for="buffer state">mapped for writing</dfn>" where the {{GPUBuffer}} is
     available for CPU operations writing its content.
 - "<dfn dfn for="buffer state">mapping pending for reading</dfn>" where the {{GPUBuffer}} is
     being made available for reading its content.
 - "<dfn dfn for="buffer state">mapping pending for writing</dfn>" where the {{GPUBuffer}} is
     being made available for writing its content.
 - "<dfn dfn for="buffer state">unmapped</dfn>" where the {{GPUBuffer}} is
     available for GPU operations.
 - "<dfn dfn for="buffer state">destroyed</dfn>" where the {{GPUBuffer}} is
     no longer available for any operations except {{GPUBuffer/destroy}}.

Note:
{{GPUBuffer/[[size]]}} and {{GPUBuffer/[[usage]]}} are immutable once the
{{GPUBuffer}} has been created.

<div class=note>
    {{GPUBuffer}} has a state machine where the states are:

     - [=buffer state/unmapped=] and [=buffer state/destroyed=] with a `null`
        {{GPUBuffer/[[mapping]]}}
     - [=buffer state/mapped for reading=] and [=buffer state/mapped for writing=]
        with an {{ArrayBuffer}} typed {{GPUBuffer/[[mapping]]}}.
     - [=buffer state/mapping pending for reading=] and [=buffer state/mapping pending for writing=]
        with a {{Promise}} typed {{GPUBuffer/[[mapping]]}}.
</div>

{{GPUBuffer}} is {{Serializable}}. It is a reference to an internal buffer
object, and {{Serializable}} means that the reference can be *copied* between
realms (threads/workers), allowing multiple realms to access it concurrently.
Since {{GPUBuffer}} has internal state (mapped, destroyed), that state is
internally-synchronized - these state changes occur atomically across realms.

## Buffer creation ## {#buffer-creation}

### {{GPUBufferDescriptor}} ### {#GPUBufferDescriptor}

This specifies the options to use in creating a {{GPUBuffer}}.

<script type=idl>
dictionary GPUBufferDescriptor : GPUObjectDescriptorBase {
    required GPUSize64 size;
    required GPUBufferUsageFlags usage;
};
</script>

<!-- TODO(kangz): Describe what are the {{device}} [[allowed buffer usages]] -->

<dl dfn-type="abstract-op">
    : <dfn>validating GPUBufferDescriptor</dfn>(device, descriptor)
    ::
        <div algorithm="validation GPUBufferDescriptor(device, descriptor)">
            1. If device is lost return false.
            1. If any of the bits of |descriptor|'s {{GPUBufferDescriptor/usage}} aren't present in this device's [[allowed buffer usages]] return false.
            1. If both the {{GPUBufferUsage/MAP_READ}} and {{GPUBufferUsage/MAP_WRITE}} bits of |descriptor|'s {{GPUBufferDescriptor/usage}} attribute are set, return false.
            1. Return true.
        </div>
</dl>

### {{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer(descriptor)}} ### {#GPUDevice-createBuffer}

<dl dfn-type="method" dfn-for="GPUDevice">
    : <dfn>createBuffer(descriptor)</dfn>
    ::
        <div algorithm="GPUDevice.createBuffer(descriptor)">
            1. If the result of [$validating GPUBufferDescriptor$](this, descriptor) is false:

                1. Record a validation error in the current scope.
                <!-- TODO(kangz): Once we have a description of the error monad, explain what the error buffer is. -->
                1. Create an [=invalid=] {{GPUBuffer}} and return the result.

            1. Let |b| be a new {{GPUBuffer}} object.
            1. Set the {{GPUBuffer/[[size]]}} slot of |b| to the value of the {{GPUBufferDescriptor/size}} attribute of |descriptor|.
            1. Set the {{GPUBuffer/[[usage]]}} slot of |b| to the value of the {{GPUBufferDescriptor/usage}} attribute of |descriptor|.
            1. Set the {{GPUBuffer/[[state]]}} internal slot of |b| to [=buffer state/unmapped=].
            1. Set the {{GPUBuffer/[[mapping]]}} internal slot of |b| to `null`.
            1. Set each byte of |b|'s allocation to zero.
            1. Return |b|.
        </div>
</dl>

### {{GPUDevice/createBufferMapped(descriptor)|GPUDevice.createBufferMapped(descriptor)}} ### {#GPUDevice-createBufferMapped}

<dl dfn-type="method" dfn-for="GPUDevice">
    : <dfn>createBufferMapped(descriptor)</dfn>
    ::
        <div algorithm="GPUDevice.createBufferMapped(descriptor)">
            1. If the result of [$validating GPUBufferDescriptor$](this, descriptor) is false:

                1. Record a validation error in the current scope.
                <!-- TODO(kangz): Once we have a description of the error monad, explain what the error buffer is. -->
                1. Create an invalid {{GPUBuffer}} and return the result.

            1. Let |b| be a new {{GPUBuffer}} object.
            1. Set the {{GPUBuffer/[[size]]}} slot of |b| to the value of the {{GPUBufferDescriptor/size}} attribute of |descriptor|.
            1. Let |m| be a zero-filled {{ArrayBuffer}} of size the {{GPUBuffer/[[size]]}} slot of |b|.
            1. Set the {{GPUBuffer/[[usage]]}} slot of |b| to the value of the {{GPUBufferDescriptor/usage}} attribute of |descriptor|.
            1. Set the {{GPUBuffer/[[state]]}} internal slot of |b| to [=buffer state/mapped for writing=].
            1. Set the {{GPUBuffer/[[mapping]]}} internal slot of |b| to |m|.
            1. Set each byte of |b|'s allocation to zero.
            1. Return a sequence containing |b| and |m| in that order.
        </div>
</dl>

## Buffer Destruction ## {#buffer-destruction}

An application that no longer requires a {{GPUBuffer}} can choose to lose
access to it before garbage collection by calling {{GPUBuffer/destroy()}}.

Note: This allows the user agent to reclaim the GPU memory associated with the {{GPUBuffer}}
once all previously submitted operations using it are complete.

<dl dfn-type="method" dfn-for="GPUBuffer">
    : <dfn>destroy()</dfn>
    ::
        <div algorithm="GPUBuffer.destroy()">
            <!-- TODO(kangz) handle error buffers once we have a description of the error monad -->
            1. If the {{[[state]]}} slot of |this| is [=buffer state/mapped for reading=] or [=buffer state/mapped for writing=]:

                1. Run the steps to unmap `"this"`

            1. Set the {{[[state]]}} slot of |this| to [=buffer state/destroyed=]
        </div>
</dl>

## Buffer Usage ## {#buffer-usage}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferUsageFlags;
interface GPUBufferUsage {
    const GPUBufferUsageFlags MAP_READ  = 0x0001;
    const GPUBufferUsageFlags MAP_WRITE = 0x0002;
    const GPUBufferUsageFlags COPY_SRC  = 0x0004;
    const GPUBufferUsageFlags COPY_DST  = 0x0008;
    const GPUBufferUsageFlags INDEX     = 0x0010;
    const GPUBufferUsageFlags VERTEX    = 0x0020;
    const GPUBufferUsageFlags UNIFORM   = 0x0040;
    const GPUBufferUsageFlags STORAGE   = 0x0080;
    const GPUBufferUsageFlags INDIRECT  = 0x0100;
};
</script>

## Buffer Mapping ## {#buffer-mapping}

An application can request to map a {{GPUBuffer}} to get its mapping which is
an {{ArrayBuffer}} representing the {{GPUBuffer}}'s allocation. Mappings are
requested asynchronously so that the user agent can ensure the GPU finished
using the {{GPUBuffer}} before the application gets its mapping. Mappings can
be requested for reading with {{GPUBuffer/mapReadAsync}} or writing with
{{GPUBuffer/mapWriteAsync}}. A mapped {{GPUBuffer}} cannot be used by the GPU
and must be unmapped using {{GPUBuffer/unmap}} before it can be used on the
[=Queue timeline=].

Issue: Add client-side validation that a mapped buffer can only be unmapped and destroyed on the worker on which it was mapped.

### {{GPUBuffer/mapReadAsync|GPUDevice.mapReadAsync}} ### {#GPUBuffer-mapReadAsync}

<dl dfn-type="method" dfn-for="GPUBuffer">
    : <dfn>mapReadAsync()</dfn>
    ::
        <div algorithm="GPUBuffer.mapReadAsync()">

            Issue: Handle error buffers once we have a description of the error monad.

            1. If the {{[[usage]]}} slot of |this| doesn't contain the {{GPUBufferUsage/MAP_READ}} bit or
                if {{[[state]]}} isn't [=buffer state/unmapped=]:

                1. Record a validation error on the current scope.
                1. Return [=a promise rejected with=] an {{AbortError}}.

                Issue: Specify that the rejection happens on the device timeline.

            1. Let |p| be a new {{Promise}}.
            1. Set the {{[[mapping]]}} slot of |this| to |p|.
            1. Set the {{[[state]]}} slot of |this| to [=buffer state/mapping pending for reading=].
            1. Enqueue an operation on the [=Queue timeline=] that will execute the following:

                1. Let |m| be a new {{ArrayBuffer}} of size the {{[[size]]}} of |this|.
                1. Set the content of |m| to the content of |this|'s allocation.
                1. Set the {{[[state]]}} slot of |this| to [=buffer state/mapped for reading=].
                1. If |p| is pending:

                    1. Resolve |p| with |m|.

            1. Return |p|.
        </div>
</dl>

### {{GPUBuffer/mapWriteAsync|GPUDevice.mapWriteAsync}} ### {#GPUBuffer-mapWriteAsync}

<dl dfn-type="method" dfn-for="GPUBuffer">
    : <dfn>mapWriteAsync()</dfn>
    ::
        <div algorithm="GPUBuffer.mapWriteAsync()">

            Issue: Handle error buffers once we have a description of the error monad.

            1. If the {{[[usage]]}} slot of |this| doesn't contain the {{GPUBufferUsage/MAP_WRITE}} bit or
                if {{[[state]]}} isn't [=buffer state/unmapped=]:

                1. Record a validation error on the current scope.
                1. Return [=a promise rejected with=] an {{AbortError}}.

                Issue: Specify that the rejection happens on the device timeline.

            1. Let |p| be a new {{Promise}}.
            1. Set the {{[[mapping]]}} slot of |this| to |p|.
            1. Set the {{[[state]]}} slot of |this| to [=buffer state/mapping pending for writing=].
            1. Enqueue an operation on the [=Queue timeline=] that will execute the following:

                1. Let |m| be a new {{ArrayBuffer}} of size the {{[[size]]}} of |this| that is filled with zeroes.
                1. Set the {{[[state]]}} slot of |this| to [=buffer state/mapped for writing=].
                1. If |p| is pending:

                    1. Resolve |p| with |m|.

            1. Return |p|.
        </div>
</dl>

### {{GPUBuffer/unmap|GPUBuffer.unmap()}} ### {#GPUBuffer-unmap}

<dl dfn-type="method" dfn-for="GPUBuffer">
    : <dfn>unmap()</dfn>
    ::
        <div algorithm="GPUBuffer.unmap()">

            1. If the {{[[state]]}} slot of |this| is [=buffer state/unmapped=] or [=buffer state/destroyed=]:

                1. Record a validation error on the current scope.
                1. Return.

            1. If the {{[[mapping]]}} slot of |this| is a {{Promise}}:

                1. [=Reject=] {{[[mapping]]}} with an {{AbortError}}.
                1. Set the {{[[mapping]]}} slot of |this| to null.

            1. If the {{[[mapping]]}} slot of |this| is an {{ArrayBuffer}}:

                1. If the {{[[state]]}} slot of this is [=buffer state/mapped for writing=]:

                    1. Enqueue an operation on the [=Queue timeline=] that updates |this|'s allocation to the content of the {{ArrayBuffer}} in the {{[[mapping]]}} slot of |this|.

                1. Detach |this|.{{[[mapping]]}} from its content.
                1. Set the {{[[mapping]]}} slot of |this| to null.

            1. Set the {{[[state]]}} slot of |this| to [=buffer state/unmapped=].

        </div>
</dl>

Textures {#textures}
====================

## GPUTexture ## {#texture}

<script type=idl>
[Serializable]
interface GPUTexture {
    GPUTextureView createView(optional GPUTextureViewDescriptor descriptor = {});

    void destroy();
};
GPUTexture includes GPUObjectBase;
</script>

### Texture Creation ### {#texture-creation}

<script type=idl>
dictionary GPUTextureDescriptor : GPUObjectDescriptorBase {
    required GPUExtent3D size;
    GPUIntegerCoordinate arrayLayerCount = 1;
    GPUIntegerCoordinate mipLevelCount = 1;
    GPUSize32 sampleCount = 1;
    GPUTextureDimension dimension = "2d";
    required GPUTextureFormat format;
    required GPUTextureUsageFlags usage;
};
</script>

<script type=idl>
enum GPUTextureDimension {
    "1d",
    "2d",
    "3d"
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUTextureUsageFlags;
interface GPUTextureUsage {
    const GPUTextureUsageFlags COPY_SRC          = 0x01;
    const GPUTextureUsageFlags COPY_DST          = 0x02;
    const GPUTextureUsageFlags SAMPLED           = 0x04;
    const GPUTextureUsageFlags STORAGE           = 0x08;
    const GPUTextureUsageFlags OUTPUT_ATTACHMENT = 0x10;
};
</script>

## GPUTextureView ## {#texture-view}

<script type=idl>
interface GPUTextureView {
};
GPUTextureView includes GPUObjectBase;
</script>

### Texture View Creation ### {#texture-view-creation}

<script type=idl>
dictionary GPUTextureViewDescriptor : GPUObjectDescriptorBase {
    GPUTextureFormat format;
    GPUTextureViewDimension dimension;
    GPUTextureAspect aspect = "all";
    GPUIntegerCoordinate baseMipLevel = 0;
    GPUIntegerCoordinate mipLevelCount = 0;
    GPUIntegerCoordinate baseArrayLayer = 0;
    GPUIntegerCoordinate arrayLayerCount = 0;
};
</script>

<!-- TODO(kainino0x): Make this a standalone algorithm used in the createView algorithm. -->
<!-- TODO(kainino0x): The references to GPUTextureDescriptor here should actually refer to
internal slots of a [=texture=] internal object once we have one. -->

<div algorithm="resolving GPUTextureViewDescriptor defaults">

  * {{GPUTextureViewDescriptor/format}}:
    If unspecified, defaults to |texture|.{{GPUTextureDescriptor/format}}.

  * {{GPUTextureViewDescriptor/dimension}}:
    If unspecified:
      - If |texture|.{{GPUTextureDescriptor/dimension}} is {{GPUTextureDimension/"1d"}},
        defaults to {{GPUTextureViewDimension/"1d"}}.
      - If |texture|.{{GPUTextureDescriptor/dimension}} is {{GPUTextureDimension/"2d"}}:
          - If |texture|.{{GPUTextureDescriptor/arrayLayerCount}} is greater than 1
            and {{GPUTextureViewDescriptor/arrayLayerCount}} is 0,
            defaults to {{GPUTextureViewDimension/"2d-array"}}.
          - Otherwise, defaults to {{GPUTextureViewDimension/"2d"}}.
      - If |texture|.{{GPUTextureDescriptor/dimension}} is {{GPUTextureDimension/"3d"}},
        defaults to {{GPUTextureViewDimension/"3d"}}.

  * {{GPUTextureViewDescriptor/mipLevelCount}}:
    If 0, defaults to |texture|.{{GPUTextureDescriptor/mipLevelCount}} &minus; {{GPUTextureViewDescriptor/baseMipLevel}}.

  * {{GPUTextureViewDescriptor/arrayLayerCount}}:
    If 0, defaults to |texture|.{{GPUTextureDescriptor/arrayLayerCount}} &minus; {{GPUTextureViewDescriptor/baseArrayLayer}}.

</div>

<script type=idl>
enum GPUTextureViewDimension {
    "1d",
    "2d",
    "2d-array",
    "cube",
    "cube-array",
    "3d"
};
</script>

<script type=idl>
enum GPUTextureAspect {
    "all",
    "stencil-only",
    "depth-only"
};
</script>

## Texture Formats ## {#texture-formats}

The name of the format specifies the order of components, bits per component,
and data type for the component.

  * `r`, `g`, `b`, `a` = red, green, blue, alpha
  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

If the format has the `-srgb` suffix, then sRGB conversions from gamma to linear
and vice versa are applied during the reading and writing of color values in the
shader. Compressed texture formats are provided by extensions. Their naming
should follow the convention here, with the texture name as a prefix. e.g.
`etc2-rgba8unorm`.

<script type=idl>
enum GPUTextureFormat {
    // 8-bit formats
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",

    // 16-bit formats
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",

    // 32-bit formats
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    // Packed 32-bit formats
    "rgb10a2unorm",
    "rg11b10float",

    // 64-bit formats
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",

    // 128-bit formats
    "rgba32uint",
    "rgba32sint",
    "rgba32float",

    // Depth and stencil formats
    "depth32float",
    "depth24plus",
    "depth24plus-stencil8"
};
</script>

  * The `depth24plus` family of formats ({{GPUTextureFormat/depth24plus}} and
    {{GPUTextureFormat/depth24plus-stencil8}})
    must have a depth-component precision of
    1 ULP &le; 1 / (2<sup>24</sup>).

    Note: This is unlike the 24-bit unsigned normalized format family typically
    found in native APIs, which has a precision of
    1 ULP = 1 / (2<sup>24</sup> &minus; 1).

<script type=idl>
enum GPUTextureComponentType {
    "float",
    "sint",
    "uint"
};
</script>

Samplers {#samplers}
====================

## GPUSampler ## {#sampler}

<script type=idl>
interface GPUSampler {
};
GPUSampler includes GPUObjectBase;
</script>

### Creation ### {#sampler-creation}

<script type=idl>
dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
    GPUAddressMode addressModeU = "clamp-to-edge";
    GPUAddressMode addressModeV = "clamp-to-edge";
    GPUAddressMode addressModeW = "clamp-to-edge";
    GPUFilterMode magFilter = "nearest";
    GPUFilterMode minFilter = "nearest";
    GPUFilterMode mipmapFilter = "nearest";
    float lodMinClamp = 0;
    float lodMaxClamp = 0xffffffff; // TODO: What should this be? Was Number.MAX_VALUE.
    GPUCompareFunction compare = "never";
};
</script>

<script type=idl>
enum GPUAddressMode {
    "clamp-to-edge",
    "repeat",
    "mirror-repeat"
};
</script>

<script type=idl>
enum GPUFilterMode {
    "nearest",
    "linear"
};
</script>

<script type=idl>
enum GPUCompareFunction {
    "never",
    "less",
    "equal",
    "less-equal",
    "greater",
    "not-equal",
    "greater-equal",
    "always"
};
</script>


Resource Binding {#binding}
===========================

## GPUBindGroupLayout ## {#bind-group-layout}

A {{GPUBindGroupLayout}} defines the interface between a set of resources bound in a {{GPUBindGroup}} and their accessibility in shader stages.

<script type=idl>
[Serializable]
interface GPUBindGroupLayout {
};
GPUBindGroupLayout includes GPUObjectBase;
</script>

### Creation ### {#bind-group-layout-creation}

A {{GPUBindGroupLayout}} is created via {{GPUDevice/createBindGroupLayout()|GPUDevice.createBindGroupLayout()}}.

<script type=idl>
dictionary GPUBindGroupLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayoutBinding> bindings;
};
</script>

A {{GPUBindGroupLayoutBinding}} describes a single shader resource binding to be included in a {{GPUBindGroupLayout}}.

<script type=idl>
dictionary GPUBindGroupLayoutBinding {
    required GPUIndex32 binding;
    required GPUShaderStageFlags visibility;
    required GPUBindingType type;
    GPUTextureViewDimension viewDimension = "2d";
    GPUTextureComponentType textureComponentType = "float";
    boolean multisampled = false;
    boolean hasDynamicOffset = false;
    GPUTextureFormat storageTextureFormat;
};
</script>

  * {{GPUBindGroupLayoutBinding/binding}}:
    A unique identifier for a resource binding within a {{GPUBindGroupLayoutBinding}}, a corresponding {{GPUBindGroupBinding}}, and shader stages.

  * {{GPUBindGroupLayoutBinding/visibility}}:
    A bitset of the members of {{GPUShaderStage}}. Each set bit indicates that a {{GPUBindGroupLayoutBinding}}'s resource will be accessible from the
    associated shader stage.

<script type=idl>
typedef [EnforceRange] unsigned long GPUShaderStageFlags;
interface GPUShaderStage {
    const GPUShaderStageFlags VERTEX   = 0x1;
    const GPUShaderStageFlags FRAGMENT = 0x2;
    const GPUShaderStageFlags COMPUTE  = 0x4;
};
</script>

  * {{GPUBindGroupLayoutBinding/type}}:
    A member of {{GPUBindingType}} that indicates the intended usage of a resource binding in its visible {{GPUShaderStage}}s.

<script type=idl>
enum GPUBindingType {
    "uniform-buffer",
    "storage-buffer",
    "readonly-storage-buffer",
    "sampler",
    "sampled-texture",
    "readonly-storage-texture",
    "writeonly-storage-texture"
    // TODO: other binding types
};
</script>

  * {{GPUBindGroupLayoutBinding/viewDimension}}, {{GPUBindGroupLayoutBinding/multisampled}}:
    Describes the dimensionality of texture view bindings, and indicates if they are multisampled.

    Note: This allows Metal-based implementations to back the respective bind
    groups with `MTLArgumentBuffer` objects that are more efficient to bind at
    run-time.

  * {{GPUBindGroupLayoutBinding/hasDynamicOffset}}:
    For {{GPUBindingType/uniform-buffer}}, {{GPUBindingType/storage-buffer}}, and {{GPUBindingType/readonly-storage-buffer}} bindings,
    indicates that the binding has a dynamic offset. One offset must be passed to
    setBindGroup for each dynamic binding in increasing order of
    {{GPUBindGroupLayoutBinding/binding}} number.

A {{GPUBindGroupLayout}} object has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBindGroupLayout">
    : <dfn>\[[bindings]]</dfn> of type sequence<{{GPUBindGroupLayoutBinding}}>.
    ::
        The set of {{GPUBindGroupLayoutBinding}}s this {{GPUBindGroupLayout}} describes.
</dl>

### {{GPUDevice/createBindGroupLayout()|GPUDevice.createBindGroupLayout(GPUBindGroupLayoutDescriptor)}} ### {#GPUDevice-createBindGroupLayout}

<div algorithm="GPUDevice.createBindGroupLayout(descriptor)">

The <dfn method for="GPUDevice">createBindGroupLayout(|descriptor|)</dfn> method is used to create {{GPUBindGroupLayout}}s.

1. Ensure [=device validation=] is not violated.
1. Let |layout| be a new valid {{GPUBindGroupLayout}} object.
1. For each {{GPUBindGroupLayoutBinding}} |bindingDescriptor| in |descriptor|.{{GPUBindGroupLayoutDescriptor/bindings}}:
    1. Ensure |bindingDescriptor|.{{GPUBindGroupLayoutBinding/binding}} does not violate [=binding validation=].
    1. If |bindingDescriptor|.{{GPUBindGroupLayoutBinding/visibility}} includes {{GPUShaderStage/VERTEX}}
        , ensure [=vertex shader binding validation=] is not violated.
    1. If |bindingDescriptor|.{{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/uniform-buffer}}:
        1. Ensure [=uniform buffer validation=] is not violated.
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutBinding/hasDynamicOffset}} is `true`, ensure [=dynamic uniform buffer validation=] is not violated.
    1. If |bindingDescriptor|.{{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/storage-buffer}} or {{GPUBindingType/readonly-storage-buffer}}:
        1. Ensure [=storage buffer validation=] is not violated.
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutBinding/hasDynamicOffset}} is `true`, ensure [=dynamic storage buffer validation=] is not violated.
    1. If |bindingDescriptor|.{{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/sampled-texture}}
        , ensure [=sampled texture validation=] is not violated.
    1. If |bindingDescriptor|.{{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/readonly-storage-texture}} or {{GPUBindingType/writeonly-storage-texture}}
        , ensure [=storage texture validation=] is not violated.
    1. If |bindingDescriptor|.{{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/sampler}}
        , ensure [=sampler validation=] is not violated.
    1. Insert |bindingDescriptor| into |layout|.{{GPUBindGroupLayout/[[bindings]]}}.
1. Return |layout|.

<b>Validation Conditions</b>

<dl dfn-for="createBindGroupLayout(descriptor)">
If any of the following conditions are violated:
    1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
    1. Create a new [=invalid=] {{GPUBindGroupLayout}} and return the result.

<dfn>device validation</dfn>: The {{GPUDevice}} must not be lost.

<dfn>binding validation</dfn>: Each |bindingDescriptor|.{{GPUBindGroupLayoutBinding/binding}} in |descriptor| must be unique.

<dfn>vertex shader binding validation</dfn>: {{GPUBindingType/storage-buffer}} is not allowed.

<dfn>uniform buffer validation</dfn>: There must be {{GPULimits/maxUniformBuffersPerShaderStage|GPULimits.maxUniformBuffersPerShaderStage}} or
    fewer |bindingDescriptor|s of type {{GPUBindingType/uniform-buffer}} visible on each shader stage in |descriptor|.

<dfn>dynamic uniform buffer validation</dfn>: There must be {{GPULimits/maxDynamicUniformBuffersPerPipelineLayout|GPULimits.maxDynamicUniformBuffersPerPipelineLayout}} or
        fewer |bindingDescriptor|s of type {{GPUBindingType/uniform-buffer}} with {{GPUBindGroupLayoutBinding/hasDynamicOffset}} set to `true` in
        |descriptor| that are visible to any shader stage.

<dfn>storage buffer validation</dfn>: There must be {{GPULimits/maxStorageBuffersPerShaderStage|GPULimits.maxStorageBuffersPerShaderStage}} or
    fewer |bindingDescriptor|s of type {{GPUBindingType/storage-buffer}} visible on each shader stage in |descriptor|.

<dfn>dynamic storage buffer validation</dfn>: There must be {{GPULimits/maxDynamicStorageBuffersPerPipelineLayout|GPULimits.maxDynamicStorageBuffersPerPipelineLayout}} or
        fewer |bindingDescriptor|s of type {{GPUBindingType/storage-buffer}} with {{GPUBindGroupLayoutBinding/hasDynamicOffset}} set to `true`
        in |descriptor| that are visible to any shader stage.

<dfn>sampled texture validation</dfn>: There must be {{GPULimits/maxSampledTexturesPerShaderStage|GPULimits.maxSampledTexturesPerShaderStage}} or
    fewer |bindingDescriptor|s of type {{GPUBindingType/sampled-texture}} visible on each shader stage in |descriptor|.
    |bindingDescriptor|.{{GPUBindGroupLayoutBinding/hasDynamicOffset}} must be `false`.

<dfn>storage texture validation</dfn>: There must be {{GPULimits/maxStorageTexturesPerShaderStage|GPULimits.maxStorageTexturesPerShaderStage}} or
    fewer |bindingDescriptor|s of type {{GPUBindingType/readonly-storage-texture}} and {{GPUBindingType/writeonly-storage-texture}} visible on each shader stage in |descriptor|.
    |bindingDescriptor|.{{GPUBindGroupLayoutBinding/hasDynamicOffset}} must be `false`.

<dfn>sampler validation</dfn>: There must be {{GPULimits/maxSamplersPerShaderStage|GPULimits.maxSamplersPerShaderStage}} or
    fewer |bindingDescriptor|s of type {{GPUBindingType/sampler}} visible on each shader stage in |descriptor|.
    |bindingDescriptor|.{{GPUBindGroupLayoutBinding/hasDynamicOffset}} must be `false`.

</dl>
</div>

## GPUBindGroup ## {#bind-groups}

A {{GPUBindGroup}} defines a set of resources to be bound together in a group
    and how the resources are used in shader stages.

<script type=idl>
interface GPUBindGroup {
};
GPUBindGroup includes GPUObjectBase;
</script>

### Bind Group Creation ### {#bind-group-creation}

A {{GPUBindGroup}} is created via {{GPUDevice/createBindGroup()|GPUDevice.createBindGroup()}}.

<script type=idl>
dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
    required GPUBindGroupLayout layout;
    required sequence<GPUBindGroupBinding> bindings;
};
</script>

A {{GPUBindGroupBinding}} describes a single resource to be bound in a {{GPUBindGroup}}.

<script type=idl>
typedef (GPUSampler or GPUTextureView or GPUBufferBinding) GPUBindingResource;

dictionary GPUBindGroupBinding {
    required GPUIndex32 binding;
    required GPUBindingResource resource;
};
</script>

<script type=idl>
dictionary GPUBufferBinding {
    required GPUBuffer buffer;
    GPUSize64 offset = 0;
    GPUSize64 size;
};
</script>

  * {{GPUBufferBinding/size}}: If undefined, specifies the range starting at
      {{GPUBufferBinding/offset}} and ending at the end of the buffer.

A {{GPUBindGroup}} object has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBindGroup">
    : <dfn>\[[layout]]</dfn> of type {{GPUBindGroupLayout}}.
    ::
        The {{GPUBindGroupLayout}} associated with this {{GPUBindGroup}}.

    : <dfn>\[[bindings]]</dfn> of type sequence<{{GPUBindGroupBinding}}>.
    ::
        The set of {{GPUBindGroupBinding}}s this {{GPUBindGroup}} describes.
</dl>

### {{GPUDevice/createBindGroup()|GPUDevice.createBindGroup(GPUBindGroupDescriptor)}} ### {#GPUDevice-createBindGroup}

<div algorithm="GPUDevice.createBindGroup(descriptor)">

The <dfn method for="GPUDevice">createBindGroup(|descriptor|)</dfn> method is used to create
    {{GPUBindGroup}}s.

1. Ensure [=bind group device validation=] is not violated.
1. Ensure |descriptor|.{{GPUBindGroupDescriptor/layout}} is a [=valid=] {{GPUBindGroupLayout}}.
1. Ensure the number of {{GPUBindGroupLayoutDescriptor/bindings}} of
    |descriptor|.{{GPUBindGroupDescriptor/layout}} exactly equals to the number of
    |descriptor|.{{GPUBindGroupDescriptor/bindings}}.
1. For each {{GPUBindGroupBinding}} |bindingDescriptor| in
    |descriptor|.{{GPUBindGroupDescriptor/bindings}}:
    1. Ensure there is exactly one {{GPUBindGroupLayoutBinding}} |layoutBinding| in
        {{GPUBindGroupLayoutDescriptor/bindings}} of |descriptor|.{{GPUBindGroupDescriptor/layout}}
        such that |layoutBinding|.{{GPUBindGroupLayoutBinding/binding}} equals to
        |bindingDescriptor|.{{GPUBindGroupBinding/binding}}.
    1. If |layoutBinding|.{{GPUBindGroupLayoutBinding/type}} is
        {{GPUBindingType/"sampler"}}:
        1. Ensure |bindingDescriptor|.{{GPUBindGroupBinding/resource}} is a
            valid {{GPUSampler}} object.
    1. If |layoutBinding|.{{GPUBindGroupLayoutBinding/type}} is
        {{GPUBindingType/"sampled-texture"}} or {{GPUBindingType/"readonly-storage-texture"}} or
        {{GPUBindingType/"writeonly-storage-texture"}}.
        1. Ensure |bindingDescriptor|.{{GPUBindGroupBinding/resource}} is a
            valid {{GPUTextureView}} object.
        1. Ensure [=texture view binding validation=] is not violated.
        1. Ensure |bindingDescriptor|.{{GPUBindGroupLayoutBinding/storageTextureFormat}} is a valid {{GPUTextureFormat}}.
    1. If |layoutBinding|.{{GPUBindGroupLayoutBinding/type}} is
        {{GPUBindingType/"uniform-buffer"}} or {{GPUBindingType/"storage-buffer"}}
        or {{GPUBindingType/"readonly-storage-buffer"}}.
        1. Ensure |bindingDescriptor|.{{GPUBindGroupBinding/resource}} is a
            valid {{GPUBufferBinding}} object.
        1. Ensure [=buffer binding validation=] is not violated.
1. Return a new {{GPUBindGroup}} object with:
    - {{GPUBindGroup/[[layout]]}} = |descriptor|.{{GPUBindGroupDescriptor/layout}}
    - {{GPUBindGroup/[[bindings]]}} = |descriptor|.{{GPUBindGroupDescriptor/bindings}}

<b>Validation Conditions</b>

<dl dfn-for="createBindGroup(descriptor)">
If any of the following conditions are violated:
    1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
    1. Create a new [=invalid=] {{GPUBindGroup}} and return the result.

<dfn>bind group device validation</dfn>: The {{GPUDevice}} must not be lost.

<dfn>texture view binding validation</dfn>: Let |view| be
    |bindingDescriptor|.{{GPUBindGroupBinding/resource}}, a {{GPUTextureView}}.
    This |layoutBinding| must be compatible with this |view|. This requires:
    1. Its |layoutBinding|.{{GPUBindGroupLayoutBinding/viewDimension}} must equal |view|'s
        {{GPUTextureViewDescriptor/dimension}}.
    1. Its |layoutBinding|.{{GPUBindGroupLayoutBinding/textureComponentType}} must be compatible
        with |view|'s {{GPUTextureViewDescriptor/format}}.
    1. If |layoutBinding|.{{GPUBindGroupLayoutBinding/multisampled}} is `true`, |view|'s texture's
        {{GPUTextureDescriptor/sampleCount}} must be greater than 1.
        Otherwise, if |bindingDescriptor|.{{GPUBindGroupLayoutBinding/multisampled}} is `false`,
        |view|'s texture's {{GPUTextureDescriptor/sampleCount}} must be 1.
    1. If |layoutBinding|.{{GPUBindGroupLayoutBinding/type}} is
        {{GPUBindingType/"sampled-texture"}}, |view|'s texture's {{GPUTextureDescriptor/usage}}
        must include {{GPUTextureUsage/SAMPLED}}.
    1. If |layoutBinding|.{{GPUBindGroupLayoutBinding/type}} is
        {{GPUBindingType/"readonly-storage-texture"}} or {{GPUBindingType/"writeonly-storage-texture"}},
        |view|'s texture's {{GPUTextureDescriptor/usage}} must include {{GPUTextureUsage/STORAGE}}.

<dfn>buffer binding validation</dfn>: Let |bufferBinding| be
    |bindingDescriptor|.{{GPUBindGroupBinding/resource}}, a {{GPUBufferBinding}}.
    This |layoutBinding| must be compatible with this |bufferBinding|. This requires:
    1. If |layoutBinding|.{{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/"uniform-buffer"}},
        the |bufferBinding|.{{GPUBufferBinding/buffer}}'s {{GPUBufferDescriptor/usage}} must include
        {{GPUBufferUsage/UNIFORM}}.
    1. If |layoutBinding|.{{GPUBindGroupLayoutBinding/type}} is {{GPUBindingType/"storage-buffer"}}
        or {{GPUBindingType/"readonly-storage-buffer"}}, the
        |bufferBinding|.{{GPUBufferBinding/buffer}}'s {{GPUBufferDescriptor/usage}} must include
        {{GPUBufferUsage/STORAGE}}.
    1. The bound part designated by |bufferBinding|.{{GPUBufferBinding/offset}} and
        |bufferBinding|.{{GPUBufferBinding/size}} must reside inside the buffer.
</dl>
</div>

## GPUPipelineLayout ## {#pipeline-layout}

<script type=idl>
interface GPUPipelineLayout {
};
GPUPipelineLayout includes GPUObjectBase;
</script>

### Creation ### {#pipeline-layout-creation}

<script type=idl>
dictionary GPUPipelineLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayout> bindGroupLayouts;
};
</script>

Shader Modules {#shader-modules}
================================

## GPUShaderModule ## {#shader-module}

<script type=idl>
[Serializable]
interface GPUShaderModule {
};
GPUShaderModule includes GPUObjectBase;
</script>

{{GPUShaderModule}} is {{Serializable}}. It is a reference to an internal
shader module object, and {{Serializable}} means that the reference can be
*copied* between realms (threads/workers), allowing multiple realms to access
it concurrently. Since {{GPUShaderModule}} is immutable, there are no race
conditions.

### Shader Module Creation ### {#shader-module-creation}

<script type=idl>
dictionary GPUShaderModuleDescriptor : GPUObjectDescriptorBase {
    required DOMString code;
};
</script>

Pipelines {#pipelines}
======================

<script type=idl>
dictionary GPUPipelineDescriptorBase : GPUObjectDescriptorBase {
    required GPUPipelineLayout layout;
};
</script>

<script type=idl>
dictionary GPUProgrammableStageDescriptor {
    required GPUShaderModule module;
    required DOMString entryPoint;
    // TODO: other stuff like specialization constants?
};
</script>

## GPUComputePipeline ## {#compute-pipeline}

<script type=idl>
[Serializable]
interface GPUComputePipeline {
};
GPUComputePipeline includes GPUObjectBase;
</script>

### Creation ### {#compute-pipeline-creation}

<script type=idl>
dictionary GPUComputePipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStageDescriptor computeStage;
};
</script>

## GPURenderPipeline ## {#render-pipeline}

<script type=idl>
[Serializable]
interface GPURenderPipeline {
};
GPURenderPipeline includes GPUObjectBase;
</script>

### Creation ### {#render-pipeline-creation}

<script type=idl>
dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStageDescriptor vertexStage;
    GPUProgrammableStageDescriptor fragmentStage;

    required GPUPrimitiveTopology primitiveTopology;
    GPURasterizationStateDescriptor rasterizationState = {};
    required sequence<GPUColorStateDescriptor> colorStates;
    GPUDepthStencilStateDescriptor depthStencilState;
    GPUVertexStateDescriptor vertexState = {};

    GPUSize32 sampleCount = 1;
    GPUSampleMask sampleMask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
    // TODO: other properties
};
</script>

  * {{GPURenderPipelineDescriptor/sampleCount}}: Number of MSAA samples.

### Primitive Topology ### {#primitive-topology}

<script type=idl>
enum GPUPrimitiveTopology {
    "point-list",
    "line-list",
    "line-strip",
    "triangle-list",
    "triangle-strip"
};
</script>

### Rasterization State ### {#rasterization-state}

<script type=idl>
dictionary GPURasterizationStateDescriptor {
    GPUFrontFace frontFace = "ccw";
    GPUCullMode cullMode = "none";

    GPUDepthBias depthBias = 0;
    float depthBiasSlopeScale = 0;
    float depthBiasClamp = 0;
};
</script>

<script type=idl>
enum GPUFrontFace {
    "ccw",
    "cw"
};
</script>

<script type=idl>
enum GPUCullMode {
    "none",
    "front",
    "back"
};
</script>

### Color State ### {#color-state}

<script type=idl>
dictionary GPUColorStateDescriptor {
    required GPUTextureFormat format;

    GPUBlendDescriptor alphaBlend = {};
    GPUBlendDescriptor colorBlend = {};
    GPUColorWriteFlags writeMask = 0xF;  // GPUColorWrite.ALL
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUColorWriteFlags;
interface GPUColorWrite {
    const GPUColorWriteFlags RED   = 0x1;
    const GPUColorWriteFlags GREEN = 0x2;
    const GPUColorWriteFlags BLUE  = 0x4;
    const GPUColorWriteFlags ALPHA = 0x8;
    const GPUColorWriteFlags ALL   = 0xF;
};
</script>

#### Blend State #### {#blend-state}

<script type=idl>
dictionary GPUBlendDescriptor {
    GPUBlendFactor srcFactor = "one";
    GPUBlendFactor dstFactor = "zero";
    GPUBlendOperation operation = "add";
};
</script>

<script type=idl>
enum GPUBlendFactor {
    "zero",
    "one",
    "src-color",
    "one-minus-src-color",
    "src-alpha",
    "one-minus-src-alpha",
    "dst-color",
    "one-minus-dst-color",
    "dst-alpha",
    "one-minus-dst-alpha",
    "src-alpha-saturated",
    "blend-color",
    "one-minus-blend-color"
};
</script>

<script type=idl>
enum GPUBlendOperation {
    "add",
    "subtract",
    "reverse-subtract",
    "min",
    "max"
};
</script>

<script type=idl>
enum GPUStencilOperation {
    "keep",
    "zero",
    "replace",
    "invert",
    "increment-clamp",
    "decrement-clamp",
    "increment-wrap",
    "decrement-wrap"
};
</script>

### Depth/Stencil State ### {#depth-stencil-state}

<script type=idl>
dictionary GPUDepthStencilStateDescriptor {
    required GPUTextureFormat format;

    boolean depthWriteEnabled = false;
    GPUCompareFunction depthCompare = "always";

    GPUStencilStateFaceDescriptor stencilFront = {};
    GPUStencilStateFaceDescriptor stencilBack = {};

    GPUStencilValue stencilReadMask = 0xFFFFFFFF;
    GPUStencilValue stencilWriteMask = 0xFFFFFFFF;
};
</script>

<script type=idl>
dictionary GPUStencilStateFaceDescriptor {
    GPUCompareFunction compare = "always";
    GPUStencilOperation failOp = "keep";
    GPUStencilOperation depthFailOp = "keep";
    GPUStencilOperation passOp = "keep";
};
</script>

### Vertex State ### {#vertex-state}

<script type=idl>
enum GPUIndexFormat {
    "uint16",
    "uint32"
};
</script>

#### Vertex formats #### {#vertex-formats}

The name of the format specifies the data type of the component, the number of
values, and whether the data is normalized.

  * `uchar` = unsigned 8-bit value
  * `char` = signed 8-bit value
  * `ushort` = unsigned 16-bit value
  * `short` = signed 16-bit value
  * `half` = half-precision 16-bit floating point value
  * `float` = 32-bit floating point value
  * `uint` = unsigned 32-bit integer value
  * `int` = signed 32-bit integer value

If no number of values is given in the name, a single value is provided.
If the format has the `-bgra` suffix, it means the values are arranged as
blue, green, red and alpha values.

<script type=idl>
enum GPUVertexFormat {
    "uchar2",
    "uchar4",
    "char2",
    "char4",
    "uchar2norm",
    "uchar4norm",
    "char2norm",
    "char4norm",
    "ushort2",
    "ushort4",
    "short2",
    "short4",
    "ushort2norm",
    "ushort4norm",
    "short2norm",
    "short4norm",
    "half2",
    "half4",
    "float",
    "float2",
    "float3",
    "float4",
    "uint",
    "uint2",
    "uint3",
    "uint4",
    "int",
    "int2",
    "int3",
    "int4"
};
</script>

<script type=idl>
enum GPUInputStepMode {
    "vertex",
    "instance"
};
</script>

<script type=idl>
dictionary GPUVertexStateDescriptor {
    GPUIndexFormat indexFormat = "uint32";
    sequence<GPUVertexBufferLayoutDescriptor?> vertexBuffers = [];
};
</script>

A <dfn dfn>vertex buffer</dfn> is, conceptually, a view into buffer memory as an *array of structures*.
{{GPUVertexBufferLayoutDescriptor/arrayStride}} is the stride, in bytes, between *elements* of that array.
Each element of a vertex buffer is like a *structure* with a memory layout defined by its
{{GPUVertexBufferLayoutDescriptor/attributes}}, which describe the *members* of the structure.

Each {{GPUVertexAttributeDescriptor}} describes its
{{GPUVertexAttributeDescriptor/format}} and its
{{GPUVertexAttributeDescriptor/offset}}, in bytes, within the structure.

Each attribute appears as a separate input in a vertex shader, each bound by a numeric *location*,
which is specified by {{GPUVertexAttributeDescriptor/shaderLocation}}.
Every location must be unique within the {{GPUVertexStateDescriptor}}.

<script type=idl>
dictionary GPUVertexBufferLayoutDescriptor {
    required GPUSize64 arrayStride;
    GPUInputStepMode stepMode = "vertex";
    required sequence<GPUVertexAttributeDescriptor> attributes;
};
</script>

<script type=idl>
dictionary GPUVertexAttributeDescriptor {
    required GPUVertexFormat format;
    required GPUSize64 offset;

    required GPUIndex32 shaderLocation;
};
</script>

Command Buffers {#command-buffers}
==================================

## GPUCommandBuffer ## {#command-buffer}

<script type=idl>
interface GPUCommandBuffer {
};
GPUCommandBuffer includes GPUObjectBase;
</script>

### Creation ### {#command-buffer-creation}

<script type=idl>
dictionary GPUCommandBufferDescriptor : GPUObjectDescriptorBase {
};
</script>


Command Encoding {#command-encoding}
====================================

## GPUCommandEncoder ## {#command-encoder}

<script type=idl>
interface GPUCommandEncoder {
    GPURenderPassEncoder beginRenderPass(GPURenderPassDescriptor descriptor);
    GPUComputePassEncoder beginComputePass(optional GPUComputePassDescriptor descriptor = {});

    void copyBufferToBuffer(
        GPUBuffer source,
        GPUSize64 sourceOffset,
        GPUBuffer destination,
        GPUSize64 destinationOffset,
        GPUSize64 size);

    void copyBufferToTexture(
        GPUBufferCopyView source,
        GPUTextureCopyView destination,
        GPUExtent3D copySize);

    void copyTextureToBuffer(
        GPUTextureCopyView source,
        GPUBufferCopyView destination,
        GPUExtent3D copySize);

    void copyTextureToTexture(
        GPUTextureCopyView source,
        GPUTextureCopyView destination,
        GPUExtent3D copySize);

    void pushDebugGroup(DOMString groupLabel);
    void popDebugGroup();
    void insertDebugMarker(DOMString markerLabel);

    GPUCommandBuffer finish(optional GPUCommandBufferDescriptor descriptor = {});
};
GPUCommandEncoder includes GPUObjectBase;
</script>

### Creation ### {#command-encoder-creation}

<script type=idl>
dictionary GPUCommandEncoderDescriptor : GPUObjectDescriptorBase {
    // TODO: reusability flag?
};
</script>

## Copy Commands ## {#copy-commands}

<script type=idl>
dictionary GPUBufferCopyView {
    required GPUBuffer buffer;
    GPUSize64 offset = 0;
    required GPUSize32 rowPitch;
    required GPUSize32 imageHeight;
};
</script>

<script type=idl>
dictionary GPUTextureCopyView {
    required GPUTexture texture;
    GPUIntegerCoordinate mipLevel = 0;
    GPUIntegerCoordinate arrayLayer = 0;
    GPUOrigin3D origin = {};
};
</script>

  * {{GPUTextureCopyView/origin}}: If unspecified, defaults to `[0, 0, 0]`.

<script type=idl>
dictionary GPUImageBitmapCopyView {
    required ImageBitmap imageBitmap;
    GPUOrigin2D origin = {};
};
</script>

  * {{GPUImageBitmapCopyView/origin}}: If unspecified, defaults to `[0, 0]`.

## Programmable Passes ## {#programmable-passes}

<script type=idl>

interface mixin GPUProgrammablePassEncoder {
    void setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      optional sequence<GPUBufferDynamicOffset> dynamicOffsets = []);

    void setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      Uint32Array dynamicOffsetsData,
                      GPUSize64 dynamicOffsetsDataStart,
                      GPUSize32 dynamicOffsetsDataLength);

    void pushDebugGroup(DOMString groupLabel);
    void popDebugGroup();
    void insertDebugMarker(DOMString markerLabel);
};
</script>

Debug groups in a {{GPUCommandEncoder}} or {{GPUProgrammablePassEncoder}}
must be well nested.

Compute Passes {#compute-passes}
================================

## GPUComputePassEncoder ## {#compute-pass-encoder}

<script type=idl>
interface GPUComputePassEncoder {
    void setPipeline(GPUComputePipeline pipeline);
    void dispatch(GPUSize32 x, optional GPUSize32 y = 1, optional GPUSize32 z = 1);
    void dispatchIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);

    void endPass();
};
GPUComputePassEncoder includes GPUObjectBase;
GPUComputePassEncoder includes GPUProgrammablePassEncoder;
</script>

### Creation ### {#compute-pass-encoder-creation}

<script type=idl>
dictionary GPUComputePassDescriptor : GPUObjectDescriptorBase {
};
</script>

Render Passes {#render-passes}
==============================

## GPURenderPassEncoder ## {#render-pass-encoder}

<script type=idl>
interface mixin GPURenderEncoderBase {
    void setPipeline(GPURenderPipeline pipeline);

    void setIndexBuffer(GPUBuffer buffer, optional GPUSize64 offset = 0);
    void setVertexBuffer(GPUIndex32 slot, GPUBuffer buffer, optional GPUSize64 offset = 0);

    void draw(GPUSize32 vertexCount, GPUSize32 instanceCount,
              GPUSize32 firstVertex, GPUSize32 firstInstance);
    void drawIndexed(GPUSize32 indexCount, GPUSize32 instanceCount,
                     GPUSize32 firstIndex, GPUSignedOffset32 baseVertex, GPUSize32 firstInstance);

    void drawIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
    void drawIndexedIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
};

interface GPURenderPassEncoder {
    void setViewport(float x, float y,
                     float width, float height,
                     float minDepth, float maxDepth);

    void setScissorRect(GPUIntegerCoordinate x, GPUIntegerCoordinate y,
                        GPUIntegerCoordinate width, GPUIntegerCoordinate height);

    void setBlendColor(GPUColor color);
    void setStencilReference(GPUStencilValue reference);

    void executeBundles(sequence<GPURenderBundle> bundles);
    void endPass();
};
GPURenderPassEncoder includes GPUObjectBase;
GPURenderPassEncoder includes GPUProgrammablePassEncoder;
GPURenderPassEncoder includes GPURenderEncoderBase;
</script>

  * In indirect draw calls, the base instance field (inside the indirect
    buffer data) must be set to zero.

  * {{GPURenderPassEncoder/setScissorRect()}}:
      * An error is generated if `width` or `height` is not greater than 0.

When a {{GPURenderPassEncoder}} is created, it has the following default state:
  * Viewport:
      * `x, y` = `0.0, 0.0`
      * `width, height` = the dimensions of the pass's render targets
      * `minDepth, maxDepth` = `0.0, 1.0`
  * Scissor rectangle:
      * `x, y` = `0, 0`
      * `width, height` = the dimensions of the pass's render targets

When a {{GPURenderBundle}} is executed, it does not inherit the pass's pipeline,
bind groups, or vertex or index buffers. After a {{GPURenderBundle}} has executed,
the pass's pipeline, bind groups, and vertex and index buffers are cleared. If zero
{{GPURenderBundle}}s are executed, the command buffer state is unchanged.

### Creation ### {#render-pass-encoder-creation}

<script type=idl>
dictionary GPURenderPassDescriptor : GPUObjectDescriptorBase {
    required sequence<GPURenderPassColorAttachmentDescriptor> colorAttachments;
    GPURenderPassDepthStencilAttachmentDescriptor depthStencilAttachment;
};
</script>

#### Color Attachments #### {#color-attachments}

<script type=idl>
dictionary GPURenderPassColorAttachmentDescriptor {
    required GPUTextureView attachment;
    GPUTextureView resolveTarget;

    required (GPULoadOp or GPUColor) loadValue;
    GPUStoreOp storeOp = "store";
};
</script>

#### Depth/Stencil Attachments #### {#depth-stencil-attachments}

<script type=idl>
dictionary GPURenderPassDepthStencilAttachmentDescriptor {
    required GPUTextureView attachment;

    required (GPULoadOp or float) depthLoadValue;
    required GPUStoreOp depthStoreOp;

    required (GPULoadOp or GPUStencilValue) stencilLoadValue;
    required GPUStoreOp stencilStoreOp;
};
</script>

### Load &amp; Store Operations ### {#load-and-store-ops}

<script type=idl>
enum GPULoadOp {
    "load"
};
</script>

<script type=idl>
enum GPUStoreOp {
    "store",
    "clear"
};
</script>


Bundles {#bundles}
==================

## GPURenderBundle ## {#render-bundle}

<script type=idl>
interface GPURenderBundle {
};
GPURenderBundle includes GPUObjectBase;
</script>

### Creation ### {#render-bundle-creation}

<script type=idl>
dictionary GPURenderBundleDescriptor : GPUObjectDescriptorBase {
};
</script>

<script type=idl>
interface GPURenderBundleEncoder {
    GPURenderBundle finish(optional GPURenderBundleDescriptor descriptor = {});
};
GPURenderBundleEncoder includes GPUObjectBase;
GPURenderBundleEncoder includes GPUProgrammablePassEncoder;
GPURenderBundleEncoder includes GPURenderEncoderBase;
</script>

### Encoding ### {#render-bundle-encoding}

<script type=idl>
dictionary GPURenderBundleEncoderDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUTextureFormat> colorFormats;
    GPUTextureFormat depthStencilFormat;
    GPUSize32 sampleCount = 1;
};
</script>


Queues {#queues}
================

<script type=idl>
interface GPUQueue {
    void submit(sequence<GPUCommandBuffer> commandBuffers);

    GPUFence createFence(optional GPUFenceDescriptor descriptor = {});
    void signal(GPUFence fence, GPUFenceValue signalValue);

    void copyImageBitmapToTexture(
        GPUImageBitmapCopyView source,
        GPUTextureCopyView destination,
        GPUExtent3D copySize);
};
GPUQueue includes GPUObjectBase;
</script>

 - {{GPUQueue/copyImageBitmapToTexture()}}:
   - For now, `copySize.z` must be `1`.

{{GPUQueue/submit(commandBuffers)}} does nothing and produces an error if any of the following is true:

 - Any {{GPUBuffer}} referenced in any element of `commandBuffers` isn't in the `"unmapped"` [=buffer state=].

## GPUFence ## {#fence}

<script type=idl>
interface GPUFence {
    GPUFenceValue getCompletedValue();
    Promise<void> onCompletion(GPUFenceValue completionValue);
};
GPUFence includes GPUObjectBase;
</script>

### Creation ### {#fence-creation}

<script type=idl>
dictionary GPUFenceDescriptor : GPUObjectDescriptorBase {
    GPUFenceValue initialValue = 0;
};
</script>


Canvas Rendering and Swap Chain {#swapchain}
============================================

<script type=idl>
interface GPUCanvasContext {
    GPUSwapChain configureSwapChain(GPUSwapChainDescriptor descriptor);

    Promise<GPUTextureFormat> getSwapChainPreferredFormat(GPUDevice device);
};
</script>

  * {{GPUCanvasContext/configureSwapChain()}}:
    Configures the swap chain for this canvas, and returns a new
    {{GPUSwapChain}} object representing it. Destroys any swapchain
    previously returned by `configureSwapChain`, including all of the
    textures it has produced.

<script type=idl>
dictionary GPUSwapChainDescriptor : GPUObjectDescriptorBase {
    required GPUDevice device;
    required GPUTextureFormat format;
    GPUTextureUsageFlags usage = 0x10;  // GPUTextureUsage.OUTPUT_ATTACHMENT
};
</script>

<script type=idl>
interface GPUSwapChain {
    GPUTexture getCurrentTexture();
};
GPUSwapChain includes GPUObjectBase;
</script>


Errors &amp; Debugging {#errors-and-debugging}
==============================================

## Fatal Errors ## {#fatal-errors}

<script type=idl>
interface GPUDeviceLostInfo {
    readonly attribute DOMString message;
};

partial interface GPUDevice {
    readonly attribute Promise<GPUDeviceLostInfo> lost;
};
</script>


## Error Scopes ## {#error-scopes}

<script type=idl>
enum GPUErrorFilter {
    "none",
    "out-of-memory",
    "validation"
};
</script>

<script type=idl>
interface GPUOutOfMemoryError {
    constructor();
};

interface GPUValidationError {
    constructor(DOMString message);
    readonly attribute DOMString message;
};

typedef (GPUOutOfMemoryError or GPUValidationError) GPUError;
</script>

<script type=idl>
partial interface GPUDevice {
    void pushErrorScope(GPUErrorFilter filter);
    Promise<GPUError?> popErrorScope();
};
</script>

{{GPUDevice/popErrorScope()}} throws {{OperationError}} if there are no error scopes on the stack.
{{GPUDevice/popErrorScope()}} rejects with {{OperationError}} if the device is lost.

## Telemetry ## {#telemetry}

<script type=idl>
[
    Exposed=(Window, DedicatedWorker)
]
interface GPUUncapturedErrorEvent : Event {
    constructor(
        DOMString type,
        GPUUncapturedErrorEventInit gpuUncapturedErrorEventInitDict
    );
    [SameObject] readonly attribute GPUError error;
};

dictionary GPUUncapturedErrorEventInit : EventInit {
    required GPUError error;
};
</script>

<script type=idl>
partial interface GPUDevice {
    [Exposed=(Window, DedicatedWorker)]
    attribute EventHandler onuncapturederror;
};
</script>

Type Definitions {#type-definitions}
====================================

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferDynamicOffset;
typedef [EnforceRange] unsigned long long GPUFenceValue;
typedef [EnforceRange] unsigned long GPUStencilValue;
typedef [EnforceRange] unsigned long GPUSampleMask;
typedef [EnforceRange] long GPUDepthBias;

typedef [EnforceRange] unsigned long long GPUSize64;
typedef [EnforceRange] unsigned long GPUIntegerCoordinate;
typedef [EnforceRange] unsigned long GPUIndex32;
typedef [EnforceRange] unsigned long GPUSize32;
typedef [EnforceRange] long GPUSignedOffset32;
</script>

## Colors and Vectors ## {#colors-and-vectors}

<script type=idl>
dictionary GPUColorDict {
    required double r;
    required double g;
    required double b;
    required double a;
};
typedef (sequence<double> or GPUColorDict) GPUColor;
</script>

Note: `double` is large enough to precisely hold 32-bit signed/unsigned
integers and single-precision floats.

<script type=idl>
dictionary GPUOrigin2DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin2DDict) GPUOrigin2D;
</script>

<script type=idl>
dictionary GPUOrigin3DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
    GPUIntegerCoordinate z = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin3DDict) GPUOrigin3D;
</script>

<script type=idl>
dictionary GPUExtent3DDict {
    required GPUIntegerCoordinate width;
    required GPUIntegerCoordinate height;
    required GPUIntegerCoordinate depth;
};
typedef (sequence<GPUIntegerCoordinate> or GPUExtent3DDict) GPUExtent3D;
</script>

<script type=idl>
typedef sequence<(GPUBuffer or ArrayBuffer)> GPUMappedBuffer;
</script>

{{GPUMappedBuffer}} is always a sequence of 2 elements, of types {{GPUBuffer}}
and {{ArrayBuffer}}, respectively.

# Temporary usages of non-exported dfns ## {#temp-dfn-usages}

Eventually all of these should disappear but they are useful to avoid warning while building the specification.

[=vertex buffer=]
