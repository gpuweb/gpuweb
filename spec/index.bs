<pre class='metadata'>
Title: WebGPU
Shortname: webgpu
Level: None
Status: w3c/ED
Group: webgpu
ED: https://gpuweb.github.io/gpuweb/
TR: https://www.w3.org/TR/webgpu/
Repository: gpuweb/gpuweb
!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues">open issues</a>)

Editor: Dzmitry Malyshau, Mozilla https://www.mozilla.org, dmalyshau@mozilla.com, w3cid 96977
Editor: Kai Ninomiya, Google https://www.google.com, kainino@google.com, w3cid 99487
Former Editor: Justin Fan, Apple https://www.apple.com, justin_fan@apple.com, w3cid 115633
Abstract: WebGPU exposes an API for performing operations, such as rendering and computation, on a Graphics Processing Unit.
Markup Shorthands: markdown yes
Markup Shorthands: dfn yes
Markup Shorthands: idl yes
Markup Shorthands: css no
Assume Explicit For: yes
</pre>

<pre class=biblio>
{
  "WGSL": {
    "authors": [
      "David Neto",
      "Myles C. Maxfield"
    ],
    "href": "https://gpuweb.github.io/gpuweb/wgsl/",
    "title": "WebGPU Shading Language",
    "status": "Editor's Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "SourceMap": {
    "authors": [
      "John Lenz",
      "Nick Fitzgerald"
    ],
    "href": "https://sourcemaps.info/spec.html",
    "title": "Source Map Revision 3 Proposal"
  }
}
</pre>

<pre class="link-defaults">
spec:html;
    type:interface; text:Navigator
spec:webidl;
    type:interface; text:Promise
</pre>

<pre class='anchors'>
spec: ECMA-262; urlPrefix: https://tc39.es/ecma262/#
    type: dfn
        text: agent; url: agent
        text: surrounding agent; url: surrounding-agent
        text: agent cluster; url: sec-agent-clusters
spec: webidl; urlPrefix: https://heycam.github.io/webidl/#
    type: dfn
        text: resolve; url: resolve
spec: web-apis; urlPrefix: https://html.spec.whatwg.org/multipage/webappapis.html#
    type: dfn
        text: cross-origin isolated capability; url: concept-settings-object-cross-origin-isolated-capability
spec: canvas; urlPrefix: https://html.spec.whatwg.org/multipage/canvas.html#
    type: dfn
        text: origin-clean; url: concept-canvas-origin-clean
        text: placeholder canvas element; url: offscreencanvas-placeholder
        text: canvas context mode; url: concept-canvas-context-mode
        text: OffscreenCanvas context mode; url: offscreencanvas-context-mode
        text: check the usability of the image argument; url: check-the-usability-of-the-image-argument
spec: WGSL; urlPrefix: https://gpuweb.github.io/gpuweb/wgsl/#
    type: dfn
        text: location; url: input-output-locations
        text: interpolation; url: interpolation
        text: pipeline-overridable; url: pipeline-overridable
        text: pipeline-overridable constant identifier string; url: pipeline-overridable-constant-identifier-string
        text: pipeline-overridable constant has a default value; url: pipeline-overridable-constant-has-a-default-value
        text: statically accessed; url: statically-accessed
        text: wgsl-declaration; url: declaration
        text: wgsl-type; url: type
        text: pipeline output; url: pipeline-output
        text: pipeline input; url: pipeline-input
        text: builtin; url: builtin-variables
        text: channel formats; url: channel-formats
        text: invalid memory reference; url: invalid-memory-reference
        text: shader-creation error; url: shader-creation-error
        text: pipeline-creation error; url: pipeline-creation-error
</pre>

<style>
/* Make <dl> blocks more distinct from their surroundings. */
main dl:not(.switch) {
    border-left: thin solid #f3e48c;
    padding-left: .5em;
}

/** In switches, make multiple consecutive <dd> entries distinguishable. */
dl.switch > dd {
    display: list-item;
    list-style: square;
}

/* <p> by default has these margins. Update ul/ol/dl to match,
 * since they are also put in places where paragraphs go. */
p, ul, ol, dl {
    margin: 1em 0;
}

/* The new spec template doesn't put a box around algorithms anymore. */
/* Add a similar box for Valid Usage requirements. */
div.algorithm, div.validusage {
    margin: .5em 0;
    padding: .5em;
    border-width: thin;
    border-style: solid;
    border-radius: .5em;
}
div.validusage {
    border-color: #88e;
}
div.algorithm {
    border-color: #ddd;
}
/*
 * If the Valid Usage requirements are the first child of a *-timeline block give it a larger top
 * margin to prevent the block labels from overlapping.
 */
.content-timeline>.validusage:first-child,
.device-timeline>.validusage:first-child,
.queue-timeline>.validusage:first-child {
    margin-top: 1.5em;
}

/*
 * Boxes for steps that occur on a particular timeline.
 */
div.content-timeline, div.device-timeline, div.queue-timeline {
    padding: .5em;
    border-radius: .5em;
}
.content-timeline {
    background: rgba(0, 255, 0, 0.05);
    background: var(--tint-green);
}
.device-timeline {
    background: rgba(255, 0, 0, 0.05);
    background: var(--tint-red);
}
.queue-timeline {
    background: rgba(255, 0, 255, 0.05);
    background: var(--tint-purple);
}

/*
 * Stylistic labels, for clarity of presentation of these blocks.
 *
 * NOTE: This text is non-accessible and non-selectable; surrounding
 * text must also explain the context.
 */
.validusage, .content-timeline, .device-timeline, .queue-timeline {
    position: relative;
}
.validusage::before,
.content-timeline::before,
.device-timeline::before,
.queue-timeline::before {
    font-weight: bold;
    font-style: italic;
    font-size: 130%;
    color: rgba(0, 0, 0, 0.15);
    color: var(--watermark-text);
    position: absolute;
    right: .3em;
    top: -.1em;
}
.validusage::before {
    content: "Valid Usage";
}
.content-timeline::before {
    content: "Content Timeline";
}
.device-timeline::before {
    content: "Device Timeline";
}
.queue-timeline::before {
    content: "Queue Timeline";
}

/*
 * Ensure that argumentdef blocks don't overflow algorithm section borders. This is made far harder
 * than it needs to be because the top-level W3C stylesheet has several @media + min-width variants
 * that mark themselves as !important and then proceed to do the wrong thing.
 */
@media screen and (min-width: 78em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
@media screen and (min-width: 90em) {
    body:not(.toc-inline) .algorithm .overlarge {
        margin-right: auto !important;
    }
}
.algorithm .overlarge {
    margin-right: auto !important;
}

/*
 * The default algorithm style has a caption that doesn't suit this spec's
 * formatting particularly well. Hide it.
 */
.algorithm .argumentdef {
    margin-top: 0;
}
.algorithm .argumentdef>caption {
    display: none;
}

/*
 * Add vertical lines to demarcate multi-column cells.
 */
table.data td[colspan] {
    border-left-style: dotted;
    border-right-style: dotted;
}

table.data.no-colspan-center td[colspan],
table.data.no-colspan-center th[colspan] {
    text-align: unset;
}

table.data tr.row-continuation td,
table.data tr.row-continuation th {
    border-top: none;
}

/*
 * Sticky table headers.
 */
.overlarge {
    /* position: sticky doesn't work inside scrollable elements. */
    overflow-x: unset;
}
thead.stickyheader th, th.stickyheader {
    position: sticky;
    top: 0;
    background: #f8f8f8;
    background: var(--stickyheader-background);
}

/*
 * Darkmode colors
 */
:root {
    --watermark-text: rgba(0, 0, 0, 15%);
    --stickyheader-background: #f8f8f8;
    --tint-red: rgba(255, 0, 0, 6%);
    --tint-green: rgba(0, 255, 0, 10%);
    --tint-blue: rgba(0, 0, 255, 5%);
    --tint-purple: rgba(255, 0, 255, 5%);
}
@media (prefers-color-scheme:dark) {
    :root {
        --watermark-text: rgba(255, 255, 255, 25%);
        --stickyheader-background: #181818;
        --tint-red: rgba(255, 0, 0, 20%);
        --tint-green: rgba(0, 255, 0, 18%);
        --tint-blue: rgba(0, 130, 255, 24%);
        --tint-purple: rgba(255, 0, 255, 22%);
    }
}

</style>


# Introduction # {#intro}

*This section is non-normative.*

[Graphics Processing Units](https://en.wikipedia.org/wiki/Graphics_processing_unit), or GPUs for short,
have been essential in enabling rich rendering and computational applications in personal computing.
WebGPU is an API that exposes the capabilities of GPU hardware for the Web.
The API is designed from the ground up to efficiently map to (post-2014) native GPU APIs.
WebGPU is not related to [WebGL](https://www.khronos.org/webgl/) and does not explicitly target OpenGL ES.

WebGPU sees physical GPU hardware as {{GPUAdapter}}s. It provides a connection to an adapter via
{{GPUDevice}}, which manages resources, and the device's {{GPUQueue}}s, which execute commands.
{{GPUDevice}} may have its own memory with high-speed access to the processing units.
{{GPUBuffer}} and {{GPUTexture}} are the <dfn dfn>physical resources</dfn> backed by GPU memory.
{{GPUCommandBuffer}} and {{GPURenderBundle}} are containers for user-recorded commands.
{{GPUShaderModule}} contains [=shader=] code. The other resources,
such as {{GPUSampler}} or {{GPUBindGroup}}, configure the way [=physical resources=] are used by the GPU.

GPUs execute commands encoded in {{GPUCommandBuffer}}s by feeding data through a [=pipeline=],
which is a mix of fixed-function and programmable stages. Programmable stages execute
<dfn dfn>shaders</dfn>, which are special programs designed to run on GPU hardware.
Most of the state of a [=pipeline=] is defined by
a {{GPURenderPipeline}} or a {{GPUComputePipeline}} object. The state not included
in these [=pipeline=] objects is set during encoding with commands,
such as {{GPUCommandEncoder/beginRenderPass()}} or {{GPURenderPassEncoder/setBlendConstant()}}.


# Malicious use considerations # {#malicious-use}

*This section is non-normative.* It describes the risks associated with exposing this API on the Web.

## Security ## {#security}

The security requirements for WebGPU are the same as ever for the web, and are likewise non-negotiable.
The general approach is strictly validating all the commands before they reach GPU,
ensuring that a page can only work with its own data.

### CPU-based undefined behavior ### {#security-cpu-ub}

A WebGPU implementation translates the workloads issued by the user into API commands specific
to the target platform. Native APIs specify the valid usage for the commands
(for example, see [vkCreateDescriptorSetLayout](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkCreateDescriptorSetLayout.html))
and generally don't guarantee any outcome if the valid usage rules are not followed.
This is called "undefined behavior", and it can be exploited by an attacker to access memory
they don't own, or force the driver to execute arbitrary code.

In order to disallow insecure usage, the range of allowed WebGPU behaviors is defined for any input.
An implementation has to validate all the input from the user and only reach the driver
with the valid workloads. This document specifies all the error conditions and handling semantics.
For example, specifying the same buffer with intersecting ranges in both "source" and "destination"
of {{GPUCommandEncoder/copyBufferToBuffer()}} results in {{GPUCommandEncoder}}
generating an error, and no other operation occurring.

See [[#errors-and-debugging]] for more information about error handling.

## GPU-based undefined behavior ## {#security-gpu-ub}

WebGPU [=shader=]s are executed by the compute units inside GPU hardware. In native APIs,
some of the shader instructions may result in undefined behavior on the GPU.
In order to address that, the shader instruction set and its defined behaviors are
strictly defined by WebGPU. When a shader is provided to {{GPUDevice/createShaderModule()}},
the WebGPU implementation has to validate it
before doing any translation (to platform-specific shaders) or transformation passes.

## Uninitialized data ## {#security-uninitialized}

Generally, allocating new memory may expose the leftover data of other applications running on the system.
In order to address that, WebGPU conceptually initializes all the resources to zero, although in practice
an implementation may skip this step if it sees the developer initializing the contents manually.
This includes variables and shared workgroup memory inside shaders.

The precise mechanism of clearing the workgroup memory can differ between platforms.
If the native API does not provide facilities to clear it, the WebGPU implementation transforms the compute
shader to first do a clear across all invocations, synchronize them, and continue executing developer's code.

## Out-of-bounds access in shaders ## {#security-shader}

[=Shader=]s can access [=physical resource=]s either directly
(for example, as a {{GPUBufferBindingType/"uniform"}} {{GPUBufferBinding}}), or via <dfn dfn>texture unit</dfn>s,
which are fixed-function hardware blocks that handle texture coordinate conversions.
Validation on the API side can only guarantee that all the inputs to the shader are provided and
they have the correct usage and types.
The host API side can not guarantee that the data is accessed within bounds
if the [=texture unit=]s are not involved.

Issue: define the host API distinct from the shader API

In order to prevent the shaders from accessing GPU memory an application doesn't own,
the WebGPU implementation may enable a special mode (called "robust buffer access") in the driver
that guarantees that the access is limited to buffer bounds.

Alternatively, an implementation may transform the shader code by inserting manual bounds checks.
When this path is taken, the out-of-bound checks only apply to array indexing. They aren't needed
for plain field access of shader structures due to the {{GPUBufferBindingLayout/minBindingSize}}
validation on the host side.

If the shader attempts to load data outside of [=physical resource=] bounds,
the implementation is allowed to:
  1. return a value at a different location within the resource bounds
  2. return a value vector of "(0, 0, 0, X)" with any "X"
  3. partially discard the draw or dispatch call

If the shader attempts to write data outside of [=physical resource=] bounds,
the implementation is allowed to:
  1. write the value to a different location within the resource bounds
  2. discard the write operation
  3. partially discard the draw or dispatch call

## Invalid data ## {#security-invalid-data}

When uploading [floating-point](https://en.wikipedia.org/wiki/IEEE_754) data from CPU to GPU,
or generating it on the GPU, we may end up with a binary representation that doesn't correspond
to a valid number, such as infinity or NaN (not-a-number). The GPU behavior in this case is
subject to the accuracy of the GPU hardware implementation of the IEEE-754 standard.
WebGPU guarantees that introducing invalid floating-point numbers would only affect the results
of arithmetic computations and will not have other side effects.

### Driver bugs ### {#security-driver-bugs}

GPU drivers are subject to bugs like any other software. If a bug occurs, an attacker
could possibly exploit the incorrect behavior of the driver to get access to unprivileged data.
In order to reduce the risk, the WebGPU working group will coordinate with GPU vendors
to integrate the WebGPU Conformance Test Suite (CTS) as part of their driver testing process,
like it was done for WebGL.
WebGPU implementations are expected to have workarounds for some of the discovered bugs,
and disable WebGPU on drivers with known bugs that can't be worked around.

### Timing attacks ### {#security-timing}

WebGPU is designed for multi-threaded use via Web Workers. As such, it is designed not to open
the users to modern high-precision timing attacks. Some of the objects,
like {{GPUBuffer}} or {{GPUQueue}}, have shared state which can be simultaneously accessed.
This allows race conditions to occur, similar to those of accessing a `SharedArrayBuffer`
from multiple Web Workers, which makes the thread scheduling observable.

WebGPU addresses this by limiting the ability to deserialize (or share) objects only to
the [=agents=] inside the [=agent cluster=], and only if
the [cross-origin isolated](https://web.dev/coop-coep/) policies are in place.
This restriction matches the [mitigations](https://hacks.mozilla.org/2020/07/safely-reviving-shared-memory/)
against the malicious `SharedArrayBuffer` use. Similarly, the user agent may also
serialize the [=agents=] sharing any handles to prevent any concurrency entirely.

In the end, the attack surface for races on shared state in WebGPU will be
a small subset of the `SharedArrayBuffer` attacks.

WebGPU also specifies the {{GPUFeatureName/"timestamp-query"}} feature, which
provides high precision timing of GPU operations. The feature is optional, and a WebGPU
implementation may limit its exposure only to those scenarios that are trusted. Alternatively,
the timing query results could be processed by a compute shader and aligned to a lower precision.

### Row hammer attacks ### {#security-rowhammer}

[Row hammer](https://en.wikipedia.org/wiki/Row_hammer) is a class of attacks that exploit the
leaking of states in DRAM cells. It could be used [on GPU](https://www.vusec.net/projects/glitch/).
WebGPU does not have any specific mitigations in place, and relies on platform-level solutions,
such as reduced memory refresh intervals.

## Denial of service ## {#security-dos}

WebGPU applications have access to GPU memory and compute units. A WebGPU implementation may limit
the available GPU memory to an application, in order to keep other applications responsive.
For GPU processing time, a WebGPU implementation may set up "watchdog" timer that makes sure an
application doesn't cause GPU unresponsiveness for more than a few seconds.
These measures are similar to those used in WebGL.

## Workload identification ## {#security-workload-identification}

WebGPU provides access to constrained global resources shared between different programs
(and web pages) running on the same machine. An application can try to indirectly probe
how constrained these global resources are, in order to reason about workloads performed
by other open web pages, based on the patterns of usage of these shared resources.
These issues are generally analogous to issues with Javascript,
such as system memory and CPU execution throughput. WebGPU does not provide any additional
mitigations for this.

### Memory resources ### {#security-memory-resources}

WebGPU exposes fallible allocations from machine-global memory heaps, such as VRAM.
This allows for probing the size of the system's remaining available memory
(for a given heap type) by attempting to allocate and watching for allocation failures.

GPUs internally have one or more (typically only two) heaps of memory
shared by all running applications. When a heap is depleted, WebGPU would fail to create a resource.
This is observable, which may allow a malicious application to guess what heaps
are used by other applications, and how much they allocate from them.

### Computation resources ### {#security-computation-resources}

If one site uses WebGPU at the same time as another, it may observe the increase
in time it takes to process some work. For example, if a site constantly submits
compute workloads and tracks completion of work on the queue,
it may observe that something else also started using the GPU.

A GPU has many parts that can be tested independently, such as the arithmetic units,
texture sampling units, atomic units, etc. A malicious application may sense when
some of these units are stressed, and attempt to guess the workload of another
application by analyzing the stress patterns. This is analogous to the realities
of CPU execution of Javascript.

## Privacy ## {#security-privacy}

### Machine-specific limits ### {#security-machine-limits}

WebGPU can expose a lot of detail on the underlying GPU architecture and the device geometry.
This includes available physical adapters, many limits on the GPU and CPU resources
that could be used (such as the maximum texture size), and any optional hardware-specific
capabilities that are available.

User agents are not obligated to expose the real hardware limits, they are in full control of
how much the machine specifics are exposed. One strategy to reduce fingerprinting is binning
all the target platforms into a few number of bins. In general, the privacy impact of exposing
the hardware limits matches the one of WebGL.

The [=limit/default=] limits are also deliberately high enough
to allow most applications to work without requesting higher limits.
All the usage of the API is validated according to the requested limits,
so the actual hardware capabilities are not exposed to the users by accident.

### Machine-specific artifacts ### {#security-machine-artifacts}

There are some machine-specific rasterization/precision artifacts and performance differences
that can be observed roughly in the same way as in WebGL. This applies to rasterization coverage
and patterns, interpolation precision of the varyings between shader stages, compute unit scheduling,
and more aspects of execution.

Generally, rasterization and precision fingerprints are identical across most or all
of the devices of each vendor. Performance differences are relatively intractable,
but also relatively low-signal (as with JS execution performance).

Privacy-critical applications and user agents should utilize software implementations to eliminate such artifacts.

### Machine-specific performance ### {#security-machine-performance}

Another factor for differentiating users is measuring the performance of specific
operations on the GPU. Even with low precision timing, repeated execution of an operation
can show if the user's machine is fast at specific workloads.
This is a fairly common vector (present in both WebGL and Javascript),
but it's also low-signal and relatively intractable to truly normalize.

WebGPU compute pipelines expose access to GPU unobstructed by the fixed-function hardware.
This poses an additional risk for unique device fingerprinting. User agents can take steps
to dissociate logical GPU invocations with actual compute units to reduce this risk.

### User Agent State ### {#security-user-agent-state}

This specification doesn't define any additional user-agent state for an origin.
However it is expected that user agents will have compilation caches for the result of expensive
compilation like {{GPUShaderModule}}, {{GPURenderPipeline}} and {{GPUComputePipeline}}.
These caches are important to improve the loading time of WebGPU applications after the first
visit.

For the specification, these caches are indifferentiable from incredibly fast compilation, but
for applications it would be easy to measure how long {{GPUDevice/createComputePipelineAsync()}}
takes to resolve. This can leak information across origins (like "did the user access a site with
this specific shader") so user agents should follow the best practices in
[storage partitioning](https://github.com/privacycg/storage-partitioning).

The system's GPU driver may also have its own cache of compiled shaders and pipelines. User agents
may want to disable these when at all possible, or add per-partition data to shaders in ways that
will make the GPU driver consider them different.

# Fundamentals # {#fundamentals}

## Conventions ## {#api-conventions}

### Dot Syntax ### {#dot-syntax}

In this specification, the `.` ("dot") syntax, common in programming languages, is used.
The phrasing "`Foo.Bar`" means "the `Bar` member of the value (or interface) `Foo`."

The `?.` ("optional chaining") syntax, adopted from JavaScript, is also used.
The phrasing "`Foo?.Bar`" means
"if `Foo` is `null` or `undefined`, `undefined`; otherwise, `Foo.Bar`".

For example, where `buffer` is a {{GPUBuffer}}, `buffer?.[[device]].[[adapter]]` means
"if `buffer` is `null` or `undefined`, then `undefined`; otherwise,
the `[[adapter]]` internal slot of the `[[device]]` internal slot of `buffer`.

### Internal Objects ### {#webgpu-internal-objects}

An <dfn dfn>internal object</dfn> is a conceptual, non-exposed WebGPU object.
[=Internal objects=] track the state of an API object and hold any underlying implementation.
If the state of a particular [=internal object=] can change in parallel from multiple [=agents=],
those changes are always atomic with respect to all [=agents=].

Note: An "[=agent=]" refers to a JavaScript "thread" (i.e. main thread, or Web Worker).

### WebGPU Interfaces ### {#webgpu-interfaces}

A <dfn dfn>WebGPU interface</dfn> is an exposed interface which encapsulates an [=internal object=].
It provides the interface through which the [=internal object=]'s state is changed.

Any interface which includes {{GPUObjectBase}} is a [=WebGPU interface=].

<script type=idl>
interface mixin GPUObjectBase {
    attribute USVString? label;
};
</script>

{{GPUObjectBase}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>label</dfn>
    ::
        A label which can be used by development tools (such as error/warning messages,
        browser developer tools, or platform debugging utilities) to identify the underlying
        [=internal object=] to the developer.
        It has no specified format, and therefore cannot be reliably machine-parsed.

        In any given situation, the user agent may or may not choose to use this label.
</dl>

{{GPUObjectBase}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUObjectBase>
    : <dfn>\[[device]]</dfn>, of type [=device=], readonly
    ::
        An internal slot holding the [=device=] which owns the [=internal object=].
</dl>

### Object Descriptors ### {#object-descriptors}

An <dfn dfn>object descriptor</dfn> holds the information needed to create an object,
which is typically done via one of the `create*` methods of {{GPUDevice}}.

<script type=idl>
dictionary GPUObjectDescriptorBase {
    USVString label;
};
</script>

{{GPUObjectDescriptorBase}} has the following members:

<dl dfn-type=dict-member dfn-for=GPUObjectDescriptorBase>
    : <dfn>label</dfn>
    ::
        The initial value of {{GPUObjectBase/label|GPUObjectBase.label}}.
</dl>

## Invalid Internal Objects &amp; Contagious Invalidity ## {#invalidity}

Object creation operations in WebGPU are internally asynchronous, so they don't fail with exceptions.
Instead, returned objects may refer to [=internal objects=] which are either
<dfn dfn>valid</dfn> or <dfn dfn>invalid</dfn>.
An [=invalid=] object may never become [=valid=] at a later time.
Some objects may become [=invalid=] during their lifetime, while most may only
be [=invalid=] from creation.

Objects are [=invalid=] from creation if it wasn't possible to create them.
This can happen, for example, if the [=object descriptor=] doesn't describe a valid
object, or if there is not enough memory to allocate a resource.

[=Internal objects=] of *most* types cannot become [=invalid=] after they are created, but still
may become unusable, e.g. if the owning device is [=lose the device|lost=] or
{{GPUDevice/destroy()|destroyed}}, or the object has a special internal state,
like buffer state [=buffer state/destroyed=].

[=Internal objects=] of some types *can* become [=invalid=] after they are created; specifically,
[=devices=], [=adapters=], and command/pass/bundle encoders.

<div algorithm>
    A given {{GPUObjectBase}} |object| is <dfn abstract-op>valid to use with</dfn>
    a |targetObject| if and only if the following requirements are met:

    <div class=validusage>
        - |object| must be [=valid=].
        - |object|.{{GPUObjectBase/[[device]]}} must be [=valid=].
        - |object|.{{GPUObjectBase/[[device]]}} must equal |targetObject|.{{GPUObjectBase/[[device]]}}.
    </div>
</div>

## Coordinate Systems ## {#coordinate-systems}

  - Y-axis is up in normalized device coordinate (NDC): point(-1.0, -1.0) in NDC is located at the bottom-left corner of NDC.
    In addition, x and y in NDC should be between -1.0 and 1.0 inclusive, while z in NDC should be between 0.0 and 1.0 inclusive.
    Vertices out of this range in NDC will not introduce any errors, but they will be clipped.
  - Y-axis is down in [=framebuffer=] coordinate, viewport coordinate and fragment/pixel coordinate:
    origin(0, 0) is located at the top-left corner in these coordinate systems.
  - Window/present coordinate matches [=framebuffer=] coordinate.
  - UV of origin(0, 0) in texture coordinate represents the first texel (the lowest byte) in texture memory.

Note: WebGPU's coordinate systems match DirectX's coordinate systems in a graphics pipeline.

## Programming Model ## {#programming-model}

### Timelines ### {#programming-model-timelines}

*This section is non-normative.*

A computer system with a user agent at the front-end and GPU at the back-end
has components working on different timelines in parallel:

: <dfn dfn>Content timeline</dfn>
:: Associated with the execution of the Web script.
    It includes calling all methods described by this specification.

    <div class=content-timeline>
        Steps executed on the content timeline look like this.
    </div>

: <dfn dfn>Device timeline</dfn>
:: Associated with the GPU device operations
    that are issued by the user agent.
    It includes creation of adapters, devices, and GPU resources
    and state objects, which are typically synchronous operations from the point
    of view of the user agent part that controls the GPU,
    but can live in a separate OS process.

    <div class=device-timeline>
        Steps executed on the device timeline look like this.
    </div>

: <dfn dfn>Queue timeline</dfn>
:: Associated with the execution of operations
    on the compute units of the GPU. It includes actual draw, copy,
    and compute jobs that run on the GPU.

    <div class=queue-timeline>
        Steps executed on the queue timeline look like this.
    </div>

In this specification, asynchronous operations are used when the result value
depends on work that happens on any timeline other than the [=Content timeline=].
They are represented by callbacks and promises in JavaScript.

<div class="example">
{{GPUComputePassEncoder/dispatch(x, y, z)|GPUComputePassEncoder.dispatch()}}:

  1. User encodes a `dispatch` command by calling a method of the
    {{GPUComputePassEncoder}} which happens on the [=Content timeline=].
  2. User issues {{GPUQueue/submit(commandBuffers)|GPUQueue.submit()}} that hands over
    the {{GPUCommandBuffer}} to the user agent, which processes it
    on the [=Device timeline=] by calling the OS driver to do a low-level submission.
  3. The submit gets dispatched by the GPU invocation scheduler onto the
    actual compute units for execution, which happens on the [=Queue timeline=].

</div>
<div class="example">
{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer()}}:

  1. User fills out a {{GPUBufferDescriptor}} and creates a {{GPUBuffer}} with it,
    which happens on the [=Content timeline=].
  2. User agent creates a low-level buffer on the [=Device timeline=].

</div>
<div class="example">
{{GPUBuffer/mapAsync()|GPUBuffer.mapAsync()}}:

  1. User requests to map a {{GPUBuffer}} on the [=Content timeline=] and
    gets a promise in return.
  2. User agent checks if the buffer is currently used by the GPU
    and makes a reminder to itself to check back when this usage is over.
  3. After the GPU operating on [=Queue timeline=] is done using the buffer,
    the user agent maps it to memory and [=resolves=] the promise.

</div>

### Memory Model ### {#programming-model-memory}

*This section is non-normative.*

Once a {{GPUDevice}} has been obtained during an application initialization routine,
we can describe the <dfn dfn>WebGPU platform</dfn> as consisting of the following layers:
  1. User agent implementing the specification.
  2. Operating system with low-level native API drivers for this device.
  3. Actual CPU and GPU hardware.

Each layer of the [=WebGPU platform=] may have different memory types
that the user agent needs to consider when implementing the specification:
  - The script-owned memory, such as an {{ArrayBuffer}} created by the script,
    is generally not accessible by a GPU driver.
  - A user agent may have different processes responsible for running
    the content and communication to the GPU driver.
    In this case, it uses inter-process shared memory to transfer data.
  - Dedicated GPUs have their own memory with high bandwidth,
    while integrated GPUs typically share memory with the system.

Most [=physical resources=] are allocated in the memory of type
that is efficient for computation or rendering by the GPU.
When the user needs to provide new data to the GPU,
the data may first need to cross the process boundary in order to reach
the user agent part that communicates with the GPU driver.
Then it may need to be made visible to the driver,
which sometimes requires a copy into driver-allocated staging memory.
Finally, it may need to be transferred to the dedicated GPU memory,
potentially changing the internal layout into one
that is most efficient for GPUs to operate on.

All of these transitions are done by the WebGPU implementation of the user agent.

Note: This example describes the worst case, while in practice
the implementation may not need to cross the process boundary,
or may be able to expose the driver-managed memory directly to
the user behind an `ArrayBuffer`, thus avoiding any data copies.

### Multi-Threading ### {#programming-model-multi-threading}

### Resource Usages ### {#programming-model-resource-usages}

A [=physical resource=] can be used on GPU with an <dfn dfn>internal usage</dfn>:
<dl dfn-type=dfn dfn-for="internal usage">
    : <dfn>input</dfn>
    :: Buffer with input data for draw or dispatch calls. Preserves the contents.
        Allowed by buffer {{GPUBufferUsage/INDEX}}, buffer {{GPUBufferUsage/VERTEX}}, or buffer {{GPUBufferUsage/INDIRECT}}.
    : <dfn>constant</dfn>
    ::  Resource bindings that are constant from the shader point of view. Preserves the contents.
        Allowed by buffer {{GPUBufferUsage/UNIFORM}} or texture {{GPUTextureUsage/TEXTURE_BINDING}}.
    : <dfn>storage</dfn>
    ::  Writable storage resource binding.
        Allowed by buffer {{GPUBufferUsage/STORAGE}} or texture {{GPUTextureUsage/STORAGE_BINDING}}.
    : <dfn>storage-read</dfn>
    ::  Read-only storage resource bindings. Preserves the contents.
        Allowed by buffer {{GPUBufferUsage/STORAGE}}.
    : <dfn>attachment</dfn>
    :: Texture used as an output attachment in a render pass.
        Allowed by texture {{GPUTextureUsage/RENDER_ATTACHMENT}}.
    : <dfn>attachment-read</dfn>
    ::  Texture used as a read-only attachment in a render pass. Preserves the contents.
        Allowed by texture {{GPUTextureUsage/RENDER_ATTACHMENT}}.
</dl>

Textures may consist of separate [=mipmap levels=] and [=array layers=],
which can be used differently at any given time.
Each such <dfn dfn>texture subresource</dfn> is uniquely identified by a
[=texture=], [=mipmap level=], and
(for {{GPUTextureDimension/2d}} textures only) [=array layer=],
and [=aspect=].

We define <dfn dfn>subresource</dfn> to be either a whole buffer, or a [=texture subresource=].

<div algorithm="compatible usage list">
Some [=internal usages=] are compatible with others. A [=subresource=] can be in a state
that combines multiple usages together. We consider a list |U| to be
a <dfn dfn>compatible usage list</dfn> if (and only if) it satisfies any of the following rules:
    - Each usage in |U| is [=internal usage/input=], [=internal usage/constant=], [=internal usage/storage-read=], or [=internal usage/attachment-read=].
    - Each usage in |U| is [=internal usage/storage=].
    - |U| contains exactly one element: [=internal usage/attachment=].
</div>

Enforcing that the usages are only combined into a [=compatible usage list=]
allows the API to limit when data races can occur in working with memory.
That property makes applications written against
WebGPU more likely to run without modification on different platforms.

Generally, when an implementation processes an operation that uses a [=subresource=]
in a different way than its current usage allows, it schedules a transition of the resource
into the new state. In some cases, like within an open {{GPURenderPassEncoder}}, such a
transition is impossible due to the hardware limitations.
We define these places as <dfn dfn>usage scopes</dfn>.

The **main usage rule** is, for any one [=subresource=], its list of [=internal usages=]
within one [=usage scope=] must be a [=compatible usage list=].

For example, binding the same buffer for [=internal usage/storage=] as well as for
[=internal usage/input=] within the same {{GPURenderPassEncoder}} would put the encoder
as well as the owning {{GPUCommandEncoder}} into the error state.
This combination of usages does not make a [=compatible usage list=].

Note: race condition of multiple writable storage buffer/texture usages in a single [=usage scope=] is allowed.

The [=subresources=] of textures included in the views provided to
{{GPURenderPassColorAttachment/view|GPURenderPassColorAttachment.view}} and
{{GPURenderPassColorAttachment/resolveTarget|GPURenderPassColorAttachment.resolveTarget}}
are considered to be used as [=internal usage/attachment=] for the [=usage scope=] of this render pass.

The <dfn dfn>physical size</dfn> of a [=texture subresource=] is the dimension of the
[=texture subresource=] in texels that includes the possible extra paddings
to form complete [=texel blocks=] in the [=subresource=].

  - For pixel-based {{GPUTextureFormat|GPUTextureFormats}}, the [=physical size=] is always equal to the size of the [=texture subresource=]
    used in the sampling hardwares.
  - [=Textures=] in block-based compressed {{GPUTextureFormat|GPUTextureFormats}} always have a [=mipmap level=] 0 whose {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}
    is a multiple of the [=texel block size=], but the lower mipmap levels might not be
    multiples of the [=texel block size=] and can have paddings.

<div class="example">
Considering a {{GPUTexture}} in BC format whose {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}} is {60, 60, 1}, when sampling
the {{GPUTexture}} at [=mipmap level=] 2, the sampling hardware uses {15, 15, 1} as the size of the [=texture subresource=],
while its [=physical size=] is {16, 16, 1} as the block-compression algorithm can only operate on 4x4 [=texel blocks=].
</div>

### Synchronization ### {#programming-model-synchronization}

For each [=subresource=] of a [=physical resource=], its set of
[=internal usage=] flags is tracked on the [=Queue timeline=].

Issue: This section will need to be revised to support multiple queues.

On the [=Queue timeline=], there is an ordered sequence of [=usage scopes=].
For the duration of each scope, the set of [=internal usage=] flags of any given
[=subresource=] is constant.
A [=subresource=] may transition to new usages at the boundaries between [=usage scope=]s.

This specification defines the following [=usage scopes=]:

- Outside of a pass (in {{GPUCommandEncoder}}), each (non-state-setting) command is one usage scope
    (e.g. {{GPUCommandEncoder/copyBufferToTexture()}}).
- In a compute pass, each dispatch command ({{GPUComputePassEncoder/dispatch()}} or
    {{GPUComputePassEncoder/dispatchIndirect()}}) is one usage scope.
    A subresource is "used" in the usage scope if it is potentially accessible by the command.
    Within a dispatch, for each bind group slot that is used by the current {{GPUComputePipeline}}'s
    {{GPUPipelineBase/[[layout]]}}, every [=subresource=] referenced by
    that bind group is "used" in the usage scope.
    State-setting compute pass commands, like
    {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}},
    do not contribute directly to a usage scope; they instead change the
    state that is checked in dispatch commands.
- One render pass is one usage scope.
    A subresource is "used" in the usage scope if it's referenced by any
    (state-setting or non-state-setting) command. For example, in
    {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}},
    every subresource in `bindGroup` is "used" in the render pass's usage scope.

Issue: The above should probably talk about [=GPU commands=]. But we don't have a way to
reference specific GPU commands (like dispatch) yet.

<div class=note>
    The above rules mean the following example resource usages **are**
    included in [=usage scope validation=]:

    - In a render pass, subresources used in any
        {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup()}}
        call, regardless of whether the currently bound pipeline's
        shader or layout actually depends on these bindings,
        or the bind group is shadowed by another 'set' call.
    - A buffer used in any {{GPURenderEncoderBase/setVertexBuffer()|setVertexBuffer()}}
        call, regardless of whether any draw call depends on this buffer,
        or this buffer is shadowed by another 'set' call.
    - A buffer used in any {{GPURenderEncoderBase/setIndexBuffer()|setIndexBuffer()}}
        call, regardless of whether any draw call depends on this buffer,
        or this buffer is shadowed by another 'set' call.
    - A texture subresource used as a color attachment, resolve attachment, or
        depth/stencil attachment in {{GPURenderPassDescriptor}} by
        {{GPUCommandEncoder/beginRenderPass()|beginRenderPass()}},
        regardless of whether the shader actually depends on these attachments.
    - Resources used in bind group entries with visibility 0, or visible only
        to the compute stage but used in a render pass (or vice versa).
</div>

During command encoding, every usage of a subresource is recorded in one of the
[=usage scopes=] in the command buffer.
For each [=usage scope=], the implementation performs
<dfn dfn>usage scope validation</dfn> by composing the list of all
[=internal usage=] flags of each [=subresource=] used in the [=usage scope=].
If any of those lists is not a [=compatible usage list=],
{{GPUCommandEncoder/finish()|GPUCommandEncoder.finish()}}
generates a {{GPUValidationError}} in the current error scope.


## Core Internal Objects ## {#core-internal-objects}

### Adapters ### {#adapters}

An <dfn dfn>adapter</dfn> identifies an implementation of WebGPU on the system:
both an instance of compute/rendering functionality on the
platform underlying a browser, and an instance of a browser's implementation of
WebGPU on top of that functionality.

[=Adapters=] do not uniquely represent underlying implementations:
calling {{GPU/requestAdapter()}} multiple times returns a different [=adapter=]
object each time.

An [=adapter=] object may become [=invalid=] at any time.
This happens inside "[=lose the device=]" and "[=mark adapters stale=]".
An invalid adapter is unable to vend new [=devices=].

Note:
This mechanism ensures that various adapter-creation scenarios look similar to applications,
so they can easily be robust to more scenarios with less testing: first initialization,
reinitialization due to an unplugged adapter, reinitialization due to a test
{{GPUDevice/destroy()|GPUDevice.destroy()}} call, etc. It also ensures applications use
the latest system state to make decisions about which adapter to use.

An [=adapter=] may be considered a <dfn>fallback adapter</dfn> if it has significant performance
caveats in exchange for some combination of wider compatibility, more predictable behavior, or
improved privacy. It is not required that a [=fallback adapter=] is available on every system.

An [=adapter=] has the following internal slots:

<dl dfn-type=attribute dfn-for=adapter>
    : <dfn>\[[features]]</dfn>, of type [=ordered set=]&lt;{{GPUFeatureName}}&gt;, readonly
    ::
        The [=features=] which can be used to create devices on this adapter.

    : <dfn>\[[limits]]</dfn>, of type [=supported limits=], readonly
    ::
        The [=limit/better|best=] limits which can be used to create devices on this adapter.

        Each adapter limit must be the same or [=limit/better=] than its default value
        in [=supported limits=].

    : <dfn>\[[fallback]]</dfn>, of type boolean
    ::
        If set to `true` indicates that the adapter is a [=fallback adapter=].
</dl>

[=Adapters=] are exposed via {{GPUAdapter}}.

### Devices ### {#devices}

A <dfn dfn>device</dfn> is the logical instantiation of an [=adapter=],
through which [=internal objects=] are created.
It can be shared across multiple [=agents=] (e.g. dedicated workers).

A [=device=] is the exclusive owner of all [=internal objects=] created from it:
when the [=device=] is [=lose the device|lost=] or {{GPUDevice/destroy()|destroyed}},
it and all objects created on it (directly, e.g.
{{GPUDevice/createTexture()}}, or indirectly, e.g. {{GPUTexture/createView()}}) become
implicitly [$valid to use with|unusable$].

Issue: Define "ownership".

A [=device=] has the following internal slots:

<dl dfn-type=attribute dfn-for=device>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        The [=adapter=] from which this device was created.

    : <dfn>\[[features]]</dfn>, of type [=ordered set=]&lt;{{GPUFeatureName}}&gt;, readonly
    ::
        The [=features=] which can be used on this device.
        No additional features can be used, even if the underlying [=adapter=] can support them.

    : <dfn>\[[limits]]</dfn>, of type [=supported limits=], readonly
    ::
        The limits which can be used on this device.
        No [=limit/better=] limits can be used, even if the underlying [=adapter=] can support them.
</dl>

<div algorithm>
    When <dfn dfn>a new device</dfn> |device| is created from [=adapter=] |adapter|
    with {{GPUDeviceDescriptor}} |descriptor|:

    - Set |device|.{{device/[[adapter]]}} to |adapter|.

    - Set |device|.{{device/[[features]]}} to the [=ordered set|set=] of values in
        |descriptor|.{{GPUDeviceDescriptor/requiredFeatures}}.

    - Let |device|.{{device/[[limits]]}} be a [=supported limits=] object with the default values.
        For each (|key|, |value|) pair in |descriptor|.{{GPUDeviceDescriptor/requiredLimits}}, set the
        member corresponding to |key| in |device|.{{device/[[limits]]}} to the [=limit/better=]
        value of |value| or the default value in [=supported limits=].
</div>

Any time the user agent needs to revoke access to a device, it calls
[=lose the device=](device, `undefined`).

<div algorithm>
    To <dfn dfn>lose the device</dfn>(|device|, |reason|):

    1. Make |device|.{{device/[[adapter]]}} [=invalid=].
    1. Make |device| [=invalid=].
    1. Issue: explain how to get from |device| to its "primary" {{GPUDevice}}.
    1. Resolve |device|.{{GPUDevice/lost}} with a new {{GPUDeviceLostInfo}} with
        {{GPUDeviceLostInfo/reason}} set to |reason| and
        {{GPUDeviceLostInfo/message}} set to an implementation-defined value.

        Note: {{GPUDeviceLostInfo/message}} should not disclose unnecessary user/system
        information and should never be parsed by applications.
</div>

[=Devices=] are exposed via {{GPUDevice}}.

## Optional Capabilities ## {#optional-capabilities}

WebGPU [=adapters=] and [=devices=] have <dfn dfn>capabilities</dfn>, which
describe WebGPU functionality that differs between different implementations,
typically due to hardware or system software constraints.
A [=capability=] is either a [=feature=] or a [=limit=].

### Features ### {#features}

A <dfn dfn>feature</dfn> is a set of optional WebGPU functionality that is not supported
on all implementations, typically due to hardware or system software constraints.

Each {{GPUAdapter}} exposes a set of available features.
Only those features may be requested in {{GPUAdapter/requestDevice()}}.

Functionality that is part of an feature may only be used if the feature was requested at device
creation.
Dictionary members added to existing dictionaries by optional features are always optional at the
WebIDL level; if the feature is not enabled, such members must not be set to non-default values.

Note: Though enabling a feature won't add new IDL-required fields, it may not necessarily be
backward-compatible with existing code.
An optional feature can enable new validation which invalidates previously-valid code.

See the [[#feature-index|Feature Index]] for a description of the functionality each feature enables.

### Limits ### {#limits}

Each <dfn dfn>limit</dfn> is a numeric limit on the usage of WebGPU on a device.

A <dfn dfn>supported limits</dfn> object has a value for every defined limit.
Each [=adapter=] has a set of [=supported limits=], and
[=devices=] are {{GPUDeviceDescriptor/requiredLimits|created}} with specific [=supported limits=] in place.
The device limits are enforced regardless of the adapter's limits.

Each limit has a <dfn dfn for=limit>default</dfn> value.
Every [=adapter=] is guaranteed to support the default value or [=limit/better=].
The default is used if a value is not explicitly specified in {{GPUDeviceDescriptor/requiredLimits}}.

One limit value may be <dfn dfn for=limit>better</dfn> than another.
A [=limit/better=] limit value always relaxes validation, enabling strictly
more programs to be valid. For each [=limit class=], "better" is defined.

Different limits have different <dfn dfn lt="limit class">limit classes</dfn>:

<dl dfn-type=dfn dfn-for="limit class">
    : <dfn>maximum</dfn>
    ::
        The limit enforces a maximum on some value passed into the API.

        Higher values are [=limit/better=].

        May only be set to values &ge; the [=limit/default=].
        Lower values are clamped to the [=limit/default=].

    : <dfn>alignment</dfn>
    ::
        The limit enforces a minimum alignment on some value passed into the API; that is,
        the value must be a multiple of the limit.

        Lower values are [=limit/better=].

        May only be set to powers of 2 which are &le; the [=limit/default=].
        Values which are not powers of 2 are invalid.
        Higher powers of 2 are clamped to the [=limit/default=].
</dl>

Note:
Setting "better" limits may not necessarily be desirable, as they may have a performance impact.
Because of this, and to improve portability across devices and implementations,
applications should generally request the "worst" limits that work for their content
(ideally, the default values).

<table class="data no-colspan-center" dfn-type=attribute dfn-for="supported limits">
    <thead>
        <tr><th>Limit name <th>Type <th>[=Limit class=] <th>[=limit/Default=]
    </thead>

    <tr><td><dfn>maxTextureDimension1D</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8192
    <tr class=row-continuation><td colspan=4>
        The maximum allowed value for the {{GPUTextureDescriptor/size}}.[=Extent3D/width=]
        of a [=texture=] created with {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}}.

    <tr><td><dfn>maxTextureDimension2D</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8192
    <tr class=row-continuation><td colspan=4>
        The maximum allowed value for the {{GPUTextureDescriptor/size}}.[=Extent3D/width=] and {{GPUTextureDescriptor/size}}.[=Extent3D/height=]
        of a [=texture=] created with {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"2d"}}.

    <tr><td><dfn>maxTextureDimension3D</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>2048
    <tr class=row-continuation><td colspan=4>
        The maximum allowed value for the {{GPUTextureDescriptor/size}}.[=Extent3D/width=], {{GPUTextureDescriptor/size}}.[=Extent3D/height=] and {{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=]
        of a [=texture=] created with {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"3d"}}.

    <tr><td><dfn>maxTextureArrayLayers</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>256
    <tr class=row-continuation><td colspan=4>
        The maximum allowed value for the {{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=]
        of a [=texture=] created with {{GPUTextureDescriptor/dimension}} {{GPUTextureDimension/"1d"}} or {{GPUTextureDimension/"2d"}}.

    <tr><td><dfn>maxBindGroups</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>4
    <tr class=row-continuation><td colspan=4>
        The maximum number of {{GPUBindGroupLayout|GPUBindGroupLayouts}}
        allowed in {{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
        when creating a {{GPUPipelineLayout}}.

    <tr><td><dfn>maxDynamicUniformBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8
    <tr class=row-continuation><td colspan=4>
        The maximum number of {{GPUBindGroupLayoutEntry}} entries across a {{GPUPipelineLayout}}
        which are uniform buffers with dynamic offsets.
        See [=Exceeds the binding slot limits=].

    <tr><td><dfn>maxDynamicStorageBuffersPerPipelineLayout</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>4
    <tr class=row-continuation><td colspan=4>
        The maximum number of {{GPUBindGroupLayoutEntry}} entries across a {{GPUPipelineLayout}}
        which are storage buffers with dynamic offsets.
        See [=Exceeds the binding slot limits=].

    <tr><td><dfn>maxSampledTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>16
    <tr class=row-continuation><td colspan=4>
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutEntry}} entries across a {{GPUPipelineLayout}}
        which are sampled textures.
        See [=Exceeds the binding slot limits=].

    <tr><td><dfn>maxSamplersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>16
    <tr class=row-continuation><td colspan=4>
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutEntry}} entries across a {{GPUPipelineLayout}}
        which are samplers.
        See [=Exceeds the binding slot limits=].

    <tr><td><dfn>maxStorageBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8
    <tr class=row-continuation><td colspan=4>
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutEntry}} entries across a {{GPUPipelineLayout}}
        which are storage buffers.
        See [=Exceeds the binding slot limits=].

    <tr><td><dfn>maxStorageTexturesPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>4
    <tr class=row-continuation><td colspan=4>
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutEntry}} entries across a {{GPUPipelineLayout}}
        which are storage textures.
        See [=Exceeds the binding slot limits=].

    <tr><td><dfn>maxUniformBuffersPerShaderStage</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>12
    <tr class=row-continuation><td colspan=4>
        For each possible {{GPUShaderStage}} `stage`,
        the maximum number of {{GPUBindGroupLayoutEntry}} entries across a {{GPUPipelineLayout}}
        which are uniform buffers.
        See [=Exceeds the binding slot limits=].

    <tr><td><dfn>maxUniformBufferBindingSize</dfn>
        <td>{{GPUSize64}} <td>[=limit class/maximum=] <td>65536
    <tr class=row-continuation><td colspan=4>
        The maximum {{GPUBufferBinding}}.{{GPUBufferBinding/size}} for bindings with a
        {{GPUBindGroupLayoutEntry}} |entry| for which
        |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
        is {{GPUBufferBindingType/"uniform"}}.

    <tr><td><dfn>maxStorageBufferBindingSize</dfn>
        <td>{{GPUSize64}} <td>[=limit class/maximum=] <td> 134217728 (128 MiB)
    <tr class=row-continuation><td colspan=4>
        The maximum {{GPUBufferBinding}}.{{GPUBufferBinding/size}} for bindings with a
        {{GPUBindGroupLayoutEntry}} |entry| for which
        |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
        is {{GPUBufferBindingType/"storage"}}
        or {{GPUBufferBindingType/"read-only-storage"}}.

    <tr><td><dfn>minUniformBufferOffsetAlignment</dfn>
        <td>{{GPUSize32}} <td>[=limit class/alignment=] <td>256
    <tr class=row-continuation><td colspan=4>
        The required alignment for {{GPUBufferBinding}}.{{GPUBufferBinding/offset}} and
        {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}}
        |dynamicOffsets| arguments for binding with a {{GPUBindGroupLayoutEntry}} |entry| for which
        |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
        is {{GPUBufferBindingType/"uniform"}}.

    <tr><td><dfn>minStorageBufferOffsetAlignment</dfn>
        <td>{{GPUSize32}} <td>[=limit class/alignment=] <td>256
    <tr class=row-continuation><td colspan=4>
        The required alignment for {{GPUBufferBinding}}.{{GPUBufferBinding/offset}} and
        {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}}
        |dynamicOffsets| arguments for binding with a {{GPUBindGroupLayoutEntry}} |entry| for which
        |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
        is {{GPUBufferBindingType/"storage"}}
        or {{GPUBufferBindingType/"read-only-storage"}}.

    <tr><td><dfn>maxVertexBuffers</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>8
    <tr class=row-continuation><td colspan=4>
        The maximum number of {{GPUVertexState/buffers}}
        when creating a {{GPURenderPipeline}}.

    <tr><td><dfn>maxVertexAttributes</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>16
    <tr class=row-continuation><td colspan=4>
        The maximum number of {{GPUVertexBufferLayout/attributes}}
        in total across {{GPUVertexState/buffers}}
        when creating a {{GPURenderPipeline}}.

    <tr><td><dfn>maxVertexBufferArrayStride</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>2048
    <tr class=row-continuation><td colspan=4>
        The maximum allowed {{GPUVertexBufferLayout/arrayStride}}
        when creating a {{GPURenderPipeline}}.

    <tr><td><dfn>maxInterStageShaderComponents</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>60
    <tr class=row-continuation><td colspan=4>
        The maximum allowed number of components of input or output variables
        for inter-stage communication (like vertex outputs or fragment inputs).

    <tr><td><dfn>maxComputeWorkgroupStorageSize</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>16352
    <tr class=row-continuation><td colspan=4>
        The maximum number of bytes used for a compute stage
        {{GPUShaderModule}} entry-point.

    <tr><td><dfn>maxComputeInvocationsPerWorkgroup</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>256
    <tr class=row-continuation><td colspan=4>
        The maximum value of the product of the `workgroup_size` dimensions for a
        compute stage {{GPUShaderModule}} entry-point.

    <tr><td><dfn>maxComputeWorkgroupSizeX</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>256
    <tr class=row-continuation><td colspan=4>
        The maximum value of the `workgroup_size` X dimension for a
        compute stage {{GPUShaderModule}} entry-point.

    <tr><td><dfn>maxComputeWorkgroupSizeY</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>256
    <tr class=row-continuation><td colspan=4>
        The maximum value of the `workgroup_size` Y dimensions for a
        compute stage {{GPUShaderModule}} entry-point.

    <tr><td><dfn>maxComputeWorkgroupSizeZ</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>64
    <tr class=row-continuation><td colspan=4>
        The maximum value of the `workgroup_size` Z dimensions for a
        compute stage {{GPUShaderModule}} entry-point.

    <tr><td><dfn>maxComputeWorkgroupsPerDimension</dfn>
        <td>{{GPUSize32}} <td>[=limit class/maximum=] <td>65535
    <tr class=row-continuation><td colspan=4>
        The maximum value for the arguments of {{GPUComputePassEncoder/dispatch(x, y, z)}}.

</table>

Issue: Do we need to have a max per-pixel render target size?

#### <dfn interface>GPUSupportedLimits</dfn> #### {#gpu-supportedlimits}

{{GPUSupportedLimits}} exposes the [=limits=] supported by an adapter or device.
See {{GPUAdapter/limits|GPUAdapter.limits}} and {{GPUDevice/limits|GPUDevice.limits}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSupportedLimits {
    readonly attribute unsigned long maxTextureDimension1D;
    readonly attribute unsigned long maxTextureDimension2D;
    readonly attribute unsigned long maxTextureDimension3D;
    readonly attribute unsigned long maxTextureArrayLayers;
    readonly attribute unsigned long maxBindGroups;
    readonly attribute unsigned long maxDynamicUniformBuffersPerPipelineLayout;
    readonly attribute unsigned long maxDynamicStorageBuffersPerPipelineLayout;
    readonly attribute unsigned long maxSampledTexturesPerShaderStage;
    readonly attribute unsigned long maxSamplersPerShaderStage;
    readonly attribute unsigned long maxStorageBuffersPerShaderStage;
    readonly attribute unsigned long maxStorageTexturesPerShaderStage;
    readonly attribute unsigned long maxUniformBuffersPerShaderStage;
    readonly attribute unsigned long long maxUniformBufferBindingSize;
    readonly attribute unsigned long long maxStorageBufferBindingSize;
    readonly attribute unsigned long minUniformBufferOffsetAlignment;
    readonly attribute unsigned long minStorageBufferOffsetAlignment;
    readonly attribute unsigned long maxVertexBuffers;
    readonly attribute unsigned long maxVertexAttributes;
    readonly attribute unsigned long maxVertexBufferArrayStride;
    readonly attribute unsigned long maxInterStageShaderComponents;
    readonly attribute unsigned long maxComputeWorkgroupStorageSize;
    readonly attribute unsigned long maxComputeInvocationsPerWorkgroup;
    readonly attribute unsigned long maxComputeWorkgroupSizeX;
    readonly attribute unsigned long maxComputeWorkgroupSizeY;
    readonly attribute unsigned long maxComputeWorkgroupSizeZ;
    readonly attribute unsigned long maxComputeWorkgroupsPerDimension;
};
</script>

#### <dfn interface>GPUSupportedFeatures</dfn> #### {#gpu-supportedfeatures}

{{GPUSupportedFeatures}} is a [=setlike=] interface. Its [=set entries=] are
the {{GPUFeatureName}} values of the [=features=] supported by an adapter or
device. It must only contain strings from the {{GPUFeatureName}} enum.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSupportedFeatures {
    readonly setlike<DOMString>;
};
</script>

<div class="note">
Note: The type of the {{GPUSupportedFeatures}} [=set entries=] is {{DOMString}} to allow user
agents to gracefully handle valid {{GPUFeatureName}}s which are added in later revisions of the spec
but which the user agent has not been updated to recognize yet. If the [=set entries=] type was
{{GPUFeatureName}} the following code would throw an {{TypeError}} rather than reporting `false`:

<div class="example">
    Check for support of an unrecognized feature:
    <pre highlight="js">
        if (adapter.features.has('unknown-feature')) {
            // Use unknown-feature
        } else {
            console.warn('unknown-feature is not supported by this adapter.');
        }
    </pre>
</div>
</div>

## Origin Restrictions ## {#origin-restrictions}

WebGPU allows accessing image data stored in images, videos, and canvases.
Restrictions are imposed on the use of cross-domain media, because shaders can be used to
indirectly deduce the contents of textures which have been uploaded to the GPU.

WebGPU disallows uploading an image source if it <l spec=html>[=is not origin-clean=]</l>.

This also implies that the [=origin-clean=] flag for a
canvas rendered using WebGPU will never be set to `false`.

For more information on issuing CORS requests for image and video elements, consult:

- [[html#cors-settings-attributes]]
- [[html#the-img-element]] <{img}>
- [[html#media-elements]] {{HTMLMediaElement}}

## Color Spaces and Encoding ## {#color-spaces}

WebGPU does not provide color management. All values within WebGPU (such as texture elements)
are raw numeric values, not color-managed color values.

WebGPU *does* interface with color-managed outputs (via {{GPUCanvasConfiguration}}) and inputs
(via {{GPUQueue/copyExternalImageToTexture()}} and {{GPUDevice/importExternalTexture()}}).
Thus, color conversion must be performed between the WebGPU numeric values and the external color values.
Each such interface point locally defines an encoding (color space, transfer function, and alpha
premultiplication) in which the WebGPU numeric values are to be interpreted.

Each color space is defined over an extended range, if defined by the referenced CSS definitions,
to represent color values outside of its space (in both chrominance and luminance).

<script type=idl>
enum GPUPredefinedColorSpace {
    "srgb",
};
</script>

Issue: Possibly replace this with {{PredefinedColorSpace}}, but note that doing so would mean new
WebGPU functionality gets added automatically when items are added to that enum in the upstream spec.

Issue(gpuweb/gpuweb#1715):
Consider a path for uploading srgb-encoded images into linearly-encoded textures.

<dl dfn-type=enum-value dfn-for=GPUPredefinedColorSpace>
    : <dfn>"srgb"</dfn>
    :: The CSS predefined color space <a value for=color()>srgb</a>.
</dl>

### Color Space Conversions ### {#color-space-conversions}

A color is converted between spaces by translating its representation in one space to a
representation in another according to the definitions above.

If the source value has fewer than 4 channels, the remaining green/blue/alpha channels are set to
`0, 0, 1` respectively, as needed, before converting for color space/encoding and alpha premultiplication.
After conversion, if the destination needs fewer than 4 channels, the additional channels
are ignored.

Colors are not lossily clamped during conversion: converting from one color space to another
will result in values outside the range [0, 1] if the source color values were outside the range
of the destination color space's gamut (e.g. if a Display P3 image is converted to sRGB).


# Initialization # {#initialization}

## Examples ## {#initialization-examples}

Issue:
Need a robust example like the one in ErrorHandling.md, which handles all situations.
Possibly also include a simple example with no handling.

## navigator.gpu ## {#navigator-gpu}

A {{GPU}} object is available in the {{Window}} and {{DedicatedWorkerGlobalScope}} contexts through the {{Navigator}}
and {{WorkerNavigator}} interfaces respectively and is exposed via `navigator.gpu`:

<script type=idl>
interface mixin NavigatorGPU {
    [SameObject, SecureContext] readonly attribute GPU gpu;
};
Navigator includes NavigatorGPU;
WorkerNavigator includes NavigatorGPU;
</script>

## GPU ## {#gpu-interface}

<dfn interface>GPU</dfn> is the entry point to WebGPU.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPU {
    Promise<GPUAdapter?> requestAdapter(optional GPURequestAdapterOptions options = {});
};
</script>

{{GPU}} has the following methods:

<dl dfn-type=method dfn-for=GPU>
    : <dfn>requestAdapter(options)</dfn>
    ::
        Requests an [=adapter=] from the user agent.
        The user agent chooses whether to return an adapter, and, if so,
        chooses according to the provided options.

        <div algorithm=GPU.requestAdapter>
            **Called on:** {{GPU}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPU/requestAdapter(options)">
                |options|: Criteria used to select the adapter.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPUAdapter}}?&gt;

            1. Let |promise| be [=a new promise=].
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If the user agent chooses to return an adapter, it should:
                        1. Create a [=valid=] [=adapter=] |adapter|, chosen according to
                            the rules in [[#adapter-selection]] and the criteria in |options|.

                        1. If |adapter| meets the criteria of a [=fallback adapter=] set
                            |adapter|.{{adapter/[[fallback]]}} to `true`.

                        1. [=Resolve=] |promise| with a new {{GPUAdapter}} encapsulating |adapter|.

                    1. Otherwise, |promise| [=resolves=] with `null`.
                </div>
            1. Return |promise|.

            <!-- If we add ways to make invalid adapter requests (aside from those
                 that violate IDL rules), specify that they reject the promise. -->
        </div>
</dl>

{{GPU}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPU>
    : <dfn>\[[previously_returned_adapters]]</dfn>, of type [=ordered set=]&lt;[=adapter=]&gt;
    ::
        The set of [=adapters=] that have been returned via {{GPU/requestAdapter()}}.
        It is used, then cleared, in [=mark adapters stale=].
</dl>

Upon any change in the system's state that could affect the result of any {{GPU/requestAdapter()}}
call, the user agent *should* [=mark adapters stale=]. For example:

- A physical adapter is added/removed (via plug, driver update, TDR, etc.)
- The system's power configuration has changed (laptop unplugged, power settings changed, etc.)

Additionally, [=mark adapters stale=] may by scheduled at any time.
User agents may choose to do this often even when there has been no system state change (e.g.
several seconds after the last call to {{GPUAdapter/requestDevice()}}.
This has no effect on well-formed applications, obfuscates real system state changes, and makes
developers more aware that calling {{GPU/requestAdapter()}} again is always necessary before
calling {{GPUAdapter/requestDevice()}}.

<div algorithm>
    To <dfn dfn>mark adapters stale</dfn>:

    1. For each |adapter| in `navigator.gpu.`{{GPU/[[previously_returned_adapters]]}}:
        1. Make |adapter|.{{GPUAdapter/[[adapter]]}} [=invalid=].
    1. [=list/Empty=] `navigator.gpu.`{{GPU/[[previously_returned_adapters]]}}.

    Issue: Update here if an `adaptersadded`/`adapterschanged` event is introduced.
</div>

<div class="example">
    Request a {{GPUAdapter}}:
    <pre highlight="js">
        const adapter = await navigator.gpu.requestAdapter(/* ... */);
        const features = adapter.features;
        // ...
    </pre>
</div>

### Adapter Selection ### {#adapter-selection}

<dfn dictionary>GPURequestAdapterOptions</dfn>
provides hints to the user agent indicating what
configuration is suitable for the application.

<script type=idl>
dictionary GPURequestAdapterOptions {
    GPUPowerPreference powerPreference;
    boolean forceFallbackAdapter = false;
};
</script>

<script type=idl>
enum GPUPowerPreference {
    "low-power",
    "high-performance",
};
</script>

{{GPURequestAdapterOptions}} has the following members:

<dl dfn-type=dict-member dfn-for=GPURequestAdapterOptions>
    : <dfn>powerPreference</dfn>
    ::
        Optionally provides a hint indicating what class of [=adapter=] should be selected from
        the system's available adapters.

        The value of this hint may influence which adapter is chosen, but it must not
        influence whether an adapter is returned or not.

        Note:
        The primary utility of this hint is to influence which GPU is used in a multi-GPU system.
        For instance, some laptops have a low-power integrated GPU and a high-performance
        discrete GPU.

        Note:
        Depending on the exact hardware configuration, such as battery status and attached displays
        or removable GPUs, the user agent may select different [=adapters=] given the same power
        preference.
        Typically, given the same hardware configuration and state and
        `powerPreference`, the user agent is likely to select the same adapter.

        It must be one of the following values:

        <dl dfn-type=enum-value dfn-for=GPUPowerPreference>
            : `undefined` (or not present)
            ::
                Provides no hint to the user agent.

            : <dfn>"low-power"</dfn>
            ::
                Indicates a request to prioritize power savings over performance.

                Note:
                Generally, content should use this if it is unlikely to be constrained by drawing
                performance; for example, if it renders only one frame per second, draws only relatively
                simple geometry with simple shaders, or uses a small HTML canvas element.
                Developers are encouraged to use this value if their content allows, since it may
                significantly improve battery life on portable devices.

            : <dfn>"high-performance"</dfn>
            ::
                Indicates a request to prioritize performance over power consumption.

                Note:
                By choosing this value, developers should be aware that, for [=devices=] created on the
                resulting adapter, user agents are more likely to force device loss, in order to save
                power by switching to a lower-power adapter.
                Developers are encouraged to only specify this value if they believe it is absolutely
                necessary, since it may significantly decrease battery life on portable devices.
        </dl>

    : <dfn>forceFallbackAdapter</dfn>
    ::
        When set to `true` indicates that only a [=fallback adapter=] may be returned. If the user
        agent does not support a [=fallback adapter=], will cause {{GPU/requestAdapter()}} to
        resolve to `null`.

        Note:
        {{GPU/requestAdapter()}} may still return a [=fallback adapter=] if
        {{GPURequestAdapterOptions/forceFallbackAdapter}} is set to `false` and either no
        other appropriate [=adapter=] is available or the user agent chooses to return a
        [=fallback adapter=]. Developers that wish to prevent their applications from running on
        [=fallback adapters=] should check the {{GPUAdapter}}.{{GPUAdapter/isFallbackAdapter}}
        attribute prior to requesting a {{GPUDevice}}.
</dl>

## <dfn interface>GPUAdapter</dfn> ## {#gpu-adapter}

A {{GPUAdapter}} encapsulates an [=adapter=],
and describes its capabilities ([=features=] and [=limits=]).

To get a {{GPUAdapter}}, use {{GPU/requestAdapter()}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUAdapter {
    readonly attribute DOMString name;
    [SameObject] readonly attribute GPUSupportedFeatures features;
    [SameObject] readonly attribute GPUSupportedLimits limits;
    readonly attribute boolean isFallbackAdapter;

    Promise<GPUDevice> requestDevice(optional GPUDeviceDescriptor descriptor = {});
};
</script>

{{GPUAdapter}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>name</dfn>
    ::
        A human-readable name identifying the adapter.
        The contents are implementation-defined.

    : <dfn>features</dfn>
    ::
        The set of values in `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[features]]}}.

    : <dfn>limits</dfn>
    ::
        The limits in `this`.{{GPUAdapter/[[adapter]]}}.{{adapter/[[limits]]}}.

    : <dfn>isFallbackAdapter</dfn>
    ::
        Returns the value of {{GPUAdapter/[[adapter]]}}.{{adapter/[[fallback]]}}.
</dl>

{{GPUAdapter}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUAdapter>
    : <dfn>\[[adapter]]</dfn>, of type [=adapter=], readonly
    ::
        The [=adapter=] to which this {{GPUAdapter}} refers.
</dl>

{{GPUAdapter}} has the following methods:

<dl dfn-type=method dfn-for=GPUAdapter>
    : <dfn>requestDevice(descriptor)</dfn>
    ::
        Requests a [=device=] from the [=adapter=].

        <div algorithm=GPUAdapter.requestDevice>
            **Called on:** {{GPUAdapter}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUAdapter/requestDevice(descriptor)">
                |descriptor|: Description of the {{GPUDevice}} to request.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPUDevice}}&gt;

            1. Let |promise| be [=a new promise=].
            1. Let |adapter| be |this|.{{GPUAdapter/[[adapter]]}}.
            1. Issue the following steps to the [=Device timeline=]:
                <div class=device-timeline>
                    1. If any of the following requirements are unmet,
                        [=reject=] |promise| with a {{TypeError}} and stop.

                        <div class=validusage>
                            - The set of values in |descriptor|.{{GPUDeviceDescriptor/requiredFeatures}}
                                must be a subset of those in |adapter|.{{adapter/[[features]]}}.
                        </div>

                        Note: This is the same error that is produced if a feature name isn't known
                        by the browser at all (in its {{GPUFeatureName}} definition).
                        This converges the behavior when the browser doesn't support a feature
                        with the behavior when a particular adapter doesn't support a feature.

                    1. If any of the following requirements are unmet,
                        [=reject=] |promise| with an {{OperationError}} and stop.

                        <div class=validusage>
                            - Each key in |descriptor|.{{GPUDeviceDescriptor/requiredLimits}}
                                must be the name of a member of [=supported limits=].

                            - For each limit name |key| in the keys of [=supported limits=]:
                                Let |value| be |descriptor|.{{GPUDeviceDescriptor/requiredLimits}}[|key|].
                                - |value| must be no [=limit/better=] than the value of that limit in
                                    |adapter|.{{adapter/[[limits]]}}.
                                - If the limit's [=limit class|class=] is [=limit class/alignment=],
                                    |value| must be a power of 2.
                        </div>

                    1. If |adapter| is [=invalid=],
                        or the user agent otherwise cannot fulfill the request:

                        1. Let |device| be a new [=device=].
                        1. [=Lose the device=](|device|, `undefined`).

                            Note:
                            This makes |adapter| [=invalid=], if it wasn't already.

                            Note:
                            User agents should consider issuing developer-visible warnings in
                            most or all cases when this occurs. Applications should perform
                            reinitialization logic starting with {{GPU/requestAdapter()}}.

                        1. [=Resolve=] |promise| with a new {{GPUDevice}} encapsulating |device|,
                            and stop.

                    1. [=Resolve=] |promise| with a new {{GPUDevice}} object encapsulating
                        [=a new device=] with the capabilities described by |descriptor|.
                </div>
            1. Return |promise|.

        </div>
</dl>

### <dfn dictionary>GPUDeviceDescriptor</dfn> ### {#gpudevicedescriptor}

{{GPUDeviceDescriptor}} describes a device request.

<script type=idl>
dictionary GPUDeviceDescriptor : GPUObjectDescriptorBase {
    sequence<GPUFeatureName> requiredFeatures = [];
    record<DOMString, GPUSize64> requiredLimits = {};
};
</script>

{{GPUDeviceDescriptor}} has the following members:

<dl dfn-type=dict-member dfn-for=GPUDeviceDescriptor>
    : <dfn>requiredFeatures</dfn>
    ::
        Specifies the [=features=] that are required by the device request.
        The request will fail if the adapter cannot provide these features.

        Exactly the specified set of features, and no more or less, will be allowed in validation
        of API calls on the resulting device.

    : <dfn>requiredLimits</dfn>
    ::
        Specifies the [=limits=] that are required by the device request.
        The request will fail if the adapter cannot provide these limits.

        Each key must be the name of a member of [=supported limits=].
        Exactly the specified limits, and no [=limit/better=] or worse,
        will be allowed in validation of API calls on the resulting device.

        <!-- If we ever need limit types other than GPUSize32/GPUSize64, we can change the value
        type to `double` or `any` in the future and write out the type conversion explicitly (by
        reference to WebIDL spec). Or change the entire type to `any` and add back a `dictionary
        GPULimits` and define the conversion of the whole object by reference to WebIDL. -->
</dl>

#### <dfn enum>GPUFeatureName</dfn> #### {#gpufeaturename}

Each {{GPUFeatureName}} identifies a set of functionality which, if available,
allows additional usages of WebGPU that would have otherwise been invalid.

<script type=idl>
enum GPUFeatureName {
    "depth-clip-control",
    "depth24unorm-stencil8",
    "depth32float-stencil8",
    "texture-compression-bc",
    "texture-compression-etc2",
    "texture-compression-astc",
    "timestamp-query",
    "indirect-first-instance",
};
</script>

## <dfn interface>GPUDevice</dfn> ## {#gpu-device}

A {{GPUDevice}} encapsulates a [=device=] and exposes
the functionality of that device.

{{GPUDevice}} is the top-level interface through which [=WebGPU interfaces=] are created.

To get a {{GPUDevice}}, use {{GPUAdapter/requestDevice()}}.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUDevice : EventTarget {
    [SameObject] readonly attribute GPUSupportedFeatures features;
    [SameObject] readonly attribute GPUSupportedLimits limits;

    [SameObject] readonly attribute GPUQueue queue;

    undefined destroy();

    GPUBuffer createBuffer(GPUBufferDescriptor descriptor);
    GPUTexture createTexture(GPUTextureDescriptor descriptor);
    GPUSampler createSampler(optional GPUSamplerDescriptor descriptor = {});
    GPUExternalTexture importExternalTexture(GPUExternalTextureDescriptor descriptor);

    GPUBindGroupLayout createBindGroupLayout(GPUBindGroupLayoutDescriptor descriptor);
    GPUPipelineLayout createPipelineLayout(GPUPipelineLayoutDescriptor descriptor);
    GPUBindGroup createBindGroup(GPUBindGroupDescriptor descriptor);

    GPUShaderModule createShaderModule(GPUShaderModuleDescriptor descriptor);
    GPUComputePipeline createComputePipeline(GPUComputePipelineDescriptor descriptor);
    GPURenderPipeline createRenderPipeline(GPURenderPipelineDescriptor descriptor);
    Promise<GPUComputePipeline> createComputePipelineAsync(GPUComputePipelineDescriptor descriptor);
    Promise<GPURenderPipeline> createRenderPipelineAsync(GPURenderPipelineDescriptor descriptor);

    GPUCommandEncoder createCommandEncoder(optional GPUCommandEncoderDescriptor descriptor = {});
    GPURenderBundleEncoder createRenderBundleEncoder(GPURenderBundleEncoderDescriptor descriptor);

    GPUQuerySet createQuerySet(GPUQuerySetDescriptor descriptor);
};
GPUDevice includes GPUObjectBase;
</script>

{{GPUDevice}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>features</dfn>
    ::
        A set containing the {{GPUFeatureName}} values of the features
        supported by the device (i.e. the ones with which it was created).

    : <dfn>limits</dfn>
    ::
        Exposes the limits supported by the device
        (which are exactly the ones with which it was created).

    : <dfn>queue</dfn>
    ::
        The primary {{GPUQueue}} for this device.
</dl>

The {{GPUObjectBase/[[device]]}} for a {{GPUDevice}} is the [=device=] that the {{GPUDevice}} refers
to.

{{GPUDevice}} has the methods listed in its WebIDL definition above.
Those not defined here are defined elsewhere in this document.

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>destroy()</dfn>
    ::
        Destroys the [=device=], preventing further operations on it.
        Outstanding asynchronous operations will fail.

        <div algorithm=GPUDevice.destroy()>
            **Called on:** {{GPUDevice}} |this|.

            1. [=Lose the device=](|this|.{{GPUObjectBase/[[device]]}},
                {{GPUDeviceLostReason/"destroyed"}}).
        </div>

        Note:
        Since no further operations can occur on this device, implementations can free resource
        allocations and abort outstanding asynchronous operations immediately.
</dl>

{{GPUDevice}} objects are [=serializable objects=].

Issue(gpuweb/gpuweb#354): Finish defining multithreading API and add `[Serializable]` back to the interface.

<div algorithm>
    <dfn abstract-op>The steps to serialize a GPUDevice object</dfn>,
    given |value|, |serialized|, and |forStorage|, are:
     1. Set |serialized|.agentCluster to be the [=surrounding agent=]'s [=agent cluster=].
     1. If |serialized|.agentCluster's [=cross-origin isolated capability=] is false, throw a "{{DataCloneError}}".
     1. If |forStorage| is `true`, throw a "{{DataCloneError}}".
     1. Set |serialized|.device to the value of |value|.{{GPUObjectBase/[[device]]}}.
</div>

<div algorithm>
    <dfn abstract-op>The steps to deserialize a GPUDevice object</dfn>,
    given |serialized| and |value|, are:
     1. If |serialized|.agentCluster is not the [=surrounding agent=]'s [=agent cluster=], throw a "{{DataCloneError}}".
     1. Set |value|.{{GPUObjectBase/[[device]]}} to |serialized|.device.
</div>

Issue: `GPUDevice` doesn't really need the cross-origin policy restriction.
It should be usable from multiple agents regardless. Once we describe the serialization
of buffers, textures, and queues - the COOP+COEP logic should be moved in there.

# Buffers # {#buffers}

## <dfn interface>GPUBuffer</dfn> ## {#buffer-interface}

Issue: define <dfn dfn>buffer</dfn> (internal object)

A {{GPUBuffer}} represents a block of memory that can be used in GPU operations.
Data is stored in linear layout, meaning that each byte of the allocation can be
addressed by its offset from the start of the {{GPUBuffer}}, subject to alignment
restrictions depending on the operation. Some {{GPUBuffer|GPUBuffers}} can be
mapped which makes the block of memory accessible via an {{ArrayBuffer}} called
its mapping.

{{GPUBuffer|GPUBuffers}} are created via
{{GPUDevice/createBuffer(descriptor)|GPUDevice.createBuffer(descriptor)}}
that returns a new buffer in the [=buffer state/mapped=] or [=buffer state/unmapped=] state.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBuffer {
    Promise<undefined> mapAsync(GPUMapModeFlags mode, optional GPUSize64 offset = 0, optional GPUSize64 size);
    ArrayBuffer getMappedRange(optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined unmap();

    undefined destroy();
};
GPUBuffer includes GPUObjectBase;
</script>

{{GPUBuffer}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBuffer">
    : <dfn>\[[size]]</dfn> of type {{GPUSize64}}.
    ::
        The length of the {{GPUBuffer}} allocation in bytes.

    : <dfn>\[[usage]]</dfn> of type {{GPUBufferUsageFlags}}.
    ::
        The allowed usages for this {{GPUBuffer}}.

    : <dfn>\[[state]]</dfn> of type [=buffer state=].
    ::
        The current state of the {{GPUBuffer}}.

    : <dfn>\[[mapping]]</dfn> of type {{ArrayBuffer}} or {{Promise}} or `null`.
    ::
        The mapping for this {{GPUBuffer}}. The {{ArrayBuffer}} isn't directly accessible
        and is instead accessed through views into it, called the mapped ranges, that are
        stored in {{GPUBuffer/[[mapped_ranges]]}}

        Issue(gpuweb/gpuweb#605): Specify {{GPUBuffer/[[mapping]]}} in term of `DataBlock` similarly
        to `AllocateArrayBuffer`?

    : <dfn>\[[mapping_range]]</dfn> of type [=list=]&lt;{{unsigned long long}}&gt; or `null`.
    ::
        The range of this {{GPUBuffer}} that is mapped.

    : <dfn>\[[mapped_ranges]]</dfn> of type [=list=]&lt;{{ArrayBuffer}}&gt; or `null`.
    ::
        The {{ArrayBuffer}}s returned via {{GPUBuffer/getMappedRange}} to the application. They are tracked
        so they can be detached when {{GPUBuffer/unmap}} is called.

    : <dfn>\[[map_mode]]</dfn> of type {{GPUMapModeFlags}}.
    ::
        The {{GPUMapModeFlags}} of the last call to {{GPUBuffer/mapAsync()}} (if any).
</dl>

Issue: {{GPUBuffer/[[usage]]}} is differently named from {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}}.
We should make it consistent.

Each {{GPUBuffer}} has a current <dfn dfn>buffer state</dfn> on the [=Content timeline=]
which is one of the following:

 - "<dfn dfn for="buffer state">mapped</dfn>" where the {{GPUBuffer}} is
     available for CPU operations on its content.
 - "<dfn dfn for="buffer state">mapped at creation</dfn>" where the {{GPUBuffer}} was
     just created and is available for CPU operations on its content.
 - "<dfn dfn for="buffer state">mapping pending</dfn>" where the {{GPUBuffer}} is
     being made available for CPU operations on its content.
 - "<dfn dfn for="buffer state">unmapped</dfn>" where the {{GPUBuffer}} is
     available for GPU operations.
 - "<dfn dfn for="buffer state">destroyed</dfn>" where the {{GPUBuffer}} is
     no longer available for any operations except {{GPUBuffer/destroy}}.

Note:
{{GPUBuffer/[[size]]}} and {{GPUBuffer/[[usage]]}} are immutable once the
{{GPUBuffer}} has been created.

<div class=note>
   Note: {{GPUBuffer}} has a state machine with the following states.
    ({{GPUBuffer/[[mapping]]}}, {{GPUBuffer/[[mapping_range]]}},
    and {{GPUBuffer/[[mapped_ranges]]}} are `null` when not specified.)

     - [=buffer state/unmapped=] and [=buffer state/destroyed=].
     - [=buffer state/mapped=] or [=buffer state/mapped at creation=] with an
        {{ArrayBuffer}} typed {{GPUBuffer/[[mapping]]}}, a sequence of two
        numbers in {{GPUBuffer/[[mapping_range]]}} and a sequence of {{ArrayBuffer}}
        in {{GPUBuffer/[[mapped_ranges]]}}
     - [=buffer state/mapping pending=] with a {{Promise}} typed {{GPUBuffer/[[mapping]]}}.
</div>

{{GPUBuffer}} is a reference to an internal buffer object.

Issue(gpuweb/gpuweb#354): Finish defining multithreading API and add `[Serializable]` back to the interface.

## Buffer Creation ## {#buffer-creation}

### {{GPUBufferDescriptor}} ### {#GPUBufferDescriptor}

This specifies the options to use in creating a {{GPUBuffer}}.

<script type=idl>
dictionary GPUBufferDescriptor : GPUObjectDescriptorBase {
    required GPUSize64 size;
    required GPUBufferUsageFlags usage;
    boolean mappedAtCreation = false;
};
</script>

- {{GPUBufferDescriptor/mappedAtCreation}} guarantees that even if the buffer eventually fails creation,
    it will still appear as if the mapped range can be written/read to until it is unmapped.

<div algorithm>
    <dfn abstract-op>validating GPUBufferDescriptor</dfn>(device, descriptor)
        1. If device is lost return `false`.
        1. If any of the bits of |descriptor|'s {{GPUBufferDescriptor/usage}} aren't present in this device's [[allowed buffer usages]] return `false`.
        1. If both the {{GPUBufferUsage/MAP_READ}} and {{GPUBufferUsage/MAP_WRITE}} bits of |descriptor|'s {{GPUBufferDescriptor/usage}} attribute are set, return `false`.
        1. Return `true`.
</div>

### Buffer Usage ### {#buffer-usage}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferUsageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUBufferUsage {
    const GPUFlagsConstant MAP_READ      = 0x0001;
    const GPUFlagsConstant MAP_WRITE     = 0x0002;
    const GPUFlagsConstant COPY_SRC      = 0x0004;
    const GPUFlagsConstant COPY_DST      = 0x0008;
    const GPUFlagsConstant INDEX         = 0x0010;
    const GPUFlagsConstant VERTEX        = 0x0020;
    const GPUFlagsConstant UNIFORM       = 0x0040;
    const GPUFlagsConstant STORAGE       = 0x0080;
    const GPUFlagsConstant INDIRECT      = 0x0100;
    const GPUFlagsConstant QUERY_RESOLVE = 0x0200;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBuffer(descriptor)</dfn>
    ::
        Creates a {{GPUBuffer}}.

        <div algorithm=GPUDevice.createBuffer>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createBuffer(descriptor)">
                |descriptor|: Description of the {{GPUBuffer}} to create.
            </pre>

            **Returns:** {{GPUBuffer}}

            1. If any of the following conditions are unsatisfied, return an error buffer and stop.
                <div class=validusage>
                    - |this| is a [=valid=] {{GPUDevice}}.
                    - |descriptor|.{{GPUBufferDescriptor/usage}} must not be 0.
                    - |descriptor|.{{GPUBufferDescriptor/usage}} is a subset of |this|.[[allowed buffer usages]].
                    - If |descriptor|.{{GPUBufferDescriptor/usage}} contains {{GPUBufferUsage/MAP_READ}}:
                        - |descriptor|.{{GPUBufferDescriptor/usage}} contains no other flags
                            except {{GPUBufferUsage/COPY_DST}}.
                    - If |descriptor|.{{GPUBufferDescriptor/usage}} contains {{GPUBufferUsage/MAP_WRITE}}:
                        - |descriptor|.{{GPUBufferDescriptor/usage}} contains no other flags
                            except {{GPUBufferUsage/COPY_SRC}}.
                    - If |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} is `true`:
                        - |descriptor|.{{GPUBufferDescriptor/size}} is a multiple of 4.

                    Issue(gpuweb/gpuweb#605): Explain what are a {{GPUDevice}}'s `[[allowed buffer usages]]`.
                </div>

            Note: If buffer creation fails, and |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} is `false`,
            any calls to {{GPUBuffer/mapAsync()}} will reject, so any resources allocated to enable mapping can
            and may be discarded or recycled.

            1. Let |b| be a new {{GPUBuffer}} object.
            1. Set |b|.{{GPUBuffer/[[size]]}} to |descriptor|.{{GPUBufferDescriptor/size}}.
            1. Set |b|.{{GPUBuffer/[[usage]]}} to |descriptor|.{{GPUBufferDescriptor/usage}}.
            1. If |descriptor|.{{GPUBufferDescriptor/mappedAtCreation}} is `true`:

                1. Set |b|.{{GPUBuffer/[[mapping]]}} to a new {{ArrayBuffer}} of size |b|.{{GPUBuffer/[[size]]}}.
                1. Set |b|.{{GPUBuffer/[[mapping_range]]}} to `[0, descriptor.size]`.
                1. Set |b|.{{GPUBuffer/[[mapped_ranges]]}} to `[]`.
                1. Set |b|.{{GPUBuffer/[[state]]}} to [=buffer state/mapped at creation=].

                Else:

                1. Set |b|.{{GPUBuffer/[[mapping]]}} to `null`.
                1. Set |b|.{{GPUBuffer/[[mapping_range]]}} to `null`.
                1. Set |b|.{{GPUBuffer/[[mapped_ranges]]}} to `null`.
                1. Set |b|.{{GPUBuffer/[[state]]}} to [=buffer state/unmapped=].

            1. Set each byte of |b|'s allocation to zero.
            1. Return |b|.

            Note: it is valid to set {{GPUBufferDescriptor/mappedAtCreation}} to `true` without {{GPUBufferUsage/MAP_READ}}
            or {{GPUBufferUsage/MAP_WRITE}} in {{GPUBufferDescriptor/usage}}. This can be used to set the buffer's
            initial data.

        </div>

</dl>

## Buffer Destruction ## {#buffer-destruction}

An application that no longer requires a {{GPUBuffer}} can choose to lose
access to it before garbage collection by calling {{GPUBuffer/destroy()}}. Destroying a buffer also
unmaps it, freeing any memory allocated for the mapping.

Note: This allows the user agent to reclaim the GPU memory associated with the {{GPUBuffer}}
once all previously submitted operations using it are complete.

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>destroy()</dfn>
    ::
        Destroys the {{GPUBuffer}}.

        <div algorithm=GPUBuffer.destroy>
            **Called on:** {{GPUBuffer}} |this|.

            **Returns:** {{undefined}}

            1. If the |this|.{{GPUBuffer/[[state]]}} is not either of [=buffer state/unmapped=] or [=buffer state/destroyed=]

                1. Run the steps to unmap |this|.

            1. Set |this|.{{GPUBuffer/[[state]]}} to [=buffer state/destroyed=].
        </div>
</dl>

## Buffer Mapping ## {#buffer-mapping}

An application can request to map a {{GPUBuffer}} so that they can access its
content via {{ArrayBuffer}}s that represent part of the {{GPUBuffer}}'s
allocations. Mapping a {{GPUBuffer}} is requested asynchronously with
{{GPUBuffer/mapAsync()}} so that the user agent can ensure the GPU
finished using the {{GPUBuffer}} before the application can access its content.
Once the {{GPUBuffer}} is mapped the application can synchronously ask for access
to ranges of its content with {{GPUBuffer/getMappedRange}}. A mapped {{GPUBuffer}}
cannot be used by the GPU and must be unmapped using {{GPUBuffer/unmap}} before
work using it can be submitted to the [=Queue timeline=].

Issue(gpuweb/gpuweb#605): Add client-side validation that a mapped buffer can
  only be unmapped and destroyed on the worker on which it was mapped. Likewise
  {{GPUBuffer/getMappedRange}} can only be called on that worker.

<script type=idl>
typedef [EnforceRange] unsigned long GPUMapModeFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUMapMode {
    const GPUFlagsConstant READ  = 0x0001;
    const GPUFlagsConstant WRITE = 0x0002;
};
</script>

<dl dfn-type=method dfn-for=GPUBuffer>
    : <dfn>mapAsync(mode, offset, size)</dfn>
    ::
        Maps the given range of the {{GPUBuffer}} and resolves the returned {{Promise}} when the
        {{GPUBuffer}}'s content is ready to be accessed with {{GPUBuffer/getMappedRange()}}.

        <div algorithm=GPUBuffer.mapAsync>
            **Called on:** {{GPUBuffer}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUBuffer/mapAsync(mode, offset, size)">
                |mode|: Whether the buffer should be mapped for reading or writing.
                |offset|: Offset in bytes into the buffer to the start of the range to map.
                |size|: Size in bytes of the range to map.
            </pre>

            **Returns:** {{Promise}}&lt;{{undefined}}&gt;

            Issue(gpuweb/gpuweb#605): Handle error buffers once we have a description of the error monad.

            1. If |size| is missing:
                1. Let |rangeSize| be max(0, |this|.{{GPUBuffer/[[size]]}} - |offset|).

                Otherwise, let |rangeSize| be |size|.

            1. If any of the following conditions are unsatisfied:
                <div class=validusage>
                    - |this| is a [=valid=] {{GPUBuffer}}.
                        TODO: check destroyed state?
                    - |offset| is a multiple of 8.
                    - |rangeSize| is a multiple of 4.
                    - |offset| + |rangeSize| is less or equal to |this|.{{GPUBuffer/[[size]]}}
                    - |this|.{{GPUBuffer/[[state]]}} is [=buffer state/unmapped=]
                    - |mode| contains exactly one of {{GPUMapMode/READ}} or {{GPUMapMode/WRITE}}.
                    - If |mode| contains {{GPUMapMode/READ}} then |this|.{{GPUBuffer/[[usage]]}} must contain {{GPUBufferUsage/MAP_READ}}.
                    - If |mode| contains {{GPUMapMode/WRITE}} then |this|.{{GPUBuffer/[[usage]]}} must contain {{GPUBufferUsage/MAP_WRITE}}.

                    Issue: Do we validate that |mode| contains only valid flags?
                </div>

                Then:
                1. Record a validation error on the current scope.
                1. Return [=a promise rejected with=] an {{OperationError}} on the [=Device timeline=].

            1. Let |p| be a new {{Promise}}.
            1. Set |this|.{{GPUBuffer/[[mapping]]}} to |p|.
            1. Set |this|.{{GPUBuffer/[[state]]}} to [=buffer state/mapping pending=].
            1. Set |this|.{{GPUBuffer/[[map_mode]]}} to |mode|.
            1. Enqueue an operation on the default queue's [=Queue timeline=] that will execute the following:
                <div class=queue-timeline>
                    1. If |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapping pending=]:

                        1. Let |m| be a new {{ArrayBuffer}} of size |rangeSize|.
                        1. Set the content of |m| to the content of |this|'s allocation starting at offset |offset| and for |rangeSize| bytes.
                        1. Set |this|.{{GPUBuffer/[[mapping]]}} to |m|.
                        1. Set |this|.{{GPUBuffer/[[state]]}} to [=buffer state/mapped=].
                        1. Set |this|.{{GPUBuffer/[[mapping_range]]}} to <code>[|offset|, |offset| + |rangeSize|]</code>.
                        1. Set |this|.{{GPUBuffer/[[mapped_ranges]]}} to `[]`.

                    1. Resolve |p|.
                </div>
            1. Return |p|.
        </div>

    : <dfn>getMappedRange(offset, size)</dfn>
    ::
        Returns a {{ArrayBuffer}} with the contents of the {{GPUBuffer}} in the given mapped range.

        <div algorithm=GPUBuffer.getMappedRange>
            **Called on:** {{GPUBuffer}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUBuffer/getMappedRange(offset, size)">
                |offset|: Offset in bytes into the buffer to return buffer contents from.
                |size|: Size in bytes of the {{ArrayBuffer}} to return.
            </pre>

            **Returns:** {{ArrayBuffer}}

            1. If |size| is missing:
                1. Let |rangeSize| be max(0, |this|.{{GPUBuffer/[[size]]}} - |offset|).

                Otherwise, let |rangeSize| be |size|.

            1. If any of the following conditions are unsatisfied, throw an {{OperationError}} and stop.
                <div class=validusage>
                    - |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapped=] or [=buffer state/mapped at creation=].
                    - |offset| is a multiple of 8.
                    - |rangeSize| is a multiple of 4.
                    - |offset| is greater than or equal to |this|.{{GPUBuffer/[[mapping_range]]}}[0].
                    - |offset| + |rangeSize| is less than or equal to |this|.{{GPUBuffer/[[mapping_range]]}}[1].
                    - [|offset|, |offset| + |rangeSize|) does not overlap another range in |this|.{{GPUBuffer/[[mapped_ranges]]}}.

                    Note: It is always valid to get mapped ranges of a {{GPUBuffer}} that is
                    [=buffer state/mapped at creation=], even if it is [=invalid=], because
                    the [=Content timeline=] might not know it is invalid.

                    Issue: Consider aligning mapAsync offset to 8 to match this.
                </div>

            1. Let |m| be a new {{ArrayBuffer}} of size |rangeSize| pointing at the content
                of |this|.{{GPUBuffer/[[mapping]]}} at offset |offset| - |this|.{{GPUBuffer/[[mapping_range]]}}[0].

            1. [=list/Append=] |m| to |this|.{{GPUBuffer/[[mapped_ranges]]}}.

            1. Return |m|.
        </div>

    : <dfn>unmap()</dfn>
    ::
        Unmaps the mapped range of the {{GPUBuffer}} and makes it's contents available for use by the
        GPU again.

        <div algorithm=GPUBuffer.unmap>
            **Called on:** {{GPUBuffer}} |this|.

            **Returns:** {{undefined}}

            1. If any of the following requirements are unmet, generate a validation
                error and stop.
                <div class=validusage>
                    - |this|.{{GPUBuffer/[[state]]}} must be [=buffer state/mapped at creation=],
                        [=buffer state/mapping pending=], or [=buffer state/mapped=].

                    Note: It is valid to unmap an [=invalid=] {{GPUBuffer}} that is
                        [=buffer state/mapped at creation=] because the [=Content timeline=]
                        might not know it is an error {{GPUBuffer}}. This allows the temporary
                        {{GPUBuffer/[[mapping]]}} memory to be freed.
                </div>

            1. If |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapping pending=]:

                1. [=Reject=] {{GPUBuffer/[[mapping]]}} with an {{AbortError}}.
                1. Set |this|.{{GPUBuffer/[[mapping]]}} to `null`.

            1. If |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapped=] or [=buffer state/mapped at creation=]:

                1. If one of the two following conditions holds:

                    - |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapped at creation=]
                    - |this|.{{GPUBuffer/[[state]]}} is [=buffer state/mapped=] and |this|.{{GPUBuffer/[[map_mode]]}} contains {{GPUMapMode/WRITE}}

                    Then:
                    1. Enqueue an operation on the default queue's [=Queue timeline=] that updates the |this|.{{GPUBuffer/[[mapping_range]]}}
                        of |this|'s allocation to the content of |this|.{{GPUBuffer/[[mapping]]}}.

                1. Detach each {{ArrayBuffer}} in |this|.{{GPUBuffer/[[mapped_ranges]]}} from its content.
                1. Set |this|.{{GPUBuffer/[[mapping]]}} to `null`.
                1. Set |this|.{{GPUBuffer/[[mapping_range]]}} to `null`.
                1. Set |this|.{{GPUBuffer/[[mapped_ranges]]}} to `null`.

            1. Set |this|.{{GPUBuffer/[[state]]}} to [=buffer state/unmapped=].

            Note: When a {{GPUBufferUsage/MAP_READ}} buffer (not currently mapped at creation) is
                unmapped, any local modifications done by the application to the mapped ranges
                {{ArrayBuffer}} are discarded and will not affect the content of follow-up mappings.
        </div>
</dl>

# Textures and Texture Views # {#textures}

Issue: define <dfn dfn>texture</dfn> (internal object)

Issue: define <dfn dfn>mipmap level</dfn>, <dfn dfn>array layer</dfn>, <dfn dfn>aspect</dfn>, <dfn dfn>slice</dfn> (concepts)

## <dfn interface>GPUTexture</dfn> ## {#texture-interface}

{{GPUTexture|GPUTextures}} are created via
{{GPUDevice/createTexture(descriptor)|GPUDevice.createTexture(descriptor)}}
that returns a new texture.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUTexture {
    GPUTextureView createView(optional GPUTextureViewDescriptor descriptor = {});

    undefined destroy();
};
GPUTexture includes GPUObjectBase;
</script>

{{GPUTexture}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUTexture">
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUTextureDescriptor}}
    ::
        The {{GPUTextureDescriptor}} describing this texture.

        All optional fields of {{GPUTextureDescriptor}} are defined.

    : <dfn>\[[destroyed]]</dfn>, of type `boolean`, initially false
    ::
        If the texture is destroyed, it can no longer be used in any operation,
        and its underlying memory can be freed.
</dl>

<div algorithm>
    <dfn abstract-op>compute render extent</dfn>(baseSize, mipLevel)

    **Arguments:**
        - {{GPUExtent3D}} |baseSize|
        - {{GPUSize32}} |mipLevel|

    **Returns:** {{GPUExtent3DDict}}

    1. Let |extent| be a new {{GPUExtent3DDict}} object.
    1. Set |extent|.{{GPUExtent3DDict/width}} to max(1, |baseSize|.[=Extent3D/width=] &Gt; |mipLevel|).
    1. Set |extent|.{{GPUExtent3DDict/height}} to max(1, |baseSize|.[=Extent3D/height=] &Gt; |mipLevel|).
    1. Set |extent|.{{GPUExtent3DDict/depthOrArrayLayers}} to 1.
    1. Return |extent|.
</div>

Issue: share this definition with the part of the specification that describes sampling.

### Texture Creation ### {#texture-creation}

<script type=idl>
dictionary GPUTextureDescriptor : GPUObjectDescriptorBase {
    required GPUExtent3D size;
    GPUIntegerCoordinate mipLevelCount = 1;
    GPUSize32 sampleCount = 1;
    GPUTextureDimension dimension = "2d";
    required GPUTextureFormat format;
    required GPUTextureUsageFlags usage;
};
</script>

<script type=idl>
enum GPUTextureDimension {
    "1d",
    "2d",
    "3d",
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUTextureUsageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUTextureUsage {
    const GPUFlagsConstant COPY_SRC          = 0x01;
    const GPUFlagsConstant COPY_DST          = 0x02;
    const GPUFlagsConstant TEXTURE_BINDING   = 0x04;
    const GPUFlagsConstant STORAGE_BINDING   = 0x08;
    const GPUFlagsConstant RENDER_ATTACHMENT = 0x10;
};
</script>

<div algorithm>
    <dfn abstract-op>maximum mipLevel count</dfn>(dimension, size)
    **Arguments:**
        - {{GPUTextureDescriptor/dimension}} |dimension|
        - {{GPUTextureDescriptor/size}} |size|

    1. Calculate the max dimension value |m|:
        - If |dimension| is:
            <dl class="switch">
                : {{GPUTextureDimension/"1d"}}
                :: Let |m| = |size|.[=Extent3D/width=].

                : {{GPUTextureDimension/"2d"}}
                :: Let |m| = max(|size|.[=Extent3D/width=], |size|.[=Extent3D/height=]).

                : {{GPUTextureDimension/"3d"}}
                :: Let |m| = max(max(|size|.[=Extent3D/width=], |size|.[=Extent3D/height=]), |size|.[=Extent3D/depthOrArrayLayer=]).
            </dl>
    1. Return floor(log<sub>2</sub>(|m|)) + 1.
</div>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createTexture(descriptor)</dfn>
    ::
        Creates a {{GPUTexture}}.

        <div algorithm=GPUDevice.createTexture>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createTexture(descriptor)">
                |descriptor|: Description of the {{GPUTexture}} to create.
            </pre>

            **Returns:** {{GPUTexture}}

            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If |descriptor|.{{GPUTextureDescriptor/format}} is a {{GPUTextureFormat}} that requires a feature (see
                        [[#texture-format-caps]]), but |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} does not
                        [=list/contain=] the feature, throw a {{TypeError}}.
                    1. If any of the following requirements are unmet:
                        <div class=validusage>
                            - |this| must be a [=valid=] {{GPUDevice}}.
                            - |descriptor|.{{GPUTextureDescriptor/usage}} must not be 0.
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=],
                                |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=],
                                and |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] must be greater than zero.
                            - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} must be greater than zero.
                            - |descriptor|.{{GPUTextureDescriptor/sampleCount}} must be either 1 or 4.

                            - If |descriptor|.{{GPUTextureDescriptor/dimension}} is:
                                <dl class="switch">
                                    : {{GPUTextureDimension/"1d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be less than or equal to
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension1D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] must be 1.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] must be 1.
                                        - |descriptor|.{{GPUTextureDescriptor/sampleCount}} must be 1.
                                        - |descriptor|.{{GPUTextureDescriptor/format}} must not be a [=compressed format=] or [=depth-or-stencil format=].

                                    : {{GPUTextureDimension/"2d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be less than or equal to
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] must be less than or equal to
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] must be less than
                                            or equal to |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureArrayLayers}}.

                                    : {{GPUTextureDimension/"3d"}}
                                    ::
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be less than or equal to
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] must be less than or equal to
                                            |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] must be less than
                                            or equal to |this|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension3D}}.
                                        - |descriptor|.{{GPUTextureDescriptor/sampleCount}} must be 1.
                                        - |descriptor|.{{GPUTextureDescriptor/format}} must not be a [=compressed format=] or [=depth-or-stencil format=].
                                </dl>
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be multiple of [=texel block width=].
                            - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/height=] must be multiple of [=texel block height=].

                            - If |descriptor|.{{GPUTextureDescriptor/sampleCount}} > 1:
                                - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} must be 1.
                                - |descriptor|.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] must be 1.
                                - |descriptor|.{{GPUTextureDescriptor/usage}} must not include the {{GPUTextureUsage/STORAGE_BINDING}} bit.
                                - |descriptor|.{{GPUTextureDescriptor/format}} must be a [=renderable format=] and support multisampling according to [[#texture-format-caps]].

                            - |descriptor|.{{GPUTextureDescriptor/mipLevelCount}} must be less than or equal to
                                [$maximum mipLevel count$](|descriptor|.{{GPUTextureDescriptor/dimension}}, |descriptor|.{{GPUTextureDescriptor/size}}).

                            - |descriptor|.{{GPUTextureDescriptor/usage}} must be a combination of {{GPUTextureUsage}} values.
                            - If |descriptor|.{{GPUTextureDescriptor/usage}} includes the {{GPUTextureUsage/RENDER_ATTACHMENT}} bit,
                                |descriptor|.{{GPUTextureDescriptor/format}} must be a [=renderable format=].
                            - If |descriptor|.{{GPUTextureDescriptor/usage}} includes the {{GPUTextureUsage/STORAGE_BINDING}} bit,
                                |descriptor|.{{GPUTextureDescriptor/format}} must be listed in [[#plain-color-formats]] table
                                with {{GPUTextureUsage/STORAGE_BINDING}} capability.
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                            1. Return a new [=invalid=] {{GPUTexture}}.

                    1. Let |t| be a new {{GPUTexture}} object.
                    1. Set |t|.{{GPUTexture/[[descriptor]]}} to |descriptor|.
                    1. Return |t|.
                </div>
        </div>
</dl>

### Texture Destruction ### {#texture-destruction}

An application that no longer requires a {{GPUTexture}} can choose to lose access to it before
garbage collection by calling {{GPUTexture/destroy()}}.

Note: This allows the user agent to reclaim the GPU memory associated with the {{GPUTexture}} once
all previously submitted operations using it are complete.

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>destroy()</dfn>
    ::
        Destroys the {{GPUTexture}}.

        <div algorithm=GPUTexture.destroy>
            **Called on:** {{GPUTexture}} |this|.

            **Returns:** {{undefined}}

            1. Set |this|.{{GPUTexture/[[destroyed]]}} to true.
        </div>
</dl>

## <dfn interface>GPUTextureView</dfn> ## {#gpu-textureview}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUTextureView {
};
GPUTextureView includes GPUObjectBase;
</script>

{{GPUTextureView}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUTextureView">
    : <dfn>\[[texture]]</dfn>
    ::
        The {{GPUTexture}} into which this is a view.

    : <dfn>\[[descriptor]]</dfn>
    ::
        The {{GPUTextureViewDescriptor}} describing this texture view.

        All optional fields of {{GPUTextureViewDescriptor}} are defined.
    : <dfn>\[[renderExtent]]</dfn>
    ::
        For renderable views, this is the effective {{GPUExtent3DDict}} for rendering.

        Note: this extent depends on the {{GPUTextureViewDescriptor/baseMipLevel}}.

</dl>

### Texture View Creation ### {#texture-view-creation}

<script type=idl>
dictionary GPUTextureViewDescriptor : GPUObjectDescriptorBase {
    GPUTextureFormat format;
    GPUTextureViewDimension dimension;
    GPUTextureAspect aspect = "all";
    GPUIntegerCoordinate baseMipLevel = 0;
    GPUIntegerCoordinate mipLevelCount;
    GPUIntegerCoordinate baseArrayLayer = 0;
    GPUIntegerCoordinate arrayLayerCount;
};
</script>

<script type=idl>
enum GPUTextureViewDimension {
    "1d",
    "2d",
    "2d-array",
    "cube",
    "cube-array",
    "3d",
};
</script>

<dl dfn-type=enum-value dfn-for=GPUTextureViewDimension>
    : <dfn>"1d"</dfn>
    ::
        The texture is viewed as a 1-dimensional image.

        Corresponding WGSL types:

        - `texture_1d`
        - `texture_storage_1d`

    : <dfn>"2d"</dfn>
    ::
        The texture is viewed as a single 2-dimensional image.

        Corresponding WGSL types:

        - `texture_2d`
        - `texture_storage_2d`
        - `texture_multisampled_2d`
        - `texture_depth_2d`
        - `texture_depth_multisampled_2d`

    : <dfn>"2d-array"</dfn>
    ::
        The texture view is viewed as an array of 2-dimensional images.

        Corresponding WGSL types:

        - `texture_2d_array`
        - `texture_storage_2d_array`
        - `texture_depth_2d_array`

    : <dfn>"cube"</dfn>
    ::
        The texture is viewed as a cubemap.
        The view has 6 array layers, corresponding to the [+X, -X, +Y, -Y, +Z, -Z] faces of the cube.

        Corresponding WGSL types:

        - `texture_cube`
        - `texture_depth_cube`

    : <dfn>"cube-array"</dfn>
    ::
        The texture is viewed as a packed array of `n` cubemaps,
        each with 6 array layers corresponding to the [+X, -X, +Y, -Y, +Z, -Z] faces of the cube.

        Corresponding WGSL types:

        - `texture_cube_array`
        - `texture_depth_cube_array`

    : <dfn>"3d"</dfn>
    ::
        The texture is viewed as a 3-dimensional image.

        Corresponding WGSL types:

        - `texture_3d`
        - `texture_storage_3d`
</dl>

<script type=idl>
enum GPUTextureAspect {
    "all",
    "stencil-only",
    "depth-only",
};
</script>

<dl dfn-type=method dfn-for=GPUTexture>
    : <dfn>createView(descriptor)</dfn>
    ::
        Creates a {{GPUTextureView}}.

        <div algorithm=GPUTexture.createView>
            **Called on:** {{GPUTexture}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUTexture/createView(descriptor)">
                |descriptor|: Description of the {{GPUTextureView}} to create.
            </pre>

            **Returns:** |view|, of type {{GPUTextureView}}.

            1. Set |descriptor| to the result of [$resolving GPUTextureViewDescriptor defaults$] with |descriptor|.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following requirements are unmet:
                        <div class=validusage>
                            - |this| is [=valid=]
                            - If the |descriptor|.{{GPUTextureViewDescriptor/aspect}} is
                                <dl class="switch">
                                    : {{GPUTextureAspect/"stencil-only"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} must be a
                                        [=depth-or-stencil format=] which has a stencil aspect.

                                    : {{GPUTextureAspect/"depth-only"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} must be a
                                        [=depth-or-stencil format=] which has a depth aspect.
                                </dl>
                            - |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} must be &gt; 0.
                            - |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}} +
                                |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} must be &le;
                                |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}.
                            - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be &gt; 0.
                            - |descriptor|.{{GPUTextureViewDescriptor/baseArrayLayer}} +
                                |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be &le;
                                the [$array layer count$] of |this|.
                            - |descriptor|.{{GPUTextureViewDescriptor/format}} must be |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.
                                <div class="issue">Allow for creating views with compatible formats as well.</div>
                            - If |descriptor|.{{GPUTextureViewDescriptor/dimension}} is:
                                <dl class="switch">
                                    : {{GPUTextureViewDimension/"1d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"1d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be `1`.

                                    : {{GPUTextureViewDimension/"2d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be `1`.

                                    : {{GPUTextureViewDimension/"2d-array"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"2d"}}.

                                    : {{GPUTextureViewDimension/"cube"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be `6`.
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be
                                        |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/height=].

                                    : {{GPUTextureViewDimension/"cube-array"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"2d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be a multiple of `6`.
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/width=] must be
                                        |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/height=].

                                    : {{GPUTextureViewDimension/"3d"}}
                                    :: |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"3d"}}.
                                    :: |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be `1`.
                                </dl>
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                            1. Return a new [=invalid=] {{GPUTextureView}}.

                    1. Let |view| be a new {{GPUTextureView}} object.
                    1. Set |view|.{{GPUTextureView/[[texture]]}} to |this|.
                    1. Set |view|.{{GPUTextureView/[[descriptor]]}} to |descriptor|.
                    1. If |this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}} contains {{GPUTextureUsage/RENDER_ATTACHMENT}}:
                        1. Let |renderExtent| be [$compute render extent$](|this|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}, |descriptor|.{{GPUTextureViewDescriptor/baseMipLevel}}).
                        1. Set |view|.{{GPUTextureView/[[renderExtent]]}} to |renderExtent|.
                    1. Return |view|.
                </div>
        </div>
</dl>

<div algorithm>
    When <dfn abstract-op>resolving GPUTextureViewDescriptor defaults</dfn> for {{GPUTextureViewDescriptor}}
    |descriptor| run the following steps:

    1. Let |resolved| be a copy of |descriptor|.
    1. If |resolved|.{{GPUTextureViewDescriptor/format}} is `undefined`,
        set |resolved|.{{GPUTextureViewDescriptor/format}} to |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.
    1. If |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} is `undefined`,
        set |resolved|.{{GPUTextureViewDescriptor/mipLevelCount}} to |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}}
        &minus; {{GPUTextureViewDescriptor/baseMipLevel}}.
    1. If |resolved|.{{GPUTextureViewDescriptor/dimension}} is `undefined` and
        |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} is:
        <dl class="switch">
            : {{GPUTextureDimension/"1d"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/dimension}} to {{GPUTextureViewDimension/"1d"}}.

            : {{GPUTextureDimension/"2d"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/dimension}} to {{GPUTextureViewDimension/"2d"}}.

            : {{GPUTextureDimension/"3d"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/dimension}} to {{GPUTextureViewDimension/"3d"}}.
        </dl>
    1. If |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} is `undefined` and
        |resolved|.{{GPUTextureViewDescriptor/dimension}} is:
        <dl class="switch">
            : {{GPUTextureViewDimension/"1d"}}, {{GPUTextureViewDimension/"2d"}}, or
                {{GPUTextureViewDimension/"3d"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} to `1`.

            : {{GPUTextureViewDimension/"cube"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} to `6`.

            : {{GPUTextureViewDimension/"2d-array"}} or {{GPUTextureViewDimension/"cube-array"}}
            :: Set |resolved|.{{GPUTextureViewDescriptor/arrayLayerCount}} to
                |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=] &minus;
                {{GPUTextureViewDescriptor/baseArrayLayer}}.
        </dl>

    1. Return |resolved|.
</div>

<div algorithm>
    To determine the <dfn abstract-op>array layer count</dfn> of {{GPUTexture}} |texture|, run the
    following steps:

        1. If |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} is:
            <dl class="switch">
                : {{GPUTextureDimension/"1d"}} or {{GPUTextureDimension/"3d"}}
                :: Return `1`.

                : {{GPUTextureDimension/"2d"}}
                :: Return |texture|.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/size}}.[=Extent3D/depthOrArrayLayers=].
            </dl>
</div>

## Texture Formats ## {#texture-formats}

The name of the format specifies the order of components, bits per component,
and data type for the component.

  * `r`, `g`, `b`, `a` = red, green, blue, alpha
  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

If the format has the `-srgb` suffix, then sRGB conversions from gamma to linear
and vice versa are applied during the reading and writing of color values in the
shader. Compressed texture formats are provided by [=features=]. Their naming
should follow the convention here, with the texture name as a prefix. e.g.
`etc2-rgba8unorm`.

The <dfn dfn>texel block</dfn> is a single addressable element of the textures in pixel-based {{GPUTextureFormat}}s,
and a single compressed block of the textures in block-based compressed {{GPUTextureFormat}}s.

The <dfn dfn>texel block width</dfn> and <dfn dfn>texel block height</dfn> specifies the dimension of one [=texel block=].
  - For pixel-based {{GPUTextureFormat}}s, the [=texel block width=] and [=texel block height=] are always 1.
  - For block-based compressed {{GPUTextureFormat}}s, the [=texel block width=] is the number of texels in each row of one [=texel block=],
    and the [=texel block height=] is the number of texel rows in one [=texel block=].

The <dfn dfn>texel block size</dfn> of a {{GPUTextureFormat}} is the number of bytes to store one [=texel block=].
The [=texel block size=] of each {{GPUTextureFormat}} is constant except for {{GPUTextureFormat/"stencil8"}}, {{GPUTextureFormat/"depth24plus"}}, and {{GPUTextureFormat/"depth24plus-stencil8"}}.

<script type=idl>
enum GPUTextureFormat {
    // 8-bit formats
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",

    // 16-bit formats
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",

    // 32-bit formats
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    // Packed 32-bit formats
    "rgb9e5ufloat",
    "rgb10a2unorm",
    "rg11b10ufloat",

    // 64-bit formats
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",

    // 128-bit formats
    "rgba32uint",
    "rgba32sint",
    "rgba32float",

    // Depth/stencil formats
    "stencil8",
    "depth16unorm",
    "depth24plus",
    "depth24plus-stencil8",
    "depth32float",

    // "depth24unorm-stencil8" feature
    "depth24unorm-stencil8",

    // "depth32float-stencil8" feature
    "depth32float-stencil8",

    // BC compressed formats usable if "texture-compression-bc" is both
    // supported by the device/user agent and enabled in requestDevice.
    "bc1-rgba-unorm",
    "bc1-rgba-unorm-srgb",
    "bc2-rgba-unorm",
    "bc2-rgba-unorm-srgb",
    "bc3-rgba-unorm",
    "bc3-rgba-unorm-srgb",
    "bc4-r-unorm",
    "bc4-r-snorm",
    "bc5-rg-unorm",
    "bc5-rg-snorm",
    "bc6h-rgb-ufloat",
    "bc6h-rgb-float",
    "bc7-rgba-unorm",
    "bc7-rgba-unorm-srgb",

    // ETC2 compressed formats usable if "texture-compression-etc2" is both
    // supported by the device/user agent and enabled in requestDevice.
    "etc2-rgb8unorm",
    "etc2-rgb8unorm-srgb",
    "etc2-rgb8a1unorm",
    "etc2-rgb8a1unorm-srgb",
    "etc2-rgba8unorm",
    "etc2-rgba8unorm-srgb",
    "eac-r11unorm",
    "eac-r11snorm",
    "eac-rg11unorm",
    "eac-rg11snorm",

    // ASTC compressed formats usable if "texture-compression-astc" is both
    // supported by the device/user agent and enabled in requestDevice.
    "astc-4x4-unorm",
    "astc-4x4-unorm-srgb",
    "astc-5x4-unorm",
    "astc-5x4-unorm-srgb",
    "astc-5x5-unorm",
    "astc-5x5-unorm-srgb",
    "astc-6x5-unorm",
    "astc-6x5-unorm-srgb",
    "astc-6x6-unorm",
    "astc-6x6-unorm-srgb",
    "astc-8x5-unorm",
    "astc-8x5-unorm-srgb",
    "astc-8x6-unorm",
    "astc-8x6-unorm-srgb",
    "astc-8x8-unorm",
    "astc-8x8-unorm-srgb",
    "astc-10x5-unorm",
    "astc-10x5-unorm-srgb",
    "astc-10x6-unorm",
    "astc-10x6-unorm-srgb",
    "astc-10x8-unorm",
    "astc-10x8-unorm-srgb",
    "astc-10x10-unorm",
    "astc-10x10-unorm-srgb",
    "astc-12x10-unorm",
    "astc-12x10-unorm-srgb",
    "astc-12x12-unorm",
    "astc-12x12-unorm-srgb",
};
</script>

The depth component of the {{GPUTextureFormat/"depth24plus"}}) and {{GPUTextureFormat/"depth24plus-stencil8"}})
formats may be implemented as either a 24-bit unsigned normalized value (like "depth24unorm" in {{GPUTextureFormat/"depth24unorm-stencil8"}})
or a 32-bit IEEE 754 floating point value (like {{GPUTextureFormat/"depth32float"}}).

Issue: add something on GPUAdapter(?) that gives an estimate of the bytes per texel of
{{GPUTextureFormat/"stencil8"}}, {{GPUTextureFormat/"depth24plus-stencil8"}}, and {{GPUTextureFormat/"depth32float-stencil8"}}.

The {{GPUTextureFormat/stencil8}} format may be implemented as
either a real "stencil8", or "depth24stencil8", where the depth aspect is
hidden and inaccessible.

Note:
While the precision of depth32float channels is strictly higher than the precision of
depth24unorm channels for all values in the representable range (0.0 to 1.0),
note that the set of representable values is not an exact superset:
for depth24unorm, 1 ULP has a constant value of 1 / (2<sup>24</sup> &minus; 1);
for depth32float, 1 ULP has a variable value no greater than 1 / (2<sup>24</sup>).

A <dfn>renderable format</dfn> is either a <dfn>color renderable format</dfn>, or a [=depth-or-stencil format=].
If a format is listed in [[#plain-color-formats]] with {{GPUTextureUsage/RENDER_ATTACHMENT}} capability, it is a
color renderable format. Any other format is not a color renderable format.
All [=depth-or-stencil formats=] are renderable.

## <dfn interface>GPUExternalTexture</dfn> ## {#gpu-external-texture}

A {{GPUExternalTexture}} is a sampleable texture wrapping an external video object.
The contents of a {{GPUExternalTexture}} object may not change, either from inside WebGPU
(it is only sampleable) or from outside WebGPU (e.g. due to video frame advancement).

Issue: Update this description with canvas.

They are bound into bind group layouts using the {{GPUBindGroupLayoutEntry/externalTexture}}
bind group layout entry member.
External textures use several binding slots: see [=Exceeds the binding slot limits=].

<div class=note>
    External textures *can* be implemented without creating a copy of the imported source,
    but this depends implementation-defined factors.
    Ownership of the underlying representation may either be exclusive or shared with other
    owners (such as a video decoder), but this is not visible to the application.

    The underlying representation of an external texture is unobservable
    (except for sampling behavior) but typically may include

    - Up to three 2D planes of data (e.g. RGBA, Y+UV, Y+U+V).
    - Metadata for converting coordinates before reading from those planes (crop and rotation).
    - Metadata for converting values into the specified output color space (matrices, gammas, 3D LUT).

    The configuration used may not be stable across time, systems, user agents, media sources,
    or frames within a single video source.
    In order to account for many possible representations,
    the binding conservatively uses the following, for *each* external texture:

    - three sampled texture bindings (for up to 3 planes),
    - one sampled texture binding for a 3D LUT,
    - one sampler binding to sample the 3D LUT, and
    - one uniform buffer binding for metadata.
</div>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUExternalTexture {
};
GPUExternalTexture includes GPUObjectBase;
</script>

{{GPUExternalTexture}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUExternalTexture">
    : <dfn>\[[destroyed]]</dfn>, of type `boolean`
    ::
        Indicates whether the object has been destroyed (can no longer be used).
        Initially set to `false`.

        <!-- Move this to an internal object if GPUExternalTexture becomes Serializable. -->
</dl>

### Importing External Textures ### {#external-texture-creation}

An external texture is created from an external video object
using {{GPUDevice/importExternalTexture()}}.

Issue: Update this description with canvas.

External textures are destroyed automatically, as a microtask,
instead of manually or upon garbage collection like other resources.

<script type=idl>
dictionary GPUExternalTextureDescriptor : GPUObjectDescriptorBase {
    required HTMLVideoElement source;
    GPUPredefinedColorSpace colorSpace = "srgb";
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>importExternalTexture(descriptor)</dfn>
    ::
        Creates a {{GPUExternalTexture}} wrapping the provided image source.

        <div algorithm=GPUDevice.importExternalTexture>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/importExternalTexture(descriptor)">
                |descriptor|: Provides the external image source object (and any creation options).
            </pre>

            **Returns:** {{GPUExternalTexture}}

            1. Let |source| be |descriptor|.{{GPUExternalTextureDescriptor/source}}.

            1. Let |usability| be the result of
                [=check the usability of the image argument|checking the usability of=] |source|
                (which may throw an exception).

            1. If |usability| is `bad`, throw an {{InvalidStateError}} and stop.

            1. If |source| <l spec=html>[=is not origin-clean=]</l>,
                throw a {{SecurityError}} and stop.

            1. Let |data| be the result of converting the current image contents of |source| into
                the color space |descriptor|.{{GPUExternalTextureDescriptor/colorSpace}}
                with unpremultiplied alpha.

                This [[#color-space-conversions|may result]] in values outside of the range [0, 1].
                If clamping is desired, it may be performed after sampling.

                Note: This is described like a copy, but may be implemented as a reference to
                read-only underlying data plus appropriate metadata to perform conversion later.

            1. Let |result| be a new {{GPUExternalTexture}} object wrapping |data|.

            1. [=Queue a microtask=] to set |result|.{{GPUExternalTexture/[[destroyed]]}} to `true`,
                releasing the underlying resource.

                Issue: Is this too restrictive?

            1. Return |result|.
        </div>
</dl>

### Sampling External Textures ### {#external-texture-sampling}

External textures are represented in WGSL with `texture_external` and may be read using
`textureLoad` and `textureSampleLevel`.

The `sampler` provided to `textureSampleLevel` is used to sample the underlying textures.
The result is in the color space set by {{GPUExternalTextureDescriptor/colorSpace}}.
It is implementation-dependent whether, for any given external texture, the sampler (and filtering)
is applied before or after conversion from underlying values into the specified color space.

Note:
If the internal representation is an RGBA plane, sampling behaves as on a regular 2D texture.
If there are several underlying planes (e.g. Y+UV), the sampler is used to sample each
underlying texture separately, prior to conversion from YUV to the specified color space.


# Samplers # {#samplers}

## <dfn interface>GPUSampler</dfn> ## {#sampler-interface}

A {{GPUSampler}} encodes transformations and filtering information that can
be used in a shader to interpret texture resource data.

{{GPUSampler|GPUSamplers}} are created via {{GPUDevice/createSampler(descriptor)|GPUDevice.createSampler(optional descriptor)}}
that returns a new sampler object.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUSampler {
};
GPUSampler includes GPUObjectBase;
</script>

{{GPUSampler}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUSampler">
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUSamplerDescriptor}}, readonly
    ::
        The {{GPUSamplerDescriptor}} with which the {{GPUSampler}} was created.

    : <dfn>\[[isComparison]]</dfn> of type {{boolean}}.
    ::
        Whether the {{GPUSampler}} is used as a comparison sampler.

    : <dfn>\[[isFiltering]]</dfn> of type {{boolean}}.
    ::
        Whether the {{GPUSampler}} weights multiple samples of a texture.
</dl>

## Sampler Creation ## {#sampler-creation}

### {{GPUSamplerDescriptor}} ### {#GPUSamplerDescriptor}

A {{GPUSamplerDescriptor}} specifies the options to use to create a {{GPUSampler}}.

<script type=idl>
dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
    GPUAddressMode addressModeU = "clamp-to-edge";
    GPUAddressMode addressModeV = "clamp-to-edge";
    GPUAddressMode addressModeW = "clamp-to-edge";
    GPUFilterMode magFilter = "nearest";
    GPUFilterMode minFilter = "nearest";
    GPUFilterMode mipmapFilter = "nearest";
    float lodMinClamp = 0;
    float lodMaxClamp = 32;
    GPUCompareFunction compare;
    [Clamp] unsigned short maxAnisotropy = 1;
};
</script>

- {{GPUSamplerDescriptor/addressModeU}}, {{GPUSamplerDescriptor/addressModeV}},
    and {{GPUSamplerDescriptor/addressModeW}} specify the address modes for the texture width,
    height, and depth coordinates, respectively.
- {{GPUSamplerDescriptor/magFilter}} specifies the sampling behavior when the sample footprint
    is smaller than or equal to one texel.
- {{GPUSamplerDescriptor/minFilter}} specifies the sampling behavior when the sample footprint
    is larger than one texel.
- {{GPUSamplerDescriptor/mipmapFilter}} specifies behavior for sampling between two mipmap levels.
- {{GPUSamplerDescriptor/lodMinClamp}} and {{GPUSamplerDescriptor/lodMaxClamp}} specify the minimum and
    maximum levels of detail, respectively, used internally when sampling a texture.
- If {{GPUSamplerDescriptor/compare}} is provided, the sampler will be a comparison sampler with the specified
    {{GPUCompareFunction}}.
- {{GPUSamplerDescriptor/maxAnisotropy}} specifies the maximum anisotropy value clamp used by the sampler.

    Note: most implementations support {{GPUSamplerDescriptor/maxAnisotropy}} values in range between 1 and 16, inclusive.

Issue: explain how LOD is calculated and if there are differences here between platforms.

Issue: explain what anisotropic sampling is

{{GPUAddressMode}} describes the behavior of the sampler if the sample footprint extends beyond
the bounds of the sampled texture.

Issue: Describe a "sample footprint" in greater detail.

<script type=idl>
enum GPUAddressMode {
    "clamp-to-edge",
    "repeat",
    "mirror-repeat",
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUAddressMode>
    : <dfn>"clamp-to-edge"</dfn>
    ::
        Texture coordinates are clamped between 0.0 and 1.0, inclusive.

    : <dfn>"repeat"</dfn>
    ::
        Texture coordinates wrap to the other side of the texture.

    : <dfn>"mirror-repeat"</dfn>
    ::
        Texture coordinates wrap to the other side of the texture, but the texture is flipped
        when the integer part of the coordinate is odd.
</dl>

{{GPUFilterMode}} describes the behavior of the sampler if the sample footprint does not exactly
match one texel.

<script type=idl>
enum GPUFilterMode {
    "nearest",
    "linear",
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUFilterMode>
    : <dfn>"nearest"</dfn>
    ::
        Return the value of the texel nearest to the texture coordinates.

    : <dfn>"linear"</dfn>
    ::
        Select two texels in each dimension and return a linear interpolation between their values.
</dl>

{{GPUCompareFunction}} specifies the behavior of a comparison sampler. If a comparison sampler is
used in a shader, an input value is compared to the sampled texture value, and the result of this
comparison test (0.0f for pass, or 1.0f for fail) is used in the filtering operation.

Issue: describe how filtering interacts with comparison sampling.

<script type=idl>
enum GPUCompareFunction {
    "never",
    "less",
    "equal",
    "less-equal",
    "greater",
    "not-equal",
    "greater-equal",
    "always",
};
</script>

<dl dfn-type="enum-value" dfn-for=GPUCompareFunction>
    : <dfn>"never"</dfn>
    ::
        Comparison tests never pass.

    : <dfn>"less"</dfn>
    ::
        A provided value passes the comparison test if it is less than the sampled value.

    : <dfn>"equal"</dfn>
    ::
        A provided value passes the comparison test if it is equal to the sampled value.

    : <dfn>"less-equal"</dfn>
    ::
        A provided value passes the comparison test if it is less than or equal to the sampled value.

    : <dfn>"greater"</dfn>
    ::
        A provided value passes the comparison test if it is greater than the sampled value.

    : <dfn>"not-equal"</dfn>
    ::
        A provided value passes the comparison test if it is not equal to the sampled value.

    : <dfn>"greater-equal"</dfn>
    ::
        A provided value passes the comparison test if it is greater than or equal to the sampled value.

    : <dfn>"always"</dfn>
    ::
        Comparison tests always pass.
</dl>

<div algorithm>
    <dfn abstract-op>validating GPUSamplerDescriptor</dfn>(device, descriptor)
    **Arguments:**
        - {{GPUDevice}} |device|
        - {{GPUSamplerDescriptor}} |descriptor|

    **Returns:** {{boolean}}

    Return `true` if and only if all of the following conditions are satisfied:
        - |device| is valid.
        - |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}} is greater than or equal to 0.
        - |descriptor|.{{GPUSamplerDescriptor/lodMaxClamp}} is greater than or equal to
            |descriptor|.{{GPUSamplerDescriptor/lodMinClamp}}.
        - |descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}} is greater than or equal to 1.
        - When |descriptor|.{{GPUSamplerDescriptor/maxAnisotropy}} is greater than 1,
            |descriptor|.{{GPUSamplerDescriptor/magFilter}}, |descriptor|.{{GPUSamplerDescriptor/minFilter}},
            and |descriptor|.{{GPUSamplerDescriptor/mipmapFilter}} must be equal to {{GPUFilterMode/"linear"}}.
</div>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createSampler(descriptor)</dfn>
    ::
        Creates a {{GPUBindGroupLayout}}.

        <div algorithm=GPUDevice.createSampler>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createSampler(descriptor)">
                |descriptor|: Description of the {{GPUSampler}} to create.
            </pre>

            **Returns:** {{GPUSampler}}

            1. Let |s| be a new {{GPUSampler}} object.
            1. Set |s|.{{GPUSampler/[[descriptor]]}} to |descriptor|.
            1. Set |s|.{{GPUSampler/[[isComparison]]}} to `false` if the {{GPUSamplerDescriptor/compare}} attribute
                    of |s|.{{GPUSampler/[[descriptor]]}} is `null` or undefined. Otherwise, set it to `true`.
            1. Set |s|.{{GPUSampler/[[isFiltering]]}} to `false` if none of {{GPUSamplerDescriptor/minFilter}},
                {{GPUSamplerDescriptor/magFilter}}, or {{GPUSamplerDescriptor/mipmapFilter}} has the value of
                {{GPUFilterMode/"linear"}}. Otherwise, set it to `true`.
            1. Return |s|.

            <div class=validusage dfn-for=GPUDevice.createSampler>
                <dfn abstract-op>Valid Usage</dfn>
                - If |descriptor| is not `null` or undefined:
                    - If [$validating GPUSamplerDescriptor$](this, |descriptor|) returns `false`:
                        1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                        1. Create a new [=invalid=] {{GPUSampler}} and return the result.
            </div>
        </div>
</dl>

# Resource Binding # {#bindings}

## <dfn interface>GPUBindGroupLayout</dfn> ## {#bind-group-layout}

A {{GPUBindGroupLayout}} defines the interface between a set of resources bound in a {{GPUBindGroup}} and their accessibility in shader stages.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBindGroupLayout {
};
GPUBindGroupLayout includes GPUObjectBase;
</script>

{{GPUBindGroupLayout}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPUBindGroupLayout>
    : <dfn>\[[descriptor]]</dfn>
    ::
</dl>

### Creation ### {#bind-group-layout-creation}

A {{GPUBindGroupLayout}} is created via {{GPUDevice/createBindGroupLayout()|GPUDevice.createBindGroupLayout()}}.

<script type=idl>
dictionary GPUBindGroupLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayoutEntry> entries;
};
</script>

A {{GPUBindGroupLayoutEntry}} describes a single shader resource binding to be included in a {{GPUBindGroupLayout}}.

<script type=idl>
typedef [EnforceRange] unsigned long GPUShaderStageFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUShaderStage {
    const GPUFlagsConstant VERTEX   = 0x1;
    const GPUFlagsConstant FRAGMENT = 0x2;
    const GPUFlagsConstant COMPUTE  = 0x4;
};

dictionary GPUBindGroupLayoutEntry {
    required GPUIndex32 binding;
    required GPUShaderStageFlags visibility;

    GPUBufferBindingLayout buffer;
    GPUSamplerBindingLayout sampler;
    GPUTextureBindingLayout texture;
    GPUStorageTextureBindingLayout storageTexture;
    GPUExternalTextureBindingLayout externalTexture;
};
</script>

{{GPUBindGroupLayoutEntry}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUBindGroupLayoutEntry>
    : <dfn>binding</dfn>
    ::
        A unique identifier for a resource binding within a
        {{GPUBindGroupLayoutEntry}}, a corresponding {{GPUBindGroupEntry}},
        and the {{GPUShaderModule}}s.

    : <dfn>visibility</dfn>
    ::
        A bitset of the members of {{GPUShaderStage}}.
        Each set bit indicates that a {{GPUBindGroupLayoutEntry}}'s resource
        will be accessible from the associated shader stage.

    : <dfn>buffer</dfn>
    ::
        When not `undefined`, indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUBufferBinding}}.

    : <dfn>sampler</dfn>
    ::
        When not `undefined`, indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUSampler}}.

    : <dfn>texture</dfn>
    ::
        When not `undefined`, indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUTextureView}}.

    : <dfn>storageTexture</dfn>
    ::
        When not `undefined`, indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUTextureView}}.

    : <dfn>externalTexture</dfn>
    ::
        When not `undefined`, indicates the [=binding resource type=] for this {{GPUBindGroupLayoutEntry}}
        is {{GPUExternalTexture}}.
</dl>

The [=binding member=] of a {{GPUBindGroupLayoutEntry}} is determined by which member of the
{{GPUBindGroupLayoutEntry}} is defined:
{{GPUBindGroupLayoutEntry/buffer}}, {{GPUBindGroupLayoutEntry/sampler}},
{{GPUBindGroupLayoutEntry/texture}}, {{GPUBindGroupLayoutEntry/storageTexture}}, or
{{GPUBindGroupLayoutEntry/externalTexture}}.
Only one may be defined for any given {{GPUBindGroupLayoutEntry}}.
Each member has an associated {{GPUBindingResource}}
type and each [=binding type=] has an associated [=internal usage=], given by this table:

<table class="data" style="white-space: nowrap">
    <thead>
        <tr>
            <th><dfn dfn>Binding member</dfn>
            <th><dfn dfn lt="Binding Resource Type">Resource type</dfn>
            <th><dfn dfn>Binding type</dfn><br>
            <th><dfn dfn>Binding usage</dfn>
    </thead>
    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/buffer}}
        <td rowspan=3>{{GPUBufferBinding}}
        <td>{{GPUBufferBindingType/"uniform"}}
        <td>[=internal usage/constant=]
    <tr>
        <td>{{GPUBufferBindingType/"storage"}}
        <td>[=internal usage/storage=]
    <tr>
        <td>{{GPUBufferBindingType/"read-only-storage"}}
        <td>[=internal usage/storage-read=]

    <tr>
        <td rowspan=3>{{GPUBindGroupLayoutEntry/sampler}}
        <td rowspan=3>{{GPUSampler}}
        <td>{{GPUSamplerBindingType/"filtering"}}
        <td rowspan=3>[=internal usage/constant=]
    <tr>
        <td>{{GPUSamplerBindingType/"non-filtering"}}
    <tr>
        <td>{{GPUSamplerBindingType/"comparison"}}

    <tr>
        <td rowspan=5>{{GPUBindGroupLayoutEntry/texture}}
        <td rowspan=5>{{GPUTextureView}}
        <td>{{GPUTextureSampleType/"float"}}
        <td rowspan=5>[=internal usage/constant=]
    <tr>
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
    <tr>
        <td>{{GPUTextureSampleType/"depth"}}
    <tr>
        <td>{{GPUTextureSampleType/"sint"}}
    <tr>
        <td>{{GPUTextureSampleType/"uint"}}

    <tr>
        <td>{{GPUBindGroupLayoutEntry/storageTexture}}
        <td>{{GPUTextureView}}
        <td>{{GPUStorageTextureAccess/"write-only"}}
        <td>[=internal usage/storage=]

    <tr>
        <td>{{GPUBindGroupLayoutEntry/externalTexture}}
        <td>{{GPUExternalTexture}}
        <td>
        <td>[=internal usage/constant=]
</table>

<div algorithm>
    The [=list=] of {{GPUBindGroupLayoutEntry}} values |entries|
    <dfn>exceeds the binding slot limits</dfn> of [=supported limits=] |limits|
    if the number of slots used toward a limit exceeds the supported value in |limits|.
    Each entry may use multiple slots toward multiple limits.

    1. For each |entry| in |entries|, if:
        <dl class=switch>
            : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                is {{GPUBufferBindingType/"uniform"}} and
                |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`
            :: Consider 1 {{supported limits/maxDynamicUniformBuffersPerPipelineLayout}} slot to be used.
            : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                is {{GPUBufferBindingType/"storage"}} and
                |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`
            :: Consider 1 {{supported limits/maxDynamicStorageBuffersPerPipelineLayout}} slot to be used.
        </dl>
    1. For each shader stage |stage| in
        &laquo; {{GPUShaderStage/VERTEX}}, {{GPUShaderStage/FRAGMENT}}, {{GPUShaderStage/COMPUTE}} &raquo;:
        1. For each |entry| in |entries|  for which
            |entry|.{{GPUBindGroupLayoutEntry/visibility}} contains |stage|, if:
            <dl class=switch>
                : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                    is {{GPUBufferBindingType/"uniform"}}
                :: Consider 1 {{supported limits/maxUniformBuffersPerShaderStage}} slot to be used.
                : |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                    is {{GPUBufferBindingType/"storage"}} or {{GPUBufferBindingType/"read-only-storage"}}
                :: Consider 1 {{supported limits/maxStorageBuffersPerShaderStage}} slot to be used.
                : |entry|.{{GPUBindGroupLayoutEntry/sampler}} is not `undefined`
                :: Consider 1 {{supported limits/maxSamplersPerShaderStage}} slot to be used.
                : |entry|.{{GPUBindGroupLayoutEntry/texture}} is not `undefined`
                :: Consider 1 {{supported limits/maxSampledTexturesPerShaderStage}} slot to be used.
                : |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} is not `undefined`
                :: Consider 1 {{supported limits/maxStorageTexturesPerShaderStage}} slot to be used.
                : |entry|.{{GPUBindGroupLayoutEntry/externalTexture}} is not `undefined`
                :: Consider
                    4 {{supported limits/maxSampledTexturesPerShaderStage}} slot,
                    1 {{supported limits/maxSamplersPerShaderStage}} slot, and
                    1 {{supported limits/maxUniformBuffersPerShaderStage}} slot
                    to be used.
            </dl>
</div>

<script type=idl>
enum GPUBufferBindingType {
    "uniform",
    "storage",
    "read-only-storage",
};

dictionary GPUBufferBindingLayout {
    GPUBufferBindingType type = "uniform";
    boolean hasDynamicOffset = false;
    GPUSize64 minBindingSize = 0;
};
</script>

{{GPUBufferBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUBufferBindingLayout>
    : <dfn>type</dfn>
    ::
        Indicates the type required for buffers bound to this bindings.

    : <dfn>hasDynamicOffset</dfn>
    ::
        Indicates whether this binding requires a dynamic offset.

    : <dfn>minBindingSize</dfn>
    ::
        Indicates the minimum buffer binding size.

        Bindings are always validated against this size in {{GPUDevice/createBindGroup()}}.

        If this *is not* `0`, pipeline creation additionally [$validating shader binding|validates$]
        that this value is large enough for the bindings declared in the shader.

        If this *is* `0`, draw/dispatch commands additionally [$Validate encoder bind groups|validate$]
        that each binding in the {{GPUBindGroup}} is large enough for the bindings declared in the shader.

        Note:
        Similar execution-time validation is theoretically possible for other
        binding-related fields specified for early validation, like
        {{GPUTextureBindingLayout/sampleType}} and {{GPUStorageTextureBindingLayout/format}},
        which currently can only be validated in pipeline creation.
        However, such execution-time validation could be costly or unnecessarily complex, so it is
        available only for {{GPUBufferBindingLayout/minBindingSize}} which is expected to have the
        most ergonomic impact.
</dl>

<script type=idl>
enum GPUSamplerBindingType {
    "filtering",
    "non-filtering",
    "comparison",
};

dictionary GPUSamplerBindingLayout {
    GPUSamplerBindingType type = "filtering";
};
</script>

{{GPUSamplerBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUSamplerBindingLayout>
    : <dfn>type</dfn>
    ::
        Indicates the required type of a sampler bound to this bindings.
</dl>

<script type=idl>
enum GPUTextureSampleType {
    "float",
    "unfilterable-float",
    "depth",
    "sint",
    "uint",
};

dictionary GPUTextureBindingLayout {
    GPUTextureSampleType sampleType = "float";
    GPUTextureViewDimension viewDimension = "2d";
    boolean multisampled = false;
};
</script>

Issue(https://github.com/gpuweb/gpuweb/issues/851): consider making {{GPUTextureBindingLayout/sampleType}}
truly optional.

{{GPUTextureBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUTextureBindingLayout>
    : <dfn>sampleType</dfn>
    ::
        Indicates the type required for texture views bound to this binding.

    : <dfn>viewDimension</dfn>
    ::
        Indicates the required {{GPUTextureViewDescriptor/dimension}} for texture views bound to
        this binding.
        <!-- https://github.com/gpuweb/gpuweb/pull/339 -->

    : <dfn>multisampled</dfn>
    ::
        Indicates whether or not texture views bound to this binding must be multisampled.
</dl>

<script type=idl>
enum GPUStorageTextureAccess {
    "write-only",
};

dictionary GPUStorageTextureBindingLayout {
    GPUStorageTextureAccess access = "write-only";
    required GPUTextureFormat format;
    GPUTextureViewDimension viewDimension = "2d";
};
</script>

Issue(https://github.com/gpuweb/gpuweb/issues/851): consider making {{GPUStorageTextureBindingLayout/format}}
truly optional.

{{GPUStorageTextureBindingLayout}} dictionaries have the following members:

<dl dfn-type=dict-member dfn-for=GPUStorageTextureBindingLayout>
    : <dfn>access</dfn>
    ::
        Indicates whether texture views bound to this binding will be bound for read-only or
        write-only access.

    : <dfn>format</dfn>
    ::
        The required {{GPUTextureViewDescriptor/format}} of texture views bound to this binding.

    : <dfn>viewDimension</dfn>
    ::
        Indicates the required {{GPUTextureViewDescriptor/dimension}} for texture views bound to
        this binding.
        <!-- https://github.com/gpuweb/gpuweb/pull/339 -->
</dl>

<script type=idl>
dictionary GPUExternalTextureBindingLayout {
};
</script>

A {{GPUBindGroupLayout}} object has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBindGroupLayout">
    : <dfn>\[[entryMap]]</dfn> of type [=ordered map=]&lt;{{GPUSize32}}, {{GPUBindGroupLayoutEntry}}&gt.
    ::
        The map of binding indices pointing to the {{GPUBindGroupLayoutEntry}}s,
        which this {{GPUBindGroupLayout}} describes.

    : <dfn>\[[dynamicOffsetCount]]</dfn> of type {{GPUSize32}}.
    ::
        The number of buffer bindings with dynamic offsets in this {{GPUBindGroupLayout}}.

    : <dfn>\[[exclusivePipeline]]</dfn> of type {{GPUPipelineBase}}?, initially `null`.
    ::
        The pipeline that created this {{GPUBindGroupLayout}}, if it was created as part of a
        [[#default-pipeline-layout|default pipeline layout]]. If not `null`, {{GPUBindGroup}}s
        created with this {{GPUBindGroupLayout}} can only be used with the specified
        {{GPUPipelineBase}}.
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroupLayout(descriptor)</dfn>
    ::
        Creates a {{GPUBindGroupLayout}}.

        <div algorithm=GPUDevice.createBindGroupLayout>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createBindGroupLayout(descriptor)">
                |descriptor|: Description of the {{GPUBindGroupLayout}} to create.
            </pre>

            **Returns:** {{GPUBindGroupLayout}}

            1. Let |layout| be a new valid {{GPUBindGroupLayout}} object.
            1. Set |layout|.{{GPUBindGroupLayout/[[descriptor]]}} to |descriptor|.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |this| is a [=valid=] {{GPUDevice}}.
                            - The {{GPUBindGroupLayoutEntry/binding}} of each entry in |descriptor| is unique.
                            - The {{GPUBindGroupLayoutEntry/binding}} of each entry in |descriptor| must be &lt; 65536.
                            - |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}} must not
                                [=exceeds the binding slot limits|exceed the binding slot limits=]
                                of |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.
                            - For each {{GPUBindGroupLayoutEntry}} |entry| in |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}}:
                                - Let |bufferLayout| be |entry|.{{GPUBindGroupLayoutEntry/buffer}}
                                - Let |samplerLayout| be |entry|.{{GPUBindGroupLayoutEntry/sampler}}
                                - Let |textureLayout| be |entry|.{{GPUBindGroupLayoutEntry/texture}}
                                - Let |storageTextureLayout| be |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}

                                - Exactly one of |bufferLayout|, |samplerLayout|, |textureLayout|,
                                    or |storageTextureLayout| are not `undefined`.

                                - If |entry|.{{GPUBindGroupLayoutEntry/visibility}} includes
                                    {{GPUShaderStage/VERTEX}}:
                                    - |entry|.{{GPUBindGroupLayoutEntry/buffer}}?.{{GPUBufferBindingLayout/type}}
                                        must not be {{GPUBufferBindingType/"storage"}}.
                                    - |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}?.{{GPUStorageTextureBindingLayout/access}}
                                        must not be {{GPUStorageTextureAccess/"write-only"}}.

                                - If the |textureLayout| is not `undefined` and
                                    |textureLayout|.{{GPUTextureBindingLayout/multisampled}} is `true`:
                                    - |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} is
                                        {{GPUTextureViewDimension/"2d"}}.
                                    - |textureLayout|.{{GPUTextureBindingLayout/sampleType}} is not
                                        {{GPUTextureSampleType/"float"}} or {{GPUTextureSampleType/"depth"}}.

                                - If |storageTextureLayout| is not `undefined`:
                                    - |storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}} is not
                                        {{GPUTextureViewDimension/"cube"}} or {{GPUTextureViewDimension/"cube-array"}}.
                                    - |storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}} must be a format
                                        which can support storage usage.
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |layout| [=invalid=] and return |layout|.

                    1. Set |layout|.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}} to the number of
                        entries in |descriptor| where {{GPUBindGroupLayoutEntry/buffer}} is not `undefined` and
                        {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`.
                    1. For each {{GPUBindGroupLayoutEntry}} |entry| in
                        |descriptor|.{{GPUBindGroupLayoutDescriptor/entries}}:
                        1. Insert |entry| into |layout|.{{GPUBindGroupLayout/[[entryMap]]}}
                            with the key of |entry|.{{GPUBindGroupLayoutEntry/binding}}.
                </div>
            1. Return |layout|.

        </div>
</dl>

### Compatibility ### {#bind-group-compatibility}

<div algorithm>
Two {{GPUBindGroupLayout}} objects |a| and |b| are considered <dfn dfn>group-equivalent</dfn>
if and only if all of the following conditions are satisfied:
    - |a|.{{GPUBindGroupLayout/[[exclusivePipeline]]}} == |b|.{{GPUBindGroupLayout/[[exclusivePipeline]]}}.
    - for any binding number |binding|, one of the following conditions is satisfied:
        - it's missing from both |a|.{{GPUBindGroupLayout/[[entryMap]]}} and |b|.{{GPUBindGroupLayout/[[entryMap]]}}.
        - |a|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|] == |b|.{{GPUBindGroupLayout/[[entryMap]]}}[|binding|]
</div>

If bind groups layouts are [=group-equivalent=] they can be interchangeably used in all contents.

## <dfn interface>GPUBindGroup</dfn> ## {#gpu-bind-group}

A {{GPUBindGroup}} defines a set of resources to be bound together in a group
    and how the resources are used in shader stages.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUBindGroup {
};
GPUBindGroup includes GPUObjectBase;
</script>

### Bind Group Creation ### {#bind-group-creation}

A {{GPUBindGroup}} is created via {{GPUDevice/createBindGroup()|GPUDevice.createBindGroup()}}.

<script type=idl>
dictionary GPUBindGroupDescriptor : GPUObjectDescriptorBase {
    required GPUBindGroupLayout layout;
    required sequence<GPUBindGroupEntry> entries;
};
</script>

A {{GPUBindGroupEntry}} describes a single resource to be bound in a {{GPUBindGroup}}.

<script type=idl>
typedef (GPUSampler or GPUTextureView or GPUBufferBinding or GPUExternalTexture) GPUBindingResource;

dictionary GPUBindGroupEntry {
    required GPUIndex32 binding;
    required GPUBindingResource resource;
};
</script>

<script type=idl>
dictionary GPUBufferBinding {
    required GPUBuffer buffer;
    GPUSize64 offset = 0;
    GPUSize64 size;
};
</script>

  * {{GPUBufferBinding/size}}: If undefined, specifies the range starting at
      {{GPUBufferBinding/offset}} and ending at the end of the buffer.

A {{GPUBindGroup}} object has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUBindGroup">
    : <dfn>\[[layout]]</dfn> of type {{GPUBindGroupLayout}}.
    ::
        The {{GPUBindGroupLayout}} associated with this {{GPUBindGroup}}.

    : <dfn>\[[entries]]</dfn> of type sequence<{{GPUBindGroupEntry}}>.
    ::
        The set of {{GPUBindGroupEntry}}s this {{GPUBindGroup}} describes.

    : <dfn>\[[usedResources]]</dfn> of type [=ordered map=]&lt;[=subresource=], [=list=]&lt;[=internal usage=]&gt;&gt;.
    ::
        The set of buffer and texture [=subresource=]s used by this bind group,
        associated with lists of the [=internal usage=] flags.
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createBindGroup(descriptor)</dfn>
    ::
        Creates a {{GPUBindGroup}}.

        <div algorithm=GPUDevice.createBindGroup>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createBindGroup(descriptor)">
                |descriptor|: Description of the {{GPUBindGroup}} to create.
            </pre>

            **Returns:** {{GPUBindGroup}}

            1. Let |bindGroup| be a new valid {{GPUBindGroup}} object.
            1. Let |limits| be |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |descriptor|.{{GPUBindGroupDescriptor/layout}} is [$valid to use with$] |this|.
                            - The number of {{GPUBindGroupLayoutDescriptor/entries}} of
                                |descriptor|.{{GPUBindGroupDescriptor/layout}} is exactly equal to
                                the number of |descriptor|.{{GPUBindGroupDescriptor/entries}}.

                            For each {{GPUBindGroupEntry}} |bindingDescriptor| in
                                |descriptor|.{{GPUBindGroupDescriptor/entries}}:
                                - Let |resource| be |bindingDescriptor|.{{GPUBindGroupEntry/resource}}.
                                - There is exactly one {{GPUBindGroupLayoutEntry}} |layoutBinding|
                                    in |descriptor|.{{GPUBindGroupDescriptor/layout}}.{{GPUBindGroupLayoutDescriptor/entries}}
                                    such that |layoutBinding|.{{GPUBindGroupLayoutEntry/binding}} equals to
                                    |bindingDescriptor|.{{GPUBindGroupEntry/binding}}.

                                - If the defined [=binding member=] for |layoutBinding| is
                                    <dl class="switch">
                                        : {{GPUBindGroupLayoutEntry/sampler}}
                                        ::
                                            - |resource| is a {{GPUSampler}}.
                                            - |resource| is [$valid to use with$] |this|.
                                            - If |layoutBinding|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} is:
                                                <dl class="switch">
                                                    : {{GPUSamplerBindingType/"filtering"}}
                                                    :: |resource|.{{GPUSampler/[[isComparison]]}} is `false`.

                                                    : {{GPUSamplerBindingType/"non-filtering"}}
                                                    ::
                                                        |resource|.{{GPUSampler/[[isFiltering]]}} is `false`.
                                                        |resource|.{{GPUSampler/[[isComparison]]}} is `false`.

                                                    : {{GPUSamplerBindingType/"comparison"}}
                                                    :: |resource|.{{GPUSampler/[[isComparison]]}} is `true`.
                                                </dl>

                                        : {{GPUBindGroupLayoutEntry/texture}}
                                        ::
                                            - |resource| is a {{GPUTextureView}}.
                                            - |resource| is [$valid to use with$] |this|.
                                            - Let |texture| be |resource|.{{GPUTextureView/[[texture]]}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}}
                                                is equal to |resource|'s {{GPUTextureViewDescriptor/dimension}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}
                                                is [[#texture-format-caps|compatible]] with
                                                |resource|'s {{GPUTextureViewDescriptor/format}}.
                                            - |texture|'s {{GPUTextureDescriptor/usage}} includes {{GPUTextureUsage/TEXTURE_BINDING}}.
                                            - If |layoutBinding|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}}
                                                is `true`, |texture|'s {{GPUTextureDescriptor/sampleCount}}
                                                &gt; `1`, Otherwise |texture|'s {{GPUTextureDescriptor/sampleCount}} is `1`.

                                        : {{GPUBindGroupLayoutEntry/storageTexture}}
                                        ::
                                            - |resource| is a {{GPUTextureView}}.
                                            - |resource| is [$valid to use with$] |this|.
                                            - Let |texture| be |resource|.{{GPUTextureView/[[texture]]}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}}
                                                is equal to |resource|'s {{GPUTextureViewDescriptor/dimension}}.
                                            - |layoutBinding|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}
                                                is equal to |resource|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}.
                                            - |texture|'s {{GPUTextureDescriptor/usage}} includes {{GPUTextureUsage/STORAGE_BINDING}}.
                                            - |resource|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/mipLevelCount}} must be 1.

                                        :  {{GPUBindGroupLayoutEntry/buffer}}
                                        ::
                                            - |resource| is a {{GPUBufferBinding}}.
                                            - |resource|.{{GPUBufferBinding/buffer}} is [$valid to use with$] |this|.
                                            - The bound part designated by |resource|.{{GPUBufferBinding/offset}} and
                                                |resource|.{{GPUBufferBinding/size}} resides inside the buffer and has non-zero size.
                                            - [$effective buffer binding size$](|resource|), is greater than or equal to
                                                |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}.

                                            - If |layoutBinding|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} is
                                                <dl class="switch">
                                                    : {{GPUBufferBindingType/"uniform"}}
                                                    :: |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}}
                                                        includes {{GPUBufferUsage/UNIFORM}}.
                                                    :: [$effective buffer binding size$](|resource|) &le;
                                                        |limits|.{{supported limits/maxUniformBufferBindingSize}}.
                                                    :: |resource|.{{GPUBufferBinding/offset}} is a multiple of
                                                        |limits|.{{supported limits/minUniformBufferOffsetAlignment}}.

                                                    : {{GPUBufferBindingType/"storage"}} or
                                                        {{GPUBufferBindingType/"read-only-storage"}}
                                                    :: |resource|.{{GPUBufferBinding/buffer}}.{{GPUBufferDescriptor/usage}}
                                                        includes {{GPUBufferUsage/STORAGE}}.
                                                    :: [$effective buffer binding size$](|resource|) &le;
                                                        |limits|.{{supported limits/maxStorageBufferBindingSize}}.
                                                    :: |resource|.{{GPUBufferBinding/offset}} is a multiple of
                                                        |limits|.{{supported limits/minStorageBufferOffsetAlignment}}.
                                                </dl>

                                        :  {{GPUBindGroupLayoutEntry/externalTexture}}
                                        ::
                                            - |resource| is a {{GPUExternalTexture}}.
                                            - |resource| is [$valid to use with$] |this|.
                                    </dl>
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |bindGroup| [=invalid=] and return |bindGroup|.

                    1. Let |bindGroup|.{{GPUBindGroup/[[layout]]}} =
                        |descriptor|.{{GPUBindGroupDescriptor/layout}}.
                    1. Let |bindGroup|.{{GPUBindGroup/[[entries]]}} =
                        |descriptor|.{{GPUBindGroupDescriptor/entries}}.
                    1. Let |bindGroup|.{{GPUBindGroup/[[usedResources]]}} = {}.

                    1. For each {{GPUBindGroupEntry}} |bindingDescriptor| in
                        |descriptor|.{{GPUBindGroupDescriptor/entries}}:
                        1. Let |internalUsage| be the [=binding usage=] for |layoutBinding|.
                        1. Each [=subresource=] seen by |resource| is added to {{GPUBindGroup/[[usedResources]]}} as |internalUsage|.
                </div>

            1. Return |bindGroup|.
        </div>
</dl>

<div algorithm>
    <dfn abstract-op>effective buffer binding size</dfn>(binding)
        1. If |binding|.{{GPUBufferBinding/size}} is `undefined`:
            1. Return max(0, |binding|.{{GPUBufferBinding/buffer}}.{{GPUBuffer/[[size]]}} - |binding|.{{GPUBufferBinding/offset}});
        1. Return |binding|.{{GPUBufferBinding/size}}.
</div>

## <dfn interface>GPUPipelineLayout</dfn> ## {#pipeline-layout}

A {{GPUPipelineLayout}} defines the mapping between resources of all {{GPUBindGroup}} objects set up during command encoding in {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup}}, and the shaders of the pipeline set by {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}} or {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}}.

The full binding address of a resource can be defined as a trio of:
  1. shader stage mask, to which the resource is visible
  2. bind group index
  3. binding number

The components of this address can also be seen as the binding space of a pipeline. A {{GPUBindGroup}} (with the corresponding {{GPUBindGroupLayout}}) covers that space for a fixed bind group index. The contained bindings need to be a superset of the resources used by the shader at this bind group index.

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUPipelineLayout {
};
GPUPipelineLayout includes GPUObjectBase;
</script>

{{GPUPipelineLayout}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUPipelineLayout">
    : <dfn>\[[bindGroupLayouts]]</dfn> of type [=list=]&lt;{{GPUBindGroupLayout}}&gt;.
    ::
        The {{GPUBindGroupLayout}} objects provided at creation in {{GPUPipelineLayoutDescriptor/bindGroupLayouts|GPUPipelineLayoutDescriptor.bindGroupLayouts}}.
</dl>

Note: using the same {{GPUPipelineLayout}} for many {{GPURenderPipeline}} or {{GPUComputePipeline}} pipelines guarantees that the user agent doesn't need to rebind any resources internally when there is a switch between these pipelines.

<div class="example">
{{GPUComputePipeline}} object X was created with {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, B, C. {{GPUComputePipeline}} object Y was created with {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGroupLayouts}} A, D, C. Supposing the command encoding sequence has two dispatches:

  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(0, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(2, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(X)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}
  1. {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)|setBindGroup(1, ...)}}
  1. {{GPUComputePassEncoder/setPipeline(pipeline)|setPipeline(Y)}}
  1. {{GPUComputePassEncoder/dispatch(x, y, z)|dispatch()}}

In this scenario, the user agent would have to re-bind the group slot 2 for the second dispatch, even though neither the {{GPUBindGroupLayout}} at index 2 of {{GPUPipelineLayout/[[bindGroupLayouts]]|GPUPipelineLayout.bindGrouplayouts}}, or the {{GPUBindGroup}} at slot 2, change.
</div>

Issue: should this example and the note be moved to some "best practices" document?

Note: the expected usage of the {{GPUPipelineLayout}} is placing the most common and the least frequently changing bind groups at the "bottom" of the layout, meaning lower bind group slot numbers, like 0 or 1. The more frequently a bind group needs to change between draw calls, the higher its index should be. This general guideline allows the user agent to minimize state changes between draw calls, and consequently lower the CPU overhead.

### Creation ### {#pipeline-layout-creation}

A {{GPUPipelineLayout}} is created via {{GPUDevice/createPipelineLayout()|GPUDevice.createPipelineLayout()}}.

<script type=idl>
dictionary GPUPipelineLayoutDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUBindGroupLayout> bindGroupLayouts;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createPipelineLayout(descriptor)</dfn>
    ::
        Creates a {{GPUPipelineLayout}}.

        <div algorithm=GPUDevice.createPipelineLayout>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createPipelineLayout(descriptor)">
                |descriptor|: Description of the {{GPUPipelineLayout}} to create.
            </pre>

            **Returns:** {{GPUPipelineLayout}}

            1. If any of the following requirements are unmet:
                <div class=validusage>
                    Let |limits| be |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.

                    Let |allEntries| be the result of concatenating
                        |bgl|.{{GPUBindGroupLayout/[[descriptor]]}}.{{GPUBindGroupLayoutDescriptor/entries}}
                        for all |bgl| in |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}.

                    - Every {{GPUBindGroupLayout}} in |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
                        must be [$valid to use with$] |this| and have a {{GPUBindGroupLayout/[[exclusivePipeline]]}}
                        of `null`.
                    - The [=list/size=] of |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}
                        must be &le; |limits|.{{supported limits/maxBindGroups}}.
                    - |allEntries| must not [=exceeds the binding slot limits|exceed the binding slot limits=] of |limits|.
                </div>

                Then:
                    1. Generate a {{GPUValidationError}} in the current scope with appropriate error message.
                    1. Create a new [=invalid=] {{GPUPipelineLayout}} and return the result.

            1. Let |pl| be a new {{GPUPipelineLayout}} object.
            1. Set the |pl|.{{GPUPipelineLayout/[[bindGroupLayouts]]}} to
                |descriptor|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}}.
            1. Return |pl|.
        </div>
</dl>

Note: two {{GPUPipelineLayout}} objects are considered equivalent for any usage
if their internal {{GPUPipelineLayout/[[bindGroupLayouts]]}} sequences contain
{{GPUBindGroupLayout}} objects that are [=group-equivalent=].

# Shader Modules # {#shader-modules}

## <dfn interface>GPUShaderModule</dfn> ## {#shader-module}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUShaderModule {
    Promise<GPUCompilationInfo> compilationInfo();
};
GPUShaderModule includes GPUObjectBase;
</script>

{{GPUShaderModule}} is a reference to an internal shader module object.

Issue(gpuweb/gpuweb#354): Finish defining multithreading API and add `[Serializable]` back to the interface.

### Shader Module Creation ### {#shader-module-creation}

<script type=idl>
dictionary GPUShaderModuleCompilationHint {
    required GPUPipelineLayout layout;
};

dictionary GPUShaderModuleDescriptor : GPUObjectDescriptorBase {
    required USVString code;
    object sourceMap;
    record<USVString, GPUShaderModuleCompilationHint> hints;
};
</script>

{{GPUShaderModuleDescriptor/sourceMap}}, if defined, MAY be interpreted as a
source-map-v3 format.
Source maps are optional, but serve as a standardized way to support dev-tool
integration such as source-language debugging. [[SourceMap]]

{{GPUShaderModuleDescriptor/hints}}, if defined, maps an entry point name from
the shader to a {{GPUShaderModuleCompilationHint}}. No validation is performed with
any of these {{GPUShaderModuleCompilationHint}}. Implementations should use any
information present in the {{GPUShaderModuleCompilationHint}} to perform as much
compilation as is possible within {{GPUDevice/createShaderModule()}}.

Note: Supplying information in {{GPUShaderModuleDescriptor/hints}} does not have any
observable effect, other than performance. Because a single shader module can hold
multiple entry points, and multiple pipelines can be created from a single shader
module, it can be more performant for an implementation to do as much compilation as
possible once in {{GPUDevice/createShaderModule()}} rather than multiple times in
the multiple calls to {{GPUDevice/createComputePipeline()}} /
{{GPUDevice/createRenderPipeline()}}.

Note: If possible, authors should be supplying the same information to
{{GPUDevice/createShaderModule()}} and {{GPUDevice/createComputePipeline()}} /
{{GPUDevice/createRenderPipeline()}}.

Note: If an author is unable to provide this {{GPUShaderModuleDescriptor/hints}}
information at the time of calling {{GPUDevice/createShaderModule()}}, they should
usually not delay calling {{GPUDevice/createShaderModule()}}; but should instead just
omit the unknown information from {{GPUShaderModuleDescriptor/hints}} or
{{GPUShaderModuleCompilationHint}}. Omitting this information may cause compilation
to be deferred to {{GPUDevice/createComputePipeline()}} /
{{GPUDevice/createRenderPipeline()}}.

Note: If an author is not confident that the information passed to
{{GPUDevice/createShaderModule()}} will match the information later passed to
{{GPUDevice/createComputePipeline()}} / {{GPUDevice/createRenderPipeline()}} with that
same module, they should avoid passing that information to
{{GPUDevice/createShaderModule()}}, as passing mismatched information to
{{GPUDevice/createShaderModule()}} may cause unnecessary compilations to occur.

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createShaderModule(descriptor)</dfn>
    ::
        Creates a {{GPUShaderModule}}.

        <div algorithm=GPUDevice.createShaderModule>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createShaderModule(descriptor)">
                descriptor: Description of the {{GPUShaderModule}} to create.
            </pre>

            **Returns:** {{GPUShaderModule}}

            Issue: Describe {{GPUDevice/createShaderModule()}} algorithm steps.
        </div>
</dl>

### Shader Module Compilation Information ### {#shader-module-compilation-information}

<script type=idl>
enum GPUCompilationMessageType {
    "error",
    "warning",
    "info",
};

[Exposed=(Window, DedicatedWorker), Serializable, SecureContext]
interface GPUCompilationMessage {
    readonly attribute DOMString message;
    readonly attribute GPUCompilationMessageType type;
    readonly attribute unsigned long long lineNum;
    readonly attribute unsigned long long linePos;
    readonly attribute unsigned long long offset;
    readonly attribute unsigned long long length;
};

[Exposed=(Window, DedicatedWorker), Serializable, SecureContext]
interface GPUCompilationInfo {
    readonly attribute FrozenArray<GPUCompilationMessage> messages;
};
</script>

A {{GPUCompilationMessage}} is an informational, warning, or error message generated by the
{{GPUShaderModule}} compiler. The messages are intended to be human readable to help developers
diagnose issues with their shader {{GPUShaderModuleDescriptor/code}}. Each message may correspond to
either a single point in the shader code, a substring of the shader code, or may not correspond to
any specific point in the code at all.

{{GPUCompilationMessage}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUCompilationMessage>
    : <dfn>message</dfn>
    ::
        A human-readable string containing the message generated during the shader compilation.

    : <dfn>type</dfn>
    ::
        The severity level of the message.

        If the {{GPUCompilationMessage/type}} is "error", it corresponds to a
        [=shader-creation error=].

    : <dfn>lineNum</dfn>
    ::
        The line number in the shader {{GPUShaderModuleDescriptor/code}} the
        {{GPUCompilationMessage/message}} corresponds to. Value is one-based, such that a lineNum of
        `1` indicates the first line of the shader {{GPUShaderModuleDescriptor/code}}.

        If the {{GPUCompilationMessage/message}} corresponds to a substring this points to
        the line on which the substring begins. Must be `0` if the {{GPUCompilationMessage/message}}
        does not correspond to any specific point in the shader {{GPUShaderModuleDescriptor/code}}.

        Issue(gpuweb/gpuweb#2435): Reference WGSL spec when it [defines what a line is](https://gpuweb.github.io/gpuweb/wgsl/#comments).

    : <dfn>linePos</dfn>
    ::
        The offset, in UTF-16 code units, from the beginning of line {{GPUCompilationMessage/lineNum}}
        of the shader {{GPUShaderModuleDescriptor/code}} to the point or beginning of the substring
        that the {{GPUCompilationMessage/message}} corresponds to. Value is one-based, such that a
        {{GPUCompilationMessage/linePos}} of `1` indicates the first character of the line.

        If {{GPUCompilationMessage/message}} corresponds to a substring this points to the
        first UTF-16 code unit of the substring. Must be `0` if the {{GPUCompilationMessage/message}}
        does not correspond to any specific point in the shader {{GPUShaderModuleDescriptor/code}}.

    : <dfn>offset</dfn>
    ::
        The offset from the beginning of the shader {{GPUShaderModuleDescriptor/code}} in UTF-16
        code units to the point or beginning of the substring that {{GPUCompilationMessage/message}}
        corresponds to. Must reference the same position as {{GPUCompilationMessage/lineNum}} and
        {{GPUCompilationMessage/linePos}}. Must be `0` if the {{GPUCompilationMessage/message}}
        does not correspond to any specific point in the shader {{GPUShaderModuleDescriptor/code}}.

    : <dfn>length</dfn>
    ::
        The number of UTF-16 code units in the substring that {{GPUCompilationMessage/message}}
        corresponds to. If the message does not correspond with a substring then
        {{GPUCompilationMessage/length}} must be 0.
</dl>

Note: {{GPUCompilationMessage}}.{{GPUCompilationMessage/lineNum}} and
{{GPUCompilationMessage}}.{{GPUCompilationMessage/linePos}} are one-based since the most common use
for them is expected to be printing human readable messages that can be correlated with the line and
column numbers shown in many text editors.

Note: {{GPUCompilationMessage}}.{{GPUCompilationMessage/offset}} and
{{GPUCompilationMessage}}.{{GPUCompilationMessage/length}} are appropriate to pass to
`substr()` in order to retrieve the substring of the shader {{GPUShaderModuleDescriptor/code}} the
{{GPUCompilationMessage/message}} corresponds to.

<dl dfn-type=method dfn-for=GPUShaderModule>
    : <dfn>compilationInfo()</dfn>
    ::
        Returns any messages generated during the {{GPUShaderModule}}'s compilation.

        The locations, order, and and contents of messages are implementation-defined.
        In particular, messages may not be ordered by {{GPUCompilationMessage/lineNum}}.

        <div algorithm=GPUShaderModule.compilationInfo>
            **Called on:** {{GPUShaderModule}} this.

            **Returns:** {{Promise}}&lt;{{GPUCompilationInfo}}&gt;

            Issue: Describe {{GPUShaderModule/compilationInfo()}} algorithm steps.
        </div>
</dl>

# Pipelines # {#pipelines}

A <dfn dfn>pipeline</dfn>, be it {{GPUComputePipeline}} or {{GPURenderPipeline}},
represents the complete function done by a combination of the GPU hardware, the driver,
and the user agent, that process the input data in the shape of bindings and vertex buffers,
and produces some output, like the colors in the output render targets.

Structurally, the [=pipeline=] consists of a sequence of programmable stages (shaders)
and fixed-function states, such as the blending modes.

Note: Internally, depending on the target platform,
the driver may convert some of the fixed-function states into shader code,
and link it together with the shaders provided by the user.
This linking is one of the reason the object is created as a whole.

This combination state is created as a single object
(by {{GPUDevice/createComputePipeline(descriptor)|GPUDevice.createComputePipeline()}} or {{GPUDevice/createRenderPipeline(descriptor)|GPUDevice.createRenderPipeline()}}),
and switched as one
(by {{GPUComputePassEncoder/setPipeline(pipeline)|GPUComputePassEncoder.setPipeline}} or {{GPURenderEncoderBase/setPipeline(pipeline)|GPURenderEncoderBase.setPipeline}} correspondingly).

## Base pipelines ## {#pipeline-base}

<script type=idl>
dictionary GPUPipelineDescriptorBase : GPUObjectDescriptorBase {
    GPUPipelineLayout layout;
};

interface mixin GPUPipelineBase {
    GPUBindGroupLayout getBindGroupLayout(unsigned long index);
};
</script>

{{GPUPipelineBase}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUPipelineBase">
    : <dfn>\[[layout]]</dfn> of type `GPUPipelineLayout`.
    ::
        The definition of the layout of resources which can be used with `this`.
</dl>

{{GPUPipelineBase}} has the following methods:

<dl dfn-type=method dfn-for=GPUPipelineBase>
    : <dfn>getBindGroupLayout(index)</dfn>
    ::
        Gets a {{GPUBindGroupLayout}} that is compatible with the {{GPUPipelineBase}}'s
        {{GPUBindGroupLayout}} at `index`.

        <div algorithm=GPUPipelineBase.getBindGroupLayout>
            **Called on:** {{GPUPipelineBase}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUPipelineBase/getBindGroupLayout(index)">
                |index|: Index into the pipeline layout's {{GPUPipelineLayout/[[bindGroupLayouts]]}}
                    sequence.
            </pre>

            **Returns:** {{GPUBindGroupLayout}}

            1. If |index| &ge;
                |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}:
                1. Throw a {{RangeError}}.

            1. If |this| is not [=valid=]:
                1. Return a new error {{GPUBindGroupLayout}}.

            1. Return a new {{GPUBindGroupLayout}} object that references the same internal object as
                |this|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|index|].

            Issue: Specify this more properly once we have internal objects for {{GPUBindGroupLayout}}.
                Alternatively only spec is as a new internal objects that's [=group-equivalent=]

            Note: Only returning new {{GPUBindGroupLayout}} objects ensures no synchronization is necessary
                between the [=Content timeline=] and the [=Device timeline=].
        </div>
</dl>

### Default pipeline layout ### {#default-pipeline-layout}

A {{GPUPipelineBase}} object that was created without a {{GPUPipelineDescriptorBase/layout}}
has a default layout created and used instead.

<div algorithm="default pipeline layout creation">

To create a <dfn abstract-op>default pipeline layout</dfn> for {{GPUPipelineBase}} |pipeline|,
run the following steps:

    1. Let |groupDescs| be a sequence of |device|.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}
        new {{GPUBindGroupLayoutDescriptor}} objects.
    1. For each |groupDesc| in |groupDescs|:

        1. Set |groupDesc|.{{GPUBindGroupLayoutDescriptor/entries}} to an empty sequence.

    1. For each {{GPUProgrammableStage}} |stageDesc| in the descriptor used to create |pipeline|:

        1. Let |stageInfo| be the "reflection information" for |stageDesc|.

            Issue: Define the reflection information concept so that this spec can interface with the WGSL
                spec and get information what the interface is for a {{GPUShaderModule}} for a specific
                entrypoint.

        1. Let |shaderStage| be the {{GPUShaderStageFlags}} for |stageDesc|.{{GPUProgrammableStage/entryPoint}}
            in |stageDesc|.{{GPUProgrammableStage/module}}.
        1. For each resource |resource| in |stageInfo|'s resource interface:

            1. Let |group| be |resource|'s "group" decoration.
            1. Let |binding| be |resource|'s "binding" decoration.
            1. Let |entry| be a new {{GPUBindGroupLayoutEntry}}.
            1. Set |entry|.{{GPUBindGroupLayoutEntry/binding}} to |binding|.
            1. Set |entry|.{{GPUBindGroupLayoutEntry/visibility}} to |shaderStage|.
            1. If |resource| is for a sampler binding:

                1. Let |samplerLayout| be a new {{GPUSamplerBindingLayout}}.
                1. Set |entry|.{{GPUBindGroupLayoutEntry/sampler}} to |samplerLayout|.

            1. If |resource| is for a comparison sampler binding:

                1. Let |samplerLayout| be a new {{GPUSamplerBindingLayout}}.
                1. Set |samplerLayout|.{{GPUSamplerBindingLayout/type}} to {{GPUSamplerBindingType/"comparison"}}.
                1. Set |entry|.{{GPUBindGroupLayoutEntry/sampler}} to |samplerLayout|.

            1. If |resource| is for a buffer binding:

                1. Let |bufferLayout| be a new {{GPUBufferBindingLayout}}.

                1. Set |bufferLayout|.{{GPUBufferBindingLayout/minBindingSize}} to |resource|'s minimum buffer binding size.

                    Issue: link to a definition for "minimum buffer binding size" in the "reflection information".

                1. If |resource| is for a read-only storage buffer:

                    1. Set |bufferLayout|.{{GPUBufferBindingLayout/type}} to {{GPUBufferBindingType/"read-only-storage"}}.

                1. If |resource| is for a storage buffer:

                    1. Set |bufferLayout|.{{GPUBufferBindingLayout/type}} to {{GPUBufferBindingType/"storage"}}.

                1. Set |entry|.{{GPUBindGroupLayoutEntry/buffer}} to |bufferLayout|.

            1. If |resource| is for a sampled texture binding:

                1. Let |textureLayout| be a new {{GPUTextureBindingLayout}}.

                1. If |resource| is a depth texture binding:
                    - Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to {{GPUTextureSampleType/"depth"}}

                    Else if the sampled type of |resource| is:

                    -
                        <dl class=switch>
                            : `f32` and |resource| is statically used with a textureSample* builtin in the shader
                            :: Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to {{GPUTextureSampleType/"float"}}
                            : `f32` otherwise
                            :: Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to {{GPUTextureSampleType/"unfilterable-float"}}
                            : `i32`
                            :: Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to {{GPUTextureSampleType/"sint"}}
                            : `u32`
                            :: Set |textureLayout|.{{GPUTextureBindingLayout/sampleType}} to {{GPUTextureSampleType/"uint"}}
                        </dl>

                1. Set |textureLayout|.{{GPUTextureBindingLayout/viewDimension}} to |resource|'s dimension.
                1. If |resource| is for a multisampled texture:

                    1. Set |textureLayout|.{{GPUTextureBindingLayout/multisampled}} to `true`.

                1. Set |entry|.{{GPUBindGroupLayoutEntry/texture}} to |textureLayout|.

            1. If |resource| is for a storage texture binding:

                1. Let |storageTextureLayout| be a new {{GPUStorageTextureBindingLayout}}.
                1. Set |storageTextureLayout|.{{GPUStorageTextureBindingLayout/format}} to |resource|'s format.
                1. Set |storageTextureLayout|.{{GPUStorageTextureBindingLayout/viewDimension}} to |resource|'s dimension.

                1. If |resource| is for a write-only storage texture:

                    1. Set |storageTextureLayout|.{{GPUStorageTextureBindingLayout/access}} to {{GPUStorageTextureAccess/"write-only"}}.

                1. Set |entry|.{{GPUBindGroupLayoutEntry/storageTexture}} to |storageTextureLayout|.

            1. If |groupDescs|[|group|] has an entry |previousEntry| with {{GPUBindGroupLayoutEntry/binding}} equal to |binding|:

                1. If |entry| has different {{GPUBindGroupLayoutEntry/visibility}} than |previousEntry|:

                    1. Add the bits set in |entry|.{{GPUBindGroupLayoutEntry/visibility}} into |previousEntry|.{{GPUBindGroupLayoutEntry/visibility}}

                1. If |resource| is for a buffer binding and |entry| has greater
                    {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                    than |previousEntry|:

                    1. Set |previousEntry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        to |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}.

                1. If |resource| is a sampled texture binding and |entry| has different
                    {{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} than |previousEntry|
                    and both |entry| and |previousEntry| have {{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}}
                    of either {{GPUTextureSampleType/"float"}} or {{GPUTextureSampleType/"unfilterable-float"}}:
                    1. Set |previousEntry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} to
                        {{GPUTextureSampleType/"float"}}.

                1. If any other property is unequal between |entry| and |previousEntry|:

                    1. Return `null` (which will cause the creation of the pipeline to fail).

            1. Else

                1. Append |entry| to |groupDescs|[|group|].

    1. Let |groupLayouts| be a new sequence.
    1. For each |groupDesc| in |groupDescs|:

        1. Let |bindGroupLayout| be the result of calling |device|.{{GPUDevice/createBindGroupLayout()}}(|groupDesc|).
        1. Set |bindGroupLayout|.{{GPUBindGroupLayout/[[exclusivePipeline]]}} to |pipeline|.
        1. Append |bindGroupLayout| to |groupLayouts|.

    1. Let |desc| be a new {{GPUPipelineLayoutDescriptor}}.
    1. Set |desc|.{{GPUPipelineLayoutDescriptor/bindGroupLayouts}} to |groupLayouts|.
    1. Return |device|.{{GPUDevice/createPipelineLayout()}}(|desc|).

    Issue: This fills the pipeline layout with empty bindgroups. Revisit once the behavior of empty bindgroups is specified.

</div>

### <dfn dictionary>GPUProgrammableStage</dfn> ### {#GPUProgrammableStage}

A {{GPUProgrammableStage}} describes the entry point in the user-provided
{{GPUShaderModule}} that controls one of the programmable stages of a [=pipeline=].

<script type=idl>
dictionary GPUProgrammableStage {
    required GPUShaderModule module;
    required USVString entryPoint;
    record<USVString, GPUPipelineConstantValue> constants;
};

typedef double GPUPipelineConstantValue; // May represent WGSL's bool, f32, i32, u32.
</script>

<dl dfn-for=GPUProgrammableStage dfn-type=dict-member>
    : <dfn>constants</dfn>
    ::
        Specifies the values of [=pipeline-overridable=] constants in the shader module
        {{GPUProgrammableStage/module}}.

        Each such [=pipeline-overridable=] constant is uniquely identified by a single
        [=pipeline-overridable constant identifier string=] (representing the numeric ID of the
        constant, if one is specified, and otherwise the constant's identifier name).

        The key of each key-value pair must equal the identifier string of one such constant.
        When the pipeline is executed, that constant will have the specified value.

        Values are specified as <dfn typedef for=>GPUPipelineConstantValue</dfn>, which is a
        `double` which is converted to the WGSL data type of the corresponding pipeline-overridable
        constant (`bool`, `i32`, `u32`, or `f32`) via [=converted to an IDL value|an IDL value=]
        ({{boolean}}, {{long}}, {{unsigned long}}, or {{float}}).

        <div class=example>
            Pipeline-overridable constants defined in WGSL:

            <pre highlight=rust>
                [[override(0)]]    let has_point_light: bool = true; // Algorithmic control.
                [[override(1200)]] let specular_param: f32 = 2.3;    // Numeric control.
                [[override(1300)]] let gain: f32;                    // Must be overridden.
                [[override]]       let width: f32 = 0.0;             // Specifed at the API level
                                                                     //   using the name "width".
                [[override]]       let depth: f32;                   // Specifed at the API level
                                                                     //   using the name "depth".
                                                                     //   Must be overridden.
            </pre>

            Corresponding JavaScript code, providing only the overrides which are required
            (have no defaults):

            <pre highlight=js>
                {
                    // ...
                    constants: {
                        1300: 2.0,  // "gain"
                        depth: -1,  // "depth"
                    }
                }
            </pre>

            Corresponding JavaScript code, overriding all constants:

            <pre highlight=js>
                {
                    // ...
                    constants: {
                        0: false,   // "has_point_light"
                        1200: 3.0,  // "specular_param"
                        1300: 2.0,  // "gain"
                        width: 20,  // "width"
                        depth: -1,  // "depth"
                    }
                }
            </pre>
        </div>
</dl>

<div algorithm>
    <dfn abstract-op>validating GPUProgrammableStage</dfn>(stage, descriptor, layout)

    **Arguments:**
    - {{GPUShaderStage}} |stage|
    - {{GPUProgrammableStage}} |descriptor|
    - {{GPUPipelineLayout}} |layout|

    Return `true` if all of the following conditions are met:

    - |descriptor|.{{GPUProgrammableStage/module}} must be a [=valid=] {{GPUShaderModule}}.
    - |descriptor|.{{GPUProgrammableStage/module}} must contain
        an entry point, for shader stage |stage|,
        named |descriptor|.{{GPUProgrammableStage/entryPoint}}.
    - For each |binding| that is [=statically used=] by the shader entry point:
        - [$validating shader binding$](|binding|, |layout|) must return `true`.
    - For each texture sampling shader call that is [=statically used=] by the entry point:
        1. Let |texture| be the {{GPUBindGroupLayoutEntry}} corresponding to the sampled texture in the call.
        1. Let |sampler| be the {{GPUBindGroupLayoutEntry}} corresponding to the used sampler in the call.
        1. If |sampler|.{{GPUSamplerBindingLayout/type}} is {{GPUSamplerBindingType/"filtering"}},
            then |texture|.{{GPUTextureBindingLayout/sampleType}} must not be
            {{GPUTextureSampleType/"unfilterable-float"}}.
    - For each |key| in [=map/get the keys|the keys=] of
        |descriptor|.{{GPUProgrammableStage/constants}}:
        - |key| must equal the [=pipeline-overridable constant identifier string=] of
            some [=pipeline-overridable=] constant defined in the shader module
            |descriptor|.{{GPUProgrammableStage/module}}.
    - For each [=pipeline-overridable constant identifier string=] |key| which is
        [=statically accessed=] by the shader entry point:
        - If the pipeline-overridable constant identified by |key|
            [=pipeline-overridable constant has a default value|does not have a default value=],
            |descriptor|.{{GPUProgrammableStage/constants}} must [=map/contain=] |key|.

    A return value of `false` corresponds to a [=pipeline-creation error=].
</div>

<div algorithm>
    <dfn abstract-op>validating shader binding</dfn>(binding, layout)

    **Arguments:**
        - shader binding declaration |variable|, a module-scope variable declaration reflected from a shader module
        - {{GPUPipelineLayout}} |layout|

    Let |bindGroup| be the bind group index, and |bindIndex| be the binding index,
    of the shader binding declaration |variable|.

    Return `true` if all of the following conditions are satisfied:

        - |layout|.{{GPUPipelineLayout/[[bindGroupLayouts]]}}[|bindGroup|] contains
            a {{GPUBindGroupLayoutEntry}} |entry| whose |entry|.{{GPUBindGroupLayoutEntry/binding}} == |bindIndex|.
        - If the defined [=binding member=] for |entry| is:
            <dl class=switch>
                : {{GPUBindGroupLayoutEntry/buffer}}
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/type}} is:
                    <dl class=switch>
                        : {{GPUBufferBindingType/"uniform"}}
                        :: |variable| is declared with the storage class `uniform`.
                        : {{GPUBufferBindingType/"storage"}}
                        :: |variable| is declared with the storage class `storage` and access mode `read_write`.
                        : {{GPUBufferBindingType/"read-only-storage"}}
                        :: |variable| is declared with the storage class `storage` and access mode `read`.
                    </dl>
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}} is not `0`:
                    - If the last field of the corresponding structure defined in the shader has an unbounded array type,
                        then the value of |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        must be greater than or equal to the byte offset of that field plus the stride of the unbounded array.
                    - If the corresponding shader structure doesn't end with an unbounded array type,
                        then the value of |entry|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/minBindingSize}}
                        must be greater than or equal to the size of the structure.

                : {{GPUBindGroupLayoutEntry/sampler}}
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/sampler}}.{{GPUSamplerBindingLayout/type}} is:
                    <dl class=switch>
                        : {{GPUSamplerBindingType/"filtering"}} or {{GPUSamplerBindingType/"non-filtering"}}
                        :: |variable| has type `sampler`.
                        : {{GPUSamplerBindingType/"comparison"}}
                        :: |variable| has type `comparison_sampler`.
                    </dl>

                : {{GPUBindGroupLayoutEntry/texture}}
                ::
                    If, and only if,
                    |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/multisampled}}
                    is `true`, |variable| has type `texture_multisampled_2d<T>` or `texture_depth_multisampled_2d<T>`.
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} is:
                    <dl class=switch>
                        : {{GPUTextureSampleType/"float"}}, {{GPUTextureSampleType/"unfilterable-float"}},
                            {{GPUTextureSampleType/"sint"}} or {{GPUTextureSampleType/"uint"}}
                        ::
                            |variable| has type `texture_1d<T>`, `texture_2d<T>`, `texture_2d_array<T>`,
                            `texture_cube<T>`, `texture_cube_array<T>`, `texture_3d<T>`, or
                            `texture_multisampled_2d<T>`.
                        ::
                            If |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/sampleType}} is:
                            <dl class=switch>
                                : {{GPUTextureSampleType/"float"}} or {{GPUTextureSampleType/"unfilterable-float"}}
                                :: The sampled type `T` is `f32`.
                                : {{GPUTextureSampleType/"sint"}}
                                :: The sampled type `T` is `i32`.
                                : {{GPUTextureSampleType/"uint"}}
                                :: The sampled type `T` is `u32`.
                            </dl>

                        : {{GPUTextureSampleType/"depth"}}
                        ::
                            |variable| has type `texture_depth_2d`, `texture_depth_2d_array`,
                            `texture_depth_cube`, `texture_depth_cube_array`, or `texture_depth_multisampled_2d`.
                    </dl>
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/texture}}.{{GPUTextureBindingLayout/viewDimension}} is:
                    <dl class=switch>
                        : {{GPUTextureViewDimension/"1d"}}
                        :: |variable| has type `texture_1d<T>`.
                        : {{GPUTextureViewDimension/"2d"}}
                        :: |variable| has type `texture_2d<T>` or `texture_multisampled_2d<T>`.
                        : {{GPUTextureViewDimension/"2d-array"}}
                        :: |variable| has type `texture_2d_array<T>`.
                        : {{GPUTextureViewDimension/"cube"}}
                        :: |variable| has type `texture_cube<T>`.
                        : {{GPUTextureViewDimension/"cube-array"}}
                        :: |variable| has type `texture_cube_array<T>`.
                        : {{GPUTextureViewDimension/"3d"}}
                        :: |variable| has type `texture_3d<T>`.
                    </dl>

                : {{GPUBindGroupLayoutEntry/storageTexture}}
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/viewDimension}} is:
                    <dl class=switch>
                        : {{GPUTextureViewDimension/"1d"}}
                        :: |variable| has type `texture_storage_1d<T, A>`.
                        : {{GPUTextureViewDimension/"2d"}}
                        :: |variable| has type `texture_storage_2d<T, A>`.
                        : {{GPUTextureViewDimension/"2d-array"}}
                        :: |variable| has type `texture_storage_2d_array<T, A>`.
                        : {{GPUTextureViewDimension/"3d"}}
                        :: |variable| has type `texture_storage_3d<T, A>`.
                    </dl>
                ::
                    If |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/access}} is:
                    <dl class=switch>
                        : {{GPUStorageTextureAccess/"write-only"}}
                        :: The access mode `A` is `write`.
                    </dl>
                ::
                    The texel format `T` equals
                    |entry|.{{GPUBindGroupLayoutEntry/storageTexture}}.{{GPUStorageTextureBindingLayout/format}}.
            </dl>
</div>

A resource binding is considered to be <dfn dfn>statically used</dfn> by a shader entry point
if and only if it's reachable by the control flow graph of the shader module,
starting at the entry point.

## <dfn interface>GPUComputePipeline</dfn> ## {#compute-pipeline}

A {{GPUComputePipeline}} is a kind of [=pipeline=] that controls the compute shader stage,
and can be used in {{GPUComputePassEncoder}}.

Compute inputs and outputs are all contained in the bindings,
according to the given {{GPUPipelineLayout}}.
The outputs correspond to {{GPUBindGroupLayoutEntry/buffer}} bindings with a type of {{GPUBufferBindingType/"storage"}}
and {{GPUBindGroupLayoutEntry/storageTexture}} bindings with a type of {{GPUStorageTextureAccess/"write-only"}}.

Stages of a compute [=pipeline=]:
  1. Compute shader

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUComputePipeline {
};
GPUComputePipeline includes GPUObjectBase;
GPUComputePipeline includes GPUPipelineBase;
</script>

### Creation ### {#compute-pipeline-creation}

<script type=idl>
dictionary GPUComputePipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStage compute;
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createComputePipeline(descriptor)</dfn>
    ::
        Creates a {{GPUComputePipeline}}.

        <div algorithm=GPUDevice.createComputePipeline>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createComputePipeline(descriptor)">
                |descriptor|: Description of the {{GPUComputePipeline}} to create.
            </pre>

            **Returns:** {{GPUComputePipeline}}

            1. Let |pipeline| be a new valid {{GPUComputePipeline}} object.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |descriptor|.{{GPUPipelineDescriptorBase/layout}} is [$valid to use with$] |this|.
                            - [$validating GPUProgrammableStage$]({{GPUShaderStage/COMPUTE}},
                                |descriptor|.{{GPUComputePipelineDescriptor/compute}},
                                |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}} uses &le;
                                |device|.limits.{{supported limits/maxComputeWorkgroupStorageSize}} bytes of
                                workgroup storage.

                                Issue: Better define using static use, etc.
                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}} uses &le;
                                |device|.limits.{{supported limits/maxComputeInvocationsPerWorkgroup}} per
                                workgroup.

                            - |descriptor|.{{GPUComputePipelineDescriptor/compute}}'s `workgroup_size` attribute
                                has each component &le; the corresponding component in
                                [|device|.limits.{{supported limits/maxComputeWorkgroupSizeX}},
                                |device|.limits.{{supported limits/maxComputeWorkgroupSizeY}},
                                |device|.limits.{{supported limits/maxComputeWorkgroupSizeZ}}].
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |pipeline| [=invalid=].

                    1. If |descriptor|.{{GPUPipelineDescriptorBase/layout}} is `undefined`:
                        1. Set |pipeline|.{{GPUPipelineBase/[[layout]]}} to a new [$default pipeline layout$]
                            for |pipeline|.

                        Otherwise set |pipeline|.{{GPUPipelineBase/[[layout]]}} to |descriptor|.{{GPUPipelineDescriptorBase/layout}}.
                </div>
            1. Return |pipeline|.

        </div>

    : <dfn>createComputePipelineAsync(descriptor)</dfn>
    ::
        Creates a {{GPUComputePipeline}}. The returned {{Promise}} resolves when the created pipeline
        is ready to be used without additional delay.

        If pipeline creation fails, the returned {{Promise}} rejects with an {{OperationError}}.

        Note: Use of this method is preferred whenever possible, as it prevents blocking the
        [=queue timeline=] work on pipeline compilation.

        <div algorithm=GPUDevice.createComputePipelineAsync>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createComputePipelineAsync(descriptor)">
                |descriptor|: Description of the {{GPUComputePipeline}} to create.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPUComputePipeline}}&gt;

            1. Let |promise| be [=a new promise=].
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. Let |pipeline| be a new {{GPUComputePipeline}} created as if
                        |this|.{{GPUDevice/createComputePipeline()}} was called with |descriptor|;

                    1. When |pipeline| is ready to be used, [=resolve=] |promise| with |pipeline|.
                </div>
            1. Return |promise|.
        </div>
</dl>

## <dfn interface>GPURenderPipeline</dfn> ## {#render-pipeline}

A {{GPURenderPipeline}} is a kind of [=pipeline=] that controls the vertex
and fragment shader stages, and can be used in {{GPURenderPassEncoder}}
as well as {{GPURenderBundleEncoder}}.

Render [=pipeline=] inputs are:
  - bindings, according to the given {{GPUPipelineLayout}}
  - vertex and index buffers, described by {{GPUVertexState}}
  - the color attachments, described by {{GPUColorTargetState}}
  - optionally, the depth-stencil attachment, described by {{GPUDepthStencilState}}

Render [=pipeline=] outputs are:
  - {{GPUBindGroupLayoutEntry/buffer}} bindings with a {{GPUBufferBindingLayout/type}} of {{GPUBufferBindingType/"storage"}}
  - {{GPUBindGroupLayoutEntry/storageTexture}} bindings with a {{GPUStorageTextureBindingLayout/access}} of {{GPUStorageTextureAccess/"write-only"}}
  - the color attachments, described by {{GPUColorTargetState}}
  - optionally, depth-stencil attachment, described by {{GPUDepthStencilState}}

A render [=pipeline=] is comprised of the following <dfn dfn>render stages</dfn>:
  1. Vertex fetch, controlled by {{GPUVertexState/buffers|GPUVertexState.buffers}}
  2. Vertex shader, controlled by {{GPUVertexState}}
  3. Primitive assembly, controlled by {{GPUPrimitiveState}}
  4. Rasterization, controlled by {{GPUPrimitiveState}}, {{GPUDepthStencilState}}, and {{GPUMultisampleState}}
  5. Fragment shader, controlled by {{GPUFragmentState}}
  6. Stencil test and operation, controlled by {{GPUDepthStencilState}}
  7. Depth test and write, controlled by {{GPUDepthStencilState}}
  8. Output merging, controlled by {{GPUFragmentState/targets|GPUFragmentState.targets}}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderPipeline {
};
GPURenderPipeline includes GPUObjectBase;
GPURenderPipeline includes GPUPipelineBase;
</script>

{{GPURenderPipeline}} has the following internal slots:

<dl dfn-type=attribute dfn-for=GPURenderPipeline>
    : <dfn>\[[descriptor]]</dfn>, of type {{GPURenderPipelineDescriptor}}
    ::
        The {{GPURenderPipelineDescriptor}} describing this pipeline.

        All optional fields of {{GPURenderPipelineDescriptor}} are defined.
    : <dfn>\[[writesDepth]]</dfn>, of type boolean
    :: True if the pipeline writes to the depth component of the depth/stencil attachment

    : <dfn>\[[writesStencil]]</dfn>, of type boolean
    :: True if the pipeline writes to the stencil component of the depth/stencil attachment
</dl>

### Creation ### {#render-pipeline-creation}

<script type=idl>
dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUVertexState vertex;
    GPUPrimitiveState primitive = {};
    GPUDepthStencilState depthStencil;
    GPUMultisampleState multisample = {};
    GPUFragmentState fragment;
};
</script>

A {{GPURenderPipelineDescriptor}} describes the state of a render [=pipeline=] by
configuring each of the [=render stages=]. See [[#rendering-operations]] for the
details.

- {{GPURenderPipelineDescriptor/vertex}} describes
    the vertex shader entry point of the [=pipeline=] and its input buffer layouts.
- {{GPURenderPipelineDescriptor/primitive}} describes the
    the primitive-related properties of the [=pipeline=].
- {{GPURenderPipelineDescriptor/depthStencil}} describes
    the optional depth-stencil properties, including the testing, operations, and bias.
- {{GPURenderPipelineDescriptor/multisample}} describes
    the multi-sampling properties of the [=pipeline=].
- {{GPURenderPipelineDescriptor/fragment}} describes
    the fragment shader entry point of the [=pipeline=] and its output colors.
    If it's `null`, the [[#no-color-output]] mode is enabled.

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderPipeline(descriptor)</dfn>
    ::
        Creates a {{GPURenderPipeline}}.

        <div algorithm=GPUDevice.createRenderPipeline>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createRenderPipeline(descriptor)">
                |descriptor|: Description of the {{GPURenderPipeline}} to create.
            </pre>

            **Returns:** {{GPURenderPipeline}}

            1. Let |pipeline| be a new valid {{GPURenderPipeline}} object.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |descriptor|.{{GPUPipelineDescriptorBase/layout}} is [$valid to use with$] |this|.
                            - [$validating GPURenderPipelineDescriptor$](|descriptor|, |this|) succeeds.
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Make |pipeline| [=invalid=].

                    1. Set |pipeline|.{{GPURenderPipeline/[[descriptor]]}} to |descriptor|.
                    1. Set |pipeline|.{{GPURenderPipeline/[[writesDepth]]}} to false.
                    1. Set |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} to false.
                    1. Let |depthStencil| be |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}.
                    1. If |depthStencil| is not null:
                        1. Set |pipeline|.{{GPURenderPipeline/[[writesDepth]]}} to |depthStencil|.{{GPUDepthStencilState/depthWriteEnabled}}.
                        1. If |depthStencil|.{{GPUDepthStencilState/stencilWriteMask}} is not 0:
                            1. Let |stencilFront| be |depthStencil|.{{GPUDepthStencilState/stencilFront}}.
                            1. Let |stencilBack| be |depthStencil|.{{GPUDepthStencilState/stencilBack}}.
                            1. Let |cullMode| be |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/cullMode}}.
                            1. If |cullMode| is not {{GPUCullMode/"front"}}, and any of |stencilFront|.{{GPUStencilFaceState/passOp}},
                                |stencilFront|.{{GPUStencilFaceState/depthFailOp}}, or |stencilFront|.{{GPUStencilFaceState/failOp}}
                                is not {{GPUStencilOperation/"keep"}}:
                                1. Set |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} to true.
                            1. If |cullMode| is not {{GPUCullMode/"back"}}, and any of |stencilBack|.{{GPUStencilFaceState/passOp}},
                                |stencilBack|.{{GPUStencilFaceState/depthFailOp}}, or |stencilBack|.{{GPUStencilFaceState/failOp}}
                                is not {{GPUStencilOperation/"keep"}}:
                                1. Set |pipeline|.{{GPURenderPipeline/[[writesStencil]]}} to true.
                    1. If |descriptor|.{{GPUPipelineDescriptorBase/layout}} is `undefined`:
                        1. Set |pipeline|.{{GPUPipelineBase/[[layout]]}} to a new [$default pipeline layout$]
                            for |pipeline|.

                        Otherwise set |pipeline|.{{GPUPipelineBase/[[layout]]}} to |descriptor|.{{GPUPipelineDescriptorBase/layout}}.
                </div>
            1. Return |pipeline|.

            Issue: need description of the render states.
        </div>

    : <dfn>createRenderPipelineAsync(descriptor)</dfn>
    ::
        Creates a {{GPURenderPipeline}}. The returned {{Promise}} resolves when the created pipeline
        is ready to be used without additional delay.

        If pipeline creation fails, the returned {{Promise}} rejects with an {{OperationError}}.

        Note: Use of this method is preferred whenever possible, as it prevents blocking the
        [=queue timeline=] work on pipeline compilation.

        <div algorithm=GPUDevice.createRenderPipelineAsync>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createRenderPipelineAsync(descriptor)">
                |descriptor|: Description of the {{GPURenderPipeline}} to create.
            </pre>

            **Returns:** {{Promise}}&lt;{{GPURenderPipeline}}&gt;

            1. Let |promise| be [=a new promise=].
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. Let |pipeline| be a new {{GPURenderPipeline}} created as if
                        |this|.{{GPUDevice/createRenderPipeline()}} was called with |descriptor|;

                    1. When |pipeline| is ready to be used, [=resolve=] |promise| with |pipeline|.
                </div>
            1. Return |promise|.
        </div>
</dl>

<div algorithm>
    <dfn abstract-op>validating GPURenderPipelineDescriptor</dfn>(descriptor, device)
        **Arguments:**
            - {{GPURenderPipelineDescriptor}} |descriptor|
            - {{GPUDevice}} |device|

        Return `true` if all of the following conditions are satisfied:

            - [$validating GPUProgrammableStage$]({{GPUShaderStage/VERTEX}},
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}},
                |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
            - [$validating GPUVertexState$](|device|, |descriptor|.{{GPURenderPipelineDescriptor/vertex}},
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}}) succeeds.
            - If |descriptor|.{{GPURenderPipelineDescriptor/fragment}} is not `null`:
                - [$validating GPUProgrammableStage$]({{GPUShaderStage/FRAGMENT}},
                    |descriptor|.{{GPURenderPipelineDescriptor/fragment}},
                    |descriptor|.{{GPUPipelineDescriptorBase/layout}}) succeeds.
                - [$validating GPUFragmentState$](|descriptor|.{{GPURenderPipelineDescriptor/fragment}}) succeeds.
                - If the "sample_mask" [=builtin=] is a [=pipeline output=] of |descriptor|.{{GPURenderPipelineDescriptor/fragment}}:
                    - |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/alphaToCoverageEnabled}} is `false`.
            - [$validating GPUPrimitiveState$](|descriptor|.{{GPURenderPipelineDescriptor/primitive}}, |device|.{{device/[[features]]}}) succeeds.
            - if |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}} is not `null`:
                - [$validating GPUDepthStencilState$](|descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}) succeeds.
            - [$validating GPUMultisampleState$](|descriptor|.{{GPURenderPipelineDescriptor/multisample}}) succeeds.
            - For each user-defined output of
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}} there must
                be a user-defined input of
                |descriptor|.{{GPURenderPipelineDescriptor/fragment}} that
                matches the
                [=location=],
                type, and
                [=interpolation=]
                of the output.
            - For each user-defined input of
                |descriptor|.{{GPURenderPipelineDescriptor/fragment}} there
                must be a user-defined output of
                |descriptor|.{{GPURenderPipelineDescriptor/vertex}} that
                [=location=],
                type, and
                [=interpolation=]
                of the input.
            - There is less than |device|.limits.{{supported limits/maxInterStageShaderComponents}}
                components of user-defined outputs for |descriptor|.{{GPURenderPipelineDescriptor/vertex}}.
            - There is less than |device|.limits.{{supported limits/maxInterStageShaderComponents}}
                components of user-defined inputs for |descriptor|.{{GPURenderPipelineDescriptor/fragment}}.
</div>

Issue: should we validate that `cullMode` is none for points and lines?

Issue: define what "compatible" means for render target formats.

Issue: need a proper limit for the maximum number of color targets.

### Primitive State ### {#primitive-state}

<script type=idl>
enum GPUPrimitiveTopology {
    "point-list",
    "line-list",
    "line-strip",
    "triangle-list",
    "triangle-strip",
};
</script>

<script type=idl>
dictionary GPUPrimitiveState {
    GPUPrimitiveTopology topology = "triangle-list";
    GPUIndexFormat stripIndexFormat;
    GPUFrontFace frontFace = "ccw";
    GPUCullMode cullMode = "none";

    // Requires "depth-clip-control" feature.
    boolean unclippedDepth = false;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUPrimitiveState</dfn>(|descriptor|, |features|)
        **Arguments:**
            - {{GPUPrimitiveState}} |descriptor|
            - [=list=]&lt;{{GPUFeatureName}}&gt; |features|

        Return `true` if all of the following conditions are satisfied:
            - If |descriptor|.{{GPUPrimitiveState/topology}} is not
                {{GPUPrimitiveTopology/"line-strip"}} or {{GPUPrimitiveTopology/"triangle-strip"}}:
                - |descriptor|.{{GPUPrimitiveState/stripIndexFormat}} is `undefined`
            - If |descriptor|.{{GPUPrimitiveState/unclippedDepth}} is `true`:
                - |features| must [=list/contain=] {{GPUFeatureName/"depth-clip-control"}}.
</div>

<script type=idl>
enum GPUFrontFace {
    "ccw",
    "cw",
};
</script>

<script type=idl>
enum GPUCullMode {
    "none",
    "front",
    "back",
};
</script>

### Multisample State ### {#multisample-state}

<script type=idl>
dictionary GPUMultisampleState {
    GPUSize32 count = 1;
    GPUSampleMask mask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUMultisampleState</dfn>(|descriptor|)
        **Arguments:**
            - {{GPUMultisampleState}} |descriptor|

        Return `true` if all of the following conditions are satisfied:
            - If |descriptor|.{{GPUMultisampleState/alphaToCoverageEnabled}} is `true`:
                - |descriptor|.{{GPUMultisampleState/count}} is greater than 1.
</div>

### Fragment State ### {#fragment-state}

<script type=idl>
dictionary GPUFragmentState : GPUProgrammableStage {
    required sequence<GPUColorTargetState> targets;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUFragmentState</dfn>(|descriptor|)
        Return `true` if all of the following requirements are met:

        - |descriptor|.{{GPUFragmentState/targets}}.length must be &le; 8.
        - For each |colorState| layout descriptor in the list |descriptor|.{{GPUFragmentState/targets}}:
            - |colorState|.{{GPUColorTargetState/format}} must be listed in [[#plain-color-formats]]
                with {{GPUTextureUsage/RENDER_ATTACHMENT}} capability.
            - If |colorState|.{{GPUColorTargetState/blend}} is not `undefined`:
                - The |colorState|.{{GPUColorTargetState/format}} must be filterable
                    according to the [[#plain-color-formats]] table.
                - |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/color}}
                    must be a [=valid GPUBlendComponent=].
                - |colorState|.{{GPUColorTargetState/blend}}.{{GPUBlendState/alpha}}
                    must be a [=valid GPUBlendComponent=].
            - |colorState|.{{GPUColorTargetState/writeMask}} must be &lt; 16.
            - If |descriptor|.{{GPUProgrammableStage/entryPoint}} has a [=pipeline output=] value
                with [=location=] attribute equal to the index of the |colorState|
                in the |descriptor|.{{GPUFragmentState/targets}} list:
                - The [=pipeline output=] type must be compatible with |colorState|.{{GPUColorTargetState/format}}.

                Otherwise:
                - |colorState|.{{GPUColorTargetState/writeMask}} must be 0.
</div>

<div algorithm>
    |component| is a <dfn>valid GPUBlendComponent</dfn> if it meets the following requirements:

    - If |component|.{{GPUBlendComponent/operation}} is
        {{GPUBlendOperation/"min"}} or {{GPUBlendOperation/"max"}}:
        - |component|.{{GPUBlendComponent/srcFactor}} and
            |component|.{{GPUBlendComponent/dstFactor}} must both be {{GPUBlendFactor/"one"}}.
</div>

Issue: define the area of reach for "statically used" things of `GPUProgrammableStage`

### Color Target State ### {#color-target-state}

<script type=idl>
dictionary GPUColorTargetState {
    required GPUTextureFormat format;

    GPUBlendState blend;
    GPUColorWriteFlags writeMask = 0xF;  // GPUColorWrite.ALL
};
</script>

<script type=idl>
dictionary GPUBlendState {
    required GPUBlendComponent color;
    required GPUBlendComponent alpha;
};
</script>

<script type=idl>
typedef [EnforceRange] unsigned long GPUColorWriteFlags;
[Exposed=(Window, DedicatedWorker)]
namespace GPUColorWrite {
    const GPUFlagsConstant RED   = 0x1;
    const GPUFlagsConstant GREEN = 0x2;
    const GPUFlagsConstant BLUE  = 0x4;
    const GPUFlagsConstant ALPHA = 0x8;
    const GPUFlagsConstant ALL   = 0xF;
};
</script>

#### Blend State #### {#blend-state}

<script type=idl>
dictionary GPUBlendComponent {
    GPUBlendOperation operation = "add";
    GPUBlendFactor srcFactor = "one";
    GPUBlendFactor dstFactor = "zero";
};
</script>

<script type=idl>
enum GPUBlendFactor {
    "zero",
    "one",
    "src",
    "one-minus-src",
    "src-alpha",
    "one-minus-src-alpha",
    "dst",
    "one-minus-dst",
    "dst-alpha",
    "one-minus-dst-alpha",
    "src-alpha-saturated",
    "constant",
    "one-minus-constant",
};
</script>

<script type=idl>
enum GPUBlendOperation {
    "add",
    "subtract",
    "reverse-subtract",
    "min",
    "max",
};
</script>

### Depth/Stencil State ### {#depth-stencil-state}

<script type=idl>
dictionary GPUDepthStencilState {
    required GPUTextureFormat format;

    boolean depthWriteEnabled = false;
    GPUCompareFunction depthCompare = "always";

    GPUStencilFaceState stencilFront = {};
    GPUStencilFaceState stencilBack = {};

    GPUStencilValue stencilReadMask = 0xFFFFFFFF;
    GPUStencilValue stencilWriteMask = 0xFFFFFFFF;

    GPUDepthBias depthBias = 0;
    float depthBiasSlopeScale = 0;
    float depthBiasClamp = 0;
};
</script>

<script type=idl>
dictionary GPUStencilFaceState {
    GPUCompareFunction compare = "always";
    GPUStencilOperation failOp = "keep";
    GPUStencilOperation depthFailOp = "keep";
    GPUStencilOperation passOp = "keep";
};
</script>

<script type=idl>
enum GPUStencilOperation {
    "keep",
    "zero",
    "replace",
    "invert",
    "increment-clamp",
    "decrement-clamp",
    "increment-wrap",
    "decrement-wrap",
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUDepthStencilState</dfn>(descriptor)
    **Arguments:**
        - {{GPUDepthStencilState}} |descriptor|

    Return `true`, if and only if, all of the following conditions are satisfied:

        - |descriptor|.{{GPUDepthStencilState/format}} is a [=depth-or-stencil format=].
        - if |descriptor|.{{GPUDepthStencilState/depthWriteEnabled}} is `true` or
            |descriptor|.{{GPUDepthStencilState/depthCompare}} is not {{GPUCompareFunction/"always"}}:
            - |descriptor|.{{GPUDepthStencilState/format}} must have a depth component.
        - if |descriptor|.{{GPUDepthStencilState/stencilFront}} or
            |descriptor|.{{GPUDepthStencilState/stencilBack}} are not default values:
            - |descriptor|.{{GPUDepthStencilState/format}} must have a stencil component.

    Issue: how can this algorithm support depth/stencil formats that are added in extensions?
</div>

### Vertex State ### {#vertex-state}

<script type=idl>
enum GPUIndexFormat {
    "uint16",
    "uint32",
};
</script>

The index format determines both the data type of index values in a buffer and, when used with
strip primitive topologies ({{GPUPrimitiveTopology/"line-strip"}} or
{{GPUPrimitiveTopology/"triangle-strip"}}) also specifies the primitive restart value. The
<dfn dfn>primitive restart value</dfn> indicates which index value indicates that a new primitive
should be started rather than continuing to construct the triangle strip with the prior indexed
vertices.

{{GPUPrimitiveState}}s that specify a strip primitive topology must specify a
{{GPUPrimitiveState/stripIndexFormat}} if they are used for indexed draws
so that the [=primitive restart value=] that will be used is known at pipeline
creation time. {{GPUPrimitiveState}}s that specify a list primitive
topology will use the index format passed to {{GPURenderEncoderBase/setIndexBuffer()}}
when doing indexed rendering.

<table class="data">
  <thead>
    <tr>
      <th>Index format</th>
      <th>Byte size</th>
      <th>Primitive restart value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>{{GPUIndexFormat/"uint16"}}</td>
      <td>2</td>
      <td>0xFFFF</td>
    </tr>
    <tr>
      <td>{{GPUIndexFormat/"uint32"}}</td>
      <td>4</td>
      <td>0xFFFFFFFF</td>
    </tr>
  </tbody>
</table>

#### Vertex Formats #### {#vertex-formats}

The name of the format specifies the order of components, bits per component,
and <dfn dfn>vertex data type</dfn> for the component.

  * `unorm` = unsigned normalized
  * `snorm` = signed normalized
  * `uint` = unsigned int
  * `sint` = signed int
  * `float` = floating point

<script type=idl>
enum GPUVertexFormat {
    "uint8x2",
    "uint8x4",
    "sint8x2",
    "sint8x4",
    "unorm8x2",
    "unorm8x4",
    "snorm8x2",
    "snorm8x4",
    "uint16x2",
    "uint16x4",
    "sint16x2",
    "sint16x4",
    "unorm16x2",
    "unorm16x4",
    "snorm16x2",
    "snorm16x4",
    "float16x2",
    "float16x4",
    "float32",
    "float32x2",
    "float32x3",
    "float32x4",
    "uint32",
    "uint32x2",
    "uint32x3",
    "uint32x4",
    "sint32",
    "sint32x2",
    "sint32x3",
    "sint32x4",
};
</script>

The multi-component formats specify the number of components after "x".
As such, {{GPUVertexFormat/"sint32x3"}} denotes a 3-component vector of `i32` values in the shader.

<script type=idl>
enum GPUVertexStepMode {
    "vertex",
    "instance",
};
</script>

The step mode configures how an address for vertex buffer data is computed, based on the
current vertex or instance index:
<dl class="switch">
    : {{GPUVertexStepMode/"vertex"}}
    :: The address is advanced by {{GPUVertexBufferLayout/arrayStride}} for each vertex,
        and reset between instances.
    : {{GPUVertexStepMode/"instance"}}
    :: The address is advanced by {{GPUVertexBufferLayout/arrayStride}} for each instance.
</dl>

<script type=idl>
dictionary GPUVertexState : GPUProgrammableStage {
    sequence<GPUVertexBufferLayout?> buffers = [];
};
</script>

A <dfn dfn>vertex buffer</dfn> is, conceptually, a view into buffer memory as an *array of structures*.
{{GPUVertexBufferLayout/arrayStride}} is the stride, in bytes, between *elements* of that array.
Each element of a vertex buffer is like a *structure* with a memory layout defined by its
{{GPUVertexBufferLayout/attributes}}, which describe the *members* of the structure.

Each {{GPUVertexAttribute}} describes its
{{GPUVertexAttribute/format}} and its
{{GPUVertexAttribute/offset}}, in bytes, within the structure.

Each attribute appears as a separate input in a vertex shader, each bound by a numeric *location*,
which is specified by {{GPUVertexAttribute/shaderLocation}}.
Every location must be unique within the {{GPUVertexState}}.

<script type=idl>
dictionary GPUVertexBufferLayout {
    required GPUSize64 arrayStride;
    GPUVertexStepMode stepMode = "vertex";
    required sequence<GPUVertexAttribute> attributes;
};
</script>

<script type=idl>
dictionary GPUVertexAttribute {
    required GPUVertexFormat format;
    required GPUSize64 offset;

    required GPUIndex32 shaderLocation;
};
</script>

<div algorithm>
    <dfn abstract-op>validating GPUVertexBufferLayout</dfn>(device, descriptor, vertexStage)
    **Arguments:**
        - {{GPUDevice}} |device|
        - {{GPUVertexBufferLayout}} |descriptor|
        - {{GPUProgrammableStage}} |vertexStage|

    Return `true`, if and only if, all of the following conditions are satisfied:

        - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} &le;
            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}.
        - |descriptor|.{{GPUVertexBufferLayout/arrayStride}} is a multiple of 4.
        - For each attribute |attrib| in the list |descriptor|.{{GPUVertexBufferLayout/attributes}}:
            - If |descriptor|.{{GPUVertexBufferLayout/arrayStride}} is zero:
                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                    |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBufferArrayStride}}.

                Otherwise:
                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                    |descriptor|.{{GPUVertexBufferLayout/arrayStride}}.
            - |attrib|.{{GPUVertexAttribute/offset}} is a multiple of the minimum of 4 and
                sizeof(|attrib|.{{GPUVertexAttribute/format}}).
            - |attrib|.{{GPUVertexAttribute/shaderLocation}} is less than
                |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}}.
        - For every vertex attribute in the shader reflection of |vertexStage|.{{GPUProgrammableStage/module}}
            that is a [=pipeline input=] of |vertexStage|.{{GPUProgrammableStage/entryPoint}},
            there is a corresponding |attrib| element of |descriptor|.{{GPUVertexBufferLayout/attributes}} for which
            all of the following are true:
            - The shader format is compatible with |attrib|.{{GPUVertexAttribute/format}}'s [=vertex data type=]:
                <dl class="switch">
                    : "unorm", "snorm", or "float"
                    :: shader format must be `f32` or `vecN<f32>`.
                    : "uint"
                    :: shader format must be `u32` or `vecN<u32>`.
                    : "sint"
                    :: shader format must be `i32` or `vecN<i32>`.
                </dl>
            - The shader location is |attrib|.{{GPUVertexAttribute/shaderLocation}}.
</div>

<div algorithm>
    <dfn abstract-op>validating GPUVertexState</dfn>(device, descriptor)
    **Arguments:**
        - {{GPUDevice}} |device|
        - {{GPUVertexState}} |descriptor|

    Return `true`, if and only if, all of the following conditions are satisfied:

        - |descriptor|.{{GPUVertexState/buffers}}.length is less than or equal to
            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}.
        - Each |vertexBuffer| layout descriptor in the list |descriptor|.{{GPUVertexState/buffers}}
            passes [$validating GPUVertexBufferLayout$](|device|, |vertexBuffer|, |descriptor|)
        - The sum of |vertexBuffer|.{{GPUVertexBufferLayout/attributes}}.length,
            over every |vertexBuffer| in |descriptor|.{{GPUVertexState/buffers}},
            is less than or equal to
            |device|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexAttributes}}.
        - Each |attrib| in the union of all {{GPUVertexAttribute}}
            across |descriptor|.{{GPUVertexState/buffers}} has a distinct
            |attrib|.{{GPUVertexAttribute/shaderLocation}} value.
</div>

# Command Buffers # {#command-buffers}

Command buffers are pre-recorded lists of [=GPU commands=] that can be submitted to a {{GPUQueue}}
for execution. Each <dfn dfn>GPU command</dfn> represents a task to be performed on the GPU, such as
setting state, drawing, copying resources, etc.

## <dfn interface>GPUCommandBuffer</dfn> ## {#command-buffer}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCommandBuffer {
};
GPUCommandBuffer includes GPUObjectBase;
</script>

{{GPUCommandBuffer}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUCommandBuffer">
    : <dfn>\[[command_list]]</dfn> of type [=list=]&lt;[=GPU command=]&gt;.
    ::
        A [=list=] of [=GPU commands=] to be executed on the [=Queue timeline=] when this command
        buffer is submitted.
</dl>

### Creation ### {#command-buffer-creation}

<script type=idl>
dictionary GPUCommandBufferDescriptor : GPUObjectDescriptorBase {
};
</script>


# Command Encoding # {#command-encoding}

## <dfn interface>GPUCommandsMixin</dfn> ## {#commands-mixin}

{{GPUCommandsMixin}} defines state common to all interfaces which encode commands.
It has no methods.

<script type=idl>
interface mixin GPUCommandsMixin {
};
</script>

{{GPUCommandsMixin}} adds the following internal slots to interfaces which include it:

<dl dfn-type=attribute dfn-for=GPUCommandsMixin>
    : <dfn>\[[state]]</dfn>, of type [=encoder state=]
    ::
        The current state of the encoder, initially set to "[=encoder state/open=]".

    : <dfn>\[[commands]]</dfn>, of type [=list=]&lt;[=GPU command=]&gt;
    ::
        A [=list=] of [=GPU commands=] to be executed on the [=Queue timeline=] when a
        {{GPUCommandBuffer}} containing these commands is submitted.
</dl>

The <dfn dfn>encoder state</dfn> may be one of the following:

<dl dfn-type=dfn dfn-for="encoder state">
    : "<dfn>open</dfn>"
    ::
        The encoder is available to encode new commands.

    : "<dfn>locked</dfn>"
    ::
        The encoder cannot be used, because it is locked by a child encoder: it is a
        {{GPUCommandEncoder}}, and a {{GPURenderPassEncoder}} or {{GPUComputePassEncoder}} is active.
        The encoder becomes "[=encoder state/open=]" again when the pass is ended.

        Any command issued in this state makes the encoder [=invalid=].

    : "<dfn>ended</dfn>"
    ::
        The encoder has been ended and new commands can no longer be encoded.

        Any command issued in this state generates a {{GPUValidationError}}.
</dl>

<div algorithm>
    To <dfn abstract-op>Prepare the encoder state</dfn> of {{GPUCommandsMixin}} |encoder|:

    If |encoder|.{{GPUCommandsMixin/[[state]]}} is:
    <dl class=switch>
        : "[=encoder state/open=]"
        :: Return `true`.

        : "[=encoder state/locked=]"
        :: Make |encoder| [=invalid=], and return `false`.

        : "[=encoder state/ended=]"
        :: Generate a {{GPUValidationError}} in the current scope, and return `false`.
    </dl>
</div>

## <dfn interface>GPUCommandEncoder</dfn> ## {#command-encoder}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCommandEncoder {
    GPURenderPassEncoder beginRenderPass(GPURenderPassDescriptor descriptor);
    GPUComputePassEncoder beginComputePass(optional GPUComputePassDescriptor descriptor = {});

    undefined copyBufferToBuffer(
        GPUBuffer source,
        GPUSize64 sourceOffset,
        GPUBuffer destination,
        GPUSize64 destinationOffset,
        GPUSize64 size);

    undefined copyBufferToTexture(
        GPUImageCopyBuffer source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined copyTextureToBuffer(
        GPUImageCopyTexture source,
        GPUImageCopyBuffer destination,
        GPUExtent3D copySize);

    undefined copyTextureToTexture(
        GPUImageCopyTexture source,
        GPUImageCopyTexture destination,
        GPUExtent3D copySize);

    undefined clearBuffer(
        GPUBuffer buffer,
        optional GPUSize64 offset = 0,
        optional GPUSize64 size);

    undefined writeTimestamp(GPUQuerySet querySet, GPUSize32 queryIndex);

    undefined resolveQuerySet(
        GPUQuerySet querySet,
        GPUSize32 firstQuery,
        GPUSize32 queryCount,
        GPUBuffer destination,
        GPUSize64 destinationOffset);

    GPUCommandBuffer finish(optional GPUCommandBufferDescriptor descriptor = {});
};
GPUCommandEncoder includes GPUObjectBase;
GPUCommandEncoder includes GPUCommandsMixin;
GPUCommandEncoder includes GPUDebugCommandsMixin;
</script>

### Creation ### {#command-encoder-creation}

<script type=idl>
dictionary GPUCommandEncoderDescriptor : GPUObjectDescriptorBase {
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createCommandEncoder(descriptor)</dfn>
    ::
        Creates a {{GPUCommandEncoder}}.

        <div algorithm=GPUDevice.createCommandEncoder>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createCommandEncoder(descriptor)">
                descriptor: Description of the {{GPUCommandEncoder}} to create.
            </pre>

            **Returns:** {{GPUCommandEncoder}}

            Issue: Describe {{GPUDevice/createCommandEncoder()}} algorithm steps.
        </div>
</dl>

## Pass Encoding ## {#command-encoder-pass-encoding}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>beginRenderPass(descriptor)</dfn>
    ::
        Begins encoding a render pass described by |descriptor|.

        <div algorithm=GPUCommandEncoder.beginRenderPass>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/beginRenderPass(descriptor)">
                |descriptor|: Description of the {{GPURenderPassEncoder}} to create.
            </pre>

            **Returns:** {{GPURenderPassEncoder}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. Let |pass| be a new {{GPURenderPassEncoder}} object.
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |this|.{{GPUCommandsMixin/[[state]]}} is "[=encoder state/open=]".
                        - |descriptor| meets the
                            [$GPURenderPassDescriptor/Valid Usage$] rules.
                        - |descriptor|.{{GPURenderPassDescriptor/timestampWrites}} is empty, or
                            |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} [=list/contain=]s
                            {{GPUFeatureName/"timestamp-query"}}.
                        - For each |timestampWrite| in |descriptor|.{{GPURenderPassDescriptor/timestampWrites}},
                            - |timestampWrite|.{{GPURenderPassTimestampWrite/querySet}} is [$valid to use with$] |this|.
                    </div>
                1. Set |this|.{{GPUCommandsMixin/[[state]]}} to "[=encoder state/locked=]".
                1. For each |colorAttachment| in |descriptor|.{{GPURenderPassDescriptor/colorAttachments}}:
                    1. The [=texture subresource=] seen by |colorAttachment|.{{GPURenderPassColorAttachment/view}}
                        is considered to be used as [=internal usage/attachment=] for the
                        duration of the render pass.
                1. Let |depthStencilAttachment| be |descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}.
                1. If |depthStencilAttachment| is not `null`:
                    1. Let |depthStencilView| be |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}.
                    1. If |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}} and
                        {{GPURenderPassDepthStencilAttachment/stencilReadOnly}} are set:
                        1. The [=texture subresources=] seen by |depthStencilView|
                            are considered to be used as [=internal usage/attachment-read=] for the duration of the render pass.
                    1. Else, the [=texture subresource=] seen by |depthStencilView|
                        is considered to be used as [=internal usage/attachment=] for the duration of the render pass.
                    1. Set |pass|.{{GPURenderEncoderBase/[[depthReadOnly]]}} to |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}}.
                    1. Set |pass|.{{GPURenderEncoderBase/[[stencilReadOnly]]}} to |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}.
                1. Set |pass|.{{GPURenderEncoderBase/[[layout]]}} to [$derive render targets layout from pass$](|descriptor|).
                1. For each |timestampWrite| in |descriptor|.{{GPURenderPassDescriptor/timestampWrites}},
                    1. If |timestampWrite|.{{GPURenderPassTimestampWrite/location}} is {{GPURenderPassTimestampLocation/"beginning"}},
                        [=list/Append=] a [=GPU command=] to
                        |pass|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[commands]]}}
                        that writes the GPU's timestamp value into the |timestampWrite|.{{GPURenderPassTimestampWrite/queryIndex}}th
                        index in |timestampWrite|.{{GPURenderPassTimestampWrite/querySet}}.
                    1. Otherwise, if |timestampWrite|.{{GPURenderPassTimestampWrite/location}} is {{GPURenderPassTimestampLocation/"end"}},
                        [=list/Append=] |timestampWrite| to |pass|.{{GPURenderPassEncoder/[[endTimestampWrites]]}}.
                1. Issue: Enqueue attachment loads/clears.
                1. Return |pass|.
            </div>

            Issue: specify the behavior of read-only depth/stencil
        </div>

    : <dfn>beginComputePass(descriptor)</dfn>
    ::
        Begins encoding a compute pass described by |descriptor|.

        <div algorithm=GPUCommandEncoder.beginComputePass>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/beginComputePass(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPUComputePassEncoder}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |this|.{{GPUCommandsMixin/[[state]]}} is "[=encoder state/open=]".
                        - |descriptor|.{{GPUComputePassDescriptor/timestampWrites}} is empty, or
                            |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} [=list/contain=]s
                            {{GPUFeatureName/"timestamp-query"}}.
                        - For each |timestampWrite| in |descriptor|.{{GPUComputePassDescriptor/timestampWrites}},
                            - |timestampWrite|.{{GPUComputePassTimestampWrite/querySet}} is [$valid to use with$] |this|.
                    </div>
                1. Set |this|.{{GPUCommandsMixin/[[state]]}} to "[=encoder state/locked=]".
                1. Let |pass| be a new {{GPUComputePassEncoder}} object.
                1. For each |timestampWrite| in |descriptor|.{{GPUComputePassDescriptor/timestampWrites}},
                    1. If |timestampWrite|.{{GPUComputePassTimestampWrite/location}} is {{GPUComputePassTimestampLocation/"beginning"}},
                        [=list/Append=] a [=GPU command=] to
                        |pass|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[commands]]}}
                        that writes the GPU's timestamp value into the |timestampWrite|.{{GPUComputePassTimestampWrite/queryIndex}}th
                        index in |timestampWrite|.{{GPUComputePassTimestampWrite/querySet}}.
                    1. Otherwise, if |timestampWrite|.{{GPUComputePassTimestampWrite/location}} is {{GPUComputePassTimestampLocation/"end"}},
                        [=list/Append=] |timestampWrite| to |pass|.{{GPUComputePassEncoder/[[endTimestampWrites]]}}.
                1. Return |pass|.
            </div>
        </div>
</dl>

## Copy Commands ## {#copy-commands}

Issue: these dictionary definitions should be inside the image copies section.

### <dfn dictionary>GPUImageDataLayout</dfn> ### {#gpu-image-data-layout}

<script type=idl>
dictionary GPUImageDataLayout {
    GPUSize64 offset = 0;
    GPUSize32 bytesPerRow;
    GPUSize32 rowsPerImage;
};
</script>

A {{GPUImageDataLayout}} is a layout of <dfn dfn>images</dfn> within some linear memory.
It's used when copying data between a [=texture=] and a [=buffer=], or when scheduling a
write into a [=texture=] from the {{GPUQueue}}.

  - For {{GPUTextureDimension/2d}} textures, data is copied between one or multiple contiguous [=images=] and [=array layers=].
  - For {{GPUTextureDimension/3d}} textures, data is copied between one or multiple contiguous [=images=] and depth [=slices=].

Issue: Define images more precisely. In particular, define them as being comprised of [=texel blocks=].

Operations that copy between byte arrays and textures always work with rows of [=texel blocks=],
which we'll call <dfn dfn>block row</dfn>s. It's not possible to update only a part of a [=texel block=].

[=Texel blocks=] are tightly packed within each [=block row=] in the linear memory layout of an
image copy, with each subsequent texel block immediately following the previous texel block,
with no padding.
This includes [[#copying-depth-stencil|copies]] to/from specific aspects of [=depth-or-stencil format=] textures:
stencil values are tightly packed in an array of bytes;
depth values are tightly packed in an array of the appropriate type ("depth16unorm" or "depth32float").

Issue: Define the exact copy semantics, by reference to common algorithms shared by the copy methods.

<dl dfn-type=dict-member dfn-for=GPUImageDataLayout>
    : <dfn>bytesPerRow</dfn>
    ::
        The stride, in bytes, between the beginning of each [=block row=] and the subsequent [=block row=].

        Required if there are multiple [=block rows=] (i.e. the copy height or depth is more than one block).

    : <dfn>rowsPerImage</dfn>
    ::
        Number of [=block rows=] per single [=image=] of the [=texture=].
        {{GPUImageDataLayout/rowsPerImage}} &times;
        {{GPUImageDataLayout/bytesPerRow}} is the stride, in bytes, between the beginning of each [=image=] of data and the subsequent [=image=].

        Required if there are multiple [=images=] (i.e. the copy depth is more than one).
</dl>

### <dfn dictionary>GPUImageCopyBuffer</dfn> ### {#gpu-image-copy-buffer}

In an [=image copy=] operation, {{GPUImageCopyBuffer}} defines a {{GPUBuffer}} and, together with
the `copySize`, how image data is laid out in the buffer's memory (see {{GPUImageDataLayout}}).

<script type=idl>
dictionary GPUImageCopyBuffer : GPUImageDataLayout {
    required GPUBuffer buffer;
};
</script>

<div algorithm class=validusage>
<dfn abstract-op>validating GPUImageCopyBuffer</dfn>

  **Arguments:**
    - {{GPUImageCopyBuffer}} |imageCopyBuffer|

  **Returns:** {{boolean}}

  Return `true` if and only if all of the following conditions are satisfied:
    - |imageCopyBuffer|.{{GPUImageCopyBuffer/buffer}} must be a [=valid=] {{GPUBuffer}}.
    - |imageCopyBuffer|.{{GPUImageDataLayout/bytesPerRow}} must be a multiple of 256.

</div>

### <dfn dictionary>GPUImageCopyTexture</dfn> ### {#gpu-image-copy-texture}

In an [=image copy=] operation, a {{GPUImageCopyTexture}} defines a {{GPUTexture}} and, together with
the `copySize`, the sub-region of the texture (spanning one or more contiguous
[=texture subresources=] at the same mip-map level).

<script type=idl>
dictionary GPUImageCopyTexture {
    required GPUTexture texture;
    GPUIntegerCoordinate mipLevel = 0;
    GPUOrigin3D origin = {};
    GPUTextureAspect aspect = "all";
};
</script>

<dl dfn-type=dict-member dfn-for=GPUImageCopyTexture>
    : <dfn>texture</dfn>
    ::
        Texture to copy to/from.

    : <dfn>mipLevel</dfn>
    ::
        Mip-map level of the {{GPUImageCopyTexture/texture}} to copy to/from.

    : <dfn>origin</dfn>
    ::
        Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from.
        Together with `copySize`, defines the full copy sub-region.

    : <dfn>aspect</dfn>
    ::
        Defines which aspects of the {{GPUImageCopyTexture/texture}} to copy to/from.
</dl>

<div algorithm class=validusage>
<dfn abstract-op>validating GPUImageCopyTexture</dfn>

  **Arguments:**
    - {{GPUImageCopyTexture}} |imageCopyTexture|
    - {{GPUExtent3D}} |copySize|

  **Returns:** {{boolean}}

  Let:
  - |blockWidth| be the [=texel block width=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.
  - |blockHeight| be the [=texel block height=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.

  Return `true` if and only if all of the following conditions apply:
  - |imageCopyTexture|.{{GPUImageCopyTexture/texture}} must be a [=valid=] {{GPUTexture}}.
  - |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}} must be less than the {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/mipLevelCount}} of
    |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.
  - |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/x=] must be a multiple of |blockWidth|.
  - |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/y=] must be a multiple of |blockHeight|.
  - The [=imageCopyTexture subresource size=] of |imageCopyTexture| is equal to |copySize| if either of
      the following conditions is true:
        - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}} is a depth-stencil format.
        - |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}} is greater than 1.

</div>

Issue(gpuweb/gpuweb#69): Define the copies with {{GPUTextureDimension/1d}} and {{GPUTextureDimension/3d}} textures.

### <dfn dictionary>GPUImageCopyTextureTagged</dfn> ### {#gpu-image-copy-texture-tagged}

WebGPU textures hold raw numeric data, and are not tagged with semantic metadata describing colors.
However, {{GPUQueue/copyExternalImageToTexture()}} copies from sources that describe colors.

A {{GPUImageCopyTextureTagged}} is a {{GPUImageCopyTexture}} which is additionally tagged with
color space/encoding and alpha-premultiplication metadata, so that semantic color data may be
preserved during copies.
This metadata affects only the semantics of the {{GPUQueue/copyExternalImageToTexture()}}
operation, not the semantics of the destination texture.

<script type=idl>
dictionary GPUImageCopyTextureTagged : GPUImageCopyTexture {
    GPUPredefinedColorSpace colorSpace = "srgb";
    boolean premultipliedAlpha = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUImageCopyTextureTagged>
    : <dfn>colorSpace</dfn>
    ::
        Describes the color space and encoding used to encode data into the destination texture.

        This [[#color-space-conversions|may result]] in values outside of the range [0, 1]
        being written to the target texture, if its format can represent them.
        Otherwise, the results are clamped to the target texture format's range.

        Note:
        If {{GPUImageCopyTextureTagged/colorSpace}} matches the source image, no conversion occurs.
        {{ImageBitmap}} color space tagging and conversion can be controlled via {{ImageBitmapOptions}}.

    : <dfn>premultipliedAlpha</dfn>
    ::
        Describes whether the data written into the texture should be have its RGB channels
        premultiplied by the alpha channel, or not.

        If this option is set to `true` and the {{GPUImageCopyExternalImage/source}} is also
        premultiplied, the source RGB values must be preserved even if they exceed their
        corresponding alpha values.

        Note:
        If {{GPUImageCopyTextureTagged/premultipliedAlpha}} matches the source image, no conversion occurs.
        2d canvases are [[html#premultiplied-alpha-and-the-2d-rendering-context|always premultiplied]],
        while WebGL canvases can be controlled via <l spec=html>[=WebGLContextAttributes=]</l>.
        {{ImageBitmap}} premultiplication can be controlled via {{ImageBitmapOptions}}.
</dl>

Issue: Define (and test) the encoding of color values into the
various encodings allowed by {{GPUQueue/copyExternalImageToTexture()}}.

### <dfn dictionary>GPUImageCopyExternalImage</dfn> ### {#gpu-image-copy-external-image}

<script type=idl>
dictionary GPUImageCopyExternalImage {
    required (ImageBitmap or HTMLCanvasElement or OffscreenCanvas) source;
    GPUOrigin2D origin = {};
    boolean flipY = false;
};
</script>

{{GPUImageCopyExternalImage}} has the following members:

<dl dfn-type=dict-member dfn-for=GPUImageCopyExternalImage>
    : <dfn>source</dfn>
    ::
        The source of the [=image copy=]. The copy source data is captured at the moment that
        {{GPUQueue/copyExternalImageToTexture()}} is issued.

    : <dfn>origin</dfn>
    ::
        Defines the origin of the copy - the minimum (top-left) corner of the source sub-region to copy from.
        Together with `copySize`, defines the full copy sub-region.
    
    : <dfn>flipY</dfn>
    ::
        Describes whether the source image is vertically flipped, or not.
       
        If this option is set to `true`, the copy is flipped vertically: the bottom row of the source
        region is copied into the first row of the destination region, and so on.
        The {{GPUImageCopyExternalImage/origin}} option is still relative to the top-left corner
        of the source image, increasing downward.
</dl>

### Buffer Copies ### {#buffer-copies}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)</dfn>
    ::
        Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of a
        {{GPUBuffer}} to a sub-region of another {{GPUBuffer}}.

        <div algorithm=GPUCommandEncoder.copyBufferToBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size)">
                |source|: The {{GPUBuffer}} to copy from.
                |sourceOffset|: Offset in bytes into |source| to begin copying from.
                |destination|: The {{GPUBuffer}} to copy to.
                |destinationOffset|: Offset in bytes into |destination| to place the copied data.
                |size|: Bytes to copy.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. [$Prepare the encoder state$] of |this|. If it returns false, stop.
                1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                    <div class=validusage>
                        - |source| is [$valid to use with$] |this|.
                        - |destination| is [$valid to use with$] |this|.
                        - |source|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/COPY_SRC}}.
                        - |destination|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/COPY_DST}}.
                        - |size| is a multiple of 4.
                        - |sourceOffset| is a multiple of 4.
                        - |destinationOffset| is a multiple of 4.
                        - (|sourceOffset| + |size|) does not overflow a {{GPUSize64}}.
                        - (|destinationOffset| + |size|) does not overflow a {{GPUSize64}}.
                        - |source|.{{GPUBuffer/[[size]]}} is greater than or equal to (|sourceOffset| + |size|).
                        - |destination|.{{GPUBuffer/[[size]]}} is greater than or equal to (|destinationOffset| + |size|).
                        - |source| and |destination| are not the same {{GPUBuffer}}.

                        Issue(gpuweb/gpuweb#69): figure out how to handle overflows in the spec.
                    </div>
                1. Issue: Describe and enqueue the GPU command.
            </div>
        </div>
</dl>

### Buffer Fills ### {#buffer-fills}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>clearBuffer(buffer, offset, size)</dfn>
    ::
        Encode a command into the {{GPUCommandEncoder}} that fills a sub-region of a
        {{GPUBuffer}} with zeros.

        <div algorithm=GPUCommandEncoder.clearBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/clearBuffer(buffer, offset, size)">
                |buffer|: The {{GPUBuffer}} to clear.
                |offset|: Offset in bytes into |buffer| where the sub-region to clear begins.
                |size|: Size in bytes of the sub-region to clear. Defaults to the size of the buffer minus |offset|.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. [$Prepare the encoder state$] of |this|. If it returns false, stop.
                1. If |size| is missing, set |size| to `max(0, |buffer|.{{GPUBuffer/[[size]]}} - |offset|)`.
                1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                    <div class=validusage>
                        - |buffer| is [$valid to use with$] |this|.
                        - |buffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/COPY_DST}}.
                        - |size| is a multiple of 4.
                        - |offset| is a multiple of 4.
                        - |buffer|.{{GPUBuffer/[[size]]}} is greater than or equal to (|offset| + |size|).
                    </div>
            </div>
        </div>
</dl>

### <dfn dfn lt="image copy">Image Copies</dfn> ### {#image-copies}

WebGPU provides {{GPUCommandEncoder/copyBufferToTexture()}} for buffer-to-texture copies and
{{GPUCommandEncoder/copyTextureToBuffer()}} for texture-to-buffer copies, as well as
{{GPUQueue/writeTexture()}} for ArrayBuffer-to-texture writes.

The following definitions and validation rules are used by these methods, as well as
{{GPUCommandEncoder/copyTextureToTexture()}}.

Issue: Does the term "image copy" include copyTextureToTexture?

[=imageCopyTexture subresource size=] and [=Valid Texture Copy Range=] also applies to
{{GPUCommandEncoder/copyTextureToTexture()}}.

<div algorithm="imageCopyTexture subresource size">

<dfn dfn>imageCopyTexture subresource size</dfn>

  **Arguments:**
    - {{GPUImageCopyTexture}} |imageCopyTexture|

  **Returns:** {{GPUExtent3D}}

  The [=imageCopyTexture subresource size=] of |imageCopyTexture| is calculated as follows:

  Its [=Extent3D/width=], [=Extent3D/height=] and [=Extent3D/depthOrArrayLayers=] are the width, height, and depth, respectively,
  of the [=physical size=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}} [=subresource=] at [=mipmap level=]
  |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}.

</div>

Issue: define this as an algorithm with (texture, mipmapLevel) parameters and use the call syntax instead of referring to the definition by label.

<div algorithm>
    <dfn abstract-op>validating linear texture data</dfn>(layout, byteSize, format, copyExtent)

    **Arguments:**
    : {{GPUImageDataLayout}} |layout|
    :: Layout of the linear texture data.
    : {{GPUSize64}} |byteSize|
    :: Total size of the linear data, in bytes.
    : {{GPUTextureFormat}} |format|
    :: Format of the texture.
    : {{GPUExtent3D}} |copyExtent|
    :: Extent of the texture to copy.

    1. Let |blockWidth|, |blockHeight|, and |blockSize| be the
        [=texel block width=], [=texel block height|height=], and
        [=texel block size|size=] of |format|.

    1. It is assumed that |copyExtent|.[=Extent3D/width=] is a multiple of |blockWidth|
        and |copyExtent|.[=Extent3D/height=] is a multiple of |blockHeight|. Let:
            - |widthInBlocks| be |copyExtent|.[=Extent3D/width=] &divide; |blockWidth|.
            - |heightInBlocks| be |copyExtent|.[=Extent3D/height=] &divide; |blockHeight|.
            - |bytesInLastRow| be |blockSize| &times; |widthInBlocks|.

    1. Fail if the following conditions are not satisfied:
        <div class=validusage>
            - If |heightInBlocks| &gt; 1,
                |layout|.{{GPUImageDataLayout/bytesPerRow}} must be specified.
            - If |copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 1,
                |layout|.{{GPUImageDataLayout/bytesPerRow}} and
                |layout|.{{GPUImageDataLayout/rowsPerImage}} must be specified.
            - If specified, |layout|.{{GPUImageDataLayout/bytesPerRow}}
                must be greater than or equal to |bytesInLastRow|.
            - If specified, |layout|.{{GPUImageDataLayout/rowsPerImage}}
                must be greater than or equal to |heightInBlocks|.
        </div>

    1. Let |requiredBytesInCopy| be 0.

    1. If |copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 1:
        1. Let |bytesPerImage| be
            |layout|.{{GPUImageDataLayout/bytesPerRow}} &times;
            |layout|.{{GPUImageDataLayout/rowsPerImage}}.
        1. Let |bytesBeforeLastImage| be
            |bytesPerImage| &times; (|copyExtent|.[=Extent3D/depthOrArrayLayers=] &minus; 1).
        1. Add |bytesBeforeLastImage| to |requiredBytesInCopy|.

    1. If |copyExtent|.[=Extent3D/depthOrArrayLayers=] &gt; 0:

        1. If |heightInBlocks| &gt; 1, add
            |layout|.{{GPUImageDataLayout/bytesPerRow}} &times;
            (|heightInBlocks| &minus; 1)
            to |requiredBytesInCopy|.

        1. If |heightInBlocks| &gt; 0, add
            |bytesInLastRow| to |requiredBytesInCopy|.

    1. Fail if the following conditions are not satisfied:
        <div class=validusage>
            - |layout|.{{GPUImageDataLayout/offset}} + |requiredBytesInCopy| &le; |byteSize|.
        </div>
</div>

<div algorithm class=validusage>

<dfn dfn>Valid Texture Copy Range</dfn>

Given a {{GPUImageCopyTexture}} |imageCopyTexture| and a {{GPUExtent3D}} |copySize|, let
  - |blockWidth| be the [=texel block width=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.
  - |blockHeight| be the [=texel block height=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/format}}.

The following validation rules apply:

  - If the {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} of |imageCopyTexture|.{{GPUImageCopyTexture/texture}} is
    {{GPUTextureDimension/1d}}:
    - Both |copySize|.[=Extent3D/height=] and [=Extent3D/depthOrArrayLayers=] must be 1.
  - If the {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}} of |imageCopyTexture|.{{GPUImageCopyTexture/texture}} is
    {{GPUTextureDimension/2d}}:
     -  (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/x=] + |copySize|.[=Extent3D/width=]),
        (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/y=] + |copySize|.[=Extent3D/height=]), and
        (|imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/z=] + |copySize|.[=Extent3D/depthOrArrayLayers=])
        must be less than or equal to the
        [=Extent3D/width=], [=Extent3D/height=], and [=Extent3D/depthOrArrayLayers=], respectively,
        of the [=imageCopyTexture subresource size=] of |imageCopyTexture|.
  - |copySize|.[=Extent3D/width=] must be a multiple of |blockWidth|.
  - |copySize|.[=Extent3D/height=] must be a multiple of |blockHeight|.

</div>

Issue(gpuweb/gpuweb#69): Define the copies with {{GPUTextureDimension/1d}} and
{{GPUTextureDimension/3d}} textures.

Issue(gpuweb/gpuweb#537): Additional restrictions on rowsPerImage if needed.

Issue(gpuweb/gpuweb#652): Define the copies with {{GPUTextureFormat/"depth24plus"}},
{{GPUTextureFormat/"depth24plus-stencil8"}}, and {{GPUTextureFormat/"stencil8"}}.

Issue: convert "Valid Texture Copy Range" into an algorithm with parameters, similar to "validating linear texture data"

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>copyBufferToTexture(source, destination, copySize)</dfn>
    ::
        Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of a
        {{GPUBuffer}} to a sub-region of one or multiple continuous [=texture subresources=].

        <div algorithm=GPUCommandEncoder.copyBufferToTexture>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyBufferToTexture(source, destination, copySize)">
                |source|: Combined with |copySize|, defines the region of the source buffer.
                |destination|: Combined with |copySize|, defines the region of the destination [=texture subresource=].
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. [$Prepare the encoder state$] of |this|. If it returns false, stop.
                1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                    <div class=validusage>
                        - Let |dstTextureDesc| be |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.
                        - [$validating GPUImageCopyBuffer$](|source|) returns `true`.
                        - |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/COPY_SRC}}.
                        - [$validating GPUImageCopyTexture$](|destination|, |copySize|) returns `true`.
                        - |dstTextureDesc|.{{GPUTextureDescriptor/usage}} contains {{GPUTextureUsage/COPY_DST}}.
                        - |dstTextureDesc|.{{GPUTextureDescriptor/sampleCount}} is 1.
                        - If |dstTextureDesc|.{{GPUTextureDescriptor/format}} is a [=depth-or-stencil format=]:
                            - |destination|.{{GPUImageCopyTexture/aspect}} must refer to a single aspect of
                                |dstTextureDesc|.{{GPUTextureDescriptor/format}}, and that aspect must be
                                a valid image copy destination according to [[#depth-formats]].
                        - [=Valid Texture Copy Range=] applies to |destination| and |copySize|.
                        - If |dstTextureDesc|.{{GPUTextureDescriptor/format}} is not a [=depth-or-stencil format=]:
                            - |source|.{{GPUImageDataLayout/offset}} is a multiple of the [=texel block size=] of
                                |dstTextureDesc|.{{GPUTextureDescriptor/format}}.
                        - If |dstTextureDesc|.{{GPUTextureDescriptor/format}} is a [=depth-or-stencil format=]:
                            - |source|.{{GPUImageDataLayout/offset}} is a multiple of 4.
                        - [$validating linear texture data$](|source|,
                            |source|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[size]]}},
                            |dstTextureDesc|.{{GPUTextureDescriptor/format}},
                            |copySize|) succeeds.
                    </div>
            </div>
        </div>

    : <dfn>copyTextureToBuffer(source, destination, copySize)</dfn>
    ::
        Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of one or
        multiple continuous [=texture subresources=]to a sub-region of a {{GPUBuffer}}.

        <div algorithm=GPUCommandEncoder.copyTextureToBuffer>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyTextureToBuffer(source, destination, copySize)">
                |source|: Combined with |copySize|, defines the region of the source [=texture subresources=].
                |destination|: Combined with |copySize|, defines the region of the destination buffer.
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. [$Prepare the encoder state$] of |this|. If it returns false, stop.
                1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                    <div class=validusage>
                        - Let |srcTextureDesc| be |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.
                        - [$validating GPUImageCopyTexture$](|source|, |copySize|) returns `true`.
                        - |srcTextureDesc|.{{GPUTextureDescriptor/usage}} contains {{GPUTextureUsage/COPY_SRC}}.
                        - |srcTextureDesc|.{{GPUTextureDescriptor/sampleCount}} is 1.
                        - If |srcTextureDesc|.{{GPUTextureDescriptor/format}} is a depth-stencil format:
                            - |destination|.{{GPUImageCopyTexture/aspect}} must refer to a single aspect of
                                |srcTextureDesc|.{{GPUTextureDescriptor/format}}, and that aspect must be
                                a valid image copy source according to [[#depth-formats]].
                        - [$validating GPUImageCopyBuffer$](|destination|) returns `true`.
                        - |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[usage]]}} contains
                            {{GPUBufferUsage/COPY_DST}}.
                        - [=Valid Texture Copy Range=] applies to |source| and |copySize|.
                        - If |srcTextureDesc|.{{GPUTextureDescriptor/format}} is not a [=depth-or-stencil format=]:
                            - |destination|.{{GPUImageDataLayout/offset}} is a multiple of the [=texel block size=] of
                                |srcTextureDesc|.{{GPUTextureDescriptor/format}}.
                        - If |srcTextureDesc|.{{GPUTextureDescriptor/format}} is a [=depth-or-stencil format=]:
                            - |destination|.{{GPUImageDataLayout/offset}} is a multiple of 4.
                        - [$validating linear texture data$](|destination|,
                            |destination|.{{GPUImageCopyBuffer/buffer}}.{{GPUBuffer/[[size]]}},
                            |srcTextureDesc|.{{GPUTextureDescriptor/format}},
                            |copySize|) succeeds.
                    </div>
            </div>
        </div>

    : <dfn>copyTextureToTexture(source, destination, copySize)</dfn>
    ::
        Encode a command into the {{GPUCommandEncoder}} that copies data from a sub-region of one
        or multiple contiguous [=texture subresources=] to another sub-region of one or
        multiple continuous [=texture subresources=].

        <div algorithm=GPUCommandEncoder.copyTextureToTexture>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/copyTextureToTexture(source, destination, copySize)">
                |source|: Combined with |copySize|, defines the region of the source [=texture subresources=].
                |destination|: Combined with |copySize|, defines the region of the destination [=texture subresources=].
                |copySize|:
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. [$Prepare the encoder state$] of |this|. If it returns false, stop.
                1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                    <div class=validusage>
                        - Let |srcTextureDesc| be |source|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.
                        - Let |dstTextureDesc| be |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.
                        - [$validating GPUImageCopyTexture$](|source|, |copySize|) returns `true`.
                        - |srcTextureDesc|.{{GPUTextureDescriptor/usage}} contains {{GPUTextureUsage/COPY_SRC}}.
                        - [$validating GPUImageCopyTexture$](|destination|, |copySize|) returns `true`.
                        - |dstTextureDesc|.{{GPUTextureDescriptor/usage}} contains {{GPUTextureUsage/COPY_DST}}.
                        - |srcTextureDesc|.{{GPUTextureDescriptor/sampleCount}} is equal to |dstTextureDesc|.{{GPUTextureDescriptor/sampleCount}}.
                        - |srcTextureDesc|.{{GPUTextureDescriptor/format}} and |dstTextureDesc|.{{GPUTextureDescriptor/format}}
                            must be [=copy-compatible=].
                        - If |srcTextureDesc|.{{GPUTextureDescriptor/format}} is a depth-stencil format:
                            - |source|.{{GPUImageCopyTexture/aspect}} and |destination|.{{GPUImageCopyTexture/aspect}}
                                must both refer to all aspects of |srcTextureDesc|.{{GPUTextureDescriptor/format}}
                                and |dstTextureDesc|.{{GPUTextureDescriptor/format}}, respectively.
                        - [=Valid Texture Copy Range=] applies to |source| and |copySize|.
                        - [=Valid Texture Copy Range=] applies to |destination| and |copySize|.
                        - The [$set of subresources for texture copy$](|source|, |copySize|) and
                            the [$set of subresources for texture copy$](|destination|, |copySize|) is disjoint.
                    </div>
            </div>
        </div>
</dl>

<div algorithm>
    Two {{GPUTextureFormat}}s |format1| and |format2| are <dfn dfn>copy-compatible</dfn> if:

    - |format1| equals |format2|, or
    - |format1| and |format2| differ only in whether they are `srgb` formats (have the `-srgb` suffix).
</div>

<div algorithm>
    The <dfn abstract-op>set of subresources for texture copy</dfn>(|imageCopyTexture|, |copySize|)
    is the set containing:

      - If |imageCopyTexture|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/dimension}}
        is {{GPUTextureDimension/"2d"}}:
          - For each |arrayLayer| of the |copySize|.[=Extent3D/depthOrArrayLayers=] [=array layers=]
            starting at |imageCopyTexture|.{{GPUImageCopyTexture/origin}}.[=Origin3D/z=]:
              - The [=subresource=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}} at
                [=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}} and
                [=array layer=] |arrayLayer|.
      - Otherwise:
          - The [=subresource=] of |imageCopyTexture|.{{GPUImageCopyTexture/texture}} at
            [=mipmap level=] |imageCopyTexture|.{{GPUImageCopyTexture/mipLevel}}.
</div>

## Queries ## {#command-encoder-queries}

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>writeTimestamp(querySet, queryIndex)</dfn>
    ::
        Writes a timestamp value into a querySet when all previous commands have completed executing.

        <div algorithm=GPUCommandEncoder.writeTimestamp>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/writeTimestamp(querySet, queryIndex)">
                |querySet|: The query set that will store the timestamp values.
                |queryIndex|: The index of the query in the query set.
            </pre>

            **Returns:** {{undefined}}

            1. If |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} does not [=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}, throw a {{TypeError}}.
            1. Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
                <div class=device-timeline>
                    1. [$Prepare the encoder state$] of |this|. If it returns false, stop.
                    1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                        <div class=validusage>
                            - |querySet| is [$valid to use with$] |this|.
                            - |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}} is {{GPUQueryType/"timestamp"}}.
                            - |queryIndex| &lt; |querySet|.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}.
                        </div>

                    Issue: Describe {{GPUCommandEncoder/writeTimestamp()}} algorithm steps.
                </div>
        </div>

    : <dfn>resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)</dfn>
    ::
        Resolves query results from a {{GPUQuerySet}} out into a range of a {{GPUBuffer}}.

        <div algorithm=GPUCommandEncoder.resolveQuerySet>
            **Called on:** {{GPUCommandEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/resolveQuerySet(querySet, firstQuery, queryCount, destination, destinationOffset)">
                querySet:
                firstQuery:
                queryCount:
                destination:
                destinationOffset:
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. [$Prepare the encoder state$] of |this|. If it returns false, stop.
                1. If any of the following conditions are unsatisfied, generate a {{GPUValidationError}} and stop.
                    <div class=validusage>
                        - |querySet| is [$valid to use with$] |this|.
                        - |destination| is [$valid to use with$] |this|.
                        - |destination|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/QUERY_RESOLVE}}.
                        - |firstQuery| is less than the number of queries in |querySet|.
                        - (|firstQuery| + |queryCount|) is less than or equal to the number of queries in |querySet|.
                        - |destinationOffset| is a multiple of 256.
                        - |destinationOffset| + 8 &times; |queryCount| &le; |destination|.{{GPUBuffer/[[size]]}}.
                    </div>

                Issue: Describe {{GPUCommandEncoder/resolveQuerySet()}} algorithm steps.
            </div>
        </div>
</dl>

## Finalization ## {#command-encoder-finalization}

A {{GPUCommandBuffer}} containing the commands recorded by the {{GPUCommandEncoder}} can be created
by calling {{GPUCommandEncoder/finish()}}. Once {{GPUCommandEncoder/finish()}} has been called the
command encoder can no longer be used.

<dl dfn-type=method dfn-for=GPUCommandEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        Completes recording of the commands sequence and returns a corresponding {{GPUCommandBuffer}}.

        <div algorithm=GPUCommandEncoder.finish>
            **Called on:** {{GPUCommandEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCommandEncoder/finish(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPUCommandBuffer}}

            1. Let |commandBuffer| be a new {{GPUCommandBuffer}}.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. Let |validationFailed| be `true` if all of the following requirements are met, and `false` otherwise.
                        <div class=validusage>
                            - |this| must be [=valid=].
                            - |this|.{{GPUCommandsMixin/[[state]]}} must be "[=encoder state/open=]".
                            - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} must [=list/is empty|be empty=].
                            - Every [=usage scope=] contained in |this| must satisfy the [=usage scope validation=].
                        </div>
                    1. Set |this|.{{GPUCommandsMixin/[[state]]}} to "[=encoder state/ended=]".
                    1. If |validationFailed|, then:
                        1. Generate a {{GPUValidationError}} in the current scope with appropriate
                            error message.
                        1. Return a new [=invalid=] {{GPUCommandBuffer}}.
                    1. Set |commandBuffer|.{{GPUCommandBuffer/[[command_list]]}} to
                        |this|.{{GPUCommandsMixin/[[commands]]}}.
                </div>

            1. Return |commandBuffer|.
        </div>
</dl>

# Programmable Passes # {#programmable-passes}

<script type=idl>

interface mixin GPUProgrammablePassEncoder {
    undefined setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      optional sequence<GPUBufferDynamicOffset> dynamicOffsets = []);

    undefined setBindGroup(GPUIndex32 index, GPUBindGroup bindGroup,
                      Uint32Array dynamicOffsetsData,
                      GPUSize64 dynamicOffsetsDataStart,
                      GPUSize32 dynamicOffsetsDataLength);
};
</script>

{{GPUProgrammablePassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUProgrammablePassEncoder">
    : <dfn>\[[command_encoder]]</dfn> of type {{GPUCommandEncoder}}.
    ::
        The {{GPUCommandEncoder}} that created this programmable pass.

    : <dfn>\[[bind_groups]]</dfn>, of type [=ordered map=]&lt;{{GPUIndex32}}, {{GPUBindGroup}}&gt;
    ::
        The current {{GPUBindGroup}} for each index, initially empty.
</dl>

## Bind Groups ## {#programmable-passes-bind-groups}

<dl dfn-type=method dfn-for=GPUProgrammablePassEncoder>
    : <dfn>setBindGroup(index, bindGroup, dynamicOffsets)</dfn>
    ::
        Sets the current {{GPUBindGroup}} for the given index.

        <div algorithm=GPUProgrammablePassEncoder.setBindGroup>
            **Called on:** {{GPUProgrammablePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)">
                |index|: The index to set the bind group at.
                |bindGroup|: Bind group to use for subsequent render or compute commands.

                <!--The overload appears to be confusing bikeshed, and it ends up expecting this to
                define the arguments for the 5-arg variant of the method, despite the "for"
                explicitly pointing at the 3-arg variant.-->
                <!--|dynamicOffsets|: Array containing buffer offsets in bytes for each entry in
                    |bindGroup| marked as {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}.-->
            </pre>

            Issue: Resolve bikeshed conflict when using `argumentdef` with overloaded functions that prevents us from
                defining |dynamicOffsets|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |bindGroup| is [$valid to use with$] |this|.
                        - |index| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxBindGroups}}.
                        - |dynamicOffsets|.length is
                            |bindGroup|.{{GPUBindGroup/[[layout]]}}.{{GPUBindGroupLayout/[[dynamicOffsetCount]]}}.

                        - [$Iterate over each dynamic binding offset$] in |bindGroup| and
                            run the following steps for each |bufferBinding|, |bufferLayout|,
                            and |dynamicOffsetIndex|:

                            - Let |bufferDynamicOffset| be |dynamicOffsets|[|dynamicOffsetIndex|].
                            - |bufferBinding|.{{GPUBufferBinding/offset}} + |bufferDynamicOffset| +
                                |bufferLayout|.{{GPUBufferBindingLayout/minBindingSize}} &le;
                                |bufferBinding|.{{GPUBufferBinding/buffer}}.{{GPUBuffer/[[size]]}}.
                            - if |bufferLayout|.{{GPUBufferBindingLayout/type}} is {{GPUBufferBindingType/"uniform"}}:

                                - |dynamicOffset| is a multiple of {{supported limits/minUniformBufferOffsetAlignment}}.

                            - if |bufferLayout|.{{GPUBufferBindingLayout/type}} is {{GPUBufferBindingType/"storage"}}
                                or {{GPUBufferBindingType/"read-only-storage"}}:

                                - |dynamicOffset| is a multiple of {{supported limits/minStorageBufferOffsetAlignment}}.

                    </div>
                1. Set |this|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index|] to be |bindGroup|.
            </div>
        </div>

    : <dfn>setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)</dfn>
    ::
        Sets the current {{GPUBindGroup}} for the given index, specifying dynamic offsets as a subset
        of a {{Uint32Array}}.

        <div algorithm=GPUProgrammablePassEncoder.setBindGroup2>
            **Called on:** {{GPUProgrammablePassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsetsData, dynamicOffsetsDataStart, dynamicOffsetsDataLength)">
                |index|: The index to set the bind group at.
                |bindGroup|: Bind group to use for subsequent render or compute commands.
                |dynamicOffsetsData|: Array containing buffer offsets in bytes for each entry in
                    |bindGroup| marked as {{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}}.
                |dynamicOffsetsDataStart|: Offset in elements into |dynamicOffsetsData| where the
                    buffer offset data begins.
                |dynamicOffsetsDataLength|: Number of buffer offsets to read from |dynamicOffsetsData|.
            </pre>

            **Returns:** {{undefined}}

            1. If any of the following requirements are unmet, throw a {{RangeError}} and stop.
                <div class=validusage>
                    - |dynamicOffsetsDataStart| must be &ge; 0.
                    - |dynamicOffsetsDataStart| + |dynamicOffsetsDataLength| must be &le;
                        |dynamicOffsetsData|.`length`.
                </div>
            1. Let |dynamicOffsets| be a [=list=] containing the range, starting at index
                |dynamicOffsetsDataStart|, of |dynamicOffsetsDataLength| elements of
                [=get a copy of the buffer source|a copy of=] |dynamicOffsetsData|.
            1. Call |this|.{{GPUProgrammablePassEncoder/setBindGroup(index,
                bindGroup, dynamicOffsets)|setBindGroup}}(|index|, |bindGroup|, |dynamicOffsets|).
</dl>

<div algorithm>
    To <dfn abstract-op>Iterate over each dynamic binding offset</dfn> in a given {{GPUBindGroup}} |bindGroup|
    with a given list of |steps| to be executed for each dynamic offset:

    1. Let |dynamicOffsetIndex| be `0`.
    1. Let |layout| be |bindGroup|.{{GPUBindGroup/[[layout]]}}.
    1. For each {{GPUBindGroupEntry}} |entry| in |bindGroup|.{{GPUBindGroup/[[entries]]}}:
        1. Let |bindingDescriptor| be the {{GPUBindGroupLayoutEntry}} at
            |layout|.{{GPUBindGroupLayout/[[entryMap]]}}[|entry|.{{GPUBindGroupEntry/binding}}]:
        1. If |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}} is not `undefined` and
            |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}.{{GPUBufferBindingLayout/hasDynamicOffset}} is `true`:
            1. Let |bufferBinding| be |entry|.{{GPUBindGroupEntry/resource}}.
            1. Let |bufferLayout| be |bindingDescriptor|.{{GPUBindGroupLayoutEntry/buffer}}.
            1. Call |steps| with |bufferBinding|, |bufferLayout|, and |dynamicOffsetIndex|.
            1. Let |dynamicOffsetIndex| be |dynamicOffsetIndex| + `1`
</div>

<div algorithm>
    <dfn abstract-op>Validate encoder bind groups</dfn>(encoder, pipeline)

    **Arguments:**
    : {{GPUProgrammablePassEncoder}} |encoder|
    :: Encoder who's bind groups are being validated.
    : {{GPUPipelineBase}} |pipeline|
    :: Pipeline to validate |encoder|s bind groups are compatible with.

    If any of the following conditions are unsatisfied, return `false`:
        <div class=validusage>
            - |pipeline| must not be `null`.
            - For each pair of ({{GPUIndex32}} |index|, {{GPUBindGroupLayout}} |bindGroupLayout|) in
                |pipeline|.{{GPUPipelineBase/[[layout]]}}.{{GPUPipelineLayout/[[bindGroupLayouts]]}}.
                - Let |bindGroup| be |encoder|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}[|index|].
                - |bindGroup| must not be `null`.
                - |bindGroup|.{{GPUBindGroup/[[layout]]}} must be [=group-equivalent=] with |bindGroupLayout|.

            Issue: Add validation that, for buffer bindings that weren't prevalidated with
            {{GPUBufferBindingLayout/minBindingSize}}, the binding ranges are large enough for
            the shader's minimum binding size requirements.
        </div>

    Otherwise return `true`.
</div>

# Debug Markers # {#debug-markers}

<dfn interface>GPUDebugCommandsMixin</dfn> provides methods to apply debug labels to groups
of commands or insert a single label into the command sequence.

Debug groups can be nested to create a hierarchy of labeled commands, and must be well-balanced.

Like {{GPUObjectBase/label|object labels}}, these labels have no required behavior, but may be shown
in error messages and browser developer tools, and may be passed to native API backends.

<script type=idl>
interface mixin GPUDebugCommandsMixin {
    undefined pushDebugGroup(USVString groupLabel);
    undefined popDebugGroup();
    undefined insertDebugMarker(USVString markerLabel);
};
</script>

{{GPUDebugCommandsMixin}} is only included by interfaces which include
{{GPUObjectBase}} and {{GPUCommandsMixin}}.

{{GPUDebugCommandsMixin}} adds the following internal slots to interfaces which include it:

<dl dfn-type=attribute dfn-for=GPUDebugCommandsMixin>
    : <dfn>\[[debug_group_stack]]</dfn> of type [=stack=]&lt;{{USVString}}&gt;.
    ::
        A stack of active debug group labels.
</dl>

{{GPUDebugCommandsMixin}} adds the following methods to interfaces which include it:

<dl dfn-type=method dfn-for=GPUDebugCommandsMixin>
    : <dfn>pushDebugGroup(groupLabel)</dfn>
    ::
        Begins a labeled debug group containing subsequent commands.

        <div algorithm=GPUDebugCommandsMixin.pushDebugGroup>
            **Called on:** {{GPUDebugCommandsMixin}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDebugCommandsMixin/pushDebugGroup(groupLabel)">
                |groupLabel|: The label for the command group.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. [$Prepare the encoder state$] of |this|. If it returns false, stop.
                1. [=stack/Push=] |groupLabel| onto |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}}.
            </div>
        </div>

    : <dfn>popDebugGroup()</dfn>
    ::
        Ends the labeled debug group most recently started by {{GPUDebugCommandsMixin/pushDebugGroup()}}.

        <div algorithm=GPUDebugCommandsMixin.popDebugGroup>
            **Called on:** {{GPUDebugCommandsMixin}} |this|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. [$Prepare the encoder state$] of |this|. If it returns false, stop.
                1. If any of the following requirements are unmet, make |this| [=invalid=], and stop.
                    <div class=validusage>
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} must not [=list/is empty|be empty=].
                    </div>
                1. [=stack/Pop=] an entry off of |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}}.
            </div>
        </div>

    : <dfn>insertDebugMarker(markerLabel)</dfn>
    ::
        Marks a point in a stream of commands with a label.

        <div algorithm=GPUDebugCommandsMixin.insertDebugMarker>
            **Called on:** {{GPUDebugCommandsMixin}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDebugCommandsMixin/insertDebugMarker(markerLabel)">
                markerLabel: The label to insert.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. [$Prepare the encoder state$] of |this|. If it returns false, stop.
            </div>
        </div>
</dl>

# Compute Passes # {#compute-passes}

## <dfn interface>GPUComputePassEncoder</dfn> ## {#compute-pass-encoder}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUComputePassEncoder {
    undefined setPipeline(GPUComputePipeline pipeline);
    undefined dispatch(GPUSize32 x, optional GPUSize32 y = 1, optional GPUSize32 z = 1);
    undefined dispatchIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);

    undefined endPass();
};
GPUComputePassEncoder includes GPUObjectBase;
GPUComputePassEncoder includes GPUCommandsMixin;
GPUComputePassEncoder includes GPUDebugCommandsMixin;
GPUComputePassEncoder includes GPUProgrammablePassEncoder;
</script>

{{GPUComputePassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUComputePassEncoder">
    : <dfn>\[[pipeline]]</dfn>, of type {{GPUComputePipeline}}
    ::
        The current {{GPUComputePipeline}}, initially `null`.

    : <dfn>\[[endTimestampWrites]]</dfn>, of type {{GPUComputePassTimestampWrites}}
    ::
        The timestamp attachments which need to be executed when the pass ends.
</dl>

### Creation ### {#compute-pass-encoder-creation}

<script type=idl>
enum GPUComputePassTimestampLocation {
    "beginning",
    "end",
};

dictionary GPUComputePassTimestampWrite {
    required GPUQuerySet querySet;
    required GPUSize32 queryIndex;
    required GPUComputePassTimestampLocation location;
};

typedef sequence<GPUComputePassTimestampWrite> GPUComputePassTimestampWrites;

dictionary GPUComputePassDescriptor : GPUObjectDescriptorBase {
    GPUComputePassTimestampWrites timestampWrites = [];
};
</script>

<dl dfn-type=dict-member dfn-for=GPUComputePassDescriptor>
    : <dfn>timestampWrites</dfn>
    ::
        A sequence of {{GPUComputePassTimestampWrite}} values define where and when timestamp values will be written for this pass.
</dl>

<div class=validusage dfn-for=GPUComputePassDescriptor>
    <dfn abstract-op>Valid Usage</dfn>

    Given a {{GPUComputePassDescriptor}} |this| the following validation rules apply:

    1. For each |timestampWrite| in |this|.{{GPUComputePassDescriptor/timestampWrites}}:

        1. |timestampWrite|.{{GPUComputePassTimestampWrite/querySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}} is {{GPUQueryType/"timestamp"}}.

        1. |timestampWrite|.{{GPUComputePassTimestampWrite/queryIndex}} &lt; |timestampWrite|.{{GPUComputePassTimestampWrite/querySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}.
</div>

### Dispatch ### {#compute-pass-encoder-dispatch}

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        Sets the current {{GPUComputePipeline}}.

        <div algorithm="GPUComputePassEncoder.setPipeline">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/setPipeline(pipeline)">
                |pipeline|: The compute pipeline to use for subsequent dispatch commands.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |pipeline| is [$valid to use with$] |this|.
                    </div>
                1. Set |this|.{{GPUComputePassEncoder/[[pipeline]]}} to be |pipeline|.
            </div>
        </div>

    : <dfn>dispatch(x, y, z)</dfn>
    ::
        Dispatch work to be performed with the current {{GPUComputePipeline}}.
        See [[#computing-operations]] for the detailed specification.

        <div algorithm="GPUComputePassEncoder.dispatch">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/dispatch(x, y, z)">
                |x|: X dimension of the grid of workgroups to dispatch.
                |y|: Y dimension of the grid of workgroups to dispatch.
                |z|: Z dimension of the grid of workgroups to dispatch.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - [$Validate encoder bind groups$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})
                            is `true`.
                        - all of |x|, |y| and |z| are less than or equal to
                            |this|.device.limits.{{supported limits/maxComputeWorkgroupsPerDimension}}.
                    </div>

                1. Let |passState| be a snapshot of |this|'s current state.
                1. [=list/Append=] a [=GPU command=] to |this|.{{GPUCommandsMixin/[[commands]]}}
                    executing the following [=queue timeline=] steps:
                    <div class=queue-timeline>
                        1. Dispatch a grid of workgroups with dimensions [|x|, |y|, |z|] with
                            |passState|.{{GPUComputePassEncoder/[[pipeline]]}} using
                            |passState|.{{GPUProgrammablePassEncoder/[[bind_groups]]}}.
                    </div>
            </div>
        </div>

    : <dfn>dispatchIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        Dispatch work to be performed with the current {{GPUComputePipeline}} using parameters read
        from a {{GPUBuffer}}.
        See [[#computing-operations]] for the detailed specification.

        The <dfn dfn for=>indirect dispatch parameters</dfn> encoded in the buffer must be a tightly
        packed block of **three 32-bit unsigned integer values (12 bytes total)**,
        given in the same order as the arguments for {{GPUComputePassEncoder/dispatch()}}. For example:

        <pre highlight="js">
            let dispatchIndirectParameters = new Uint32Array(3);
            dispatchIndirectParameters[0] = x;
            dispatchIndirectParameters[1] = y;
            dispatchIndirectParameters[2] = z;
        </pre>

        <div algorithm="GPUComputePassEncoder.dispatchIndirect">
            **Called on:** {{GPUComputePassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUComputePassEncoder/dispatchIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: Buffer containing the [=indirect dispatch parameters=].
                |indirectOffset|: Offset in bytes into |indirectBuffer| where the dispatch data begins.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - [$Validate encoder bind groups$](|this|, |this|.{{GPUComputePassEncoder/[[pipeline]]}})
                            is `true`.
                        - |indirectBuffer| is [$valid to use with$] |this|.
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect dispatch parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}.
                        - |indirectOffset| is a multiple of 4.
                    </div>
                1. Add |indirectBuffer| to the [=usage scope=] as {{GPUBufferUsage/INDIRECT}}.
            </div>

            If any of the dispatch parameters (x, y, or z) is greater than
            |this|.device.limits.{{supported limits/maxComputeWorkgroupsPerDimension}},
            no workgroups will be dispatched.
        </div>
</dl>

### Finalization ### {#compute-pass-encoder-finalization}

The compute pass encoder can be ended by calling {{GPUComputePassEncoder/endPass()}} once the user
has finished recording commands for the pass. Once {{GPUComputePassEncoder/endPass()}} has been
called the compute pass encoder can no longer be used.

<dl dfn-type=method dfn-for=GPUComputePassEncoder>
    : <dfn>endPass()</dfn>
    ::
        Completes recording of the compute pass commands sequence.

        <div algorithm="GPUComputePassEncoder.endPass">
            **Called on:** {{GPUComputePassEncoder}} |this|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following requirements are unmet,
                    generate a {{GPUValidationError}} and stop.
                    <div class=validusage>
                        - |this|.{{GPUCommandsMixin/[[state]]}} must be "[=encoder state/open=]",
                    </div>
                1. [=Assert=]: |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[state]]}} is "[=encoder state/locked=]".
                1. Set |this|.{{GPUCommandsMixin/[[state]]}} to "[=encoder state/ended=]".
                1. Set |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[state]]}} to "[=encoder state/open=]".
                1. If any of the following requirements are unmet, make
                    |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}} [=invalid=] and stop.
                    <div class=validusage>
                        - |this| must be [=valid=].
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} must be [=list/is empty|be empty=].
                    </div>
                1. [=list/Extend=] |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[commands]]}}
                    with |this|.{{GPUCommandsMixin/[[commands]]}}.
                1. For each |timestampWrite| in |this|.{{GPUComputePassEncoder/[[endTimestampWrites]]}}:
                    1. [=Assert=]: |timestampWrite|.{{GPUComputePassTimestampWrite/location}} is {{GPUComputePassTimestampLocation/"end"}}.
                    1. [=list/Append=] a [=GPU command=] to
                        |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[commands]]}}
                        that writes the GPU's timestamp value into the |timestampWrite|.{{GPUComputePassTimestampWrite/queryIndex}}th
                        index in |timestampWrite|.{{GPUComputePassTimestampWrite/querySet}}.
            </div>
        </div>
</dl>

# Render Passes # {#render-passes}

## <dfn interface>GPURenderPassEncoder</dfn> ## {#render-pass-encoder}

<script type=idl>
interface mixin GPURenderEncoderBase {
    undefined setPipeline(GPURenderPipeline pipeline);

    undefined setIndexBuffer(GPUBuffer buffer, GPUIndexFormat indexFormat, optional GPUSize64 offset = 0, optional GPUSize64 size);
    undefined setVertexBuffer(GPUIndex32 slot, GPUBuffer buffer, optional GPUSize64 offset = 0, optional GPUSize64 size);

    undefined draw(GPUSize32 vertexCount, optional GPUSize32 instanceCount = 1,
              optional GPUSize32 firstVertex = 0, optional GPUSize32 firstInstance = 0);
    undefined drawIndexed(GPUSize32 indexCount, optional GPUSize32 instanceCount = 1,
                     optional GPUSize32 firstIndex = 0,
                     optional GPUSignedOffset32 baseVertex = 0,
                     optional GPUSize32 firstInstance = 0);

    undefined drawIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
    undefined drawIndexedIndirect(GPUBuffer indirectBuffer, GPUSize64 indirectOffset);
};

[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderPassEncoder {
    undefined setViewport(float x, float y,
                     float width, float height,
                     float minDepth, float maxDepth);

    undefined setScissorRect(GPUIntegerCoordinate x, GPUIntegerCoordinate y,
                        GPUIntegerCoordinate width, GPUIntegerCoordinate height);

    undefined setBlendConstant(GPUColor color);
    undefined setStencilReference(GPUStencilValue reference);

    undefined beginOcclusionQuery(GPUSize32 queryIndex);
    undefined endOcclusionQuery();

    undefined executeBundles(sequence<GPURenderBundle> bundles);
    undefined endPass();
};
GPURenderPassEncoder includes GPUObjectBase;
GPURenderPassEncoder includes GPUCommandsMixin;
GPURenderPassEncoder includes GPUDebugCommandsMixin;
GPURenderPassEncoder includes GPUProgrammablePassEncoder;
GPURenderPassEncoder includes GPURenderEncoderBase;
</script>

  * In indirect draw calls, the base instance field (inside the indirect
    buffer data) must be set to zero.

{{GPURenderEncoderBase}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPURenderEncoderBase">
    : <dfn>\[[layout]]</dfn>, of type {{GPURenderPassLayout}}
    ::
        The layout of the render pass.

    : <dfn>\[[depthReadOnly]]</dfn>, of type boolean?
    ::
        If present, indicates that the depth component is not modified.

    : <dfn>\[[stencilReadOnly]]</dfn>, of type boolean?
    ::
        If present, indicates that the stencil component is not modified.

    : <dfn>\[[pipeline]]</dfn>, of type {{GPURenderPipeline}}
    ::
        The current {{GPURenderPipeline}}, initially `null`.

    : <dfn>\[[index_buffer]]</dfn>, of type {{GPUBuffer}}
    ::
        The current buffer to read index data from, initially `null`.

    : <dfn>\[[index_format]]</dfn>, of type {{GPUIndexFormat}}
    ::
        The format of the index data in {{GPURenderEncoderBase/[[index_buffer]]}}.

    : <dfn>\[[index_buffer_size]]</dfn>, of type {{GPUSize64}}
    ::
        The size in bytes of the section of {{GPURenderEncoderBase/[[index_buffer]]}} currently set,
        initially `0`.

    : <dfn>\[[vertex_buffers]]</dfn>, of type [=ordered map=]&lt;slot, {{GPUBuffer}}&gt;
    ::
        The current {{GPUBuffer}}s to read vertex data from for each slot, initially empty.

    : <dfn>\[[vertex_buffer_sizes]]</dfn>, of type [=ordered map=]&lt;slot, {{GPUSize64}}&gt;
    ::
        The size in bytes of the section of {{GPUBuffer}} currently set for each slot, initially
        empty.
</dl>

{{GPURenderPassEncoder}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPURenderPassEncoder">
    : <dfn>\[[attachment_size]]</dfn>
    ::
        Set to the following extents:
            - `width, height` = the dimensions of the pass's render attachments

    : <dfn>\[[occlusion_query_set]]</dfn>, of type {{GPUQuerySet}}.
    ::
        The {{GPUQuerySet}} to store occlusion query results for the pass, which is initialized with
        {{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/occlusionQuerySet}} at pass creation time.

    : <dfn>\[[occlusion_query_active]]</dfn>, of type {{boolean}}.
    ::
        Whether the pass's {{GPURenderPassEncoder/[[occlusion_query_set]]}} is being written.

    : <dfn>\[[viewport]]</dfn>
    ::  Current viewport rectangle and depth range.

    : <dfn>\[[endTimestampWrites]]</dfn>, of type {{GPURenderPassTimestampWrites}}
    ::
        The timestamp attachments which need to be executed when the pass ends.
</dl>

When a {{GPURenderPassEncoder}} is created, it has the following default state:
  * {{GPURenderPassEncoder/[[viewport]]}}:
      * `x, y` = `0.0, 0.0`
      * `width, height` = the dimensions of the pass's render targets
      * `minDepth, maxDepth` = `0.0, 1.0`
  * Scissor rectangle:
      * `x, y` = `0, 0`
      * `width, height` = the dimensions of the pass's render targets

### Creation ### {#render-pass-encoder-creation}

<script type=idl>
enum GPURenderPassTimestampLocation {
    "beginning",
    "end",
};

dictionary GPURenderPassTimestampWrite {
    required GPUQuerySet querySet;
    required GPUSize32 queryIndex;
    required GPURenderPassTimestampLocation location;
};

typedef sequence<GPURenderPassTimestampWrite> GPURenderPassTimestampWrites;

dictionary GPURenderPassDescriptor : GPUObjectDescriptorBase {
    required sequence<GPURenderPassColorAttachment> colorAttachments;
    GPURenderPassDepthStencilAttachment depthStencilAttachment;
    GPUQuerySet occlusionQuerySet;
    GPURenderPassTimestampWrites timestampWrites = [];
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDescriptor>
    : <dfn>colorAttachments</dfn>
    ::
        The set of {{GPURenderPassColorAttachment}} values in this sequence defines which
        color attachments will be output to when executing this render pass.

        Due to [=compatible usage list|usage compatibility=], no color attachment
        may alias another attachment or any resource used inside the render pass.

    : <dfn>depthStencilAttachment</dfn>
    ::
        The {{GPURenderPassDepthStencilAttachment}} value that defines the depth/stencil
        attachment that will be output to and tested against when executing this render pass.

        Due to [=compatible usage list|usage compatibility=], no writable depth/stencil attachment
        may alias another attachment or any resource used inside the render pass.

    : <dfn>occlusionQuerySet</dfn>
    ::
        The {{GPUQuerySet}} value defines where the occlusion query results will be stored for this pass.

    : <dfn>timestampWrites</dfn>
    ::
        A sequence of {{GPURenderPassTimestampWrite}} values defines where and when timestamp values will be written for this pass.
</dl>

<div class=validusage dfn-for=GPURenderPassDescriptor>
    <dfn abstract-op>Valid Usage</dfn>

    Given a {{GPURenderPassDescriptor}} |this| the following validation rules apply:

    1. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length must be less than or equal to 8.
    1. |this|.{{GPURenderPassDescriptor/colorAttachments}}.length must be greater than `0` or
        |this|.{{GPURenderPassDescriptor/depthStencilAttachment}} must not be `null`.
    1. For each |colorAttachment| in |this|.{{GPURenderPassDescriptor/colorAttachments}}:

        1. |colorAttachment| must meet the [$GPURenderPassColorAttachment/GPURenderPassColorAttachment Valid Usage$] rules.

    1. If |this|.{{GPURenderPassDescriptor/depthStencilAttachment}} is not `null`:

        1. |this|.{{GPURenderPassDescriptor/depthStencilAttachment}} must meet the [$GPURenderPassDepthStencilAttachment/GPURenderPassDepthStencilAttachment Valid Usage$] rules.

    1. All {{GPURenderPassColorAttachment/view}}s in |this|.{{GPURenderPassDescriptor/colorAttachments}},
        and |this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}}
        if present, must have equal {{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}s.

    1. For each {{GPURenderPassColorAttachment/view}} in |this|.{{GPURenderPassDescriptor/colorAttachments}}
        and |this|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}},
        if present, the {{GPUTextureView/[[renderExtent]]}} must match.

    1. If |this|.{{GPURenderPassDescriptor/occlusionQuerySet}} is not `null`:

        1. |this|.{{GPURenderPassDescriptor/occlusionQuerySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}}
            must be {{GPUQueryType/occlusion}}.

    1. For each |timestampWrite| in |this|.{{GPURenderPassDescriptor/timestampWrites}}:

        1. |timestampWrite|.{{GPURenderPassTimestampWrite/querySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/type}} is {{GPUQueryType/"timestamp"}}.

        1. |timestampWrite|.{{GPURenderPassTimestampWrite/queryIndex}} &lt; |timestampWrite|.{{GPURenderPassTimestampWrite/querySet}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}.

    Issue(gpuweb/gpuweb#503): support for no attachments
</div>

<div algorithm="GPURenderPassDescriptor accessors" dfn-for=RenderPassDescriptor>
    For a given {{GPURenderPassDescriptor}} value |descriptor|, the syntax:

      - |descriptor|.<dfn dfn>renderExtent</dfn> refers to
        {{GPUTextureView/[[renderExtent]]}} of any {{GPUTextureView/[[descriptor]]}}
        in either |descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}.{{GPURenderPassDepthStencilAttachment/view}},
        or any of the {{GPURenderPassColorAttachment/view}} in |descriptor|.{{GPURenderPassDescriptor/colorAttachments}}.

    Issue: make it a define once we reference to this from other places

    Note: the [$GPURenderPassDescriptor/Valid Usage$] guarantees that all of the render extents
    of the attachments are the same, so we can take any of them, assuming the descriptor is valid.
</div>

#### Color Attachments #### {#color-attachments}

<script type=idl>
dictionary GPURenderPassColorAttachment {
    required GPUTextureView view;
    GPUTextureView resolveTarget;

    required (GPULoadOp or GPUColor) loadValue;
    required GPUStoreOp storeOp;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassColorAttachment>
    : <dfn>view</dfn>
    ::
        A {{GPUTextureView}} describing the texture [=subresource=] that will be output to for this
        color attachment.

    : <dfn>resolveTarget</dfn>
    ::
        A {{GPUTextureView}} describing the texture [=subresource=] that will receive the resolved
        output for this color attachment if {{GPURenderPassColorAttachment/view}} is
        multisampled.

    : <dfn>loadValue</dfn>
    ::
        If a {{GPULoadOp}}, indicates the load operation to perform on
        {{GPURenderPassColorAttachment/view}} prior to executing the render pass.
        If a {{GPUColor}}, indicates the value to clear {{GPURenderPassColorAttachment/view}}
        to prior to executing the render pass.

        Note: It is recommended to prefer a clear-value; see {{GPULoadOp/"load"}}.

    : <dfn>storeOp</dfn>
    ::
        The store operation to perform on {{GPURenderPassColorAttachment/view}}
        after executing the render pass.
</dl>

<div class=validusage dfn-for=GPURenderPassColorAttachment>
    <dfn abstract-op>GPURenderPassColorAttachment Valid Usage</dfn>

    Given a {{GPURenderPassColorAttachment}} |this|:

    1. Let |renderViewDescriptor| be |this|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.
    1. Let |resolveViewDescriptor| be |this|.{{GPURenderPassColorAttachment/resolveTarget}}.{{GPUTextureView/[[descriptor]]}}.
    1. Let |renderTextureDescriptor| be |this|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.
    1. Let |resolveTextureDescriptor| be |this|.{{GPURenderPassColorAttachment/resolveTarget}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.

    The following validation rules apply:

    - |renderViewDescriptor|.{{GPUTextureViewDescriptor/format}} must be a [=color renderable format=].
    - |this|.{{GPURenderPassColorAttachment/view}} must be a [$renderable texture view$].
    - If |this|.{{GPURenderPassColorAttachment/resolveTarget}} is not `null`:
        - |renderTextureDescriptor|.{{GPUTextureDescriptor/sampleCount}} must be greater than 1.
        - |resolveTextureDescriptor|.{{GPUTextureDescriptor/sampleCount}} must be 1.
        - |this|.{{GPURenderPassColorAttachment/resolveTarget}} must be a [$renderable texture view$].
        - The sizes of the [=subresource=]s seen by |this|.{{GPURenderPassColorAttachment/resolveTarget}}
            and |this|.{{GPURenderPassColorAttachment/view}} must match.
        - |resolveViewDescriptor|.{{GPUTextureViewDescriptor/format}} must equal
            |renderViewDescriptor|.{{GPUTextureViewDescriptor/format}}.
        - |resolveViewDescriptor|.{{GPUTextureViewDescriptor/format}} must support resolve according to [[#plain-color-formats]].
</div>

<div algorithm>
    A {{GPUTextureView}} |view| is a <dfn abstract-op>renderable texture view</dfn>
    if the following requirements are met:

    - |view|.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/usage}}
        must contain {{GPUTextureUsage/RENDER_ATTACHMENT}}.
    - |descriptor|.{{GPUTextureViewDescriptor/dimension}} must be {{GPUTextureViewDimension/"2d"}}.
    - |descriptor|.{{GPUTextureViewDescriptor/mipLevelCount}} must be 1.
    - |descriptor|.{{GPUTextureViewDescriptor/arrayLayerCount}} must be 1.
    - |descriptor|.{{GPUTextureViewDescriptor/aspect}} must refer to all [=aspects=] of
        |view|.{{GPUTextureView/[[texture]]}}.

    where |descriptor| is |view|.{{GPUTextureView/[[descriptor]]}}.
</div>

#### Depth/Stencil Attachments #### {#depth-stencil-attachments}

<script type=idl>
dictionary GPURenderPassDepthStencilAttachment {
    required GPUTextureView view;

    required (GPULoadOp or float) depthLoadValue;
    required GPUStoreOp depthStoreOp;
    boolean depthReadOnly = false;

    required (GPULoadOp or GPUStencilValue) stencilLoadValue;
    required GPUStoreOp stencilStoreOp;
    boolean stencilReadOnly = false;
};
</script>

<dl dfn-type=dict-member dfn-for=GPURenderPassDepthStencilAttachment>
    : <dfn>view</dfn>
    ::
        A {{GPUTextureView}} describing the texture [=subresource=] that will be output to
        and read from for this depth/stencil attachment.

    : <dfn>depthLoadValue</dfn>
    ::
        If this is a {{GPULoadOp}}, it indicates the load operation to perform on
        {{GPURenderPassDepthStencilAttachment/view}}'s depth component prior to
        executing the render pass.

        Otherwise, this is a `float` indicating the value to clear {{GPURenderPassDepthStencilAttachment/view}}'s
        depth component to prior to executing the render pass.
        Must be between 0.0 and 1.0, inclusive. <!-- unless unrestricted depth is enabled -->

        Note: It is recommended to prefer a clear-value; see {{GPULoadOp/"load"}}.

    : <dfn>depthStoreOp</dfn>
    ::
        The store operation to perform on {{GPURenderPassDepthStencilAttachment/view}}'s
        depth component after executing the render pass.

        Note: It is recommended to prefer a clear-value; see {{GPULoadOp/"load"}}.

    : <dfn>depthReadOnly</dfn>
    ::
        Indicates that the depth component of {{GPURenderPassDepthStencilAttachment/view}}
        is read only.

    : <dfn>stencilLoadValue</dfn>
    ::
        If a {{GPULoadOp}}, indicates the load operation to perform on
        {{GPURenderPassDepthStencilAttachment/view}}'s stencil component prior to
        executing the render pass.
        If a {{GPUStencilValue}}, indicates the value to clear
        {{GPURenderPassDepthStencilAttachment/view}}'s stencil component to prior to
        executing the render pass.

    : <dfn>stencilStoreOp</dfn>
    ::
        The store operation to perform on {{GPURenderPassDepthStencilAttachment/view}}'s
        stencil component after executing the render pass.

    : <dfn>stencilReadOnly</dfn>
    ::
        Indicates that the stencil component of {{GPURenderPassDepthStencilAttachment/view}}
        is read only.
</dl>

<div class=validusage dfn-for=GPURenderPassDepthStencilAttachment>
    <dfn abstract-op>GPURenderPassDepthStencilAttachment Valid Usage</dfn>

    Given a {{GPURenderPassDepthStencilAttachment}} |this|, the following validation
    rules apply:

    - |this|.{{GPURenderPassDepthStencilAttachment/view}} must have a [=depth-or-stencil format=].
    - |this|.{{GPURenderPassDepthStencilAttachment/view}} must be a [$renderable texture view$].
    - If |this|.{{GPURenderPassDepthStencilAttachment/depthLoadValue}} is a clear value (has type `float`),
        it must be between 0.0 and 1.0, inclusive. <!-- unless unrestricted depth is enabled -->
    - If |this|.{{GPURenderPassDepthStencilAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}
        is a [=combined depth-stencil format=]:
        - |this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}} must be equal to |this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}}
    - If |this|.{{GPURenderPassDepthStencilAttachment/depthReadOnly}} is `true`:
        - |this|.{{GPURenderPassDepthStencilAttachment/depthLoadValue}} must be {{GPULoadOp/"load"}}.
        - |this|.{{GPURenderPassDepthStencilAttachment/depthStoreOp}} must be {{GPUStoreOp/"store"}}.
    - If |this|.{{GPURenderPassDepthStencilAttachment/stencilReadOnly}} is `true`:
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilLoadValue}} must be {{GPULoadOp/"load"}}.
        - |this|.{{GPURenderPassDepthStencilAttachment/stencilStoreOp}} must be {{GPUStoreOp/"store"}}.
</div>

#### Load &amp; Store Operations #### {#load-and-store-ops}

<script type=idl>
enum GPULoadOp {
    "load",
};
</script>

<dl dfn-type=enum-value dfn-for=GPULoadOp>
    : <dfn>"load"</dfn>
    ::
        Loads the existing value for this attachment into the render pass.

        Note:
        On some GPU hardware (primarily mobile), providing a clear-value is significantly cheaper
        because it avoids loading data from main memory into tile-local memory.
        On other GPU hardware, there isn't a significant difference. As a result, it is
        recommended to use a clear-value, rather than {{GPULoadOp/"load"}}, in cases where the
        initial value doesn't matter (e.g. the render target will be cleared using a skybox).
</dl>

<script type=idl>
enum GPUStoreOp {
    "store",
    "discard",
};
</script>

#### Render Pass Layout #### {#render-pass-layout}

{{GPURenderPassLayout}} contains the layout of the render targets for the current pass,
which determines the compatibility of the pass with render pipelines.

<script type=idl>
dictionary GPURenderPassLayout: GPUObjectDescriptorBase {
    required sequence<GPUTextureFormat> colorFormats;
    GPUTextureFormat depthStencilFormat;
    GPUSize32 sampleCount = 1;
};
</script>

<div algorithm>
    <dfn abstract-op>derive render targets layout from pass</dfn>

    **Arguments:**
    - {{GPURenderPassDescriptor}} |descriptor|

    **Returns:** {{GPURenderPassLayout}}

    1. Let |layout| be a new {{GPURenderPassLayout}} object.
    1. For each |colorAttachment| in |descriptor|.{{GPURenderPassDescriptor/colorAttachments}}:
        1. Set |layout|.{{GPURenderPassLayout/sampleCount}} to |colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}.
        1. Append |colorAttachment|.{{GPURenderPassColorAttachment/view}}.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}} to |layout|.{{GPURenderPassLayout/colorFormats}}.
    1. Let |depthStencilAttachment| be |descriptor|.{{GPURenderPassDescriptor/depthStencilAttachment}}.
    1. If |depthStencilAttachment| is not `null`:
        1. Let |view| be |depthStencilAttachment|.{{GPURenderPassDepthStencilAttachment/view}}
        1. Set |layout|.{{GPURenderPassLayout/sampleCount}} to |view|.{{GPUTextureView/[[texture]]}}.{{GPUTexture/[[descriptor]]}}.{{GPUTextureDescriptor/sampleCount}}.
        1. Set |layout|.{{GPURenderPassLayout/depthStencilFormat}} to |view|.{{GPUTextureView/[[descriptor]]}}.{{GPUTextureViewDescriptor/format}}.
    1. Return |layout|.

</div>

<div algorithm>
    <dfn abstract-op>derive render targets layout from pipeline</dfn>

    **Arguments:**
    - {{GPURenderPipelineDescriptor}} |descriptor|

    **Returns:** {{GPURenderPassLayout}}

    1. Let |layout| be a new {{GPURenderPassLayout}} object.
    1. Set |layout|.{{GPURenderPassLayout/sampleCount}} to |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}.
    1. If |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}} is not `null`:
        1. Set |layout|.{{GPURenderPassLayout/depthStencilFormat}} to |descriptor|.{{GPURenderPipelineDescriptor/depthStencil}}/{{GPUDepthStencilState/format}}.
    1. If |descriptor|.{{GPURenderPipelineDescriptor/fragment}} is not `null`:
        1. For each |colorTarget| in |descriptor|.{{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}:
            1. Append |colorTarget|.{{GPUColorTargetState/format}} to |layout|.{{GPURenderPassLayout/colorFormats}}
    1. Return |layout|.

</div>

### Drawing ### {#render-pass-encoder-drawing}

<dl dfn-type=method dfn-for=GPURenderEncoderBase>
    : <dfn>setPipeline(pipeline)</dfn>
    ::
        Sets the current {{GPURenderPipeline}}.

        <div algorithm="GPURenderEncoderBase.setPipeline">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setPipeline(pipeline)">
                |pipeline|: The render pipeline to use for subsequent drawing commands.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. Let |pipelineTargetsLayout| be [$derive render targets layout from pipeline$](|pipeline|.{{GPURenderPipeline/[[descriptor]]}}).
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |pipeline| is [$valid to use with$] |this|.
                        - |this|.{{GPURenderEncoderBase/[[layout]]}} equals |pipelineTargetsLayout|.
                        - If |pipeline|.{{GPURenderPipeline/[[writesDepth]]}}:
                            |this|.{{GPURenderEncoderBase/[[depthReadOnly]]}} must be `false`.
                        - If |pipeline|.{{GPURenderPipeline/[[writesStencil]]}}:
                            |this|.{{GPURenderEncoderBase/[[stencilReadOnly]]}} must be `false`.
                    </div>
                1. Set |this|.{{GPURenderEncoderBase/[[pipeline]]}} to be |pipeline|.

                Issue: define what "equals" means for {{GPURenderPassLayout}} here.
            </div>
        </div>

    : <dfn>setIndexBuffer(buffer, indexFormat, offset, size)</dfn>
    ::
        Sets the current index buffer.

        <div algorithm="GPURenderEncoderBase.setIndexBuffer">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setIndexBuffer(buffer, indexFormat, offset, size)">
                |buffer|: Buffer containing index data to use for subsequent drawing commands.
                |indexFormat|: Format of the index data contained in |buffer|.
                |offset|: Offset in bytes into |buffer| where the index data begins. Defaults to `0`.
                |size|: Size in bytes of the index data in |buffer|.
                    Defaults to the size of the buffer minus the offset.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If |size| is missing, set |size| to max(0, |buffer|.{{GPUBuffer/[[size]]}} - |offset|).
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |buffer| is [$valid to use with$] |this|.
                        - |buffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/INDEX}}.
                        - |offset| is a multiple of |indexFormat|'s byte size.
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/[[size]]}}.
                    </div>
                1. Add |buffer| to the [=usage scope=] as [=internal usage/input=].
                1. Set |this|.{{GPURenderEncoderBase/[[index_buffer]]}} to be |buffer|.
                1. Set |this|.{{GPURenderEncoderBase/[[index_format]]}} to be |indexFormat|.
                1. Set |this|.{{GPURenderEncoderBase/[[index_buffer_size]]}} to be |size|.
            </div>
        </div>

    : <dfn>setVertexBuffer(slot, buffer, offset, size)</dfn>
    ::
        Sets the current vertex buffer for the given slot.

        <div algorithm="GPURenderEncoderBase.setVertexBuffer">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/setVertexBuffer(slot, buffer, offset, size)">
                |slot|: The vertex buffer slot to set the vertex buffer for.
                |buffer|: Buffer containing vertex data to use for subsequent drawing commands.
                |offset|: Offset in bytes into |buffer| where the vertex data begins. Defaults to `0`.
                |size|: Size in bytes of the vertex data in |buffer|.
                    Defaults to the size of the buffer minus the offset.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If |size| is missing, set |size| to max(0, |buffer|.{{GPUBuffer/[[size]]}} - |offset|).
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - |buffer| is [$valid to use with$] |this|.
                        - |buffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/VERTEX}}.
                        - |slot| &lt; |this|.{{GPUObjectBase/[[device]]}}.{{device/[[limits]]}}.{{supported limits/maxVertexBuffers}}.
                        - |offset| is a multiple of 4.
                        - |offset| + |size| &le; |buffer|.{{GPUBuffer/[[size]]}}.
                    </div>
                1. Add |buffer| to the [=usage scope=] as [=internal usage/input=].
                1. Set |this|.{{GPURenderEncoderBase/[[vertex_buffers]]}}[|slot|] to be |buffer|.
                1. Set |this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|] to be |size|.
            </div>
        </div>

    : <dfn>draw(vertexCount, instanceCount, firstVertex, firstInstance)</dfn>
    ::
        Draws primitives.
        See [[#rendering-operations]] for the detailed specification.

        <div algorithm="GPURenderEncoderBase.draw">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/draw(vertexCount, instanceCount, firstVertex, firstInstance)">
                |vertexCount|: The number of vertices to draw.
                |instanceCount|: The number of instances to draw.
                |firstVertex|: Offset into the vertex buffers, in vertices, to begin drawing from.
                |firstInstance|: First instance to draw.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                <div class=validusage>
                    - It is [$valid to draw$] with |this|.
                    - Let |buffers| be |this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.
                    - For each {{GPUIndex32}} |slot| `0` to |buffers|.length:
                        - Let |bufferSize| be |this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|].
                        - Let |stride| be |buffers|[|slot|].{{GPUVertexBufferLayout/arrayStride}}.
                        - If |stride| is zero:
                            - For each attribute |attrib| in the list |this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.{{GPUVertexBufferLayout/attributes}}:
                                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                                    |bufferSize|

                            Otherwise:

                            - If |buffers|[|slot|].{{GPUVertexBufferLayout/stepMode}} is:
                                <dl class="switch">
                                    : {{GPUVertexStepMode/"vertex"}}
                                    :: (|firstVertex| + |vertexCount|) * |stride| &le; |bufferSize|.
                                    : {{GPUVertexStepMode/"instance"}}
                                    :: (|firstInstance| + |instanceCount|) * |stride| &le; |bufferSize|.
                                </dl>
                </div>
            </div>
        </div>

    : <dfn>drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)</dfn>
    ::
        Draws indexed primitives.
        See [[#rendering-operations]] for the detailed specification.

        <div algorithm="GPURenderEncoderBase.drawIndexed">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)">
                |indexCount|: The number of indices to draw.
                |instanceCount|: The number of instances to draw.
                |firstIndex|: Offset into the index buffer, in indices, begin drawing from.
                baseVertex: Added to each index value before indexing into the vertex buffers.
                |firstInstance|: First instance to draw.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                <div class=validusage>
                    - It is [$valid to draw indexed$] with |this|.
                    - |firstIndex| + |indexCount| &le; |this|.{{GPURenderEncoderBase/[[index_buffer_size]]}}
                        &div; |this|.{{GPURenderEncoderBase/[[index_format]]}}'s byte size;
                    - Let |buffers| be |this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.
                    - For each {{GPUIndex32}} |slot| `0` to |buffers|.length:
                        - Let |bufferSize| be |this|.{{GPURenderEncoderBase/[[vertex_buffer_sizes]]}}[|slot|].
                        - Let |stride| be |buffers|[|slot|].{{GPUVertexBufferLayout/arrayStride}}.
                        - If |stride| is zero:
                            - For each attribute |attrib| in the list |this|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.{{GPUVertexBufferLayout/attributes}}:
                                - |attrib|.{{GPUVertexAttribute/offset}} + sizeof(|attrib|.{{GPUVertexAttribute/format}}) &le;
                                    |bufferSize|

                            Otherwise:

                            - If |buffers|[|slot|].{{GPUVertexBufferLayout/stepMode}} is {{GPUVertexStepMode/"instance"}}:
                                - (|firstInstance| + |instanceCount|) * |stride| &le; |bufferSize|.
                </div>
            </div>
        </div>

    : <dfn>drawIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        Draws primitives using parameters read from a {{GPUBuffer}}.
        See [[#rendering-operations]] for the detailed specification.

        The <dfn dfn for=>indirect draw parameters</dfn> encoded in the buffer must be a tightly
        packed block of **four 32-bit unsigned integer values (16 bytes total)**, given in the same
        order as the arguments for {{GPURenderEncoderBase/draw()}}. For example:

        <pre highlight="js">
            let drawIndirectParameters = new Uint32Array(4);
            drawIndirectParameters[0] = vertexCount;
            drawIndirectParameters[1] = instanceCount;
            drawIndirectParameters[2] = firstVertex;
            drawIndirectParameters[3] = firstInstance;
        </pre>

        The value corresponding to `firstInstance` must be 0, unless the {{GPUFeatureName/"indirect-first-instance"}}
        [=feature=] is enabled.  If the {{GPUFeatureName/"indirect-first-instance"}} [=feature=] is not enabled and
        `firstInstance` is not zero the {{GPURenderEncoderBase/drawIndirect()}} call will be treated as a no-op.

        <div algorithm="GPURenderEncoderBase.drawIndirect">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: Buffer containing the [=indirect draw parameters=].
                |indirectOffset|: Offset in bytes into |indirectBuffer| where the drawing data begins.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - It is [$valid to draw$] with |this|.
                        - |indirectBuffer| is [$valid to use with$] |this|.
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect draw parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}.
                        - |indirectOffset| is a multiple of 4.
                    </div>
                1. Add |indirectBuffer| to the [=usage scope=] as [=internal usage/input=].
            </div>
        </div>

    : <dfn>drawIndexedIndirect(indirectBuffer, indirectOffset)</dfn>
    ::
        Draws indexed primitives using parameters read from a {{GPUBuffer}}.
        See [[#rendering-operations]] for the detailed specification.

        The <dfn dfn for=>indirect drawIndexed parameters</dfn> encoded in the buffer must be a
        tightly packed block of **five 32-bit unsigned integer values (20 bytes total)**, given in
        the same order as the arguments for {{GPURenderEncoderBase/drawIndexed()}}. For example:

        <pre highlight="js">
            let drawIndexedIndirectParameters = new Uint32Array(5);
            drawIndexedIndirectParameters[0] = indexCount;
            drawIndexedIndirectParameters[1] = instanceCount;
            drawIndexedIndirectParameters[2] = firstIndex;
            drawIndexedIndirectParameters[3] = baseVertex;
            drawIndexedIndirectParameters[4] = firstInstance;
        </pre>

        The value corresponding to `firstInstance` must be 0, unless the {{GPUFeatureName/"indirect-first-instance"}}
        [=feature=] is enabled.  If the {{GPUFeatureName/"indirect-first-instance"}} [=feature=] is not enabled and
        `firstInstance` is not zero the {{GPURenderEncoderBase/drawIndexedIndirect()}} call will be treated as a no-op.

        <div algorithm="GPURenderEncoderBase.drawIndexedIndirect">
            **Called on:** {{GPURenderEncoderBase}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderEncoderBase/drawIndexedIndirect(indirectBuffer, indirectOffset)">
                |indirectBuffer|: Buffer containing the [=indirect drawIndexed parameters=].
                |indirectOffset|: Offset in bytes into |indirectBuffer| where the drawing data begins.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, make |this| [=invalid=] and stop.
                    <div class=validusage>
                        - It is [$valid to draw indexed$] with |this|.
                        - |indirectBuffer| is [$valid to use with$] |this|.
                        - |indirectBuffer|.{{GPUBuffer/[[usage]]}} contains {{GPUBufferUsage/INDIRECT}}.
                        - |indirectOffset| + sizeof([=indirect drawIndexed parameters=]) &le;
                            |indirectBuffer|.{{GPUBuffer/[[size]]}}.
                        - |indirectOffset| is a multiple of 4.
                    </div>
                1. Add |indirectBuffer| to the [=usage scope=] as [=internal usage/input=].
            </div>
        </div>
</dl>

<div algorithm>
    To determine if it's <dfn abstract-op>valid to draw</dfn> with {{GPURenderEncoderBase}} |encoder|
    run the following steps:

    If any of the following conditions are unsatisfied, return `false`:
        <div class=validusage>
            - [$Validate encoder bind groups$](|encoder|, |encoder|.{{GPURenderEncoderBase/[[pipeline]]}})
                must be `true`.

            - Let |pipelineDescriptor| be |encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.
            - For each {{GPUIndex32}} |slot| `0` to
                |pipelineDescriptor|.{{GPURenderPipelineDescriptor/vertex}}.{{GPUVertexState/buffers}}.length:
                - |encoder|.{{GPURenderEncoderBase/[[vertex_buffers]]}}[|slot|] must not be `null`.
        </div>

    Otherwise return `true`.
</div>

<div algorithm>
    To determine if it's <dfn abstract-op>valid to draw indexed</dfn> with {{GPURenderEncoderBase}} |encoder|
    run the following steps:

    If any of the following conditions are unsatisfied, return `false`:
        <div class=validusage>
            - It must be [$valid to draw$] with |encoder|.

            - |encoder|.{{GPURenderEncoderBase/[[index_buffer]]}} must not be `null`.
            - Let |topology| be |encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}.
            - If |topology| is {{GPUPrimitiveTopology/"line-strip"}} or {{GPUPrimitiveTopology/"triangle-strip"}}:
                - |encoder|.{{GPURenderEncoderBase/[[index_format]]}} must equal
                    |encoder|.{{GPURenderEncoderBase/[[pipeline]]}}.{{GPURenderPipeline/[[descriptor]]}}.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/stripIndexFormat}}.
        </div>

    Otherwise return `true`.
</div>

### Rasterization state ### {#render-pass-encoder-rasterization-state}

The {{GPURenderPassEncoder}} has several methods which affect how draw commands are rasterized to
attachments used by this encoder.

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>setViewport(x, y, width, height, minDepth, maxDepth)</dfn>
    ::
        Sets the viewport used during the rasterization stage to linearly map from normalized device
        coordinates to viewport coordinates.

        <div algorithm="GPURenderPassEncoder.setViewport">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setViewport(x, y, width, height, minDepth, maxDepth)">
                |x|: Minimum X value of the viewport in pixels.
                |y|: Minimum Y value of the viewport in pixels.
                |width|: Width of the viewport in pixels.
                |height|: Height of the viewport in pixels.
                |minDepth|: Minimum depth value of the viewport.
                |maxDepth|: Maximum depth value of the viewport.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |x| is greater than or equal to `0`.
                        - |y| is greater than or equal to `0`.
                        - |width| is greater than or equal to `0`.
                        - |height| is greater than or equal to `0`.
                        - |x| + |width| is less than or equal to
                            |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width.
                        - |y| + |height| is less than or equal to
                            |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height.
                        - |minDepth| is greater than or equal to `0.0` and less than or equal to `1.0`.
                        - |maxDepth| is greater than or equal to `0.0` and less than or equal to `1.0`.
                        - |maxDepth| is greater than |minDepth|.
                    </div>
                1. Set |this|.{{GPURenderPassEncoder/[[viewport]]}} to the extents |x|, |y|, |width|, |height|, |minDepth|, and |maxDepth|.
            </div>

            Issue: Allowed for GPUs to use fixed point or rounded viewport coordinates
        </div>

    : <dfn>setScissorRect(x, y, width, height)</dfn>
    ::
        Sets the scissor rectangle used during the rasterization stage.
        After transformation into viewport coordinates any fragments which fall outside the scissor
        rectangle will be discarded.

        <div algorithm="GPURenderPassEncoder.setScissorRect">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setScissorRect(x, y, width, height)">
                |x|: Minimum X value of the scissor rectangle in pixels.
                |y|: Minimum Y value of the scissor rectangle in pixels.
                |width|: Width of the scissor rectangle in pixels.
                |height|: Height of the scissor rectangle in pixels.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |x|+|width| is less than or equal to
                            |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.width.
                        - |y|+|height| is less than or equal to
                            |this|.{{GPURenderPassEncoder/[[attachment_size]]}}.height.
                    </div>
                1. Set the scissor rectangle to the extents |x|, |y|, |width|, and |height|.
            </div>
        </div>

    : <dfn>setBlendConstant(color)</dfn>
    ::
        Sets the constant blend color and alpha values used with {{GPUBlendFactor/"constant"}}
        and {{GPUBlendFactor/"one-minus-constant"}} {{GPUBlendFactor}}s.

        <div algorithm="GPURenderPassEncoder.setBlendConstant">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setBlendConstant(color)">
                color: The color to use when blending.
            </pre>
        </div>

    : <dfn>setStencilReference(reference)</dfn>
    ::
        Sets the stencil reference value used during stencil tests with the the
        {{GPUStencilOperation/"replace"}} {{GPUStencilOperation}}.

        <div algorithm="GPURenderPassEncoder.setStencilReference">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/setStencilReference(reference)">
                reference: The stencil reference value.
            </pre>
        </div>
</dl>

### Queries ### {#render-pass-encoder-queries}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>beginOcclusionQuery(queryIndex)</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.beginOcclusionQuery">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/beginOcclusionQuery(queryIndex)">
                |queryIndex|: The index of the query in the query set.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                    <div class=validusage>
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}} is not `null`.
                        - |queryIndex| &lt; |this|.{{GPURenderPassEncoder/[[occlusion_query_set]]}}.{{GPUQuerySet/[[descriptor]]}}.{{GPUQuerySetDescriptor/count}}.
                        - The query at same |queryIndex| must not have been previously written to in this pass.
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} is `false`.
                    </div>

                1. Set |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} to `true`.
            </div>
        </div>

    : <dfn>endOcclusionQuery()</dfn>
    ::

        <div algorithm="GPURenderPassEncoder.endOcclusionQuery">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|.{{GPUObjectBase/[[device]]}}:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                    <div class=validusage>
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} is `true`.
                    </div>

                1. Set |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} to `false`.
            </div>
        </div>
</dl>

### Bundles ### {#render-pass-encoder-bundles}

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>executeBundles(bundles)</dfn>
    ::
        Executes the commands previously recorded into the given {{GPURenderBundle}}s as part of
        this render pass.

        When a {{GPURenderBundle}} is executed, it does not inherit the render pass's pipeline, bind
        groups, or vertex and index buffers. After a {{GPURenderBundle}} has executed, the render
        pass's pipeline, bind groups, and vertex and index buffers are cleared.

        Note: state is cleared even if zero {{GPURenderBundle|GPURenderBundles}} are executed.

        <div algorithm="GPURenderPassEncoder.executeBundles">
            **Called on:** {{GPURenderPassEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderPassEncoder/executeBundles(bundles)">
                |bundles|: List of render bundles to execute.
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - For each |bundle| in |bundles|:
                            - |bundle| must be [$valid to use with$] |this|.
                            - |this|.{{GPURenderEncoderBase/[[layout]]}} must equal |bundle|.{{GPURenderBundle/[[layout]]}}.
                            - If |this|.{{GPURenderEncoderBase/[[depthReadOnly]]}} is true, |bundle|.{{GPURenderBundle/[[depthReadOnly]]}} must be true.
                            - If |this|.{{GPURenderEncoderBase/[[stencilReadOnly]]}} is true, |bundle|.{{GPURenderBundle/[[stencilReadOnly]]}} must be true.
                    </div>
            </div>

        </div>
</dl>

### Finalization ### {#render-pass-encoder-finalization}

The render pass encoder can be ended by calling {{GPURenderPassEncoder/endPass()}} once the user
has finished recording commands for the pass. Once {{GPURenderPassEncoder/endPass()}} has been
called the render pass encoder can no longer be used.

<dl dfn-type=method dfn-for=GPURenderPassEncoder>
    : <dfn>endPass()</dfn>
    ::
        Completes recording of the render pass commands sequence.

        <div algorithm="GPURenderPassEncoder.endPass">
            **Called on:** {{GPURenderPassEncoder}} |this|.

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following requirements are unmet,
                    generate a {{GPUValidationError}} and stop.
                    <div class=validusage>
                        - |this|.{{GPUCommandsMixin/[[state]]}} must be "[=encoder state/open=]",
                    </div>
                1. [=Assert=]: |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[state]]}} is "[=encoder state/locked=]".
                1. Set |this|.{{GPUCommandsMixin/[[state]]}} to "[=encoder state/ended=]".
                1. Set |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[state]]}} to "[=encoder state/open=]".
                1. If any of the following requirements are unmet, make
                    |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}} [=invalid=] and stop.
                    <div class=validusage>
                        - |this| must be [=valid=].
                        - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} must be [=list/is empty|be empty=].
                        - |this|.{{GPURenderPassEncoder/[[occlusion_query_active]]}} must be `false`.
                    </div>
                1. [=list/Extend=] |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[commands]]}}
                    with |this|.{{GPUCommandsMixin/[[commands]]}}.
                1. For each |timestampWrite| in |this|.{{GPURenderPassEncoder/[[endTimestampWrites]]}}:
                    1. [=Assert=]: |timestampWrite|.{{GPURenderPassTimestampWrite/location}} is {{GPURenderPassTimestampLocation/"end"}}.
                    1. [=list/Append=] a [=GPU command=] to
                        |this|.{{GPUProgrammablePassEncoder/[[command_encoder]]}}.{{GPUCommandsMixin/[[commands]]}}
                        that writes the GPU's timestamp value into the |timestampWrite|.{{GPURenderPassTimestampWrite/queryIndex}}th
                        index in |timestampWrite|.{{GPURenderPassTimestampWrite/querySet}}.
                1. Issue: Enqueue the attachment stores/discards.
            </div>
        </div>
</dl>

# Bundles # {#bundles}

## <dfn interface>GPURenderBundle</dfn> ## {#render-bundle}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderBundle {
};
GPURenderBundle includes GPUObjectBase;
</script>

<dl dfn-type=attribute dfn-for="GPURenderBundle">
    : <dfn>\[[command_list]]</dfn> of type [=list=]&lt;[=GPU command=]&gt;.
    ::
        A [=list=] of [=GPU commands=] to be submitted to the {{GPURenderPassEncoder}} when the
        {{GPURenderBundle}} is executed.

    : <dfn>\[[layout]]</dfn>, of type {{GPURenderPassLayout}}
    ::
        The layout of the render bundle.

    : <dfn>\[[depthReadOnly]]</dfn>, of type boolean?
    ::
        If present, indicates that the depth component is not modified by executing this render bundle.

    : <dfn>\[[stencilReadOnly]]</dfn>, of type boolean?
    ::
        If present, indicates that the stencil component is not modified by executing this render bundle.
</dl>

### Creation ### {#render-bundle-creation}

<script type=idl>
dictionary GPURenderBundleDescriptor : GPUObjectDescriptorBase {
};
</script>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPURenderBundleEncoder {
    GPURenderBundle finish(optional GPURenderBundleDescriptor descriptor = {});
};
GPURenderBundleEncoder includes GPUObjectBase;
GPURenderBundleEncoder includes GPUCommandsMixin;
GPURenderBundleEncoder includes GPUDebugCommandsMixin;
GPURenderBundleEncoder includes GPUProgrammablePassEncoder;
GPURenderBundleEncoder includes GPURenderEncoderBase;
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createRenderBundleEncoder(descriptor)</dfn>
    ::
        Creates a {{GPURenderBundleEncoder}}.

        <div algorithm=GPUDevice.createRenderBundleEncoder>
            **Called on:** {{GPUDevice}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createRenderBundleEncoder(descriptor)">
                |descriptor|: Description of the {{GPURenderBundleEncoder}} to create.
            </pre>

            **Returns:** {{GPURenderBundleEncoder}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation
                    error and stop.
                    <div class=validusage>
                        - |descriptor|.{{GPURenderPassLayout/colorFormats}}.length must be less than or equal to 8.
                        - |descriptor|.{{GPURenderPassLayout/colorFormats}}.length must be greater than `0` or
                            |descriptor|.{{GPURenderPassLayout/depthStencilFormat}} must not be `null`.
                        - For each |colorFormat| in |descriptor|.{{GPURenderPassLayout/colorFormats}}:
                            - |colorFormat| must be a [=color renderable format=].
                        - Let |depthStencilFormat| be |descriptor|.{{GPURenderPassLayout/depthStencilFormat}}.
                        - If |depthStencilFormat| is not `null`:
                            - |depthStencilFormat| must be a [=depth-or-stencil format=].
                            - If |depthStencilFormat| is a [=combined depth-stencil format=]:
                                - |descriptor|.{{GPURenderBundleEncoderDescriptor/depthReadOnly}} must be equal to
                                    |descriptor|.{{GPURenderBundleEncoderDescriptor/stencilReadOnly}}
                    </div>
                1. Let |e| be a new {{GPURenderBundleEncoder}} object.
                1. Set |e|.{{GPURenderEncoderBase/[[layout]]}} to |descriptor|.{{GPURenderPassLayout}}.
                1. Set |e|.{{GPURenderEncoderBase/[[depthReadOnly]]}} to |descriptor|.{{GPURenderBundleEncoderDescriptor/depthReadOnly}}.
                1. Set |e|.{{GPURenderEncoderBase/[[stencilReadOnly]]}} to |descriptor|.{{GPURenderBundleEncoderDescriptor/stencilReadOnly}}.
                1. Set |e|.{{GPUCommandsMixin/[[state]]}} to "[=encoder state/open=]".
                1. Return |e|.

                Issue: Describe the reset of the steps for {{GPUDevice/createRenderBundleEncoder()}}.
            </div>
        </div>
</dl>

### Encoding ### {#render-bundle-encoding}

<script type=idl>
dictionary GPURenderBundleEncoderDescriptor : GPURenderPassLayout {
    boolean depthReadOnly = false;
    boolean stencilReadOnly = false;
};
</script>

### Finalization ### {#render-bundle-finalization}

<dl dfn-type=method dfn-for=GPURenderBundleEncoder>
    : <dfn>finish(descriptor)</dfn>
    ::
        Completes recording of the render bundle commands sequence.

        <div algorithm="GPURenderBundleEncoder.finish">
            **Called on:** {{GPURenderBundleEncoder}} this.

            **Arguments:**
            <pre class=argumentdef for="GPURenderBundleEncoder/finish(descriptor)">
                descriptor:
            </pre>

            **Returns:** {{GPURenderBundle}}

            1. Let |renderBundle| be a new {{GPURenderBundle}}.
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. Let |validationFailed| be `true` if all of the following requirements are met, and `false` otherwise.
                        <div class=validusage>
                            - |this| must be [=valid=].
                            - |this|.{{GPUCommandsMixin/[[state]]}} must be "[=encoder state/open=]".
                            - |this|.{{GPUDebugCommandsMixin/[[debug_group_stack]]}} must [=list/is empty|be empty=].
                            - Every [=usage scope=] contained in |this| must satisfy the [=usage scope validation=].
                        </div>
                    1. Set |this|.{{GPUCommandsMixin/[[state]]}} to "[=encoder state/ended=]".
                    1. If |validationFailed|, then:
                        1. Generate a {{GPUValidationError}} in the current scope with appropriate
                            error message.
                        1. Return a new [=invalid=] {{GPURenderBundle}}.
                    1. Set |renderBundle|.{{GPURenderBundle/[[command_list]]}} to
                        |this|.{{GPUCommandsMixin/[[commands]]}}.
                </div>

            1. Return |renderBundle|.
        </div>
</dl>

# Queues # {#queues}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUQueue {
    undefined submit(sequence<GPUCommandBuffer> commandBuffers);

    Promise<undefined> onSubmittedWorkDone();

    undefined writeBuffer(
        GPUBuffer buffer,
        GPUSize64 bufferOffset,
        [AllowShared] BufferSource data,
        optional GPUSize64 dataOffset = 0,
        optional GPUSize64 size);

    undefined writeTexture(
        GPUImageCopyTexture destination,
        [AllowShared] BufferSource data,
        GPUImageDataLayout dataLayout,
        GPUExtent3D size);

    undefined copyExternalImageToTexture(
        GPUImageCopyExternalImage source,
        GPUImageCopyTextureTagged destination,
        GPUExtent3D copySize);
};
GPUQueue includes GPUObjectBase;
</script>

{{GPUQueue}} has the following methods:

<dl dfn-type=method dfn-for=GPUQueue>
    : <dfn>writeBuffer(buffer, bufferOffset, data, dataOffset, size)</dfn>
    ::
        Issues a write operation of the provided data into a {{GPUBuffer}}.

        <div algorithm=GPUQueue.writeBuffer>
            **Called on:** {{GPUQueue}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/writeBuffer(buffer, bufferOffset, data, dataOffset, size)">
                |buffer|: The buffer to write to.
                |bufferOffset|: Offset in bytes into |buffer| to begin writing at.
                |data|: Data to write into |buffer|.
                |dataOffset|: Offset in into |data| to begin writing from. Given in elements if
                    |data| is a `TypedArray` and bytes otherwise.
                |size|: Size of content to write from |data| to |buffer|. Given in elements if
                    |data| is a `TypedArray` and bytes otherwise.
            </pre>

            **Returns:** {{undefined}}

            1. If |data| is an {{ArrayBuffer}} or {{DataView}}, let the element type be "byte".
                Otherwise, |data| is a TypedArray; let the element type be the type of the TypedArray.
            1. Let |dataSize| be the size of |data|, in elements.
            1. If |size| is missing,
                let |contentsSize| be |dataSize| &minus; |dataOffset|.
                Otherwise, let |contentsSize| be |size|.
            1. If any of the following conditions are unsatisfied,
                throw {{OperationError}} and stop.
                <!-- Note: it's easiest to write the valid usage rules inline
                     here, because they depend on contentsSize above. -->
                <div class=validusage>
                    - |contentsSize| &ge; 0.
                    - |dataOffset| + |contentsSize| &le; |dataSize|.
                    - |contentsSize|, converted to bytes, is a multiple of 4 bytes.
                </div>
            1. Let |dataContents| be [=get a copy of the buffer source|a copy of the bytes held by the buffer source=].
            1. Let |contents| be the |contentsSize| elements of |dataContents| starting at
                an offset of |dataOffset| elements.
            1. Issue the following steps on the [=Queue timeline=] of |this|:
                <div class=queue-timeline>
                    1. If any of the following conditions are unsatisfied,
                        generate a validation error and stop.
                        <div class=validusage>
                            - |buffer| is [$valid to use with$] |this|.
                            - |buffer|.{{GPUBuffer/[[state]]}} is [=buffer state/unmapped=].
                            - |buffer|.{{GPUBuffer/[[usage]]}} includes {{GPUBufferUsage/COPY_DST}}.
                            - |bufferOffset|, converted to bytes, is a multiple of 4 bytes.
                            - |bufferOffset| + |contentsSize|, converted to bytes, &le; |buffer|.{{GPUBuffer/[[size]]}} bytes.
                        </div>
                    1. Write |contents| into |buffer| starting at |bufferOffset|.
                </div>
        </div>

    : <dfn>writeTexture(destination, data, dataLayout, size)</dfn>
    ::
        Issues a write operation of the provided data into a {{GPUTexture}}.

        <div algorithm=GPUQueue.writeTexture>
            **Called on:** {{GPUQueue}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/writeTexture(destination, data, dataLayout, size)">
                |destination|: The [=texture subresource=] and origin to write to.
                |data|: Data to write into |destination|.
                |dataLayout|: Layout of the content in |data|.
                |size|: Extents of the content to write from |data| to |destination|.
            </pre>

            **Returns:** {{undefined}}

            1. Let |dataBytes| be [=get a copy of the buffer source|a copy of the bytes held by the buffer source=] |data|.
            1. Let |dataByteSize| be the number of bytes in |dataBytes|.
            1. Let |textureDesc| be |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.
            1. If any of the following conditions are unsatisfied,
                throw {{OperationError}} and stop.
                <div class=validusage>
                    - [$validating linear texture data$](|dataLayout|,
                        |dataByteSize|,
                        |textureDesc|.{{GPUTextureDescriptor/format}},
                        |size|) succeeds.
                </div>
            1. Let |contents| be the contents of the [=images=] seen by
                viewing |dataBytes| with |dataLayout| and |size|.

                Issue: Specify more formally.
            1. Issue the following steps on the [=Queue timeline=] of |this|:
                <div class=queue-timeline>
                    1. If any of the following conditions are unsatisfied,
                        generate a validation error and stop.
                        <div class=validusage>
                            - [$validating GPUImageCopyTexture$](|destination|, |size|) returns `true`.
                            - |textureDesc|.{{GPUTextureDescriptor/usage}} includes {{GPUTextureUsage/COPY_DST}}.
                            - |textureDesc|.{{GPUTextureDescriptor/sampleCount}} is 1.
                            - [=Valid Texture Copy Range=](|destination|, |size|) is satisfied.
                            - |destination|.{{GPUImageCopyTexture/aspect}} must refer to a single aspect of
                                |textureDesc|.{{GPUTextureDescriptor/format}}, and that aspect must be
                                a valid image copy destination according to [[#depth-formats]].

                            Note: unlike
                            {{GPUCommandEncoder}}.{{GPUCommandEncoder/copyBufferToTexture()}},
                            there is no alignment requirement on either
                            |dataLayout|.{{GPUImageDataLayout/bytesPerRow}} or |dataLayout|.{{GPUImageDataLayout/offset}}.
                        </div>
                    1. Write |contents| into |destination|.

                        Issue: Specify more formally.
                </div>
        </div>

    : <dfn>copyExternalImageToTexture(source, destination, copySize)</dfn>
    ::
        Issues a copy operation of the contents of a platform image/canvas
        into the destination texture.

        This operation performs [[#color-space-conversions|color encoding]] into the destination
        encoding according to the parameters of {{GPUImageCopyTextureTagged}}.

        Copying into a `-srgb` texture results in the same texture bytes, not the same decoded
        values, as copying into the corresponding non-`-srgb` format.
        Thus, after a copy operation, sampling the destination texture has
        different results depending on whether its format is `-srgb`, all else unchanged.

        Issue: If an srgb-linear color space is added, explain here how it interacts.

        <div algorithm=GPUQueue.copyExternalImageToTexture>
            **Called on:** {{GPUQueue}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/copyExternalImageToTexture(source, destination, copySize)">
                |source|: source image and origin to copy to |destination|.
                |destination|: The [=texture subresource=] and origin to write to, and its encoding metadata.
                |copySize|: Extents of the content to write from |source| to |destination|.
            </pre>

            **Returns:** {{undefined}}

            1. Let |sourceImage| be |source|.{{GPUImageCopyExternalImage/source}}
            1. Run [=Check the usability of the image argument=](|sourceImage|).
                If it throws an exception, stop.
                If it does not return `good`, throw an {{InvalidStateError}} and stop.
            1. If |sourceImage| <l spec=html>[=is not origin-clean=]</l>,
                throw a {{SecurityError}} and stop.
            1. If any of the following requirements are unmet, throw an {{OperationError}} and stop.
                <div class=validusage>
                    - If |source|.{{GPUImageCopyExternalImage/source}} is an {{HTMLCanvasElement}}:
                        Its [=canvas context mode=] must be `"2d"`, `"webgl"`, `"webgl2"`, or `"webgpu"`.
                    - If |source|.{{GPUImageCopyExternalImage/source}} is an {{OffscreenCanvas}}:
                        Its [=OffscreenCanvas context mode=] must be `"2d"`, `"webgl"`, `"webgl2"`, or `"webgpu"`.
                    - |source|.|origin|.[=Origin3D/x=] + |copySize|.[=Extent3D/width=]
                        must be &le; the width of |sourceImage|.
                    - |source|.|origin|.[=Origin3D/y=] + |copySize|.[=Extent3D/height=]
                        must be &le; the height of |sourceImage|.
                    - |source|.|origin|.[=Origin3D/z=] + |copySize|.[=Extent3D/depthOrArrayLayers=]
                        must be &le; 1.
                </div>
            1. Issue the following steps on the [=Device timeline=] of |this|:
                <div class=device-timeline>
                    1. Let |textureDesc| be |destination|.{{GPUImageCopyTexture/texture}}.{{GPUTexture/[[descriptor]]}}.
                    1. If any of the following requirements are unmet, generate a validation error and stop.
                        <div class=validusage>
                            - |destination|.{{GPUImageCopyTexture/texture}} must be [$valid to use with$] |this|.
                            - [$validating GPUImageCopyTexture$](destination, copySize) must return true.
                            - [=Valid Texture Copy Range=](destination, copySize) must be satisfied.
                            - |textureDesc|.{{GPUTextureDescriptor/usage}} must include both
                                {{GPUTextureUsage/RENDER_ATTACHMENT}} and {{GPUTextureUsage/COPY_DST}}.
                            - |textureDesc|.{{GPUTextureDescriptor/dimension}} must be {{GPUTextureDimension/"2d"}}.
                            - |textureDesc|.{{GPUTextureDescriptor/sampleCount}} must be 1.
                            - |textureDesc|.{{GPUTextureDescriptor/format}} must be one of the following
                                formats (which all support {{GPUTextureUsage/RENDER_ATTACHMENT}} usage):
                                - {{GPUTextureFormat/"r8unorm"}}
                                - {{GPUTextureFormat/"r16float"}}
                                - {{GPUTextureFormat/"r32float"}}
                                - {{GPUTextureFormat/"rg8unorm"}}
                                - {{GPUTextureFormat/"rg16float"}}
                                - {{GPUTextureFormat/"rg32float"}}
                                - {{GPUTextureFormat/"rgba8unorm"}}
                                - {{GPUTextureFormat/"rgba8unorm-srgb"}}
                                - {{GPUTextureFormat/"bgra8unorm"}}
                                - {{GPUTextureFormat/"bgra8unorm-srgb"}}
                                - {{GPUTextureFormat/"rgb10a2unorm"}}
                                - {{GPUTextureFormat/"rgba16float"}}
                                - {{GPUTextureFormat/"rgba32float"}}
                        </div>
                    1. Issue: Do the actual copy.
                </div>
        </div>

    : <dfn>submit(commandBuffers)</dfn>
    ::
        Schedules the execution of the command buffers by the GPU on this queue.

        <div algorithm=GPUQueue.submit>
            **Called on:** {{GPUQueue}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/submit(commandBuffers)">
                |commandBuffers|:
            </pre>

            **Returns:** {{undefined}}

            Issue the following steps on the [=Device timeline=] of |this|:
            <div class=device-timeline>
                1. If any of the following conditions are unsatisfied, generate a validation error and stop.
                    <div class=validusage>
                        - Every {{GPUBuffer}} referenced in any element of |commandBuffers| is in the
                            `"unmapped"` [=buffer state=].
                        - Every {{GPUQuerySet}} referenced in a command in any element of |commandBuffers| is
                            in the [=query set state/available=] state. For occlusion queries,
                            {{GPURenderPassDescriptor/occlusionQuerySet}} in {{GPUCommandEncoder/beginRenderPass()}}
                            does not constitute a reference, while {{GPURenderPassEncoder/beginOcclusionQuery()}}
                            does.
                    </div>

                1. Issue the following steps on the [=Queue timeline=] of |this|:
                    <div class=queue-timeline>
                        1. For each |commandBuffer| in |commandBuffers|:
                            1. Execute each command in |commandBuffer|.{{GPUCommandBuffer/[[command_list]]}}.
                    </div>
            </div>
        </div>

    : <dfn>onSubmittedWorkDone()</dfn>
    ::
        Returns a {{Promise}} that resolves once this queue finishes processing all the work submitted
        up to this moment.

        <div algorithm="GPUQueue.onSubmittedWorkDone">
            **Called on:** {{GPUQueue}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUQueue/onSubmittedWorkDone()">
            </pre>

            **Returns:** {{Promise}}&lt;{{undefined}}&gt;

            Issue: Describe {{GPUQueue/onSubmittedWorkDone()}} algorithm steps.
        </div>
</dl>

Queries {#queries}
================

## <dfn interface>GPUQuerySet</dfn> ## {#queryset}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUQuerySet {
    undefined destroy();
};
GPUQuerySet includes GPUObjectBase;
</script>

{{GPUQuerySet}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUQuerySet">
    : <dfn>\[[descriptor]]</dfn>, of type {{GPUQuerySetDescriptor}}
    ::
        The {{GPUQuerySetDescriptor}} describing this query set.

        All optional fields of {{GPUTextureViewDescriptor}} are defined.

    : <dfn>\[[state]]</dfn> of type [=query set state=].
    ::
        The current state of the {{GPUQuerySet}}.
</dl>

Each {{GPUQuerySet}} has a current <dfn dfn>query set state</dfn> on the [=Device timeline=]
which is one of the following:

 - "<dfn dfn for="query set state">available</dfn>" where the {{GPUQuerySet}} is
     available for GPU operations on its content.
 - "<dfn dfn for="query set state">destroyed</dfn>" where the {{GPUQuerySet}} is
     no longer available for any operations except {{GPUQuerySet/destroy}}.

### QuerySet Creation ### {#queryset-creation}

A {{GPUQuerySetDescriptor}} specifies the options to use in creating a {{GPUQuerySet}}.

<script type=idl>
dictionary GPUQuerySetDescriptor : GPUObjectDescriptorBase {
    required GPUQueryType type;
    required GPUSize32 count;
};
</script>

<dl dfn-type=dict-member dfn-for=GPUQuerySetDescriptor>
    : <dfn>type</dfn>
    ::
        The type of queries managed by {{GPUQuerySet}}.

    : <dfn>count</dfn>
    ::
        The number of queries managed by {{GPUQuerySet}}.
</dl>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>createQuerySet(descriptor)</dfn>
    ::
        Creates a {{GPUQuerySet}}.

        <div algorithm=GPUDevice.createQuerySet>
            **Called on:** {{GPUDevice}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUDevice/createQuerySet(descriptor)">
                descriptor: Description of the {{GPUQuerySet}} to create.
            </pre>

            **Returns:** {{GPUQuerySet}}

            1. If |descriptor|.{{GPUQuerySetDescriptor/type}} is {{GPUQueryType/"timestamp"}},
                but |this|.{{GPUObjectBase/[[device]]}}.{{device/[[features]]}} does not [=list/contain=]
                {{GPUFeatureName/"timestamp-query"}}, throw a {{TypeError}}.
            1. If any of the following requirements are unmet, return an error query set and stop.
                <div class=validusage>
                    - |this| must be a [=valid=] {{GPUDevice}}.
                    - |descriptor|.{{GPUQuerySetDescriptor/count}} must be &le; 8192.
                </div>
            1. Let |q| be a new {{GPUQuerySet}} object.
            1. Set |q|.{{GPUQuerySet/[[descriptor]]}} to |descriptor|.
            1. Set |q|.{{GPUQuerySet/[[state]]}} to [=query set state/available=].
            1. Return |q|.
        </div>
</dl>

### QuerySet Destruction ### {#queryset-destruction}

An application that no longer requires a {{GPUQuerySet}} can choose to lose access to it before
garbage collection by calling {{GPUQuerySet/destroy()}}.

<dl dfn-type=method dfn-for=GPUQuerySet>
    : <dfn>destroy()</dfn>
    ::
        Destroys the {{GPUQuerySet}}.

        <div algorithm="GPUQuerySet.destroy">
            **Called on:** {{GPUQuerySet}} |this|.

            **Returns:** {{undefined}}

            1. Set |this|.{{GPUQuerySet/[[state]]}} to [=query set state/destroyed=].
        </div>
</dl>

## QueryType ## {#querytype}

<script type=idl>
enum GPUQueryType {
    "occlusion",
    "timestamp",
};
</script>

## Occlusion Query ## {#occlusion}

Occlusion query is only available on render passes, to query the number of fragment samples that pass
all the per-fragment tests for a set of drawing commands, including scissor, sample mask, alpha to
coverage, stencil, and depth tests. Any non-zero result value for the query indicates that at least
one sample passed the tests and reached the output merging stage of the render pipeline, 0 indicates
that no samples passed the tests.

When beginning a render pass, {{GPURenderPassDescriptor}}.{{GPURenderPassDescriptor/occlusionQuerySet}}
must be set to be able to use occlusion queries during the pass. An occlusion query is begun
and ended by calling {{GPURenderPassEncoder/beginOcclusionQuery()}} and
{{GPURenderPassEncoder/endOcclusionQuery()}} in pairs that cannot be nested.

## Timestamp Query ## {#timestamp}

Timestamp query allows application to write timestamp values to a {{GPUQuerySet}} by calling {{GPUCommandEncoder/writeTimestamp()}} on {{GPUCommandEncoder}}, and then resolve timestamp values in **nanoseconds** (type of {{GPUSize64}}) to a {{GPUBuffer}} (using {{GPUCommandEncoder/resolveQuerySet()}}).

Timestamp query requires {{GPUFeatureName/"timestamp-query"}} is available on the device.

Note: The timestamp values may be zero if the physical device reset timestamp counter, please ignore it and the following values.

Issue: Write normative text about timestamp value resets.

Issue: Because timestamp query provides high-resolution GPU timestamp, we need to decide what constraints, if any, are on its availability.

# Canvas Rendering # {#canvas-rendering}

## {{HTMLCanvasElement/getContext()|HTMLCanvasElement.getContext()}} ## {#canvas-getcontext}

A {{GPUCanvasContext}} object can be obtained via the {{HTMLCanvasElement/getContext()}}
method of an {{HTMLCanvasElement}} instance by passing the string literal `'webgpu'` as its
`contextType` argument.

<div class="example">
    Get a {{GPUCanvasContext}} from an offscreen {{HTMLCanvasElement}}:
    <pre highlight="js">
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('webgpu');
        context.configure(/* ... */);
        // ...
    </pre>
</div>

## GPUCanvasContext ## {#canvas-context}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUCanvasContext {
    readonly attribute (HTMLCanvasElement or OffscreenCanvas) canvas;

    undefined configure(GPUCanvasConfiguration configuration);
    undefined unconfigure();

    GPUTextureFormat getPreferredFormat(GPUAdapter adapter);
    GPUTexture getCurrentTexture();
};
</script>

{{GPUCanvasContext}} has the following attributes:

<dl dfn-type=attribute dfn-for=GPUCanvasContext>
    : <dfn>canvas</dfn>
    ::
        The canvas this context was created from.
</dl>

{{GPUCanvasContext}} has the following internal slots:

<dl dfn-type=attribute dfn-for="GPUCanvasContext">
    : <dfn>\[[validConfiguration]]</dfn> of type boolean, initially `false`.
    ::
        Indicates if the context currently has a valid configuration.

    : <dfn>\[[configuration]]</dfn> of type {{GPUCanvasConfiguration}}, initially `null`.
    ::
        The options this context is configured with. `null` if the context has not been configured
        or the configuration has been removed.

    : <dfn>\[[size]]</dfn> of type {{GPUExtent3D}}
    ::
        The size of {{GPUTexture}}s returned from this context.
        [=Extent3D/depthOrArrayLayers=] is always `1`.

    : <dfn>\[[currentTexture]]</dfn> of type {{GPUTexture}}?, initially `null`
    ::
        The current texture that will be returned by the context when calling
        {{GPUCanvasContext/getCurrentTexture()}}, and the next one to be composited to the
        document. Initially set to the result of [$allocating a new context texture$] for this
        context.
</dl>

{{GPUCanvasContext}} has the following methods:

<dl dfn-type=method dfn-for=GPUCanvasContext>
    : <dfn>configure(configuration)</dfn>
    ::
        Configures the context for this canvas. Destroys any textures produced with a previous
        configuration.

        <div algorithm="GPUCanvasContext.configure">
            **Called on:** {{GPUCanvasContext}} |this|.

            **Arguments:**
            <pre class=argumentdef for="GPUCanvasContext/configure(configuration)">
                |configuration|: Desired configuration for the context.
            </pre>

            **Returns:** undefined

            1. Set |this|.{{GPUCanvasContext/[[validConfiguration]]}} to `false`.
            1. Set |this|.{{GPUCanvasContext/[[configuration]]}} to |configuration|.
            1. If |this|.{{GPUCanvasContext/[[currentTexture]]}} is not `null` call
                {{GPUTexture/destroy()}} on |this|.{{GPUCanvasContext/[[currentTexture]]}}.
            1. Set |this|.{{GPUCanvasContext/[[currentTexture]]}} to `null`.
            1. Let |device| be |configuration|.{{GPUCanvasConfiguration/device}}.
            1. Let |canvas| be |this|.{{GPUCanvasContext/canvas}}.
            1. If |configuration|.{{GPUCanvasConfiguration/size}} is `undefined` set
                |this|.{{GPUCanvasContext/[[size]]}} to [|canvas|.width, |canvas|.height, 1],
                otherwise set |this|.{{GPUCanvasContext/[[size]]}} to
                |configuration|.{{GPUCanvasConfiguration/size}}.

            1. Issue the following steps on the [=Device timeline=] of |device|:
                <div class=device-timeline>
                    1. If any of the following conditions are unsatisfied:
                        <div class=validusage>
                            - |device| is a [=valid=] {{GPUDevice}}.
                            - [=Supported context formats=] [=set/contains=]
                                |configuration|.{{GPUCanvasConfiguration/format}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/width=] &gt; 0.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/width=] &le;
                                |device|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/height=] &gt; 0.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/height=] &le;
                                |device|.{{GPUDevice/limits}}.{{GPUSupportedLimits/maxTextureDimension2D}}.
                            - |this|.{{GPUCanvasContext/[[size]]}}.[=Extent3D/depthOrArrayLayers=]
                                is 1;
                        </div>

                        Then:
                            1. Generate a {{GPUValidationError}} in the current scope with appropriate
                                error message.
                            1. Return.
                </div>
            1. Set |this|.{{GPUCanvasContext/[[validConfiguration]]}} to `true`.
        </div>

    : <dfn>unconfigure()</dfn>
    ::
        Removes the context configuration. Destroys any textures produced while configured.

        <div algorithm="GPUCanvasContext.unconfigure">
            **Called on:** {{GPUCanvasContext}} |this|.

            **Returns:** undefined

            1. Set |this|.{{GPUCanvasContext/[[validConfiguration]]}} to `false`.
            1. Set |this|.{{GPUCanvasContext/[[configuration]]}} to `null`.
            1. If |this|.{{GPUCanvasContext/[[currentTexture]]}} is not `null` call
                {{GPUTexture/destroy()}} on |this|.{{GPUCanvasContext/[[currentTexture]]}}.
            1. Set |this|.{{GPUCanvasContext/[[currentTexture]]}} to `null`.
        </div>

    : <dfn>getPreferredFormat(adapter)</dfn>
    ::
        Returns an optimal {{GPUTextureFormat}} to use with this context and devices created from
        the given adapter.

        <div algorithm="GPUCanvasContext.getPreferredFormat">
            **Called on:** {{GPUCanvasContext}} this.

            **Arguments:**
            <pre class=argumentdef for="GPUCanvasContext/getPreferredFormat(adapter)">
                |adapter|: Adapter the format should be queried for.
            </pre>

            **Returns:** {{GPUTextureFormat}}

            <div class=content-timeline>
                1. Return an optimal {{GPUTextureFormat}} to use when calling {{GPUCanvasContext/configure()}}
                    with the given |adapter|. Must be one of the [=supported context formats=].
            </div>
        </div>

    : <dfn>getCurrentTexture()</dfn>
    ::
        Get the {{GPUTexture}} that will be composited to the document by the {{GPUCanvasContext}}
        next.

        <div algorithm="GPUCanvasContext.getCurrentTexture">
            **Called on:** {{GPUCanvasContext}} |this|.

            **Returns:** {{GPUTexture}}

            1. If |this|.{{GPUCanvasContext/[[configuration]]}} is `null`:
                1. Throw an {{OperationError}} and stop.
            1. If |this|.{{GPUCanvasContext/[[currentTexture]]}} is `null` or
                |this|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/[[destroyed]]}} is true:
                1. Set |this|.{{GPUCanvasContext/[[currentTexture]]}} to the result of [$allocating
                    a new context texture$] for |this|.
            1. Return |this|.{{GPUCanvasContext/[[currentTexture]]}}.
        </div>

        Note: Developers can expect that the same {{GPUTexture}} object will be returned by every
        call to {{GPUCanvasContext/getCurrentTexture()}} made within the same frame (i.e. between
        invocations of [=Update the rendering=]) unless {{GPUCanvasContext/configure()}} is called.
</dl>

<div algorithm>
    During the "update the rendering [of the] `Document`" step of the "[=Update the rendering=]"
    HTML processing model, each {{GPUCanvasContext}} |context| must <dfn abstract-op>present the
    context content to the canvas</dfn> by running the following steps:

    1. If |context|.{{GPUCanvasContext/[[currentTexture]]}} is not `null` and
        |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/[[destroyed]]}} is `false`:
        1. Let |imageContents| be
            [$get a copy of the image contents of a context|a copy of the image contents$]
            of |context|.
        1. Update |context|.{{GPUCanvasContext/canvas}} with |imageContents|.
        1. Call |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/destroy()}}.
    1. Set |context|.{{GPUCanvasContext/[[currentTexture]]}} to `null`.
</div>

<div algorithm="transferToImageBitmap from WebGPU">
    When {{OffscreenCanvas/transferToImageBitmap()}} is called on a canvas with
    {{GPUCanvasContext}} |context|:

    1. Let |imageContents| be
        [$get a copy of the image contents of a context|a copy of the image contents$]
        of |context|.
    1. If |context|.{{GPUCanvasContext/[[currentTexture]]}} is not `null`:
        1. Call |context|.{{GPUCanvasContext/[[currentTexture]]}}.{{GPUTexture/destroy()}}.
    1. Set |context|.{{GPUCanvasContext/[[currentTexture]]}} to `null`.
    1. Return a new {{ImageBitmap}} containing the |imageContents|.
</div>

<div algorithm>
    When WebGPU canvas contents are read using other Web APIs, like
    {{CanvasDrawImage/drawImage()}}, `texImage2D()`, `texSubImage2D()`,
    {{HTMLCanvasElement/toDataURL()}}, {{HTMLCanvasElement/toBlob()}}, and so on,
    they <dfn abstract-op>get a copy of the image contents of a context</dfn>:

    **Arguments:**
    |context|: the {{GPUCanvasContext}}

    **Returns:** image contents

    1. Let |texture| be |context|.{{GPUCanvasContext/[[currentTexture]]}}.
    1. If any of the following requirements is unmet, return a transparent black image of size
        |context|.{{GPUCanvasContext/[[size]]}} and stop.
        <div class=validusage>
            - |texture| must not be `null`.
            - |texture|.{{GPUTexture/[[destroyed]]}} must be false.
            - If |context|.{{GPUCanvasContext/canvas}} is an {{OffscreenCanvas}},
                it must not be linked to a [=placeholder canvas element=].

                Issue: If added, canvas must also not be `desynchronized`.
        </div>
    1. Ensure that all submitted work items (e.g. queue submissions) have
        completed writing to |texture|.
    1. Return the contents of |texture|, tagged as having alpha premultiplied, and with the color space
        |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/colorSpace}}.

        Issue(gpuweb/gpuweb#1847): Does compositingAlphaMode=opaque make this return opaque contents?
</div>

<div algorithm>
    To <dfn abstract-op lt='allocating a new context texture'>allocate a new context texture</dfn>
    for {{GPUCanvasContext}} |context| run the following steps:

        1. Let |device| be |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/device}}.
        1. If |context|.{{GPUCanvasContext/[[validConfiguration]]}} is `false`:
            1. Generate a {{GPUValidationError}} in the current scope of |device| with an appropriate error message.
            1. Return a new [=invalid=] {{GPUTexture}}.
        1. Let |textureDescriptor| be a new {{GPUTextureDescriptor}}.
        1. Set |textureDescriptor|.{{GPUTextureDescriptor/size}} to |context|.{{GPUCanvasContext/[[size]]}}.
        1. Set |textureDescriptor|.{{GPUTextureDescriptor/format}} to
            |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/format}}.
        1. Set |textureDescriptor|.{{GPUTextureDescriptor/usage}} to
            |context|.{{GPUCanvasContext/[[configuration]]}}.{{GPUCanvasConfiguration/usage}}.
        1. Let |texture| be a new {{GPUTexture}} created as if |device|.{{GPUDevice/createTexture()}}
            were called with |textureDescriptor|.
            <div class='note'>If a previously presented texture from |context| matches the required criteria,
            its GPU memory may be re-used.</div>
        1. Ensure |texture| is cleared to `(0, 0, 0, 0)`.
        1. Return |texture|.
</div>

## GPUCanvasConfiguration ## {#canvas-configuration}

The <dfn dfn>supported context formats</dfn> are a [=set=] of {{GPUTextureFormat}}s that must be
supported when specified as a {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/format}}
regardless of the given {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/device}},
initially set to: &laquo;{{GPUTextureFormat/"bgra8unorm"}}, {{GPUTextureFormat/"bgra8unorm-srgb"}},
{{GPUTextureFormat/"rgba8unorm"}}, {{GPUTextureFormat/"rgba8unorm-srgb"}}&raquo;.

<script type=idl>

enum GPUCanvasCompositingAlphaMode {
    "opaque",
    "premultiplied",
};

dictionary GPUCanvasConfiguration {
    required GPUDevice device;
    required GPUTextureFormat format;
    GPUTextureUsageFlags usage = 0x10;  // GPUTextureUsage.RENDER_ATTACHMENT
    GPUPredefinedColorSpace colorSpace = "srgb";
    GPUCanvasCompositingAlphaMode compositingAlphaMode = "opaque";
    GPUExtent3D size;
};
</script>

### Canvas Color Space ### {#canvas-color-space}

During presentation, the chrominance of color values outside of the [0, 1] range is not to be
clamped to that range; extended values may be used to display colors outside of the gamut defined
by the canvas' color space's primaries, when permitted by the configured
{{GPUCanvasConfiguration/format}} and the user's display capabilities.
This is in contrast with luminance, which is to be clamped to the maximum standard dynamic range
luminance.

Issue:
[Unless](https://github.com/WICG/canvas-color-space/blob/6bc492d2564abec316e2c5663aec9f9fa523a6a2/CanvasColorSpaceProposal.md#compositing-of-the-htmlcanvaselement)
high dynamic range is explicitly enabled for the canvas element.

### Canvas Context sizing ### {#context-sizing}

A {{GPUCanvasContext}}'s {{GPUCanvasContext/[[size]]}} is set by the {{GPUCanvasConfiguration}}
passed to {{GPUCanvasContext/configure()}}, and remains the same until {{GPUCanvasContext/configure()}}
is called again with a new size. If a {{GPUCanvasConfiguration/size}} is not specified then the
width and height attributes of the {{GPUCanvasContext}}.{{GPUCanvasContext/canvas}}
at the time {{GPUCanvasContext/configure()}} is called will be used. If
{{GPUCanvasContext}}.{{GPUCanvasContext/[[size]]}} does not match the dimensions of the canvas
the textures produced by the {{GPUCanvasContext}} will be scaled to fit the canvas element.

<div class="note">
    Note: Unlike `'webgl'` or `'2d'` contexts, `width` and `height` attributes of canvases with a
    `'webgpu'` context only affect:
    - Default layout size, if not overridden by CSS.
    - Default {{GPUCanvasConfiguration}}.{{GPUCanvasConfiguration/size}} when calling
        {{GPUCanvasContext/configure()}}, if not overridden.
</div>

If it is desired to match the dimensions of the canvas after it is resized, the {{GPUCanvasContext}}
must be reconfigured by calling {{GPUCanvasContext/configure()}} again with the new dimensions.

<div class="example">
    Reconfigure a {{GPUCanvasContext}} in response to canvas resize, monitored using
    [ResizeObserver](https://www.w3.org/TR/resize-observer/) to get the exact pixel dimensions of
    the canvas:

    <pre highlight="js">
        const canvas = document.createElement('canvas');
        const context =  canvas.getContext('webgpu');

        const resizeObserver = new ResizeObserver(entries => {
            for (const entry of entries) {
                if (entry != canvas) { continue; }
                context.configure({
                    device: someDevice,
                    format: context.getPreferredFormat(someDevice.adapter),
                    size: {
                        // This reports the size of the canvas element in pixels
                        width: entry.devicePixelContentBoxSize[0].inlineSize,
                        height: entry.devicePixelContentBoxSize[0].blockSize,
                    }
                });
            }
        });
        resizeObserver.observe(canvas);
    </pre>
</div>

## <dfn dfn-type=enum-value dfn-for=GPUCanvasCompositingAlphaMode>GPUCanvasCompositingAlphaMode</dfn> ## {#GPUCanvasCompositingAlphaMode}

This enum selects how the contents of the canvas' context will paint onto the page.

<table class='data'>
    <thead>
        <tr>
            <th>GPUCanvasCompositingAlphaMode
            <th>Description
            <th>dst.rgb
            <th>dst.a
    </thead>
    <tr>
        <td>{{GPUCanvasCompositingAlphaMode/opaque}}
        <td>Paint RGB as opaque and ignore alpha values.
            If the content is not already opaque, implementations may need to clear alpha to opaque during presentation.
        <td>|dst.rgb = src.rgb|
        <td>|dst.a = 1|
    <tr>
        <td>{{GPUCanvasCompositingAlphaMode/premultiplied}}
        <td>Composite assuming color values are premultiplied by their alpha value.
            100% red 50% opaque is [0.5, 0, 0, 0.5].
            Color values must be less than or equal to their alpha value.
            [1.0, 0, 0, 0.5] is "super-luminant" and cannot reliably be displayed.
        <td>|dst.rgb = src.rgb + dst.rgb*(1-src.a)|
        <td>|dst.a = src.a + dst.a*(1-src.a)|
</table>

# Errors &amp; Debugging # {#errors-and-debugging}

## Fatal Errors ## {#fatal-errors}

<script type=idl>
enum GPUDeviceLostReason {
    "destroyed",
};

[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUDeviceLostInfo {
    readonly attribute (GPUDeviceLostReason or undefined) reason;
    readonly attribute DOMString message;
};

partial interface GPUDevice {
    readonly attribute Promise<GPUDeviceLostInfo> lost;
};
</script>

{{GPUDevice}} has the following additional attributes:

<dl dfn-type=attribute dfn-for=GPUDevice>
    : <dfn>lost</dfn>
    ::
        A promise which is created with the device, remains pending for the lifetime of the device,
        then resolves when the device is lost.

        This attribute is backed by an immutable internal slot of the same name, initially set
        to [=a new promise=], and always returns its value.
</dl>

## Error Scopes ## {#error-scopes}

<script type=idl>
enum GPUErrorFilter {
    "out-of-memory",
    "validation",
};
</script>

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUOutOfMemoryError {
    constructor();
};

[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUValidationError {
    constructor(DOMString message);
    readonly attribute DOMString message;
};

typedef (GPUOutOfMemoryError or GPUValidationError) GPUError;
</script>

<script type=idl>
partial interface GPUDevice {
    undefined pushErrorScope(GPUErrorFilter filter);
    Promise<GPUError?> popErrorScope();
};
</script>

<dl dfn-type=method dfn-for=GPUDevice>
    : <dfn>pushErrorScope(filter)</dfn>
    ::
        Issue: Define pushErrorScope.

    : <dfn>popErrorScope()</dfn>
    ::
        Issue: Define popErrorScope.

        Rejects with {{OperationError}} if:

        - The device is lost.
        - There are no error scopes on the stack.
</dl>

## Telemetry ## {#telemetry}

<script type=idl>
[Exposed=(Window, DedicatedWorker), SecureContext]
interface GPUUncapturedErrorEvent : Event {
    constructor(
        DOMString type,
        GPUUncapturedErrorEventInit gpuUncapturedErrorEventInitDict
    );
    readonly attribute GPUError error;
};

dictionary GPUUncapturedErrorEventInit : EventInit {
    required GPUError error;
};
</script>

<dl dfn-type=attribute dfn-for=GPUUncapturedErrorEvent>
    : <dfn>error</dfn>
    ::
        Object representing the error that was uncaptured.
        This has the same type as errors returned by {{GPUDevice/popErrorScope()}}.

        This attribute is backed by an immutable internal slot of the same name, and
        always returns its value.

        Issue(whatwg/webidl#1077): This attribute should be `[SameObject]`.
        (If GPUError [becomes an interface](https://github.com/gpuweb/gpuweb/issues/1884) then
        we can do this without resolving the WebIDL issue.)
</dl>

<script type=idl>
partial interface GPUDevice {
    [Exposed=(Window, DedicatedWorker)]
    attribute EventHandler onuncapturederror;
};
</script>

# Detailed Operations # {#detailed-operations}

This section describes the details of various GPU operations.

## Transfer ## {#transfer-operations}

Issue: describe the transfers at the high level

## Computing ## {#computing-operations}

Computing operations provide direct access to GPU's programmable hardware.
Compute shaders do not have pipeline inputs or outputs, their results are
side effects from writing data into storage bindings bound as
{{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}} and {{GPUStorageTextureBindingLayout}}.
These operations are encoded within {{GPUComputePassEncoder}} as:
  - {{GPUComputePassEncoder/dispatch()}}
  - {{GPUComputePassEncoder/dispatchIndirect()}}

Issue: describe the computing algorithm

## Rendering ## {#rendering-operations}

Rendering is done by a set of GPU operations that are executed within {{GPURenderPassEncoder}},
and result in modifications of the texture data, viewed by the render pass attachments.
These operations are encoded with:
  - {{GPURenderEncoderBase/draw()}}
  - {{GPURenderEncoderBase/drawIndexed()}},
  - {{GPURenderEncoderBase/drawIndirect()}}
  - {{GPURenderEncoderBase/drawIndexedIndirect()}}.

Note: rendering is the traditional use of GPUs, and is supported by multiple fixed-function
blocks in hardware.

A <dfn dfn>RenderState</dfn> is an internal object representing the state
of the current {{GPURenderPassEncoder}} during command encoding.
[=RenderState=] is a spec namespace for the following definitions:
<div algorithm="RenderState accessors" dfn-for=RenderState>
    For a given {{GPURenderPassEncoder}} |pass|, the syntax:

      - |pass|.<dfn dfn>indexBuffer</dfn> refers to
        the index buffer bound via {{GPURenderEncoderBase/setIndexBuffer()}}, if any.
      - |pass|.<dfn dfn>vertexBuffers</dfn> refers to
        [=list=]&lt;vertex buffer&gt; bound by {{GPURenderEncoderBase/setVertexBuffer()}}.
      - |pass|.<dfn dfn>bindGroups</dfn> refers to
        [=list=]&lt;{{GPUBindGroup}}&gt; bound by {{GPUProgrammablePassEncoder/setBindGroup(index, bindGroup, dynamicOffsets)}}.
      - |pass|.<dfn dfn>viewport</dfn> refers to an object containing {{GPURenderPassEncoder/setViewport()}} arguments.
        At the start of a render pass, the state is equivalent to a call of setViewport(0, 0, |pass|.{{GPURenderPassEncoder/[[attachment_size]]}}.width, |pass|.{{GPURenderPassEncoder/[[attachment_size]]}}.height, 0.0, 1.0).
      - |pass|.<dfn dfn>scissorRect</dfn> refers to an object containing {{GPURenderPassEncoder/setScissorRect()}} arguments.
        At the start of a render pass, the state is equivalent to a call of setScissorRect(0, 0, |pass|.{{GPURenderPassEncoder/[[attachment_size]]}}.width, |pass|.{{GPURenderPassEncoder/[[attachment_size]]}}.height).
</div>

The main rendering algorithm:

<div algorithm>
    <dfn abstract-op>render</dfn>(descriptor, drawCall, state)

        **Arguments:**
            - |descriptor|: Description of the current {{GPURenderPipeline}}.
            - |drawCall|: The draw call parameters.
            - |state|: [=RenderState=] of the {{GPURenderEncoderBase}} where the draw call is issued.

        1. **Resolve indices**. See [[#index-resolution]].

            Let |vertexList| be the result of [$resolve indices$](|drawCall|, |state|).

        1. **Process vertices**. See [[#vertex-processing]].

            Execute [$process vertices$](|vertexList|, |drawCall|, |descriptor|.{{GPURenderPipelineDescriptor/vertex}}, |state|).

        1. **Assemble primitives**. See [[#primitive-assembly]].

            Execute [$assemble primitives$](|vertexList|, |drawCall|, |descriptor|.{{GPURenderPipelineDescriptor/primitive}}).

        1. **Clip primitives**. See [[#primitive-clipping]].

            Let |primitiveList| be the result of this stage.

        1. **Rasterize**. See [[#rasterization]].

            Let |rasterizationList| be the result of [$rasterize$](|primitiveList|, |state|).

        1. **Process fragments**. See [[#fragment-processing]].

            Gather a list of |fragments|, resulting from executing
            [$process fragment$](|rasterPoint|, |descriptor|.{{GPURenderPipelineDescriptor/fragment}}, |state|)
            for each |rasterPoint| in |rasterizationList|.

        1. **Process depth/stencil**.

            Issue: fill out the section, using |fragments|

        1. **Write pixels**.

            Issue: fill out the section
</div>

### Index Resolution ### {#index-resolution}

At the first stage of rendering, the pipeline builds
a list of vertices to process for each instance.

<div algorithm>
    <dfn abstract-op>resolve indices</dfn>(drawCall, state)

    **Arguments:**
    - |drawCall|: The draw call parameters.
    - |state|: The active [=RenderState=].

    **Returns:** list of integer indices.

    1. Let |vertexIndexList| be an empty list of indices.
    1. If |drawCall| is an indexed draw call:
        1. Initialize the |vertexIndexList| with |drawCall|.indexCount integers.
        1. For |i| in range 0 .. |drawCall|.indexCount (non-inclusive):
            1. Let |relativeVertexIndex| be [$fetch index$](|i| + |drawCall|.`firstIndex`,
                |state|.[=RenderState/indexBuffer=]).
            1. If |relativeVertexIndex| has the special value `"out of bounds"`,
                stop and return the empty list.

                Note: Implementations may choose to display a warning when this occurs,
                especially when it is easy to detect (like in non-indirect indexed draw calls).
            1. Append |drawCall|.`baseVertex` + |relativeVertexIndex| to the |vertexIndexList|.
    1. Otherwise:
        1. Initialize the |vertexIndexList| with |drawCall|.vertexCount integers.
        1. Set each |vertexIndexList| item |i| to the value |drawCall|.firstVertex + |i|.
    1. Return |vertexIndexList|.

    Note: in case of indirect draw calls, the `indexCount`, `vertexCount`,
    and other properties of |drawCall| are read from the indirect buffer
    instead of the draw command itself.

    Issue: specify indirect commands better.
</div>

<div algorithm>
    <dfn abstract-op>fetch index</dfn>(i, buffer, offset, format)

    **Arguments:**
    - |i|: Index of a vertex index to fetch.
    - |indexBufferState|: A value of [=RenderState/indexBuffer=] (buffer, format, offset, and size).

    **Returns:** unsigned integer or `"out of bounds"`

    1. Let |indexSize| be defined by the |indexBufferState|.`format`:
        <dl class="switch">
            : {{GPUIndexFormat/"uint16"}}
            :: 2
            : {{GPUIndexFormat/"uint32"}}
            :: 4
        </dl>
    1. If |indexBufferState|.`offset` + |i + 1| &times; |indexSize| &gt; |indexBufferState|.`size`,
        return the special value `"out of bounds"`.
    1. Interpret the data in |indexBufferState|.`buffer`, starting at offset
        |indexBufferState|.`offset` + |i| &times; |indexSize|,
        of size |indexSize| bytes, as an unsigned integer and return it.
</div>

### Vertex Processing ### {#vertex-processing}

Vertex processing stage is a programmable stage of the render [=pipeline=] that
processes the vertex attribute data, and produces
clip space positions for [[#primitive-clipping]], as well as other data for the
[[#fragment-processing]].

<div algorithm>
    <dfn abstract-op>process vertices</dfn>(vertexIndexList, drawCall, desc, state)

    **Arguments:**
    - |vertexIndexList|: List of vertex indices to process (mutable, passed by reference).
    - |drawCall|: The draw call parameters.
    - |desc|: The descriptor of type {{GPUVertexState}}.
    - |state|: The active [=RenderState=].

    Each vertex |vertexIndex| in the |vertexIndexList|,
    in each instance of index |rawInstanceIndex|, is processed independently.
    The |rawInstanceIndex| is in range from 0 to |drawCall|.instanceCount - 1, inclusive.
    This processing happens in parallel, and any side effects, such as
    writes into {{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}} bindings,
    may happen in any order.
    1. Let |instanceIndex| be |rawInstanceIndex| + |drawCall|.firstInstance.
    1. For each non-`null` |vertexBufferLayout| in the list of |desc|.{{GPUVertexState/buffers}}:
        1. Let |i| be the index of the buffer layout in this list.
        1. Let |vertexBuffer|, |vertexBufferOffset|, and |vertexBufferBindingSize| be the
            buffer, offset, and size at slot |i| of |state|.[=RenderState/vertexBuffers=].
        1. Let |vertexElementIndex| be dependent on |vertexBufferLayout|.{{GPUVertexBufferLayout/stepMode}}:
            <dl class="switch">
                : {{GPUVertexStepMode/"vertex"}}
                :: |vertexIndex|
                : {{GPUVertexStepMode/"instance"}}
                :: |instanceIndex|
            </dl>
        1. For each |attributeDesc| in |vertexBufferLayout|.{{GPUVertexBufferLayout/attributes}}:
            1. Let |attributeOffset| be |vertexBufferOffset| +
                |vertexElementIndex| * |vertexBufferLayout|.{{GPUVertexBufferLayout/arrayStride}} +
                |attributeDesc|.{{GPUVertexAttribute/offset}}.
            1. Load the attribute |data| of format |attributeDesc|.{{GPUVertexAttribute/format}}
                from |vertexBuffer| starting at offset |attributeOffset|.
                The components are loaded in the order `x`, `y`, `z`, `w` from buffer memory.

                If this results in an out-of-bounds access, the resulting value is determined
                according to WGSL's [=invalid memory reference=] behavior.
            1. **Optionally (implementation-defined):**
                If |attributeOffset| + sizeof(|attributeDesc|.{{GPUVertexAttribute/format}}) &gt;
                |vertexBufferOffset| + |vertexBufferBindingSize|,
                [=list/empty=] |vertexIndexList| and stop, cancelling the draw call.

                Note: This allows implementations to detect out-of-bounds values in the index buffer
                before issuing a draw call, instead of using [=invalid memory reference=] behavior.
            1. Convert the |data| into a shader-visible format, according to [=channel formats=] rules.
                <div class="example">
                    An attribute of type {{GPUVertexFormat/"snorm8x2"}} and byte values of `[0x70, 0xD0]`
                    will be converted to `vec2<f32>(0.88, -0.38)` in WGSL.
                </div>
            1. Adjust the |data| size to the shader type:
                - if both are scalar, or both are vectors of the same dimensionality, no adjustment is needed.
                - if |data| is vector but the shader type is scalar, then only the first component is extracted.
                - if both are vectors, and |data| has a higher dimension, the extra components are dropped.
                    <div class="example">
                        An attribute of type {{GPUVertexFormat/"float32x3"}} and value `vec3<f32>(1.0, 2.0, 3.0)`
                        will exposed to the shader as `vec2<f32>(1.0, 2.0)` if a 2-component vector is expected.
                    </div>
                - if the shader type is a vector of higher dimensionality, or the |data| is a scalar,
                    then the missing components are filled from `vec4<*>(0, 0, 0, 1)` value.
                    <div class="example">
                        An attribute of type {{GPUVertexFormat/"sint32"}} and value `5` will be exposed
                        to the shader as `vec4<i32>(5, 0, 0, 1)` if a 4-component vector is expected.
                    </div>
            1. Bind the |data| to vertex shader input
                location |attributeDesc|.{{GPUVertexAttribute/shaderLocation}}.
    1. For each {{GPUBindGroup}} group at |index| in |state|.[=RenderState/bindGroups=]:
        1. For each resource {{GPUBindingResource}} in the bind group:
            1. Let |entry| be the corresponding {{GPUBindGroupLayoutEntry}} for this resource.
            1. If |entry|.{{GPUBindGroupLayoutEntry}}.visibility includes {{GPUShaderStage/VERTEX}}:
                - Bind the resource to the shader under group |index| and binding {{GPUBindGroupLayoutEntry/binding|GPUBindGroupLayoutEntry.binding}}.
    1. Set the shader [=builtins=]:
        - Set the `vertex_index` builtin, if any, to |vertexIndex|.
        - Set the `instance_index` builtin, if any, to |instanceIndex|.
    1. Invoke the vertex shader entry point described by |desc|.

        Note: The target platform caches the results of vertex shader invocations.
        There is no guarantee that any |vertexIndex| that repeats more than once will
        result in multiple invocations. Similarly, there is no guarantee that a single |vertexIndex|
        will only be processed once.
</div>

### Primitive Assembly ### {#primitive-assembly}

Primitives are assembled by a fixed-function stage of GPUs.

<div algorithm>
    <dfn abstract-op>assemble primitives</dfn>(vertexIndexList, drawCall, desc)

    **Arguments:**
        - |vertexIndexList|: List of vertex indices to process.
        - |drawCall|: The draw call parameters.
        - |desc|: The descriptor of type {{GPUPrimitiveState}}.

    For each instance, the primitives get assembled from the vertices that have been
    processed by the shaders, based on the |vertexIndexList|.

    1. First, if the primitive topology is a strip, (which means that
        |desc|.{{GPUPrimitiveState/stripIndexFormat}} is not undefined)
        and the |drawCall| is indexed, the |vertexIndexList| is split into
        sub-lists using the maximum value of |desc|.{{GPUPrimitiveState/stripIndexFormat}}
        as a separator.

        Example: a |vertexIndexList| with values `[1, 2, 65535, 4, 5, 6]` of type {{GPUIndexFormat/"uint16"}}
        will be split in sub-lists `[1, 2]` and `[4, 5, 6]`.

    1. For each of the sub-lists |vl|, primitive generation is done according to the
        |desc|.{{GPUPrimitiveState/topology}}:
        <dl class="switch">
            : {{GPUPrimitiveTopology/"line-list"}}
            ::
                Line primitives are composed from (|vl|.0, |vl|.1),
                then (|vl|.2, |vl|.3), then (|vl|.4 to |vl|.5), etc.
                Each subsequent primitive takes 2 vertices.

            : {{GPUPrimitiveTopology/"line-strip"}}
            ::
                Line primitives are composed from (|vl|.0, |vl|.1),
                then (|vl|.1, |vl|.2), then (|vl|.2, |vl|.3), etc.
                Each subsequent primitive takes 1 vertex.

            : {{GPUPrimitiveTopology/"triangle-list"}}
            ::
                Triangle primitives are composed from (|vl|.0, |vl|.1, |vl|.2),
                then (|vl|.3, |vl|.4, |vl|.5), then (|vl|.6, |vl|.7, |vl|.8), etc.
                Each subsequent primitive takes 3 vertices.

            : {{GPUPrimitiveTopology/"triangle-strip"}}
            ::
                Triangle primitives are composed from (|vl|.0, |vl|.1, |vl|.2),
                then (|vl|.2, |vl|.1, |vl|.3), then (|vl|.2, |vl|.3, |vl|.4),
                then (|vl|.4, |vl|.3, |vl|.5), etc.
                Each subsequent primitive takes 1 vertices.
        </dl>

        Issue: should this be defined more formally?

        Any incomplete primitives are dropped.

</div>

### Primitive Clipping ### {#primitive-clipping}

Vertex shaders have to produce a built-in "position" (of type `vec4<f32>`),
which denotes the <dfn dfn>clip position</dfn> of a vertex.

Issue: link to WGSL built-ins

Primitives are clipped to the <dfn dfn>clip volume</dfn>, which, for any [=clip position=] |p|
inside a primitive, is defined by the following inequalities:
  - &minus;|p|.w &le; |p|.x &le; |p|.w
  - &minus;|p|.w &le; |p|.y &le; |p|.w
  - 0 &le; |p|.z &le; |p|.w (<dfn dfn>depth clipping</dfn>)

If |descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/unclippedDepth}} is `true`,
[=depth clipping=] is not applied: the [=clip volume=] is not bounded in the z dimension.

A primitive passes through this stage unchanged if every one of its edges
lie entirely inside the [=clip volume=].
If the edges of a primitives intersect the boundary of the [=clip volume=],
the intersecting edges are reconnected by new edges that lie along the boundary of the [=clip volume=].
For triangular primitives (|descriptor|.{{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}} is
{{GPUPrimitiveTopology/"triangle-list"}} or {{GPUPrimitiveTopology/"triangle-strip"}}), this reconnection
may result in introduction of new vertices into the polygon, internally.

If a primitive intersects an edge of the [=clip volume=]’s boundary,
the clipped polygon must include a point on this boundary edge.

If the vertex shader outputs other floating-point values (scalars and vectors), qualified with
"perspective" interpolation, they also get clipped.
The output values associated with a vertex that lies within the clip volume are unaffected by clipping.
If a primitive is clipped, however, the output values assigned to vertices produced by clipping are clipped.

Considering an edge between vertices |a| and |b| that got clipped, resulting in the vertex |c|,
let's define |t| to be the ratio between the edge vertices:
|c|.p = |t| &times; |a|.p &plus; (1 &minus; |t|) &times; |b|.p,
where |x|.p is the output [=clip position=] of a vertex |x|.

For each vertex output value "v" with a corresponding fragment input,
|a|.v and |b|.v would be the outputs for |a| and |b| vertices respectively.
The clipped shader output |c|.v is produced based on the interpolation qualifier:
<dl class="switch">
    : "flat"
    ::
        Flat interpolation is unaffected, and is based on <dfn dfn>provoking vertex</dfn>,
        which is the first vertex in the primitive. The output value is the same
        for the whole primitive, and matches the vertex output of the [=provoking vertex=]:
        |c|.v = [=provoking vertex=].v

    : "linear"
    ::
        The interpolation ratio gets adjusted against the perspective coordinates of the
        [=clip position=]s, so that the result of interpolation is linear in screen space.

        Issue: provide more specifics here, if possible

    : "perspective"
    ::
        The value is linearly interpolated in clip space, producing perspective-correct values:

        |c|.v = |t| &times; |a|.v &plus; (1 &minus; |t|) &times; |b|.v
</dl>

Issue: link to interpolation qualifiers in WGSL

The result of primitive clipping is a new set of primitives, which are contained
within the [=clip volume=].

### Rasterization ### {#rasterization}

Rasterization is the hardware processing stage that maps the generated primitives
to the 2-dimensional rendering area of the <dfn dfn>framebuffer</dfn> -
the set of render attachments in the current {{GPURenderPassEncoder}}.
This rendering area is split into an even grid of pixels.

Rasterization determines the set of pixels affected by a primitive. In case of multi-sampling,
each pixel is further split into |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}
samples. The locations of samples are the same for each pixel, but not defined in this spec.

Issue: do we want to force-enable the "Standard sample locations" in Vulkan?

The [=framebuffer=] coordinates start from the top-left corner of the render targets.
Each unit corresponds exactly to a pixel. See [[#coordinate-systems]] for more information.

Let's define a <dfn dfn>FragmentDestination</dfn> to contain:
<dl dfn-for=FragmentDestination>
    : <dfn dfn>position</dfn>
    :: the 2D pixel position in [=framebuffer=] space
    : <dfn dfn>sampleIndex</dfn>
    :: an integer in case [[#sample-frequency-shading]] is active,
        or `null` otherwise
</dl>

We'll also use a notion of <dfn dfn>NDC</dfn> - normalized device coordinates.
In this coordinate system, the viewport bounds range in X and Y from -1 to 1, and in Z from 0 to 1.

Rasterization produces a list of <dfn dfn>RasterizationPoint</dfn>s, each containing the following data:
<dl dfn-for=RasterizationPoint>
    : <dfn dfn>destination</dfn>
    :: refers to [=FragmentDestination=]
    : <dfn dfn>coverageMask</dfn>
    :: refers to multisample coverage mask (see [[#sample-masking]])
    : <dfn dfn>frontFacing</dfn>
    :: is true if it's a point on the front face of a primitive
    : <dfn dfn>perspectiveDivisor</dfn>
    :: refers to interpolated 1.0 &divide; W across the primitive
    : <dfn dfn>depth</dfn>
    :: refers to the depth in [=NDC=]
    : <dfn dfn>primitiveVertices</dfn>
    :: refers to the list of vertex outputs forming the primitive
    : <dfn dfn>barycentricCoordinates</dfn>
    :: refers to [[#barycentric-coordinates]]
</dl>

Issue: define the depth computation algorithm

<div algorithm>
    <dfn abstract-op>rasterize</dfn>(primitiveList, state)

    **Arguments:**
    - |primitiveList|: List of primitives to rasterize.
    - |state|: The active [=RenderState=].

    **Returns:** list of [=RasterizationPoint=].

    Each primitive in |primitiveList| is processed independently.
    However, the order of primitives affects later stages, such as depth/stencil operations and pixel writes.

    1. First, the clipped vertices are transformed into [=NDC=] - normalized device coordinates.
        Given the output position |p|, the [=NDC=] coordinates are computed as:

        divisor(|p|) = 1.0 &divide; |p|.w

        ndc(|p|) = vector(|p|.x &divide; |p|.w, |p|.y &divide; |p|.w, |p|.z &divide; |p|.w)

    1. Let |vp| be |state|.[=RenderState/viewport=].
        Then the [=NDC=] coordinates |n| are converted into [=framebuffer=] coordinates,
        based on the size of the render targets:

       framebufferCoords(|n|) = vector(|vp|.`x` &plus; 0.5 &times; (|n|.x &plus; 1) &times; |vp|.`width`, |vp|.`y` &plus; .5 &times; (|n|.y &plus; 1) &times; |vp|.`height`)

       Issue: specify the depth translation into viewport as well

    1. Let |rasterizationPoints| be an empty list.

      Issue: specify that each rasterization point gets assigned an interpolated `divisor(p)`
      and `framebufferCoords(n)`, as well as the other attributes.

    1. Proceed with a specific rasterization algorithm,
        depending on {{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/topology}}:
        <dl class="switch">
            : {{GPUPrimitiveTopology/"point-list"}}
            :: The point, if not filtered by [[#primitive-clipping]], goes into [[#point-rasterization]].
            : {{GPUPrimitiveTopology/"line-list"}} or {{GPUPrimitiveTopology/"line-strip"}}
            :: The line cut by [[#primitive-clipping]] goes into [[#line-rasterization]].
            : {{GPUPrimitiveTopology/"triangle-list"}} or {{GPUPrimitiveTopology/"triangle-strip"}}
            :: The polygon produced in [[#primitive-clipping]] goes into [[#polygon-rasterization]].
        </dl>

        Issue: reword the "goes into" part

    1. Remove all the points |rp| from |rasterizationPoints| that have
        |rp|.[=RasterizationPoint/destination=].[=FragmentDestination/position=]
        outside of |state|.[=RenderState/scissorRect=].

    1. Return |rasterizationPoints|.

</div>

#### Point Rasterization #### {#point-rasterization}

A single [=FragmentDestination=] is selected within the pixel containing the
[=framebuffer=] coordinates of the point.

The coverage mask depends on multi-sampling mode:
<dl class="switch">
    : sample-frequency
    :: coverageMask = 1 &Lt; `sampleIndex`
    : pixel-frequency multi-sampling
    :: coverageMask = 1 &Lt; |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}} &minus; 1
    : no multi-sampling
    :: coverageMask = 1
</dl>

#### Line Rasterization #### {#line-rasterization}

Issue: fill out this section

#### Barycentric coordinates #### {#barycentric-coordinates}

Barycentric coordinates is a list of |n| numbers |b|<sub>|i|</sub>,
defined for a point |p| inside a convex polygon with |n| vertices |v|<sub>|i|</sub> in [=framebuffer=] space.
Each |b|<sub>|i|</sub> is in range 0 to 1, inclusive, and represents the proximity to vertex |v|<sub>|i|</sub>.
Their sum is always constant:

&sum; (|b|<sub>|i|</sub>) = 1

These coordinates uniquely specify any point |p| within the polygon (or on its boundary) as:

|p| = &sum; (|b|<sub>|i|</sub> &times; |p|<sub>|i|</sub>)

For a polygon with 3 vertices - a triangle,
barycentric coordinates of any point |p| can be computed as follows:

|A|<sub>polygon</sub> = A(|v|<sub>|1|</sub>, |v|<sub>|2|</sub>, |v|<sub>|3|</sub>)
|b|<sub>|1|</sub> = A(|p|, |b|<sub>|2|</sub>, |b|<sub>|3|</sub>) &divide; |A|<sub>polygon</sub>
|b|<sub>|2|</sub> = A(|b|<sub>|1|</sub>, |p|, |b|<sub>|3|</sub>) &divide; |A|<sub>polygon</sub>
|b|<sub>|3|</sub> = A(|b|<sub>|1|</sub>, |b|<sub>|2|</sub>, |p|) &divide; |A|<sub>polygon</sub>

Where A(list of points) is the area of the polygon with the given set of vertices.

For polygons with more than 3 vertices, the exact algorithm is implementation-dependent.
One of the possible implementations is to triangulate the polygon and compute the barycentrics
of a point based on the triangle it falls into.

#### Polygon Rasterization #### {#polygon-rasterization}

A polygon is <dfn dfn>front-facing</dfn> if it's oriented towards the projection.
Otherwise, the polygon is <dfn dfn>back-facing</dfn>.

<div algorithm>
    <dfn abstract-op>rasterize polygon</dfn>()

    **Arguments:**

    **Returns:** list of [=RasterizationPoint=].

    1. Let |rasterizationPoints| be an empty list.
    1. Let |v|(|i|) be the [=framebuffer=] coordinates for the clipped vertex number |i| (starting with 1)
        in a rasterized polygon of |n| vertices.

        Note: this section uses the term "polygon" instead of a "triangle",
        since [[#primitive-clipping]] stage may have introduced additional vertices.
        This is non-observable by the application.

    1. Determine if the polygon is front-facing,
        which depends on the sign of the |area| occupied by the polygon in [=framebuffer=] coordinates:

        |area| = 0.5 &times; ((|v|<sub>1</sub>.x &times; |v|<sub>|n|</sub>.y &minus; |v|<sub>|n|</sub>.x &times; |v|<sub>1</sub>.y) &plus; &sum; (|v|<sub>|i|&plus;1</sub>.x &times; |v|<sub>|i|</sub>.y &minus; |v|<sub>|i|</sub>.x &times; |v|<sub>|i|&plus;1</sub>.y))

        The sign of |area| is interpreted based on the {{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/frontFace}}:
        <dl class="switch">
            : {{GPUFrontFace/"ccw"}}
            :: |area| &gt; 0 is considered [=front-facing=], otherwise [=back-facing=]
            : {{GPUFrontFace/"cw"}}
            :: |area| &lt; 0 is considered [=front-facing=], otherwise [=back-facing=]
        </dl>

    1. Cull based on {{GPURenderPipelineDescriptor/primitive}}.{{GPUPrimitiveState/cullMode}}:
        <dl class="switch">
            : {{GPUCullMode/"none"}}
            :: All polygons pass this test.
            : {{GPUCullMode/"front"}}
            :: The [=front-facing=] polygons are discarded,
                and do not process in later stages of the render pipeline.
            : {{GPUCullMode/"back"}}
            :: The [=back-facing=] polygons are discarded.
        </dl>

    1. Determine a set of [=fragments=] inside the polygon in [=framebuffer=] space -
        these are locations scheduled for the per-fragment operations.
        This operation is known as "point sampling".
        The logic is based on |descriptor|.{{GPURenderPipelineDescriptor/multisample}}:
        <dl class="switch">
            : disabled
            :: [=Fragment=]s are associated with pixel centers. That is, all the points with coordinates |C|, where
                fract(|C|) = vector2(0.5, 0.5) in the [=framebuffer=] space, enclosed into the polygon, are included.
                If a pixel center is on the edge of the polygon, whether or not it's included is not defined.

                Note: this becomes a subject of precision for the rasterizer.

            : enabled
            :: Each pixel is associated with |descriptor|.{{GPURenderPipelineDescriptor/multisample}}.{{GPUMultisampleState/count}}
                locations, which are implementation-defined.
                The locations are ordered, and the list is the same for each pixel of the [=framebuffer=].
                Each location corresponds to one fragment in the multisampled [=framebuffer=].

                The rasterizer builds a mask of locations being hit inside each pixel and provides is as "sample-mask"
                built-in to the fragment shader.
        </dl>

    1. For each produced fragment of type [=FragmentDestination=]:

        1. Let |rp| be be a new [=RasterizationPoint=] object
        1. Compute the list |b| as [[#barycentric-coordinates]] of that fragment.
            Set |rp|.[=RasterizationPoint/barycentricCoordinates=] to |b|.

        1. Let |d|<sub>|i|</sub> be the depth value of |v|<sub>|i|</sub>.

            Issue: define how this value is constructed.
        1. Set |rp|.[=RasterizationPoint/depth=] to &sum; (|b|<sub>|i|</sub> &times; |d|<sub>|i|</sub>)
        1. Append |rp| to |rasterizationPoints|.

    1. Return |rasterizationPoints|.

</div>

### Fragment Processing ### {#fragment-processing}

The fragment processing stage is a programmable stage of the render [=pipeline=] that
computes the fragment data (often a color) to be written into render targets.

This stage produces a <dfn dfn>Fragment</dfn> for each [=RasterizationPoint=]:
<div algorithm="Fragment accessors" dfn-for=Fragment>
    - <dfn dfn>destination</dfn> refers to [=FragmentDestination=].
    - <dfn dfn>coverageMask</dfn> refers to multisample coverage mask (see [[#sample-masking]]).
    - <dfn dfn>depth</dfn> refers to the depth in [=NDC=] coordinates.
    - <dfn dfn>colors</dfn> refers to the list of color values,
        one for each target in {{GPURenderPassDescriptor/colorAttachments}}.
</div>

<div algorithm>
    <dfn abstract-op>process fragment</dfn>(rp, desc, state)

    **Arguments:**
    - |rp|: The [=RasterizationPoint=], produced by [[#rasterization]].
    - |desc|: The descriptor of type {{GPUFragmentState}}.
    - |state|: The active [=RenderState=].

    **Returns:** [=Fragment=] or `null`.

    1. Let |fragment| be a new [=Fragment=] object.
    1. Set |fragment|.[=Fragment/destination=] to |rp|.[=RasterizationPoint/destination=].
    1. Set |fragment|.[=Fragment/coverageMask=] to |rp|.[=RasterizationPoint/coverageMask=].
    1. Set |fragment|.[=Fragment/depth=] to |rp|.[=RasterizationPoint/depth=].
    1. If |desc| is not `null`:
        1. Set the shader input [=builtins=]. For each non-composite argument of the entry point,
            annotated as a [=builtin=], set its value based on the annotation:
            <dl class="switch">
                : `position`
                :: `vec4<f32>`(|rp|.[=RasterizationPoint/destination=].[=FragmentDestination/position=], |rp|.[=RasterizationPoint/depth=], |rp|.[=RasterizationPoint/perspectiveDivisor=])

                : `front_facing`
                :: |rp|.[=RasterizationPoint/frontFacing=]

                : `sample_index`
                :: |rp|.[=RasterizationPoint/destination=].[=FragmentDestination/sampleIndex=]

                : `sample_mask`
                :: |rp|.[=RasterizationPoint/coverageMask=]
            </dl>
        1. For each user-specified [=pipeline input=] of the fragment stage:
            1. Let |value| be the interpolated fragment input,
                based on |rp|.[=RasterizationPoint/barycentricCoordinates=], |rp|.[=RasterizationPoint/primitiveVertices=],
                and the [=interpolation=] qualifier on the input.

                Issue: describe the exact equations.
            1. Set the corresponding fragment shader [=location=] input to |value|.
        1. Invoke the fragment shader entry point described by |desc|.
        1. If the fragment issued `discard`, return `null`.
        1. Set |fragment|.[=Fragment/colors=] to the user-specified [=pipeline output=] values from the shader.
        1. Take the shader output [=builtins=]:
            1. If `frag_depth` [=builtin=] is produced by the shader as |value|:
                1. Let |vp| be |state|.[=RenderState/viewport=].
                1. Set |fragment|.[=Fragment/depth=] to clamp(|value|, |vp|.`minDepth`, |vp|.`maxDepth`).
        1. If `sample_mask` [=builtin=] is produced by the shader as |value|:
            1. Set |fragment|.[=Fragment/coverageMask=] to |fragment|.[=Fragment/coverageMask=] &and; |value|.

        Otherwise we are in [[#no-color-output]] mode, and |fragment|.[=Fragment/colors=] is empty.
    1. Return |fragment|.
</div>

Processing of fragments happens in parallel, while any side effects,
such as writes into {{GPUBufferBindingType/"storage"|GPUBufferBindingType."storage"}} bindings,
may happen in any order.

### Output Merging ### {#output-merging}

Issue: fill out this section

The depth input to this stage, if any, is clamped to the current
{{GPURenderPassEncoder/[[viewport]]}} depth range
(regardless of whether the fragment shader stage writes the `frag_depth` builtin).

### No Color Output ### {#no-color-output}

In no-color-output mode, [=pipeline=] does not produce any color attachment outputs.

The [=pipeline=] still performs rasterization and produces depth values
based on the vertex position output. The depth testing and stencil operations can still be used.

### Alpha to Coverage ### {#alpha-to-coverage}

In alpha-to-coverage mode, an additional <dfn dfn>alpha-to-coverage mask</dfn>
of MSAA samples is generated based on the |alpha| component of the
fragment shader output value of the {{GPURenderPipelineDescriptor/fragment}}.{{GPUFragmentState/targets}}[0].

The algorithm of producing the extra mask is platform-dependent and can vary for different pixels.
It guarantees that:
  - if |alpha| is 0.0 or less, the result is 0x0
  - if |alpha| is 1.0 or greater, the result is 0xFFFFFFFF
  - if |alpha| is greater than some other |alpha1|,
    then the produced sample mask has at least as many bits set to 1 as the mask for |alpha1|

### Sample frequency shading ### {#sample-frequency-shading}

Issue: fill out the section

### Sample Masking ### {#sample-masking}

The <dfn dfn>final sample mask</dfn> for a pixel is computed as:
[=rasterization mask=] & {{GPUMultisampleState/mask}} & [=shader-output mask=].

Only the lower {{GPUMultisampleState/count}} bits of the mask are considered.

If the least-significant bit at position |N| of the [=final sample mask=] has value of "0",
the sample color outputs (corresponding to sample |N|) to all attachments of the fragment shader are discarded.
Also, no depth test or stencil operations are executed on the relevant samples of the depth-stencil attachment.

Note: the color output for sample |N| is produced by the fragment shader execution
with SV_SampleIndex == |N| for the current pixel.
If the fragment shader doesn't use this semantics, it's only executed once per pixel.

The <dfn dfn>rasterization mask</dfn> is produced by the rasterization stage,
based on the shape of the rasterized polygon. The samples included in the shape get the relevant
bits 1 in the mask.

The <dfn dfn>shader-output mask</dfn> takes the output value of "sample_mask" [=builtin=] in the fragment shader.
If the builtin is not output from the fragment shader, and {{GPUMultisampleState/alphaToCoverageEnabled}}
is enabled, the [=shader-output mask=] becomes the [=alpha-to-coverage mask=]. Otherwise, it defaults to 0xFFFFFFFF.

# Type Definitions # {#type-definitions}

<script type=idl>
typedef [EnforceRange] unsigned long GPUBufferDynamicOffset;
typedef [EnforceRange] unsigned long GPUStencilValue;
typedef [EnforceRange] unsigned long GPUSampleMask;
typedef [EnforceRange] long GPUDepthBias;

typedef [EnforceRange] unsigned long long GPUSize64;
typedef [EnforceRange] unsigned long GPUIntegerCoordinate;
typedef [EnforceRange] unsigned long GPUIndex32;
typedef [EnforceRange] unsigned long GPUSize32;
typedef [EnforceRange] long GPUSignedOffset32;

typedef unsigned long GPUFlagsConstant;
</script>

## Colors &amp; Vectors ## {#colors-and-vectors}

<script type=idl>
dictionary GPUColorDict {
    required double r;
    required double g;
    required double b;
    required double a;
};
typedef (sequence<double> or GPUColorDict) GPUColor;
</script>

Note: `double` is large enough to precisely hold 32-bit signed/unsigned
integers and single-precision floats.

<script type=idl>
dictionary GPUOrigin2DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin2DDict) GPUOrigin2D;
</script>

An <dfn dfn>Origin2D</dfn> is a {{GPUOrigin2D}}.
[=Origin2D=] is a spec namespace for the following definitions:
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin2D accessors" dfn-for=Origin2D>
    For a given {{GPUOrigin2D}} value |origin|, depending on its type, the syntax:

      - |origin|.<dfn dfn>x</dfn> refers to
        either {{GPUOrigin2DDict}}.{{GPUOrigin2DDict/x}}
        or the first item of the sequence or 0 if it isn't present.
      - |origin|.<dfn dfn>y</dfn> refers to
        either {{GPUOrigin2DDict}}.{{GPUOrigin2DDict/y}}
        or the second item of the sequence or 0 if it isn't present.
</div>

<script type=idl>
dictionary GPUOrigin3DDict {
    GPUIntegerCoordinate x = 0;
    GPUIntegerCoordinate y = 0;
    GPUIntegerCoordinate z = 0;
};
typedef (sequence<GPUIntegerCoordinate> or GPUOrigin3DDict) GPUOrigin3D;
</script>

An <dfn dfn>Origin3D</dfn> is a {{GPUOrigin3D}}.
[=Origin3D=] is a spec namespace for the following definitions:
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUOrigin3D accessors" dfn-for=Origin3D>
    For a given {{GPUOrigin3D}} value |origin|, depending on its type, the syntax:

      - |origin|.<dfn dfn>x</dfn> refers to
        either {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/x}}
        or the first item of the sequence or 0 if it isn't present.
      - |origin|.<dfn dfn>y</dfn> refers to
        either {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/y}}
        or the second item of the sequence or 0 if it isn't present.
      - |origin|.<dfn dfn>z</dfn> refers to
        either {{GPUOrigin3DDict}}.{{GPUOrigin3DDict/z}}
        or the third item of the sequence or 0 if it isn't present.
</div>

<script type=idl>
dictionary GPUExtent3DDict {
    required GPUIntegerCoordinate width;
    GPUIntegerCoordinate height = 1;
    GPUIntegerCoordinate depthOrArrayLayers = 1;
};
typedef (sequence<GPUIntegerCoordinate> or GPUExtent3DDict) GPUExtent3D;
</script>

An <dfn dfn>Extent3D</dfn> is a {{GPUExtent3D}}.
[=Extent3D=] is a spec namespace for the following definitions:
<!-- This is silly, but provides convenient syntax for the spec. -->

<div algorithm="GPUExtent3D accessors" dfn-for=Extent3D>
    For a given {{GPUExtent3D}} value |extent|, depending on its type, the syntax:

      - |extent|.<dfn dfn>width</dfn> refers to
        either {{GPUExtent3DDict}}.{{GPUExtent3DDict/width}}
        or the first item of the sequence (1 if not present).
      - |extent|.<dfn dfn>height</dfn> refers to
        either {{GPUExtent3DDict}}.{{GPUExtent3DDict/height}}
        or the second item of the sequence (1 if not present).
      - |extent|.<dfn dfn>depthOrArrayLayers</dfn> refers to
        either {{GPUExtent3DDict}}.{{GPUExtent3DDict/depthOrArrayLayers}}
        or the third item of the sequence (1 if not present).
</div>

# Feature Index # {#feature-index}

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth-clip-control"</dfn> ## {#depth-clip-control}

Issue: Define functionality when the {{GPUFeatureName/"depth-clip-control"}} [=feature=] is enabled.

**Feature Dictionary Values**

The following dictionary values are supported if and only if the {{GPUFeatureName/"depth-clip-control"}}
[=feature=] is enabled; otherwise, they must be set to their default values:

<dl>
    : {{GPUPrimitiveState}}
    ::
        * {{GPUPrimitiveState/unclippedDepth}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth24unorm-stencil8"</dfn> ## {#depth24unorm-stencil8}

Allows for explicit creation of textures of format {{GPUTextureFormat/"depth24unorm-stencil8"}}.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"depth24unorm-stencil8"}}
[=feature=] is enabled:

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"depth24unorm-stencil8"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"depth32float-stencil8"</dfn> ## {#depth32float-stencil8}

Allows for explicit creation of textures of format {{GPUTextureFormat/"depth32float-stencil8"}}.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"depth32float-stencil8"}}
[=feature=] is enabled:

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"depth32float-stencil8"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-bc"</dfn> ## {#texture-compression-bc}

Allows for explicit creation of textures of BC compressed formats.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"texture-compression-bc"}}
[=feature=] is enabled:

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"bc1-rgba-unorm"}}
        * {{GPUTextureFormat/"bc1-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc2-rgba-unorm"}}
        * {{GPUTextureFormat/"bc2-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc3-rgba-unorm"}}
        * {{GPUTextureFormat/"bc3-rgba-unorm-srgb"}}
        * {{GPUTextureFormat/"bc4-r-unorm"}}
        * {{GPUTextureFormat/"bc4-r-snorm"}}
        * {{GPUTextureFormat/"bc5-rg-unorm"}}
        * {{GPUTextureFormat/"bc5-rg-snorm"}}
        * {{GPUTextureFormat/"bc6h-rgb-ufloat"}}
        * {{GPUTextureFormat/"bc6h-rgb-float"}}
        * {{GPUTextureFormat/"bc7-rgba-unorm"}}
        * {{GPUTextureFormat/"bc7-rgba-unorm-srgb"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-etc2"</dfn> ## {#texture-compression-etc}

Allows for explicit creation of textures of ETC2 compressed formats.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"texture-compression-etc2"}}
[=feature=] is enabled:

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"etc2-rgb8unorm"}}
        * {{GPUTextureFormat/"etc2-rgb8unorm-srgb"}}
        * {{GPUTextureFormat/"etc2-rgb8a1unorm"}}
        * {{GPUTextureFormat/"etc2-rgb8a1unorm-srgb"}}
        * {{GPUTextureFormat/"etc2-rgba8unorm"}}
        * {{GPUTextureFormat/"etc2-rgba8unorm-srgb"}}
        * {{GPUTextureFormat/"eac-r11unorm"}}
        * {{GPUTextureFormat/"eac-r11snorm"}}
        * {{GPUTextureFormat/"eac-rg11unorm"}}
        * {{GPUTextureFormat/"eac-rg11snorm"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"texture-compression-astc"</dfn> ## {#texture-compression-astc}

Allows for explicit creation of textures of ASTC compressed formats.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"texture-compression-astc"}}
[=feature=] is enabled:

<dl>
    : {{GPUTextureFormat}}
    ::
        * {{GPUTextureFormat/"astc-4x4-unorm"}}
        * {{GPUTextureFormat/"astc-4x4-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-5x4-unorm"}}
        * {{GPUTextureFormat/"astc-5x4-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-5x5-unorm"}}
        * {{GPUTextureFormat/"astc-5x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-6x5-unorm"}}
        * {{GPUTextureFormat/"astc-6x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-6x6-unorm"}}
        * {{GPUTextureFormat/"astc-6x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x5-unorm"}}
        * {{GPUTextureFormat/"astc-8x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x6-unorm"}}
        * {{GPUTextureFormat/"astc-8x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-8x8-unorm"}}
        * {{GPUTextureFormat/"astc-8x8-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x5-unorm"}}
        * {{GPUTextureFormat/"astc-10x5-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x6-unorm"}}
        * {{GPUTextureFormat/"astc-10x6-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x8-unorm"}}
        * {{GPUTextureFormat/"astc-10x8-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-10x10-unorm"}}
        * {{GPUTextureFormat/"astc-10x10-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-12x10-unorm"}}
        * {{GPUTextureFormat/"astc-12x10-unorm-srgb"}}
        * {{GPUTextureFormat/"astc-12x12-unorm"}}
        * {{GPUTextureFormat/"astc-12x12-unorm-srgb"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"timestamp-query"</dfn> ## {#timestamp-query}

Issue: Define functionality when the {{GPUFeatureName/"timestamp-query"}} [=feature=] is enabled.

**Feature Enums**

The following enums are supported if and only if the {{GPUFeatureName/"timestamp-query"}}
[=feature=] is enabled:

<dl>
    : {{GPUQueryType}}
    ::
        * {{GPUQueryType/"timestamp"}}
</dl>

## <dfn dfn-type=enum-value dfn-for=GPUFeatureName>"indirect-first-instance"</dfn> ## {#indirect-first-instance}

Removes the zero value restriction on `firstInstance` in [=indirect draw parameters=] and [=indirect drawIndexed parameters=].
`firstInstance` is allowed to be non-zero if and only if the {{GPUFeatureName/"indirect-first-instance"}} [=feature=] is enabled.

# Appendices # {#appendices}

## Texture Format Capabilities ## {#texture-format-caps}

### Plain color formats ### {#plain-color-formats}

All plain color formats support {{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}}, and {{GPUTextureUsage/TEXTURE_BINDING}} usage.

Only formats with {{GPUTextureSampleType}} {{GPUTextureSampleType/"float"}} can be blended.

The {{GPUTextureUsage/RENDER_ATTACHMENT}} and {{GPUTextureUsage/STORAGE_BINDING}} columns
specify support for {{GPUTextureUsage/RENDER_ATTACHMENT|GPUTextureUsage.RENDER_ATTACHMENT}}
and {{GPUTextureUsage/STORAGE_BINDING|GPUTextureUsage.STORAGE_BINDING}} usage respectively.

<table class='data'>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>{{GPUTextureSampleType}}
            <th>{{GPUTextureUsage/RENDER_ATTACHMENT}}
            <th>multisampling
            <th>resolve
            <th>{{GPUTextureUsage/STORAGE_BINDING}}
    </thead>
    <tr><th class=stickyheader>8-bit per component<th><th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>&checkmark;
        <td>
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/r8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/r8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/rg8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>&checkmark;
        <td>
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/rg8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rgba8snorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>&checkmark;
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba8sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/bgra8unorm-srgb}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr><th class=stickyheader>16-bit per component<th><th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/r16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/r16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Vulkan -->
    <tr>
        <td>{{GPUTextureFormat/rgba16uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba16sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba16float}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
    <tr><th class=stickyheader>32-bit per component<th><th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/r32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/r32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/r32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td><!-- Metal -->
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rg32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32uint}}
        <td>{{GPUTextureSampleType/"uint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32sint}}
        <td>{{GPUTextureSampleType/"sint"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/rgba32float}}
        <td>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td><!-- Metal -->
        <td>
        <td>&checkmark;
    <tr><th class=stickyheader>mixed component width<th><th><th><th><th>
    <tr>
        <td>{{GPUTextureFormat/rgb10a2unorm}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>&checkmark;
        <td>&checkmark;
        <td>&checkmark;
        <td>
    <tr>
        <td>{{GPUTextureFormat/rg11b10ufloat}}
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td><!-- Vulkan -->
        <td>&checkmark;
        <td>
        <td><!-- Vulkan -->

</table>

### Depth-stencil formats ### {#depth-formats}

A <dfn dfn>depth-or-stencil format</dfn> is any format with depth and/or stencil aspects.
A <dfn dfn>combined depth-stencil format</dfn> is a [=depth-or-stencil format=] that has both
depth and stencil aspects.

All [=depth-or-stencil formats=] support the {{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}},
{{GPUTextureUsage/TEXTURE_BINDING}}, and {{GPUTextureUsage/RENDER_ATTACHMENT}} usages.
All of these formats support multisampling.
However, certain copy operations also restrict the source and destination formats.

None of the depth formats can be filtered.

<table class='data'>
    <thead>
        <tr>
            <th>Format
            <th>Bytes per texel
            <th>Aspect
            <th>{{GPUTextureSampleType}}
            <th>Valid [=image copy=] source
            <th>Valid [=image copy=] destination
    </thead>
    <tr>
        <td>{{GPUTextureFormat/stencil8}}
        <td>1 &minus; 4
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth16unorm}}
        <td>2
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth24plus}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&cross;
    <tr>
        <td rowspan=2 style='white-space:nowrap'>{{GPUTextureFormat/depth24plus-stencil8}}
        <td rowspan=2>4 &minus; 8
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&cross;
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
    <tr>
        <td>{{GPUTextureFormat/depth32float}}
        <td>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=1>&checkmark;
        <td colspan=1>&cross;
    <tr>
        <td rowspan=2 style='white-space:nowrap'>{{GPUTextureFormat/depth24unorm-stencil8}}
        <td rowspan=2>4
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=2>&cross;
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
    <tr>
        <td rowspan=2 style='white-space:nowrap'>{{GPUTextureFormat/depth32float-stencil8}}
        <td rowspan=2>5 &minus; 8
        <td>depth
        <td>{{GPUTextureSampleType/"depth"}}
        <td colspan=1>&checkmark;
        <td colspan=1>&cross;
    <tr>
        <td>stencil
        <td>{{GPUTextureSampleType/"uint"}}
        <td colspan=2>&checkmark;
</table>

#### Reading and Sampling Depth/Stencil Textures #### {#reading-depth-stencil}

When reading or sampling a depth component via a `texture_depth_*`-typed binding, the value is
returned as an `f32` value.

Issue(gpuweb/gpuweb#2094): Depending on the resolution of this issue, allow reading/sampling via
`texture_2d` etc. in the table above and specify the behavior. (`vec4<f32>(D, X, X, X)`?)
Update the note below which would become slightly outdated.

Reading or sampling a stencil component must be done via a normal texture binding
(`texture_2d`, `texture_2d_array`, `texture_cube`, or `texture_cube_array`).
When doing so, the value is returned as `vec4<u32>(S, X, X, X)`, where S is the stencil value and each X is an implementation-defined unspecified value.
Authors must not rely on these `.y`, `.z`, and `.w` components, as their behavior is non-portable.

Note:
Short of adding a new more constrained stencil sampler type (like depth), it's infeasible for implementations to efficiently paper over the driver differences for stencil reads.
As this was not a portability pain point for WebGL, it's not expected to be problematic in WebGPU.
In practice, expect either `vec4<u32>(S, S, S, S)` or `vec4<u32>(S, 0, 0, 1)`, depending on hardware.

#### Copying Depth/Stencil Textures #### {#copying-depth-stencil}

The texel values of depth32float formats
({{GPUTextureFormat/"depth32float"}} and {{GPUTextureFormat/"depth32float-stencil8"}}
have a limited range.
As a result, copies into such textures are only valid from other textures of the same format.
<!-- Update this if an unrestricted-depth feature is added. -->

The depth aspects of depth24plus formats
({{GPUTextureFormat/"depth24plus"}} and {{GPUTextureFormat/"depth24plus-stencil8"}})
have opaque representations (implemented as either "depth24unorm" or "depth32float").
The depth aspect of {{GPUTextureFormat/"depth24unorm-stencil8"}}
doesn't have a aligned tightly-packed representation (because its size is 3 bytes).
As a result, depth-aspect [=image copies=] are not allowed with these formats.

<div class=note>
    It is possible to imitate these disallowed copies:

    - All of these formats can be written in a render pass using a fragment shader that outputs
        depth values via the `frag_depth` output.
    - Textures with "depth24plus"/"depth24unorm" formats can be read as shader textures, and
        written to a texture (as a render pass attachment) or
        buffer (via a storage buffer binding in a compute shader).
</div>

### Packed formats ### {#packed-formats}

All packed texture formats support {{GPUTextureUsage/COPY_SRC}}, {{GPUTextureUsage/COPY_DST}},
and {{GPUTextureUsage/TEXTURE_BINDING}} usages. All of these formats have {{GPUTextureSampleType/"float"}}
type and can be filtered on sampling. None of these formats support multisampling.

A <dfn dfn>compressed format</dfn> is any format with a block size greater than 1 &times; 1.

<table class='data'>
    <thead class=stickyheader>
        <tr>
            <th>Format
            <th>Bytes per block
            <th>{{GPUTextureSampleType}}
            <th>Block Size
            <th>[=Feature=]
    </thead>
    <tr>
        <td>{{GPUTextureFormat/rgb9e5ufloat}}
        <td>4
        <td>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td>1 &times; 1
        <td>
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm}}
        <td rowspan=2>8
        <td rowspan=14>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=14>4 &times; 4
        <td rowspan=14>{{GPUFeatureName/texture-compression-bc}}
    <tr>
        <td>{{GPUTextureFormat/bc1-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc2-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc3-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/bc4-r-unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/bc4-r-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc5-rg-snorm}}
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-ufloat}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc6h-rgb-float}}
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/bc7-rgba-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8unorm}}
        <td rowspan=2>8
        <td rowspan=10>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=10>4 &times; 4
        <td rowspan=10>{{GPUFeatureName/texture-compression-etc2}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8a1unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/etc2-rgb8a1unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/etc2-rgba8unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/etc2-rgba8unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/eac-r11unorm}}
        <td rowspan=2>8
    <tr>
        <td>{{GPUTextureFormat/eac-r11snorm}}
    <tr>
        <td>{{GPUTextureFormat/eac-rg11unorm}}
        <td rowspan=2>16
    <tr>
        <td>{{GPUTextureFormat/eac-rg11snorm}}
    <tr>
        <td>{{GPUTextureFormat/astc-4x4-unorm}}
        <td rowspan=2>16
        <td rowspan=28>{{GPUTextureSampleType/"float"}},<br/>{{GPUTextureSampleType/"unfilterable-float"}}
        <td rowspan=2>4 &times; 4
        <td rowspan=28>{{GPUFeatureName/texture-compression-astc}}
    <tr>
        <td>{{GPUTextureFormat/astc-4x4-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-5x4-unorm}}
        <td rowspan=2>16
        <td rowspan=2>5 &times; 4
    <tr>
        <td>{{GPUTextureFormat/astc-5x4-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-5x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>5 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-5x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-6x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>6 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-6x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-6x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>6 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-6x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-8x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-8x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-8x8-unorm}}
        <td rowspan=2>16
        <td rowspan=2>8 &times; 8
    <tr>
        <td>{{GPUTextureFormat/astc-8x8-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x5-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 5
    <tr>
        <td>{{GPUTextureFormat/astc-10x5-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x6-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 6
    <tr>
        <td>{{GPUTextureFormat/astc-10x6-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x8-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 8
    <tr>
        <td>{{GPUTextureFormat/astc-10x8-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-10x10-unorm}}
        <td rowspan=2>16
        <td rowspan=2>10 &times; 10
    <tr>
        <td>{{GPUTextureFormat/astc-10x10-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-12x10-unorm}}
        <td rowspan=2>16
        <td rowspan=2>12 &times; 10
    <tr>
        <td>{{GPUTextureFormat/astc-12x10-unorm-srgb}}
    <tr>
        <td>{{GPUTextureFormat/astc-12x12-unorm}}
        <td rowspan=2>16
        <td rowspan=2>12 &times; 12
    <tr>
        <td>{{GPUTextureFormat/astc-12x12-unorm-srgb}}
</table>

## Temporary usages of non-exported dfns ## {#temp-dfn-usages}

[=Origin2D/x=] [=Origin2D/y=]
[=RenderPassDescriptor/renderExtent=]

Eventually all of these should disappear but they are useful to avoid warning while building the specification.

[=vertex buffer=]
