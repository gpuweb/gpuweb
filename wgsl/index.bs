<pre class='metadata'>
Title: WebGPU Shading Language
Shortname: WGSL
Level: None
Status: w3c/ED
Group: webgpu
ED: https://gpuweb.github.io/gpuweb/wgsl/
TR: https://www.w3.org/TR/WGSL/
Repository: gpuweb/gpuweb
Text Macro: INT i32 or u32
Text Macro: UNSIGNEDINTEGRAL u32 or vec|N|&lt;u32&gt;
Text Macro: SIGNEDINTEGRAL i32 or vec|N|&lt;i32&gt;
Text Macro: ALLSIGNEDINTEGRAL AbstractInt, i32, vec|N|&lt;AbstractInt&gt;, or vec|N|&lt;i32&gt;
Text Macro: INTEGRAL i32, u32, vec|N|&lt;i32&gt;, or vec|N|&lt;u32&gt;
Text Macro: FLOATING f32, f16, vec|N|&lt;f32&gt;, or vec|N|&lt;f16&gt;
Text Macro: NUMERIC i32, u32, f32, f16, vec|N|&lt;i32&gt;, vec|N|&lt;u32&gt;, vec|N|&lt;f32&gt;, or vec|N|&lt;f16&gt;
Text Macro: ALLINTEGRALDECL |S| is AbstractInt, i32, or u32<br>|T| is |S| or vec|N|&lt;|S|&gt;
Text Macro: ALLFLOATINGDECL |S| is AbstractFloat, f32, or f16<br>|T| is |S| or vec|N|&lt;|S|&gt;
Text Macro: ALLNUMERICDECL |S| is AbstractInt, AbstractFloat, i32, u32, f32, or f16<br>|T| is |S|, or vec|N|&lt;|S|&gt;
Ignored Vars: i, c0, e, e1, e2, e3, edge, eN, p, s1, s2, sn, AS, AM, N, newbits, M, C, R, v, Stride, Offset, Align, Extent, T, T1

!Participate: <a href="https://github.com/gpuweb/gpuweb/issues/new?labels=wgsl">File an issue</a> (<a href="https://github.com/gpuweb/gpuweb/issues?q=is%3Aissue+is%3Aopen+label%3Awgsl">open issues</a>)
!Tests: <a href=https://github.com/gpuweb/cts/tree/main/src/webgpu/shader/>WebGPU CTS shader/</a>

Editor: David Neto, Google https://www.google.com, dneto@google.com, w3cid 99785
Editor: Myles C. Maxfield, Apple Inc., mmaxfield@apple.com, w3cid 77180
Former Editor: dan sinclair, Google https://www.google.com, dsinclair@google.com
Abstract: Shading language for WebGPU.
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Markup Shorthands: idl no
Assume Explicit For: yes
</pre>

<style>
tr:nth-child(2n) {
  background-color: #b0b0b050;
}
thead {
  background-color: #b0b0b050;
  font-weight: bold;
}
.nowrap {
  white-space:nowrap;
}
.small {
  font-size: smaller;
}
div.syntax {
  display: block;
  page-break-before: avoid;
  padding: .5em 1em;
  background: var(--def-bg);
  border-left: 0.5em solid var(--def-border);
  color: black;
  color: var(--def-text);
  margin-block-start: 1em;
  margin-block-end: 1em;
}
div.syntax > p {
  margin-block-start: 0em;
  margin-block-end: 0em;
  margin-inline-start: 1em;
  margin-inline-end: 0em;
}
div.syntax > p::first-letter {
  letter-spacing: 0.5em;
}
div.syntax > p > a {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
}
div.syntax > p > code {
  margin-inline-start: 0.1em;
  margin-inline-end: 0.1em;
}
</style>

<pre class=biblio>
{
  "WebGPU": {
    "authors": [
      "Dzmitry Malyshau",
      "Kai Ninomiya",
      "Brandon Jones"
    ],
    "href": "https://gpuweb.github.io/gpuweb/",
    "title": "WebGPU",
    "status": "Editor's Draft",
    "publisher": "W3C",
    "deliveredBy": [
      "https://github.com/gpuweb/gpuweb"
    ]
  },
  "IEEE-754":{
    "href":"http://ieeexplore.ieee.org/servlet/opac?punumber=4610933",
    "title":"IEEE Standard for Floating-Point Arithmetic",
    "publisher":"Institute of Electrical and Electronics Engineers",
    "isbn":"978-0-7381-5752-8",
    "versions":["IEEE-754-2008","IEEE-754-1985"],
    "id":"IEEE-754",
    "date":"29 August 2008"
  },
  "VulkanMemoryModel": {
    "authors": [
      "Jeff Bolz",
      "Alan Baker",
      "Tobias Hector",
      "David Neto",
      "Robert Simpson",
      "Brian Sumner"
    ],
    "href": "https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#memory-model",
    "title": "Vulkan Memory Model",
    "publisher": "Khronos Group"
  },
  "UnicodeVersion14": {
    "href":"http://www.unicode.org/versions/Unicode14.0.0/",
    "author":"The Unicode Consortium",
    "title":"The Unicode Standard, Version 14.0.0",
    "isbn":"978-1-936213-29-0",
    "id":"UnicodeVersion14"
  },
  "DeRemer1969": {
    "href":"http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-065.pdf",
    "author":"F. L. DeRemer",
    "publisher":"Massachusetts Institute of Technology",
    "date":"24 October 1969",
    "title":"Practical Translators for LR(k) Languages"
  },
  "VanWyk2007": {
    "href":"https://dl.acm.org/doi/10.1145/1289971.1289983",
    "title":"Context-Aware Scanning for Parsing Extensible Languages",
    "authors": [
      "Eric R. Van Wyk",
      "August C. Schwerdfeger"
    ],
    "publisher":"Association for Computing Machinery",
    "series":"GCPE'07",
    "date":"2007"
  }
}
</pre>

<pre class='anchors'>
spec: Vulkan ; urlPrefix: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#
    type: dfn
        text: memory model memory operation; url: memory-model-memory-operation
        text: memory model reference; url: memory-model-references
        text: memory model atomic operation; url: memory-model-atomic-operation
        text: memory model scope; url:memory-model-scope
        text: memory model memory semantics; url:memory-model-memory-semantics
        text: memory model non-private; url: memory-model-non-private
spec: UAX14; urlPrefix: https://www.unicode.org/reports/tr14
    type: dfn
        text: UAX14 Section 6.1 Non-tailorable Line Breaking Rules; url: BreakingRules
        text: UAX14 LB4; url: LB4
        text: UAX14 LB5; url: LB5
spec: UAX31; urlPrefix: https://www.unicode.org/reports/tr31/tr31-35.html
    type: dfn
        text: Unicode Standard Annex #31 for Unicode Version 14.0.0
        text: UAX31 Lexical Classes; url: Table_Lexical_Classes_for_Identifiers
        text: UAX31 Grammar; url: D1
spec: Unicode Character Database for Unicode Version 14.0.0; urlPrefix: https://www.unicode.org/Public/14.0.0/ucd/DerivedCoreProperties.txt
    type: dfn
        text: Unicode Character Database for Unicode Version 14.0.0
spec: UnicodeVersion14; urlPrefix: https://www.unicode.org/versions/Unicode14.0.0/UnicodeStandard-14.0.pdf
    type: dfn
        text: code point; url:
</pre>

# Introduction # {#intro}

WebGPU Shading Language (WGSL) is the shader language for [[!WebGPU]].
That is, an application using the WebGPU API uses WGSL to express the programs, known as shaders,
that run on the GPU.

<div class='example wgsl global-scope'>
  <xmp highlight='rust'>
    @fragment
    fn main() -> @location(0) vec4<f32> {
        return vec4<f32>(0.4, 0.4, 0.8, 1.0);
    }
  </xmp>
</div>

## Technical Overview ## {#technical-overview}

WebGPU issues a unit of work to the GPU in the form of a [[WebGPU#gpu-command|GPU command]].
WGSL is concerned with two kinds of GPU commands:
* a <dfn noexport>draw command</dfn> executes a [=GPURenderPipeline|render pipeline=]
    in the context of [=pipeline input|inputs=], [=pipeline output|outputs=], and attached [=resources=].
* a <dfn noexport>dispatch command</dfn> executes a [=GPUComputePipeline|compute pipeline=]
    in the context of [=pipeline input|inputs=] and attached [=resources=].

Both kinds of pipelines use shaders written in WGSL.

A <dfn noexport>shader</dfn> is the portion of a WGSL program that executes a [=shader stage=] in a pipeline.
A shader comprises:
* An [=entry point=] [=function/function=].
* The transitive closure of all called functions, starting with the entry point.
    This set includes both [=user-defined function|user-defined=] and [=built-in function|built-in=] functions.
    (For a more rigorous definition, see "[=functions in a shader stage=]".)
* The set of variables and constants [=statically accessed=] by all those functions.
* The set of types used to define or analyze all those functions, variables, and constants.

When executing a shader stage, the implementation:
* Computes the values of constants declared at [=module scope|module-scope=].
* Binds [=resources=] to variables in the shader's [=resource interface of a shader|resource interface=],
    making the contents of those resources available to the shader during execution.
* Allocates memory for other [=module scope|module-scope=] variables,
    and populates that memory with the specified initial values.
* Populates the formal parameters of the entry point, if they exist, with the stage's pipeline inputs.
* Connects the entry point [=return value=], if one exists, to the stage's pipeline outputs.
* Then it invokes the entry point.

A WGSL program is organized into:
* Functions, which specify execution behaviour.
* Statements, which are declarations or units of executable behaviour.
* Literals, which are text representations for pure mathematical values.
* Constants, each providing a name for a value computed at a specific time.
* Variables, each providing a name for memory holding a value.
* Expressions, each of which combines a set of values to produce a result value.
* Types, each of which describes:
    * A set of values.
    * Constraints on supported expressions.
    * The semantics of those expressions.

WGSL is an imperative language: behaviour is specified as a sequence of statements to execute.
Statements:
* Declare constants or variables.
* Modify the contents of variables.
* Modify execution order using structured programming constructs:
    * Selective execution: if/else if/else, switch.
    * Repetition: loop, while, for.
    * Escaping a nested execution construct: break, continue.
    * Refactoring: function call and return.
    * Discard (fragment shaders only): terminating the invocation and throwing away the output.
* Evaluate expressions to compute values as part of the above behaviours.

WGSL is statically typed: each value computed by a particular expression is in a specific type,
determined only by examining the program source.

WGSL has types to describe booleans, numbers, vectors, matrices, and aggregations
of these in the form of arrays and structures.
Additional types describe memory.

WGSL does not have implicit conversions or promotions between numeric or boolean types.
Converting a value from one numeric or boolean type to another requires
an explicit [[#conversion-expr|conversion]],
[[#type-constructor-expr|construction]], or [[#bitcast-expr|reinterpretation of bits]].
This also applies to vector types.

WGSL has texture and sampler types.
Together with their associated built-in functions, these support functionality
commonly used for graphics rendering, and commonly provided by GPUs.

The work of a shader stage is partitioned into one or more <dfn noexport>invocations</dfn>,
each of which executes the entry point, but under slightly different conditions.
Invocations in a shader stage share access to certain variables:
* All invocations in the stage share the resources in the shader interface.
* In a [=compute shader stage|compute shader=], invocations in the same
     [=compute shader stage/workgroup=] share
     variables in the [=address spaces/workgroup=] [=address space=].
     Invocations in different workgroups do not share those variables.

However, the invocations act on different sets of pipeline inputs, including built-in inputs
that provide an identifying value to distinguish an invocation from its peers.
Each invocation has its own independent memory space in the form
of variables in the [=address spaces/private=] and [=address spaces/function=] address spaces.

Invocations within a shader stage execute concurrently, and may often execute in parallel.
The shader author is responsible for ensuring the dynamic behaviour of the invocations
in a shader stage:
* Meet the [[#uniformity|uniformity]] requirements of certain primitive operations, including texture sampling and control barriers.
* Coordinate potentially conflicting accesses to shared variables, to avoid race conditions.

WGSL sometimes permits several possible behaviours for a given feature.
This is a portability hazard, as different implementations may exhibit the different behaviours.
The design of WGSL aims to minimize such cases, but is constrained by feasibility,
and goals for achieving high performance across a broad range of devices.

## Notation ## {#notation}

The <dfn noexport>floor expression</dfn> is defined over real numbers |x|:

* &lfloor;|x|&rfloor; = |k|, where |k| is the unique integer such that |k| &le; |x| &lt; |k|+1

The <dfn noexport>ceiling expression</dfn> is defined over real numbers |x|:

* &lceil;|x|&rceil; = |k|, where |k| is the unique integer such that |k|-1 &lt; |x| &le; |k|

The <dfn noexport>truncate</dfn> function is defined over real numbers |x|,
and computes the nearest whole number whose absolute value is less than or equal to |x|:

* truncate(|x|) = &lfloor;|x|&rfloor; if |x| &ge; 0, and &lceil;|x|&rceil; if |x| &lt; 0.

The <dfn noexport>roundUp</dfn> function is defined for positive integers |k| and |n| as:

* roundUp(|k|, |n|) = &lceil;|n| &div; |k|&rceil; &times; |k|

The <dfn noexport>transpose</dfn> of an |c|-column |r|-row matrix |A| is the |r|-column |c|-row matrix
|A|<sup>T</sup> formed by copying the rows of |A| as the columns of |A|<sup>T</sup>:

* transpose(|A|) = |A|<sup>T</sup>
* transpose(|A|)<sub>|i|,|j|</sub> = |A|<sub>|j|,|i|</sub>

The transpose of a column vector is defined by interpreting the column vector as a 1-row matrix.
Similarly, the transpose of a row vector is defined by interpreting the row vector as a 1-column matrix.

# Shader Lifecycle # {#shader-lifecycle}

There are four key events in the lifecycle of a WGSL program and the shaders it may contain.
The first two correspond to the WebGPU API methods used to prepare a WGSL program
for execution.
The last two are the start and end of execution of a shader.

The events are:

1. <dfn noexport>Shader module creation</dfn>
    * This occurs when the
        [[WebGPU#dom-gpudevice-createshadermodule|WebGPU createShaderModule]] method
        is called.
        The source text for a WGSL program is provided at this time.
2. <dfn noexport>Pipeline creation</dfn>
    * This occurs when the
        [[WebGPU#dom-gpudevice-createcomputepipeline|WebGPU createComputePipeline]] method
        or the
        [[WebGPU#dom-gpudevice-createrenderpipeline|WebGPU createRenderPipeline]] method
        is invoked.
        These methods use one or more previously created shader modules, together with other
        configuration information.
3. <dfn noexport>Shader execution start</dfn>
    * This occurs when a [=draw command|draw=] or [=dispatch command=] is issued to the GPU,
        begins executing the pipeline,
        and invokes the [=shader stage=] [=entry point=] function.
4. <dfn noexport>Shader execution end</dfn>
    * This occurs when all work in the shader completes:
        * all its [=invocations=] terminate, and
        * all accesses to [=resources=] complete, and
        * outputs, if any, are passed to downstream pipeline stages.

The events are ordered due to:
*  data dependencies: shader execution requires a pipeline, and a pipeline requires a shader module.
*  causality: the shader must start executing before it can finish executing.

## Processing Errors ## {#processing-errors}

A WebGPU implementation may fail to process a shader for two reasons:

* A <dfn export>program error</dfn> occurs if the shader does not satisfy the requirements of the WGSL or WebGPU specifications.
* An <dfn noexport>uncategorized error</dfn> may occur
    even when all WGSL and WebGPU requirements have been satisfied.
    Possible causes include:
    * The shaders are too complex, exceeding the capabilities of the implementation,
        but in a way not easily captured by prescribed [[#limits|limits]].
        Simplifying the shaders may work around the issue.
    * A defect in the WebGPU implementation.


A processing error may occur during three phases in the shader lifecycle:

* A <dfn export>shader-creation error</dfn>
    is an error feasibly detectable at [=shader module creation=] time.
    Detection relies only on the WGSL program source text
    and other information available to the `createShaderModule` API method.
    Statements in this specification that describe something the program *must*
    do generally produce a shader-creation error if those assertions are violated.

* A <dfn export>pipeline-creation error</dfn>
    is an error detectable at [=pipeline creation=] time.
    Detection relies on the WGSL program source text
    and other information available to the particular pipeline creation API method.

* A <dfn export>dynamic error</dfn> is an error occurring during shader execution.
    These errors may or may not be detectable.

Note: For example, a race condition may not be detectable.

Each requirement will be checked at the earliest opportunity.
That is:
* A shader-creation error results when failing to meet a requirement detectable at shader-creation time.
* A pipeline-creation error results when failing to meet a requirement detectable at pipeline-creation time,
    but not detectable earlier.

When unclear from context, this specification indicates
whether failure to meet a particular requirement
results in a shader-creation, pipeline-creation, or dynamic error.

The WebGPU specification describes the consequences of each kind of error.

# Textual Structure # {#textual-structure}

A WGSL program is text.
This specification does not prescribe a particular encoding for that text.
However, UTF-8 is always a valid encoding for a WGSL program.

Note: The intent of promoting UTF-8 like this is to simplify interchange of WGSL programs
and to encourage interoperability among tools.

WGSL program text consists of a sequence of Unicode [=code points=], grouped into contiguous non-empty sets forming:
* [=comments=]
* [=tokens=]
* [=blankspaces=]

The program text [=shader-creation error|must not=] include a null code point (`U+0000`).

## Parsing ## {#parsing}

To parse a WGSL program:
1. Remove [=comments=]:
    * Replace the first comment with a space code point (`U+0020`).
    * Repeat until no comments remain.
2. Parse the whole text, attempting to match the [=syntax/translation_unit=] grammar rule.
    Parsing uses a LALR(1) parser (one token of lookahead) [[!DeRemer1969]], with the following customization:
    * Tokenization is interleaved with parsing, and is context-aware.
        When the parser requests the next token:
        * Consume and ignore an initial sequence of [=blankspace=] code points.
        * A <dfn>token candidate</dfn> is any WGSL [=token=] formed from the non-empty prefix of the remaining unconsumed code points.
        * The token returned is the longest [=token candidate=] that is also a valid lookahead token for the current parser state. [[!VanWyk2007]]

A [=shader-creation error=] results if:
* the entire source text cannot be converted into a finite sequence of valid tokens, or
* the [=syntax/translation_unit=] grammar rule does not match the entire token sequence.

## Blankspace and line breaks ## {#blankspace-and-line-breaks}

<dfn>Blankspace</dfn> is any combination of one or more of code points from the Unicode
[=Unicode Standard Annex #31 for Unicode Version 14.0.0|Pattern_White_Space=] property.
The following is the set of code points in [=Unicode Standard Annex #31 for Unicode Version 14.0.0|Pattern_White_Space=]:
* space (`U+0020`)
* horizontal tab (`U+0009`)
* line feed (`U+000A`)
* vertical tab (`U+000B`)
* form feed (`U+000C`)
* carriage return (`U+000D`)
* next line (`U+0085`)
* left-to-right mark (`U+200E`)
* right-to-left mark (`U+200F`)
* line separator (`U+2028`)
* paragraph separator (`U+2029`)

<div class='syntax' noexport='true'>
  <dfn for=syntax>_blankspace</dfn> :

    | `/[\u0020\u0009\u000a\u000b\u000c\u000d\u0085\u200e\u200f\u2028\u2029]/uy`
</div>

A <dfn>line break</dfn> is a contiguous sequence of [=blankspace=] code points indicating the end of a line.
It is defined as the blankspace signalling a "mandatory break" as defined by
[=UAX14 Section 6.1 Non-tailorable Line Breaking Rules=] [=UAX14 LB4|LB4=] and [=UAX14 LB5|LB5=].
That is, a line break is any of:
* line feed (`U+000A`)
* vertical tab (`U+000B`)
* form feed (`U+000C`)
* carriage return (`U+000D`) when not also followed by line feed (`U+000A`)
* carriage return (`U+000D`) followed by line feed (`U+000A`)
* next line (`U+0085`)
* line separator (`U+2028`)
* paragraph separator (`U+2029`)

Note: Diagnostics that report source text locations in terms of line numbers should use [=line breaks=] to
count lines.

## Comments ## {#comments}

A <dfn>comment</dfn> is a span of text that does not influence the validity or meaning of a WGSL
program, except that a comment can separate [=tokens=].
Shader authors can use comments to document their programs.

A <dfn noexport>line-ending comment</dfn> is a kind of [=comment=] consisting
of the two code points `//` (`U+002F` followed by `U+002F`) and the code points that follow,
up until but not including:
* the next [=line break=], or
* the end of the program.

A <dfn noexport>block comment</dfn> is a kind of [=comment=] consisting of:
* The two code points `/*` (`U+002F` followed by `U+002A`)
* Then any sequence of:
    * A [=block comment=], or
    * Text that does not contain either `*/` (`U+002A` followed by `U+002F`)
        or `/*` (`U+002F` followed by `U+002A`)
* Then the two code points `*/` (`U+002A` followed by `U+002F`)

Note: Block comments can be nested.
Since a block comment requires matching start and end text sequences, and allows arbitrary nesting,
a block comment cannot be recognized with a regular expression.
This is a consequence of the Pumping Lemma for Regular Languages.

<div class='example wgsl' heading='Comments'>
  <xmp highlight='rust'>
  const f = 1.5; // This is line-ending comment.
  const g = 2.5; /* This is a block comment
                  that spans lines.
                  /* Block comments can nest.
                   */
                  But all block comments must terminate.
                 */
  </xmp>
</div>

## Tokens ## {#tokens}

A <dfn>token</dfn> is a contiguous sequence of code points forming one of:
* a [=literal=].
* a [=keyword=].
* a [=reserved word=].
* a [=syntactic token=].
* an [=identifier=].

## Literals ## {#literals}

A <dfn>literal</dfn> is one of:
* A <dfn noexport>boolean literal</dfn>: either `true` or `false`.
* A <dfn>numeric literal</dfn>: either an [=integer literal=] or a [=floating point literal=],
    and is used to represent a number.

<div class='example wgsl bool-literals' heading='boolean literals'>
  <xmp highlight='rust'>
    const a = true;
    const b = false;
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>bool_literal</dfn> :

    | [=syntax/true=]

    | [=syntax/false=]
</div>

The form of a [=numeric literal=] is defined via pattern-matching.

An <dfn>integer literal</dfn> is:
* An integer specified as any of:
    * `0`
    * A sequence of decimal digits, where the first digit is not `0`.
    * `0x` or `0X` followed by a sequence of hexadecimal digits.
* Then an optional `i` or `u` suffix.

<div class='example wgsl int-literals' heading='integer literals'>
  <xmp highlight='rust'>
    const a = 0x123;
    const b = 0X123u;
    const c = 1u;
    const d = 123;
    const e = 0;
    const f = 0i;
    const g = 0x3f;
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>int_literal</dfn> :

    | `/0[xX][0-9a-fA-F]+[iu]?/`

    | `/0[iu]?/`

    | `/[1-9][0-9]*[iu]?/`
</div>

A <dfn>floating point literal</dfn> is either a [=decimal floating point literal=]
or a [=hexadecimal floating point literal=].
* A <dfn noexport>decimal floating point literal</dfn> is:
    * A mantissa, specified as a sequence of digits, with an optional decimal point (`.`) somewhere among them.
    * Then an optional exponent suffix consisting of:
        * `e` or `E`.
        * Then an exponent specified as an decimal number with an optional leading sign (`+` or `-`).
        * Then an optional `f` or `h` suffix.
    * At least one of the decimal point, or the exponent, or the `f` or `h` suffix
         [=shader-creation error|must=] be present.
         If none are, then the token is instead an [=integer literal=].
    * The value of the literal is the value of the mantissa multiplied by 10 to the power of the exponent.
         When no exponent is specified, an exponent of 0 is assumed.

* A <dfn noexport>hexadecimal floating point literal</dfn> is:
    * A `0x` or `0X` prefix
    * Then a mantissa, specified as a sequence of hexadecimal digits, with an optional hexadecimal point (`.`) somewhere among them.
    * Then an optional exponent suffix consisting of:
        * `p` or `P`
        * Then an exponent specified as an decimal number with an optional leading sign (`+` or `-`).
        * Then an optional `f` or `h` suffix.
    * At least one of the hexadecimal point, or the exponent [=shader-creation error|must=] be present.
         If neither are, then the token is instead an [=integer literal=].
    * The value of the literal is the value of the mantissa multiplied by 2 to the power of the exponent.
         When no exponent is specified, an exponent of 0 is assumed.

<div class='example wgsl float-literals' heading='floating point literals'>
  <xmp highlight='rust'>
    const a = 0.e+4f;
    const b = 01.;
    const c = .01;
    const d = 12.34;
    const f = .0f;
    const g = 0h;
    const h = 1e-3;
    const i = 0xa.fp+2;
    const j = 0x1P+4f;
    const k = 0X.3;
    const l = 0x3p+2h;
    const m = 0X1.fp-4;
    const n = 0x3.2p+2h;
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>float_literal</dfn> :

    | [=syntax/decimal_float_literal=]

    | [=syntax/hex_float_literal=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>decimal_float_literal</dfn> :

    | `/[0-9]*\.[0-9]+([eE](\+|-)?[0-9]+)?[fh]?/`

    | `/[0-9]+\.[0-9]*([eE](\+|-)?[0-9]+)?[fh]?/`

    | `/[0-9]+[eE](\+|-)?[0-9]+[fh]?/`

    | `/0[fh]/`

    | `/[1-9][0-9]*[fh]/`
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>hex_float_literal</dfn> :

    | `/0[xX][0-9a-fA-F]*\.[0-9a-fA-F]+([pP](\+|-)?[0-9]+[fh]?)?/`

    | `/0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*([pP](\+|-)?[0-9]+[fh]?)?/`

    | `/0[xX][0-9a-fA-F]+[pP](\+|-)?[0-9]+[fh]?/`
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>const_literal</dfn> :

    | [=syntax/int_literal=]

    | [=syntax/float_literal=]

    | [=syntax/bool_literal=]
</div>

When a [=numeric literal=] has a suffix, the literal denotes a value in a specific [=scalar=] type.
Otherwise, the literal denotes a value one of the [=abstract numeric types=] defined below.

<table class=data>
  <caption>Mapping literals to types</caption>
  <thead>
    <tr><th>Literal<th>Suffix<th>Type<th>Examples
  </thead>

  <tr><td>[=integer literal=]<td>`i`<td>[=i32=]<td>42i
  <tr><td>[=integer literal=]<td>`u`<td>[=u32=]<td>42u
  <tr><td>[=integer literal=]<td><td>[=AbstractInt=]<td>124
  <tr><td>[=floating point literal=]<td>`f`<td>[=f32=]<td>42f 1e5f 1.2f 0x1.0p10f
  <tr><td>[=floating point literal=]<td>`h`<td>[=f16=]<td>42h 1e5h 1.2h 0x1.0p10h
  <tr><td>[=floating point literal=]<td><td>[=AbstractFloat=]<td>1e5 1.2 0x1.0p10
</table>

A [=shader-creation error=] results if:
* An [=integer literal=] with a `i` or `u` suffix cannot be represented by the target type.
* A [=hexadecimal floating point literal=] with a `f` or `h` suffix overflows or cannot be exactly represented by the target type.
* A [=decimal floating point literal=] with a `f` or `h` suffix overflows the target type.
* A [=floating point literal=] with a `h` suffix is used while the [=extension/f16|f16 extension=] is not enabled.

Note: The hexadecimal float value 0x1.00000001p0 requires 33 mantissa bits to be represented exactly,
but [=f32=] only has 23 explicit mantissa bits.

Note: If you want to use an `f` suffix to force a hexadecimal float literal to be of type, the literal must also
use a binary exponent.  For example, write `0x1p0f`.  In comparison, `0x1f` is a hexadecimal integer literal.

## Keywords ## {#keywords}

A <dfn>keyword</dfn> is a [=token=] which always refers to a predefined language concept.
See [[#keyword-summary]] for the list of WGSL keywords.

## Identifiers ## {#identifiers}

An <dfn>identifier</dfn> is a kind of [=token=] used as a name.
See [[#declaration-and-scope]] and [[#directives]].

The form of an identifier is based on the
[=Unicode Standard Annex #31 for Unicode Version 14.0.0|Unicode Standard Annex #31=] for
[[!UnicodeVersion14|Unicode Version 14.0.0]],
with the following elaborations.

Identifiers use the following profile described in terms of [=UAX31 Grammar=]:

```
<Identifier> := <Start> <Continue>* (<Medial> <Continue>+)*

<Start> := XID_Start + U+005F
<Continue> := <Start> + XID_Continue
<Medial> :=
```

This means identifiers with non-ASCII code points like these are
valid: `ŒîŒ≠ŒªœÑŒ±`, `r√©flexion`, `–ö—ã–∑—ã–ª`, `ê∞ìê∞èê∞á`, `ÊúùÁÑº„Åë`, `ÿ≥ŸÑÿßŸÖ`, `Í≤ÄÏ†ï`, `◊©÷∏◊Å◊ú◊ï÷π◊ù`, `‡§ó‡•Å‡§≤‡§æ‡§¨‡•Ä`, `÷É’´÷Ä’∏÷Ç’¶`.

With the following exceptions:
* An identifier [=shader-creation error|must not=] have the same spelling as a [=keyword=] or as a [=reserved word=].
* An identifier [=shader-creation error|must not=] be `_` (a single underscore, `U+005F`).
* An identifier [=shader-creation error|must not=] start with `__` (two underscores, `U+005F` followed by `U+005F`).

<div class='syntax' noexport='true'>
  <dfn for=syntax>ident</dfn> :

    | `/([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/uy`
</div>

[=Unicode Character Database for Unicode Version 14.0.0=] includes non-normative listing
with all valid code points
of both [=UAX31 Lexical Classes|XID_Start=] and
[=UAX31 Lexical Classes|XID_Continue=].

Note: The [=return type=] for some [=built-in functions=] are structure types whose name cannot be used WGSL source.
Those structure types are described as if they were [=predeclared=] with a name starting with two underscores.
The result value can be saved into newly declared `let` or `var` using type inferencing, or immediately have one of its members
immediately extracted by name.  See example usages in the description of `frexp` and `modf`.

### Identifier Comparison ### {#identifier-comparison}

Two WGSL identifiers are the same if and only if they consist of the same sequence of code points.

Note: This specification does not permit Unicode normalization of values for the purposes of comparison.
Values that are visually and semantically identical but use different Unicode character sequences will not match.
Content authors are advised to use the same encoding sequence consistently or to avoid potentially troublesome
characters when choosing values. For more information, see [[CHARMOD-NORM]].

Note: A user agent should issue developer-visible warnings when the meaning of a WGSL program would change if
all instances of an identifier are replaced with one of that identifier's homographs.
(A homoglyph is a sequence of code points that may appear the same to a reader as another sequence of code points.
Examples of mappings to detect homoglyphs are the transformations, mappings, and matching algorithms mentioned in
the previous paragraph. Two sequences of code points are homographs if the identifier can transform one into the other by
repeatedly replacing a subsequence with its homoglyph.)

## Attributes ## {#attributes}

An <dfn noexport>attribute</dfn> modifies an object or type.
WGSL provides a unified syntax for applying attributes.
Attributes are used for a variety of purposes such as specifying the interface with the API.
Generally speaking, from the language's point-of-view, attributes can be
ignored for the purposes of type and semantic checking.

An attribute [=shader-creation error|must not=] be specified more than once per object or type.

<div class='syntax' noexport='true'>
  <dfn for=syntax>attribute</dfn> :

    | [=syntax/attr=] [=syntax/ident=] [=syntax/paren_left=] ( [=syntax/literal_or_ident=] [=syntax/comma=] ) * [=syntax/literal_or_ident=] [=syntax/comma=] ? [=syntax/paren_right=]

    | [=syntax/attr=] [=syntax/ident=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>literal_or_ident</dfn> :

    | [=syntax/float_literal=]

    | [=syntax/int_literal=]

    | [=syntax/ident=]
</div>

<table class='data'>
  <caption>Attributes defined in WGSL</caption>
  <thead>
    <tr><th>Attribute<th>Valid Values<th>Description
  </thead>

  <tr><td><dfn noexport dfn-for="attribute">`align`</dfn>
    <td>[=shader-creation error|Must=] be a positive [=i32=] or [=AbstractInt=] [=integer literal|literal=]
    <td>[=shader-creation error|Must=] only be applied to a member of a [=structure=] type.

    [=shader-creation error|Must=] be a power of 2, and [=shader-creation error|must=] satisfy the required-alignment for the member type:

    <p algorithm="align constraint">
    If `align(`|n|`)` is applied to a member of |S|
    with type |T|, and |S| is the [=store type=]
    or contained in the store type for a variable in address space |C|,
    then |n| [=shader-creation error|must=] satisfy:
    |n|&nbsp;=&nbsp;|k|&nbsp;&times;&nbsp;[=RequiredAlignOf=](|T|,|C|)
    for some positive integer |k|.
    </p>

    See [[#memory-layouts]]

  <tr><td><dfn noexport dfn-for="attribute">`binding`</dfn>
    <td>[=shader-creation error|Must=] be a non-negative [=i32=] or [=AbstractInt=] [=integer literal|literal=]
    <td>[=shader-creation error|Must=] only be applied to a [=resource=] variable.

    Specifies the binding number of the resource in a bind [=attribute/group=].
    See [[#resource-interface]].

  <tr><td><dfn noexport dfn-for="attribute">`builtin`</dfn>
    <td>identifier name for a built-in value
    <td>[=shader-creation error|Must=] only be applied to an entry point
    function parameter, entry point return type, or member of a [=structure=].

    Declares a built-in value.
    See [[#builtin-values]].

  <tr><td><dfn noexport dfn-for="attribute">`const`</dfn>
    <td>*None*
    <td>Must only be applied to function declarations.

    Specifies that the function can be used as a [=creation-time function=].
    It is a [=shader-creation error=] if this attribute is a applied to a
    user-defined function.

    Note: This attribute is used as a notational convention to describe which
    built-in functions can be used in [=creation-time expressions=].

  <tr><td><dfn noexport dfn-for="attribute">`group`</dfn>
    <td>[=shader-creation error|Must=] be a non-negative [=i32=] or [=AbstractInt=] [=integer literal|literal=]
    <td>[=shader-creation error|Must=] only be applied to a [=resource=] variable.

    Specifies the binding group of the resource.
    See [[#resource-interface]].

  <tr><td><dfn noexport dfn-for="attribute">`id`</dfn>
    <td>[=shader-creation error|Must=] be a non-negative [=i32=] or [=AbstractInt=] [=integer literal|literal=]
    <td>[=shader-creation error|Must=] only be applied to an [=override declaration=] of [=scalar=] type.

    Specifies a numeric identifier as an alternate name for a
    [=pipeline-overridable=] constant.

  <tr><td><dfn noexport dfn-for="attribute">`interpolate`</dfn>
    <td>One or two parameters.

    The first parameter [=shader-creation error|must=] be an [=interpolation type=].
    The second parameter, if present, [=shader-creation error|must=] specify the [=interpolation sampling=].
    <td>[=shader-creation error|Must=] only be applied to a declaration that is decorated with a
    [=attribute/location=] attribute.

    Specifies how the user-defined IO [=shader-creation error|must=] be interpolated.
    The attribute is only significant on user-defined [=vertex=] outputs
    and [=fragment=] inputs.
    See [[#interpolation]].

  <tr><td><dfn noexport dfn-for="attribute">`invariant`</dfn>
    <td>*None*
    <td>[=shader-creation error|Must=] only be applied to the `position` built-in value.

    When applied to the `position` [=built-in output value=] of a vertex
    shader, the computation of the result is invariant across different
    programs and different invocations of the same entry point.
    That is, if the data and control flow match for two `position` outputs in
    different entry points, then the result values are guaranteed to be the
    same.
    There is no affect on a `position` [=built-in input value=].

    Note: this attribute maps to the `precise` qualifier in HLSL, and the
    `invariant` qualifier in GLSL.

  <tr><td><dfn noexport dfn-for="attribute">`location`</dfn>
    <td>[=shader-creation error|Must=] be a non-negative [=i32=] or [=AbstractInt=] [=integer literal|literal=]
    <td>[=shader-creation error|Must=] only be applied to an entry point function parameter, entry point
    return type, or member of a [=structure=] type.
    [=shader-creation error|Must=] only be applied to declarations of [=numeric scalar=] or [=numeric
    vector=] type.
    [=shader-creation error|Must not=] be used with the [=compute=] shader stage.

    Specifies a part of the user-defined IO of an entry point.
    See [[#input-output-locations]].

  <tr><td><dfn noexport dfn-for="attribute">`size`</dfn>
    <td>[=shader-creation error|Must=] be a positive [=i32=] or [=AbstractInt=] [=integer literal|literal=]
    <td>[=shader-creation error|Must=] only be applied to a member of a [=structure=] type.

    The number of bytes reserved in the struct for this member.

    This number [=shader-creation error|must=] be at least the [=byte-size=] of the type of the member:
    <p algorithm="byte-size constraint">
    If `size(`|n|`)` is applied to a member with type |T|, then [=SizeOf=](|T|)&nbsp;&leq;&nbsp;|n|.
    </p>

    See [[#memory-layouts]]

  <tr><td><dfn noexport dfn-for="attribute">`workgroup_size`</dfn>
    <td>One, two or three parameters.

    Each parameter is either a literal or [[#module-constants|module-scope constant]].
    All parameters [=shader-creation error|must=] be of the same type, either i32 or u32.
    <td>[=shader-creation error|Must=] be applied to a [=compute shader stage|compute shader=] entry point function.
    [=shader-creation error|Must not=] be applied to any other object.

    Specifies the x, y, and z dimensions of the [=workgroup grid=] for the compute shader.

    The first parameter specifies the x dimension.
    The second parameter, if provided, specifies the y dimension, otherwise is assumed to be 1.
    The third parameter, if provided, specifies the z dimension, otherwise is assumed to be 1.
    Each dimension [=shader-creation error|must=] be at least 1 and at most an
    upper bound specified by the WebGPU API.

</table>

The <dfn noexport>pipeline stage attributes</dfn> below
designate a function as an [=entry point=] for a particular [=shader stage=].
These attributes [=shader-creation error|must=] only be applied to [=function declarations=],
and at most one may be present on a given function.
They take no parameters.

<table class='data'>
  <caption>Pipeline Stage Attributes</caption>
  <thead>
    <tr><th>Attribute<th>Description
  </thead>

  <tr><td><dfn noexport dfn-for="attribute">`vertex`</dfn><br>
    <td>Declares the function to be an [=entry point=] for the [=vertex shader stage=]
    of a [=GPURenderPipeline|render pipeline=].

  <tr><td><dfn noexport dfn-for="attribute">`fragment`</dfn><br>
    <td>Declares the function to be an [=entry point=] for the [=fragment shader stage=]
    of a [=GPURenderPipeline|render pipeline=].

  <tr><td><dfn noexport dfn-for="attribute">`compute`</dfn><br>
    <td>Declares the function to be an [=entry point=] for the [=compute shader stage=]
    of a [=GPUComputePipeline|compute pipeline=].

</table>

## Directives ## {#directives}

A <dfn noexport>directive</dfn> is a [=token=] sequence which modifies how a WGSL
program is processed by a WebGPU implementation.

Directives are optional.
If present, all directives [=shader-creation error|must=] appear before any declarations.

See [[#enable-directive-section]].

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_directive</dfn> :

    | [=syntax/enable_directive=]
</div>

## Declaration and Scope ## {#declaration-and-scope}

A <dfn noexport>declaration</dfn> associates an [=identifier=] with one of
the following kinds of objects:
* a [=type=]
* a [=value declaration|value=]
* a [=variable=]
* a [=function/function=]
* a [=formal parameter=]

In other words, a declaration introduces a <dfn noexport>name</dfn> for an object.

The <dfn noexport>scope</dfn> of a declaration is the set of
program locations where a use of the declared identifier potentially denotes
its associated object.
We say the identifier is <dfn noexport>in scope</dfn>
(of the declaration) at those source locations.

When an identifier is used, it [=shader-creation error|must=] be [=in scope=]
for some declaration, or as part of a directive.
When an identifier is used in scope of one or more declarations for that name,
the identifier will denote the object of the non-[=module scope|module-scope=] declaration appearing closest to
that use, or the [=module scope|module-scope=] declaration if no other declaration is in scope.
We say the identifier use <dfn noexport>resolves</dfn> to that declaration.

Where a declaration appears determines its scope.
Generally, the scope is a span of text beginning immediately after the end of
the declaration.
Declarations at [=module scope=] are the exception, described below.

A declaration [=shader-creation error|must not=] introduce a name when that identifier is
already in scope with the same end of scope as another instance of that name.

Certain objects are provided by the WebGPU implementation, and are treated as
if they have been declared by every WGSL program.
We say such objects are <dfn noexport>predeclared</dfn>.
Their scope is the entire WGSL program.
Examples of predeclared objects are:
* [=built-in functions=], and
* built-in types.

A declaration is at <dfn noexport>module scope</dfn> if the declaration appears outside
the text of any other declaration.
Module scope declarations are [=in scope=] for the entire program.
That is, a declaration at module scope may be referenced by source text
that follows *or precedes* that declaration.

It is a [=shader-creation error=] if any module scope declaration is recursive.
That is, no cycles can exist among the declarations:

> Consider the directed graph where:
> * Each node corresponds to a declaration |D|.
> * There is an edge from declaration |D| to declaration |T| when the definition
>      for |D| mentions an identifier which [=resolves=] to |T|.
>
> This graph must not have a cycle.

Note: The [=function body=] is part of the [=function declaration=], thus
functions must not be recursive, either directly or indirectly.

Note: Use of a non-[=module scope=] identifier must follow the declaration of
that identifier in the text.
This is not true, however, for [=module scope=] declarations, which may be
referenced out of order in the text.

Note: Only a [=function declaration=] can contain other declarations.

<div class='example wgsl' heading='Valid and invalid declarations'>
  <xmp highlight='rust'>
    // Invalid, cannot reuse built-in function names (modf in this case).
    var<private> modf: f32 = 0.0;

    // Valid, foo_1 is in scope for the entire program.
    var<private> foo: f32 = 0.0; // foo_1

    // Valid, bar_1 is in scope for the entire program.
    var<private> bar: u32 = 0u; // bar_1

    // Valid, my_func_1 is in scope for the entire program.
    // Valid, foo_2 is in scope until the end of the function.
    fn my_func(foo: f32) { // my_func_1, foo_2
      // Any reference to 'foo' resolves to the function parameter.

      // Invalid, the scope of foo_2 ends at the of the function.
      var foo: f32; // foo_3

      // Valid, bar_2 is in scope until the end of the function.
      var bar: u32; // bar_2
      // References to 'bar' resolve to bar_2
      {
        // Valid, bar_3 is in scope until the end of the compound statement.
        var bar: u32; // bar_3
        // References to 'bar' resolve to bar_3

        // Invalid, bar_4 has the same end scope as bar_3.
        var bar: i32; // bar_4

        // Valid, i_1 is in scope until the end of the for loop
        for ( var i: i32 = 0; i < 10; i++ ) { // i_1
          // Invalid, i_2 has the same end scope as i_1.
          var i: i32 = 1; // i_2.
        }
      }

      // Invalid, bar_5 has the same end scope as bar_2.
      var bar: u32; // bar_5

      // Valid, later_def, a module scope declaration, is in scope for the entire program.
      var early_use : i32 = later_def;
    }

    // Invalid, bar_6 has the same scope as bar_1.
    var<private> bar: u32 = 1u; // bar_6

    // Invalid, my_func_2 has the same end scope as my_func_1.
    fn my_func() { } // my_func_2

    // Valid, my_foo_1 is in scope for the entire program.
    fn my_foo( //my_foo_1
      // Valid, my_foo_2 is in scope until the end of the function.
      my_foo: i32 // my_foo_2
    ) { }

    var<private> later_def : i32 = 1;
  </xmp>
</div>

# Types # {#types}

Programs calculate values.

In WGSL, a <dfn noexport>type</dfn> is a set of values, and each value belongs to exactly one type.
A value's type determines the syntax and semantics of operations that can be performed on that value.

For example, the mathematical number 1 corresponds to these distinct values in [SHORTNAME]:
* the 32-bit signed integer value `1i`,
* the 32-bit unsigned integer value `1u`,
* the 32-bit floating point value `1.0f`,
* the 16-bit floating point value `1.0h` if the [=extension/f16|f16 extension=] is enabled,
* the [=AbstractInt=] value 1, and
* the [=AbstractFloat=] value 1.0

WGSL treats these as different because their machine representation and operations differ.

A type is either [=predeclared=], or created in WGSL source via a [=declaration=].

We distinguish between the *concept* of a type and the *syntax* in WGSL to denote that type.
In many cases the spelling of a type in this specification is the same as its WGSL syntax.
For example:
* the set of 32-bit unsigned integer values is spelled `u32` in this specification,
    and also in a WGSL program.
* the spelling is different for structure types, or types containing structures.

Some WGSL types are only used for analyzing a source program and
for determining the program's runtime behaviour.
This specification will describe such types, but they do not appear in WGSL source text.

Note: WGSL [=reference types=] are not written in WGSL programs. See [[#memory-view-types]].

## Type Checking ## {#type-checking-section}

A WGSL value is computed by evaluating an expression.
An <dfn noexport>expression</dfn> is a segment of source text
parsed as one of the [SHORTNAME] grammar rules whose name ends with "`_expression`".
An expression |E| can contain <dfn noexport>subexpressions</dfn> which are expressions properly contained
in the outer expression |E|.
A <dfn noexport>top-level expression</dfn> is an expression that is not itself a subexpression.
See [[#expression-grammar]].

The particular value produced by an expression evaluation depends on:
* <dfn noexport>static context</dfn>:
    the source text surrounding the expression, and
* <dfn noexport>dynamic context</dfn>:
    the state of the invocation evaluating the expression,
    and the execution context in which the invocation is running.

The values that may result from evaluating a particular expression will always belong to a specific WGSL type,
known as the <dfn noexport>static type</dfn> of the expression.
The rules of WGSL are designed so that the static type of an expression depends
only on the expression's [=static context=].


A <dfn noexport>type assertion</dfn> is a mapping from some WGSL source expression to a WGSL type.
The notation

> *e* : *T*

is a type assertion meaning *T* is the static type of WGSL expression *e*.

Note: A type assertion is a statement of fact about the text of a program.
It is not a runtime check.


Statements often use expressions, and may place requirements on the static types of those expressions.
For example:
* The condition expression of an `if` statement [=shader-creation error|must=] be of type [=bool=].
* In a `let` declaration with an explicit type specified, the initializer
      expression [=shader-creation error|must=] evaluate to that type.

<dfn noexport>Type checking</dfn> a successfully parsed WGSL program is the process of mapping
each expression to its static type,
and verifying that type requirements of each statement are satisfied.
If type checking fails, a special case of a [=shader-creation error=], called a <dfn noexport>type error</dfn>, results.

Type checking can be performed by recursively applying [=type rules=]
to syntactic phrases, where a <dfn noexport>syntactic phrase</dfn> is either an [=expression=] or a [[#statements|statement]].
A <dfn noexport>type rule</dfn> describes how the [=static context=] for a [=syntactic phrase=]
determines the static type for expressions contained within that phrase.
A [=type rule=] has two parts:
* A <dfn noexport lt="type rule conclusion">conclusion</dfn>.
    * If the phrase is an expression, the conclusion is a [=type assertion=] for the expression.
    * If the phrase is a statement, the conclusion is a set of [=type assertions=],
        one for each of the statement's [=top-level expressions=].
    * In both cases, the [=syntactic phrases=] are specified schematically,
        using *italicized* names to denote subexpressions
        or other syntactically-determined parameters.
* <dfn noexport lt="type rule preconditions">Preconditions</dfn>, consisting of:
    * For expressions:
        * Type assertions for subexpressions, when it has subexpressions.
             Each may be satisfied directly, or via a [=feasible automatic conversion=] (as defined in [[#conversion-rank]]).
        * How the expression is used in a statement.
    * For statements:
        * The syntactic form of the statement, and
        * Type assertions for [=top-level expressions=] in the statement.
    * Conditions on the other schematic parameters, if any.
    * Optionally, other static context.

Each distinct type parameterization for a type rule is called an <dfn noexport>overload</dfn>.
For example, [[#arithmetic-expr|unary negation]] (an expression of the form `-`|e|)
has twelve overloads, because its type rules are parameterized by a type |T| that can be any of:
* [=i32=]
* [=vector|vec2&lt;i32&gt;=]
* vec3&lt;i32&gt;
* vec4&lt;i32&gt;
* [=f32=]
* [=vector|vec2&lt;f32&gt;=]
* vec3&lt;f32&gt;
* vec4&lt;f32&gt;
* [=f16=]
* [=vector|vec2&lt;f16&gt;=]
* vec3&lt;f16&gt;
* vec4&lt;f16&gt;

A <dfn noexport>type rule applies to a syntactic phrase</dfn> when:
* The rule's conclusion matches a valid parse of the [=syntactic phrase=], and
* The rule's preconditions are satisfied.

Consider the expression, `1u+2u`.
It has two [[#literal-expressions|literal subexpressions]]: `1u` and `2u`, both of type u32.
The [=top-level expression=] is an addition.
Referring to the [[#arithmetic-expr]] rules, the type rule for scalar u32 addition applies to the expression, because:
* `1u+2u` matches a parse of the form |e1|+|e2|, with |e1| standing for `1u` and |e2| standing for `2u`, and
* |e1| is of type u32, and
* |e2| is of type u32.

When analyzing a [=syntactic phrase=], three cases may occur:
* No type rules apply to the expression.  This results in a [=type error=].
* Exactly one type rule applies to the expression.
    In this case, the rule's [=type rule conclusion|conclusion=] is asserted, determining the static type for the expression.
* More than one type rule applies. That is, the preconditions for more than one [=overload=] are satisfied.
    In this case the tie-breaking procedure described in [[#overload-resolution-section]] is used.
    * If overload resolution succeeds, a single type rule is determined to apply to the expression.
        The [=type assertions=] in the [=type rule conclusion|conclusion=] for that overload are asserted,
        and therefore determines the types for the expression or expressions in the [=syntactic phrase=].
    * If overload resolution fails, a [=type error=] results.

Continuing the example above, only one type rule applies to the expression `1u+2u`, and so type checking
accepts the conclusion of that type rule, which is that `1u+2u` is of type u32.

A WGSL source program is <dfn noexport>well-typed</dfn> when:
* The static type can be determined for each expression in the program by applying the type rules, and
* The type requirements for each statement are satisfied.

Otherwise there is a [=type error=] and the source program is not a valid WGSL program.

WGSL is a <dfn noexport>statically typed language</dfn>
because type checking a WGSL program will either succeed or
discover a type error, while only having to inspect the program source text.

### Type Rule Tables ### {#typing-tables-section}

The WGSL [=type rules=] for expressions are organized into <dfn noexport>type rule tables</dfn>,
with one row per type rule.

The <dfn noexport>semantics of an expression</dfn> is the effect of evaluating that expression,
and is primarily the production of a result value.
The *Description* column of the type rule that applies to an expression will specify the expression's semantics.
The semantics usually depends on the values of the type rule parameters, including
the assumed values of any subexpressions.
Sometimes the semantics of an expression includes effects other than producing
a result value, such as the non-result-value effects of its subexpressions.

TODO: example: non-result-value effect is any side effect of a function call subexpression.

### Conversion Rank ### {#conversion-rank}

When a type assertion |e|:|T| is used as a [=type rule precondition=], it is satisfied when:
* |e| is already of type |T|, or
* |e| is of type |S|, and type |S| is [=feasible automatic conversion|automatically convertible=] to type |T|, as defined below.

The rule is codified by the <dfn>ConversionRank</dfn> function over pairs of types, defined in the table below.
The [=ConversionRank=] function expresses the preference and feasibility of automatically converting a value of one type (*Src*) to
another type (*Dest*).
Lower ranks are more desirable.

A <dfn>feasible automatic conversion</dfn> converts a value from type *Src* to type *Dest*, and is allowed when [=ConversionRank=](*Src*,*Dest*) is finite.
Such conversions are value-preserving, subject to limitations described in [[#floating-point-evaluation]].

Note: Automatic conversions only occur in two kinds of situations.
First, when converting a [=creation-time constant=] to its corresponding typed numeric value that can be used on the GPU.
Second, when a load from a reference-to-memory occurs, yielding the value stored in that memory.

Note: A conversion of infinite rank is infeasible, i.e. not allowed.

Note: When no conversion is performed, the conversion rank is zero.

<table class='data'>
  <caption>
    ConversionRank from one type to another
  </caption>
  <thead>
    <tr><th>Src
        <th>Dest
        <th>ConversionRank(Src,Dest)
        <th>Description
  </thead>
  <tr algorithm="conversion rank identity">
      <td>|T|
      <td>|T|
      <td>0
      <td>Identity. No conversion performed.
  <tr algorithm="conversion rank from reference via load rule">
      <td>ref&lt;|AS|,|T|,|AM|&gt;<br>for [=address space=] |AS|,
          and where [=access mode=] |AM| is [=access/read=] or [=access/read_write=].
      <td>|T|
      <td>0
      <td>Apply the [=Load Rule=] to load a value from a memory reference.
  <tr algorithm="conversion rank abstract float to f32">
      <td>[=AbstractFloat=]
      <td>f32
      <td>1
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract float to f16">
      <td>[=AbstractFloat=]
      <td>f16
      <td>2
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract int to i32">
      <td>[=AbstractInt=]
      <td>i32
      <td>3
      <td>Identity if the value is in [=i32=].
          Produces a [=shader-creation error=] otherwise.
  <tr algorithm="conversion rank abstract int to u32">
      <td>[=AbstractInt=]
      <td>u32
      <td>4
      <td>Identity if the value is in [=u32=].
          Produces a [=shader-creation error=] otherwise.
  <tr algorithm="conversion rank abstract int to abstract float">
      <td>[=AbstractInt=]
      <td>[=AbstractFloat=]
      <td>5
      <td>See [[#floating-point-conversion]]
  <tr algorithm="conversion rank abstract int to f32">
      <td>[=AbstractInt=]
      <td>f32
      <td>6
      <td>Behaves as [=AbstractInt=] to [=AbstractFloat=], and then [=AbstractFloat=] to f32
  <tr algorithm="conversion rank abstract int to f16">
      <td>[=AbstractInt=]
      <td>f16
      <td>7
      <td>Behaves as [=AbstractInt=] to [=AbstractFloat=], and then [=AbstractFloat=] to f16
  <tr algorithm="conversion rank abstract vector">
      <td>vec|N|&lt;|S|&gt;
      <td>vec|N|&lt;|T|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component types.
  <tr algorithm="conversion rank abstract matrix">
      <td>mat|C|x|R|&lt;|S|&gt;
      <td>mat|C|x|R|&lt;|T|&gt;
      <td>ConversionRank(|S|,|T|)
      <td>Inherit conversion rank from component types.
  <tr algorithm="conversion rank for non-convertible cases">
      <td><var ignore>S</var>
      <td><var ignore>T</var><br>where above cases don't apply
      <td>infinity
      <td>There are no automatic conversions between other types.
</table>

### Overload Resolution ### {#overload-resolution-section}

When more than one [=type rule applies to a syntactic phrase=], a tie-breaking procedure is used
to determine which one should take effect.
This procedure is called <dfn noexport>overload resolution</dfn>,
and assumes type checking has already succeeded in finding static types for [=subexpressions=].

Consider a [=syntactic phrase=] |P|, and all [=type rule applies to a syntactic phrase|type rules that apply=] to |P|.
The overload resolution algorithm calls these type rules <dfn noexport>overload candidates</dfn>.
For each candidate:
* Its preconditions have been met either directly or through [=feasible automatic conversion|automatic conversion=].
* Its [=type rule conclusion|conclusion=] has:
    * A syntactic form matching a valid parse of |P|, and
    * A [=type assertion=] corresponding to each [=top-level expression=] in |P|.

Overload resolution for |P| proceeds as follows, with the goal of finding a single most [=preferable candidate|preferable=] [=overload candidate=]:

1. For each candidate |C|, enumerate conversion ranks for subexpressions in the syntactic phrase.
    The candidate's preconditions have been met, and so for the |i|'th subexpression in the |P|:
    * Its static type has been computed.
    * There is a [=feasible automatic conversion=] from the expression's static type to the type required by the corresponding type assertion in the preconditions.
        Let |C|.|R|(i) be the [=ConversionRank=] of that conversion.

1. Rank candidates: Given two overload candidates |C1| and |C2|, |C1| is <dfn lt="preferable candidate">preferred</dfn> over |C2| if:
    * For each expression position |i| in |P|, |C1|.|R|(i) &le; |C2|.|R|(i).
         * That is, each expression conversion required to apply |C1| to |P| is at least as preferable as the corresponding expression conversion required to apply |C2| to |P|.
    * There is at least one expression position |i| where |C1|.|R|(i) &lt; |C2|.|R|(i).
         * That is, there is at least one expression conversion required to apply |C1| that is strictly more preferable than the corresponding conversion required to apply |C2|.

1. If there is a single candidate |C| which is [=preferable candidate|preferred=] over all the others, then overload resolution succeeds, yielding the candidate type rule |C|.
      Otherwise, overload resolution fails.

TODO: Examples

## Types for Creation-Time Constants ## {#types-for-creation-time-constants}

Certain expressions are evaluated at [=shader module creation|shader-creation time=],
and with a numeric range and precision that may be larger than directly implemented by the GPU.

[SHORTNAME] defines two <dfn>abstract numeric types</dfn> for these evaluations:
* The <dfn noexport>AbstractInt</dfn> type is the set of integers |i|, with -2<sup>63</sup> &leq; |i| &lt; 2<sup>63</sup>.
* The <dfn noexport>AbstractFloat</dfn> type is the set of finite floating point numbers representable
    in the [[!IEEE-754|IEEE-754]] binary64 (double precision) format.

An evaluation of an expression in one of these types [=shader-creation
error|must not=] overflow or produce undefined results.

These types cannot be spelled in WGSL source. They are only used by [=type checking=].

A type that is not an abstract numeric type nor contains an abstract numeric
type is called <dfn noexport>concrete</dfn>.

A [=numeric literal=] without a suffix denotes a value in an [=abstract numeric type=]:
* An [=integer literal=] without an `i` or `u` suffix denotes an [=AbstractInt=] value.
* A [=floating point literal=] without an `f` suffix denotes a [=AbstractFloat=] value.

Example:  The expression `log2(32)` is analyzed as follows:
* `log2(32)` is parsed as a function call to the `log2` builtin function with operand [=AbstractInt=] value 32.
* There is no overload of `log2` with an integral scalar formal parameter.
* Instead [=overload resolution=] applies, considering two possible overloads and [=feasible automatic conversions=]:
    * [=AbstractInt=] to [=AbstractFloat=]. (Conversion rank 4)
    * [=AbstractInt=] to [=f32=]. (Conversion rank 5)
* The resulting computation occurs as an [=AbstractFloat=] (e.g. `log2(32.0)`).

Example:  The expression `1 + 2.5` is analyzed as follows:
* `1 + 2.5` is parsed as an addition operation with subexpressions [=AbstractInt=] value 1, and [=AbstractFloat=] value 2.5.
* There is no overload for |e|+|f| where |e| is integral and |f| is floating point.
* However, using feasible automic conversions, there are two potential overloads:
    * `1` is converted to [=AbstractFloat=] value `1.0` (rank 4) and `2.5` remains an [=AbstractFloat=] (rank 0).
    * `1` is converted to [=f32=] value `1.0f` (rank 5) and `2.5` is converted to [=f32=] value `2.5f` (rank 1).
* The first overload is the [=preferable candidate=] and type checking succeeds.
* The resulting computation occurs as an [=AbstractFloat=] `1.0 + 2.5`.

Example:  `let x = 1 + 2.5;`
* This example is similar to the above, except that `x` cannot resolve to an [=abstract numeric type=].
* Therefore, there is only one viable overload candidate: addition using [=f32=].
* The effect of the declaration is as if it were written `let x : f32 = 1.0f + 2.5f;`.

Example:  `1u + 2.5` results in a [=shader-creation error=]:
* The `1u` term is an expression of type [=u32=].
* The `2.5` term is an expression of type [=AbstractFloat=].
* There are no valid overload candidates:
    * There is no feaisble automatic conversion from a GPU-materialized integral type to a floating point type.
    * No type rule matches *e*`+`*f* with *e* in an integral type, and *f* in a floating point type.

<div class='example literals' heading="Type inference for literals">
  <xmp highlight='rust'>
    // Explicitly-typed unsigned integer literal.
    var u32_1 = 1u; // variable holds a u32

    // Explicitly-typed signed integer literal.
    var i32_1 = 1i; // variable holds a i32

    // Explicitly-typed floating point literal.
    var f32_1 = 1f; // variable holds a f32

    // Explicitly-typed unsigned integer literal cannot be negated.
    var u32_neg = -1u; // invalid: unary minus does not support u32

    // When the context does not force a concrete type, an integer literal is
    // interpreted as an i32 value:
    //   Initializer for a let-declaration must be constructible (or pointer).
    //   The most preferred automatic conversion from AbstractInt to a constructible type
    //   is AbstractInt to i32, with conversion rank 2.  So '1' is inferred as i32.
    let some_i32 = 1; // like let some_i32: i32 = 1i;

    // Inferred from declaration type.
    var i32_from_type : i32 = 1; // variable holds i32.  AbstractInt to i32, conversion rank 2
    var u32_from_type : u32 = 1; // variable holds u32.  AbstractInt to u32, conversion rank 3

    // Unsuffixed integer literal can convert to floating point when needed:
    //   Automatically convert AbstractInt to f32, with conversion rank 5.
    var f32_promotion : f32 = 1; // variable holds f32

    // Invalid: no feasible conversion from floating point to integer
    var i32_demotion : i32 = 1.0; // Invalid

    // Inferred from expression.
    var u32_from_expr = 1 + u32_1; // variable holds u32
    var i32_from_expr = 1 + i32_1; // variable holds i32

    // Values must be representable.
    let u32_too_large   : u32 = 1234567890123456890; // invalid, overflow
    let i32_too_large   : i32 = 1234567890123456890; // invalid, overflow
    let u32_large : u32 = 2147483649; // valid
    let i32_large : i32 = 2147483649; // invalid, overflow
    let f32_out_of_range1 = 0x1p500; // invalid, out of range
    let f32_hex_lost_bits = 0x1.0000000001p0; // invalid, not exactly representable in f32

    // Minimum integer: unary negation over AbstractInt, then infer i32.
    // Most preferred conversion from AbstractInt to a constructible type (with lowest
    // conversion rank) is AbstractInt to i32.
    let i32_min = -2147483648;  // has type i32

    // Invalid.  Select AbstractInt to i32 as above, but the value is out of
    // range, producing shader-creation error.
    let i32_too_large_2 = 2147483648; // Invalid.

    // Subexpressions can resolve to AbstractInt and AbstractFloat.
    // The following examples are all valid and the value of the variable is 6u.
    // var u32_expr1 = (1 + (1 + (1 + (1 + 1)))) + 1u;
    // var u32_expr2 = 1u + (1 + (1 + (1 + (1 + 1))));
    // var u32_expr3 = (1 + (1 + (1 + (1u + 1)))) + 1;
    // var u32_expr4 = 1 + (1 + (1 + (1 + (1u + 1))));

    // Inference based on built-in function parameters.

    // Most-preferred candidate is clamp(i32,i32,i32)->i32
    let i32_clamp = clamp(1, -5, 5);
    // Most preferred candidate is clamp(u32,u32,u32).
    // Literals use automatic conversion AbstractInt to u32.
    let u32_clamp = clamp(5, 0, u32_from_expr);
    // Most preferred candidate is clamp(f32,f32,f32)->f32
    // literals use automatic conversion AbstractInt to f32.
    let f32_clamp = clamp(0, f32_1, 1);

    // TODO: When AbstractFloat gains support for addition, then these will become valid,
    // via promotion.
    // let f32_promotion1 = 1.0 + 2 + 3 + 4; // TODO: like let f32_promotion1:f32 = 10f;
    // let f32_promotion2 = 2 + 1.0 + 3 + 4; // TODO: like let f32_promotion1:f32 = 10f;
    // let f32_promotion3 = 1f + ((2 + 3) + 4); // TODO: like let f32_promotion1:f32 = 10f;
    // let f32_promotion4 = ((2 + (3 + 1f)) + 4); // TODO: like let f32_promotion1:f32 = 10f;

    // Type rule violations.

    // Invalid, the initializer can only resolve to f32:
    // No feasible automatic conversion from AbstractFloat to u32.
    let mismatch : u32 = 1.0;

    // Invalid. There is no overload of clamp that allows mixed sign parameters.
    let ambiguous_clamp = clamp(1u, 0, 1i);

    // Inference completes at the statement level.

    // Initializer for a let-declaration must be constructible (or pointer).
    // The most preferred automatic conversion from AbstractInt to a constructible type
    // is AbstractInt to i32, with conversion rank 2.  So '1' is inferred as i32.
    let some_i32 = 1; // like let some_i32: i32 = 1i;

    let some_f32 : f32 = some_i32; // Type error: i32 cannot be assigned to f32

    // Another overflow case
    let overflow_u32 = (1 -2) + 1u; // invalid, -1 is out of range of u32

    // Ideal value out of range of 32-bits, but brought back into range
    let out_and_in_again = (0x1ffffffff / 8);

    // Similar, but invalid
    let out_of_range = (0x1ffffffff / 8u); // requires computation is done in 32-bits,
			                   // making 0x1ffffffff out of range.

  </xmp>
</div>

## Plain Types ## {#plain-types-section}

[=Plain types=] are types for the machine representation of boolean values, numbers, vectors,
matrices, or aggregations of such values.

A <dfn>plain type</dfn> is either a [=scalar=] type, an [=atomic type|atomic=] type, or a [=composite=] type.

Note: Plain types in WGSL are similar to Plain-Old-Data types in C++, but also include atomic types.

### Boolean Type ### {#bool-type}

The <dfn noexport>bool</dfn> type contains the values `true` and `false`.

<table class='data'>
  <caption>Boolean literal type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr><td><td>`true`: bool<td>The true value.<br>OpConstantTrue %bool
  <tr><td><td>`false`: bool<td>The false value.<br>OpConstantFalse %bool
</table>

### Integer Types ### {#integer-types}

The <dfn noexport>u32</dfn> type is the set of 32-bit unsigned integers.

The <dfn noexport>i32</dfn> type is the set of 32-bit signed integers.
It uses a two's complementation representation, with the sign bit in the most significant bit position.

### Floating Point Type ### {#floating-point-types}

The <dfn noexport>f32</dfn> type is the set of 32-bit floating point values of the
[[!IEEE-754|IEEE-754]] binary32 (single precision) format.
See [[#floating-point-evaluation]] for details.

The <dfn noexport>f16</dfn> type is the set of 16-bit floating point values of the
[[!IEEE-754|IEEE-754]] binary16 (half precision) format. It is a [=shader-creation error=]
if the [=f16=] type is used unless the program contains the `enable f16;` directive to enable
the [=extension/f16|f16 extension=]. See [[#floating-point-evaluation]] for details.

### Scalar Types ### {#scalar-types}

The <dfn noexport>scalar</dfn> types are [=bool=], [=i32=], [=u32=], [=f32=], and [=f16=].

The <dfn noexport>numeric scalar</dfn> types are [=i32=], [=u32=], [=f32=], and [=f16=].

The <dfn noexport>integer scalar</dfn> types are [=i32=] and [=u32=].

### Vector Types ### {#vector-types}

A <dfn noexport>vector</dfn> is a grouped sequence of 2, 3, or 4 [=scalar=] or
[=abstract numeric type=] components.

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr><td>vec*N*<*T*><td>Vector of *N* components of type *T*.
                          *N* must be in {2, 3, 4} and *T* [=shader-creation
                          error|must=] be one of the [=scalar=] or [=abstract
                          numeric type|abstract numeric=] types.
                          We say *T* is the <dfn noexport>component type</dfn> of the vector.
</table>

A vector is a <dfn noexport>numeric vector</dfn> if its component type is a [=numeric scalar=].

A vector is an <dfn noexport>abstract vector</dfn> if its component type is an [=abstract numeric type=].

Key use cases of a vector include:

* to express both a direction and a magnitude.
* to express a position in space.
* to express a color in some color space.
    For example, the components could be intensities of red, green, and blue,
    while the fourth component could be an alpha (opacity) value.

Many operations on vectors act <dfn noexport>component-wise</dfn>, i.e. the
result vector is formed by operating on each component independently.

<div class='example wgsl type-scope' heading='Vector'>
  <xmp highlight='rust'>
    vec2<f32>  // is a vector of two f32s.
  </xmp>
</div>

<div class='example wgsl function-scope component-wise addition' heading='Component-wise addition'>
  <xmp highlight='rust'>
    let x : vec3<f32> = a + b; // a and b are vec3<f32>
    // x[0] = a[0] + b[0]
    // x[1] = a[1] + b[1]
    // x[2] = a[2] + b[2]
  </xmp>
</div>

### Matrix Types ### {#matrix-types}

A <dfn noexport>matrix</dfn> is a grouped sequence of 2, 3, or 4 floating point vectors.

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="matrix type">
    <td>mat|C|x|R|&lt;|T|&gt;
    <td>Matrix of |C| columns and |R| rows of type |T|, where |C| and |R| are both in {2, 3, 4}, and |T| must be [=f32=], [=f16=], or [=AbstractFloat=].
        Equivalently, it can be viewed as |C| column vectors of type vec|R|&lt;*T*&gt;.
</table>

The key use case for a matrix is to embody a linear transformation.
In this interpretation, the vectors of a matrix are treated as column vectors.

The product operator (`*`) is used to either:

* scale the transformation by a scalar magnitude.
* apply the transformation to a vector.
* combine the transformation with another matrix.

See [[#arithmetic-expr]].

<div class='example wgsl type-scope' heading='Matrix'>
  <xmp highlight='rust'>
    mat2x3<f32>  // This is a 2 column, 3 row matrix of 32-bit floats.
                 // Equivalently, it is 2 column vectors of type vec3<f32>.
  </xmp>
</div>

### Atomic Types ### {#atomic-types}

An <dfn noexport>atomic type</dfn> encapsulates an [=integer scalar=] type such that:
* atomic objects provide certain guarantees to concurrent observers, and
* the only valid operations on atomic objects are the [[#atomic-builtin-functions|atomic builtin functions]].

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="atomic type"><td>atomic&lt;|T|&gt;
    <td>Atomic of type |T|. |T| [=shader-creation error|must=] be either [=u32=] or [=i32=].
</table>

An expression [=shader-creation error|must not=] evaluate to an atomic type.

Atomic types may only be instantiated by variables in the [=address spaces/workgroup=]
address space or by [=storage buffer=] variables with a [=access/read_write=] access mode.
The [=memory scope=] of operations on the type is determined by the [=address space=]
it is instantiated in.
Atomic types in the [=address spaces/workgroup=] address space have a memory
scope of `Workgroup`, while those in the [=address spaces/storage=]
address space have a memory scope of `QueueFamily`.

An <dfn noexport>atomic modification</dfn> is any
[[#memory-operation|operation]] on an atomic object which sets the content of
the object.
The operation counts as a modification even if the new value is the same as the
object's existing value.

In WGSL, atomic modifications are mutually ordered, for each object.
That is, during execution of a shader stage, for each atomic object *A*, all
agents observe the same order of modification operations applied to *A*.
The ordering for distinct atomic objects may not be related in any way; no
causality is implied.
Note that variables in [=address spaces/workgroup=] space are shared within a
[=compute shader stage/workgroup=], but are not shared between different
workgroups.


### Array Types ### {#array-types}

An <dfn noexport>array</dfn> is an indexable grouping of element values.

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr><td algorithm="fixed-size array type">array&lt;|E|,|N|&gt;
      <td>A <dfn>fixed-size array</dfn> with |N| elements of type |E|.<br>
          |N| is called the <dfn noexport>element count</dfn> of the array.
  <tr><td algorithm="runtime-sized array type">array&lt;|E|&gt;
      <td>A <dfn noexport>runtime-sized</dfn> array of elements of type |E|.
          These may only appear in specific contexts.<br>
</table>

The first element in an array is at index 0, and each successive element is at the next integer index.
See [[#array-access-expr]].

An expression [=shader-creation error|must not=] evaluate to a runtime-sized array type.

The element count expression |N| of a fixed-size array is subject to the following constraints:
* It [=shader-creation error|must=] be an [=override expression=].
* It [=shader-creation error|must=] evalute to an [=integer scalar=].
* It is a [=pipeline-creation error=] if expression is not greater than zero.

Note:  The element count value is fully determined at [=pipeline creation=] time.

An array element type [=shader-creation error|must=] be one of:
* a [=scalar=] type
* a [=vector=] type with [=concrete=] components
* a [=matrix=] type with [=concrete=] components
* an [=atomic type|atomic=] type
* an [=array=] type having a [=creation-fixed footprint=]
* a [=structure=] type having a [=creation-fixed footprint=].

Note: The element type must be a [=plain type=].

Two array types are the same if and only if all of the following are true:
* They have the same element type.
* Their element count specifications match, i.e. one of the following is true:
    * They are both runtime-sized.
    * They are both fixed-sized with [=creation-fixed footprint=], and
        equal-valued element counts, even if one is signed and the other is unsigned.
        (Signed and unsigned values are comparable in this case because element counts
        are always positive.)
    * They are both fixed-sized with element count specified as the same
        [=pipeline-overridable=] constant.

<div class='example wgsl fixed-size array types' heading='Example fixed-size array types, non-overridable element count'>
  <xmp highlight='rust'>
    // array<f32,8> and array<i32,8> are different types:
    // different element types
    var<private> a: array<f32,8>;
    var<private> b: array<i32,8>;
    var<private> c: array<i32,8u>;  // array<i32,8> and array<i32,8u> are the same type

    const width = 8;
    const height = 8;

    // array<i32,8>, array<i32,8u>, and array<i32,width> are the same type.
    // Their element counts evaluate to 8.
    var<private> d: array<i32,width>;

    // array<i32,height> and array<i32,width> are the same type.
    var<private> e: array<i32,width>;
    var<private> f: array<i32,height>;
  </xmp>
</div>

Note: The only valid use of an array sized by an overridable constant is as the store type
of a variable in [=address spaces/workgroup=] space.

<div class='example wgsl global-scope' heading="Workgroup variables sized by overridable constants">
  <xmp highlight='rust'>
    override blockSize = 16;

    var<workgroup> odds: array<i32,blockSize>;
    var<workgroup> evens: array<i32,blockSize>;

    // An invalid example, because the overridable element count may only occur
    // at the outer level.
    // var<workgroup> both: array<array<i32,blockSize>,2>;

    // An invalid example, because the overridable element count is only
    // valid for workgroup variables.
    // var<private> bad_address_space: array<i32,blockSize>;
  </xmp>
</div>


<div class='syntax' noexport='true'>
  <dfn for=syntax>array_type_decl</dfn> :

    | [=syntax/array=] [=syntax/less_than=] [=syntax/type_decl=] ( [=syntax/comma=] [=syntax/element_count_expression=] ) ? [=syntax/greater_than=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>element_count_expression</dfn> :

    | [=syntax/additive_expression=]

    | [=syntax/bitwise_expression=]
</div>

### Structure Types ### {#struct-types}

A <dfn noexport>structure</dfn> is a grouping of named member values.

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="structure type">
      <td>struct&lt;|T|<sub>1</sub>,...,|T|<sub>N</sub>&gt;
      <td>An ordered tuple of *N* members of types
          |T|<sub>1</sub> through |T|<sub>N</sub>, with |N| being an integer greater than 0.
          A structure type declaration specifies an [=identifier=] name for each member.
          Two members of the same structure type [=shader-creation error|must not=] have the same name.
</table>

A structure member type [=shader-creation error|must=] be one of:
* a [=scalar=] type
* a [=vector=] type
* a [=matrix=] type
* an [=atomic type|atomic=] type
* a [=fixed-size array=] type with [=creation-fixed footprint=]
* a [=runtime-sized=] array type, but only if it is the last member of the structure
* a [=structure=] type that has a [=creation-fixed footprint=]

Note: Each member type must be a [=plain type=].

Some consequences of the restrictions structure member and array element types are:
* A pointer, texture, or sampler [=shader-creation error|must not=] appear in any level of nesting within an array or structure.
* When a [=runtime-sized=] array is part of a larger type, it may only appear
    as the last element of a structure, which itself cannot be part of an enclosing array or structure.

<div class='example wgsl global-scope' heading="Structure">
  <xmp highlight='rust'>
    // A structure with four members.
    struct Data {
      a: i32,
      b: vec2<f32>,
      c: array<i32,10>,
      d: array<f32>, // last comma is optional
    }
  </xmp>
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_decl</dfn> :

    | [=syntax/struct=] [=syntax/ident=] [=syntax/struct_body_decl=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_body_decl</dfn> :

    | [=syntax/brace_left=] ( [=syntax/struct_member=] [=syntax/comma=] ) * [=syntax/struct_member=] [=syntax/comma=] ? [=syntax/brace_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct_member</dfn> :

    | [=syntax/attribute=] * [=syntax/variable_ident_decl=]
</div>

WGSL defines the following attributes that can be applied to structure members:
 * [=attribute/align=]
 * [=attribute/builtin=]
 * [=attribute/location=]
 * [=attribute/interpolate=]
 * [=attribute/invariant=]
 * [=attribute/size=]

Note: Layout attributes may be required if the structure type is used
to define a [=uniform buffer=] or a [=storage buffer=]. See [[#memory-layouts]].

<div class='example wgsl global-scope' heading='Structure declaration'>
  <xmp highlight='rust'>
    struct my_struct {
      a: f32,
      b: vec4<f32>
    }
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Structure used to declare a buffer'>
  <xmp highlight='rust'>
    // Runtime Array
    type RTArr = array<vec4<f32>>;
    struct S {
      a: f32,
      b: f32,
      data: RTArr
    }
    @group(0) @binding(0) var<storage> buffer: S;
  </xmp>
</div>

### Composite Types ### {#composite-types}

A type is <dfn noexport>composite</dfn> if it has internal structure
expressed as a composition of other types.
The internal parts do not overlap, and are called <dfn noexport>components</dfn>.

The composite types are:

* [=vector=] type
* [=matrix=] type
* [=array=] type
* [=structure=] type

For a composite type |T|, the <dfn>nesting depth</dfn> of |T|, written *NestDepth*(|T|) is:
* 1 for a vector type
* 2 for a matrix type
* 1 + *NestDepth*(|E|) for an array type with element type |E|
* 1 + max(*NestDepth*(*M*<sub>1</sub>),..., *NestDepth*(*M*<sub>N</sub>))
    if |T| is a structure type with member types *M*<sub>1</sub>,...,*M*<sub>1</sub>


### Constructible Types ### {#constructible-types}

Many kinds of values can be created, loaded, stored, passed into functions,
and returned from functions.
We call these [=constructible=].

A type is <dfn>constructible</dfn> if it is one of:

* a [=scalar=] type
* a [=vector=] type with [=concrete=] components
* a [=matrix=] type with [=concrete=] components
* a [=fixed-size array=] type, if it has [=creation-fixed footprint=] and its element type is constructible.
* a [=structure=] type, if all its members are constructible.

Note: All constructible types are [=plain types|plain=] and have [=creation-fixed footprint=].

Note: Atomic types and runtime-sized array types are not constructible.
Composite types containing atomics and runtime-sized arrays are not constructible.

### Fixed-Footprint Types ### {#fixed-footprint-types}

The <dfn noexport>memory footprint</dfn> of a variable is the number of [=memory locations=]
used to store the contents of the variable.
The memory footprint of a variable depends on its [=store type=] and becomes finalized at some point
in the [[#shader-lifecycle|shader lifecycle]].
Most variables are sized very early, at [=Shader module creation|shader creation=] time.
Some variables may be sized later, at [=pipeline creation=] time,
and others as late as the [=shader execution start|start of shader execution=].

A [=plain type=] has a <dfn>creation-fixed footprint</dfn> if its size is fully determined
at [=shader module creation|shader creation=] time.

A [=plain type=] has a <dfn>fixed footprint</dfn> if its size is fully determined
at [=pipeline creation=] time.

Note: Pipeline creation depends on shader creation, so a type with [=creation-fixed footprint=] also has [=fixed footprint=].

The plain types with [=creation-fixed footprint=] are:
* a [=scalar=] type
* a [=vector=] type with [=concrete=] components
* a [=matrix=] type with [=concrete=] components
* an [=atomic type|atomic=] type
* a [=fixed-size array=] type, when:
     * its [=element count=] is a [=creation-time expression=].
* a [=structure=] type, if all its members have [=creation-fixed footprint=].

Note: A [=constructible=] type has [=creation-fixed footprint=].

The plain types with [=fixed footprint=] are any of:
* a type with [=creation-fixed footprint=]
* a [=fixed-size array=] type

Note: The only valid use of a fixed-size array with an element count that is an
[=override expression=] that is not a [=creation-time expression=] is as the
[=store type=] for a [=address spaces/workgroup=] variable.

Note: A fixed-footprint type may contain an [=atomic type|atomic=] type, either directly or
indirectly, while a [=constructible=] type must not.

Note: Fixed-footprint types exclude [=runtime-sized=] arrays, and any structures or arrays
that contain [=runtime-sized=] arrays, recursively.

## Memory ## {#memory}

In WGSL, a value of [=storable=] type may be stored in memory, for later retrieval.
This section describes the structure of memory, and how WGSL types are used to
describe the contents of memory.

### Memory Locations ### {#memory-locations-section}

Memory consists of a set of distinct <dfn noexport>memory locations</dfn>.
Each memory location is 8-bits
in size. An operation affecting memory interacts with a set of one or more
memory locations.

Two sets of memory locations <dfn noexport>overlap</dfn> if the intersection of
their sets of memory locations is non-empty. Each variable declaration has a
set of memory locations that does not overlap with the sets of memory locations of
any other variable declaration. Memory operations on structures and arrays will
not access padding memory locations.

### Memory Access Mode ### {#memory-access-mode}

A <dfn noexport>memory access</dfn> is an operation that acts on memory locations.

* A <dfn noexport>read access</dfn> observes the contents of memory locations.
* A <dfn noexport>write access</dfn> sets the contents of memory locations.

A single operation can read, write, or both read and write.

Particular memory locations may support only certain kinds of accesses, expressed
as the memory's <dfn noexport>access mode</dfn>:

: <dfn noexport dfn-for="access">read</dfn>
:: Supports read accesses, but not writes.
: <dfn noexport dfn-for="access">write</dfn>
:: Supports write accesses, but not reads.
: <dfn noexport dfn-for="access">read_write</dfn>
:: Supports both read and write accesses.

<div class='syntax' noexport='true'>
  <dfn for=syntax>access_mode</dfn> :

    | `'read'`

    | `'write'`

    | `'read_write'`
</div>

### Storable Types ### {#storable-types}

The value contained in a [=variable=] [=shader-creation error|must=] be of a [=storable=] type.
A storable type may have an explicit representation defined by WGSL,
as described in [[#internal-value-layout]],
or it may be opaque, such as for textures and samplers.

A type is <dfn noexport>storable</dfn> if it is one of:

* a [=scalar=] type
* a [=vector=] type with [=concrete=] components
* a [=matrix=] type with [=concrete=] components
* an [=atomic type|atomic=] type
* an [=array=] type
* a [=structure=] type
* a [=texture=] type
* a [=sampler=] type

Note: That is, the storable types are the [=plain types=], texture types, and sampler types.

### IO-shareable Types ### {#io-shareable-types}

[[#user-defined-inputs-outputs|User-defined pipeline input and output values]]
[=shader-creation error|must=] be of IO-shareable type.

A type is <dfn noexport>IO-shareable</dfn> if it is one of:

* a [=numeric scalar=] type
* a [=numeric vector=] type
* a [=structure=] type, if all its members are [=numeric scalars=] or [=numeric vectors=]

The following kinds of values [=shader-creation error|must=] be of IO-shareable type:

* Values accepted as user-defined inputs from an upstream pipeline stage.
* Values written as user-defined output for downstream processing in the pipeline, or to an output attachment.

Note: Only user-defined pipeline input and output values must be
IO-shareable. Built-in pipeline inputs and outputs have the types specified in
[[#builtin-values]], which are not necessarily in this category. For example, the
`front_facing` built-in input for fragment shaders has type `bool`, which is not
IO-shareable.

### Host-shareable Types ### {#host-shareable-types}

Host-shareable types are used to describe the contents of buffers which are shared between
the host and the GPU, or copied between host and GPU without format translation.
When used for this purpose, the type may be additionally decorated with layout attributes
as described in [[#memory-layouts]].
We will see in [[#module-scope-variables]] that the [=store type=] of [=uniform buffer=] and [=storage buffer=]
variables [=shader-creation error|must=] be host-shareable.

A type is <dfn noexport>host-shareable</dfn> if it is one of:

* a [=numeric scalar=] type
* a [=numeric vector=] type
* a [=matrix=] type
* an [=atomic type|atomic=] type
* a [=fixed-size array=] type, if it has [=creation-fixed footprint=] and its element type is host-shareable
* a [=runtime-sized=] array type, if its element type is host-shareable
* a [=structure=] type, if all its members are host-shareable

WGSL defines the following attributes that affect memory layouts:
 * [=attribute/align=]
 * [=attribute/size=]

Note: Many types are host-shareable, but not IO-shareable, including [=atomic types=],
[=runtime-sized=] arrays, and any composite types containing them.

Note: Both IO-shareable and host-shareable types have specified sizes, but counted differently.
IO-shareable types are sized by a location-count metric, see [[#input-output-locations]].
Host-shareable types are sized by a byte-count metric, see [[#memory-layouts]].

### Address spaces ### {#address-space}

Memory locations are partitioned into <dfn noexport>address spaces</dfn>.
Each address space has unique properties determining
mutability, visibility, the values it may contain,
and how to use variables with it.

<table class='data' id="address-space-table">
  <caption>Address Spaces</caption>
  <thead>
    <tr><th>Address space
        <th>Sharing among invocations
        <th>Supported access modes
        <th>Variable scope
        <th>Restrictions on stored values
        <th>Notes
  </thead>
  <tr><td><dfn noexport dfn-for="address spaces">function</dfn>
      <td>Same invocation only
      <td>[=access/read_write=]
      <td>[=Function scope=]
      <td>[=Constructible=] type
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">private</dfn>
      <td>Same invocation only
      <td>[=access/read_write=]
      <td>[=Module scope=]
      <td>[=Constructible=] type
      <td>
  <tr><td><dfn noexport dfn-for="address spaces">workgroup</dfn>
      <td>Invocations in the same [=compute shader stage|compute shader=] [=compute shader stage/workgroup=]
      <td>[=access/read_write=]
      <td>[=Module scope=]
      <td>[=Plain type=] with [=fixed footprint=]
      <td>The [=element count=] of an outermost array may be a [=pipeline-overridable=] constant.
  <tr><td><dfn noexport dfn-for="address spaces">uniform</dfn>
      <td>Invocations in the same [=shader stage=]
      <td>[=access/read=]
      <td>[=Module scope=]
      <td>[=Constructible=] [=host-shareable=] types
      <td>For [=uniform buffer=] variables
  <tr><td><dfn noexport dfn-for="address spaces">storage</dfn>
      <td>Invocations in the same [=shader stage=]
      <td> [=access/read_write=], [=access/read=] (default)
      <td>[=Module scope=]
      <td>[=Host-shareable=]
      <td>For [=storage buffer=] variables
  <tr><td><dfn noexport dfn-for="address spaces">handle</dfn>
      <td>Invocations in the same shader stage
      <td>[=access/read=]
      <td>[=Module scope=]
      <td>[=Sampler=] types or [=texture=] types
      <td>For [=sampler=] and texture variables.<br>
</table>

Note: The token `handle` is reserved: it is never used in a WGSL program.

Note: A texture variable holds an opaque handle which is used to access the underlying
grid of texels.
The handle itself is always read-only.
In most cases the underlying texels are read-only.
For a write-only storage texture, the underlying texels are write-only.

<div class='syntax' noexport='true'>
  <dfn for=syntax>address_space</dfn> :

    | [=syntax/function=]

    | [=syntax/private=]

    | [=syntax/workgroup=]

    | [=syntax/uniform=]

    | [=syntax/storage=]
</div>

### Memory Layout ### {#memory-layouts}

[=Uniform buffer=] and [=storage buffer=] variables are used to share
bulk data organized as a sequence of bytes in memory.
Buffers are shared between the CPU and the GPU, or between different shader stages
in a pipeline, or between different pipelines.

Because buffer data are shared without reformatting or translation, it is a
[=dynamic error=] if buffer producers and consumers do not agree on the <dfn
noexport>memory layout</dfn>, which is the description of how the bytes in a
buffer are organized into typed WGSL values.

The [=store type=] of a buffer variable [=shader-creation error|must=] be
[=host-shareable=], with fully elaborated memory layout, as described below.

Each buffer variable [=shader-creation error|must=] be declared in either the
[=address spaces/uniform=] or [=address spaces/storage=] address spaces.

The memory layout of a type is significant only when evaluating an expression with:
* a variable in the [=address spaces/uniform=] or [=address spaces/storage=] address space, or
* a pointer into the [=address spaces/uniform=] or [=address spaces/storage=] address space.

An 8-bit byte is the most basic unit of [=host-shareable=] memory.
The terms defined in this section express counts of 8-bit bytes.

We will use the following notation:
* <dfn noexport>AlignOf</dfn>(|T|) is the [=alignment=] of host-shareable type |T|.
* <dfn noexport>AlignOfMember</dfn>(|S|, |i|) is the alignment of the |i|'th member of the host-shareable structure |S|.
* <dfn noexport>SizeOf</dfn>(|T|) is the [=byte-size=] of host-shareable type |T|.
* <dfn noexport>SizeOfMember</dfn>(|S|, |i|) is the size of the |i|'th member of the host-shareable structure |S|.
* <dfn noexport>OffsetOfMember</dfn>(|S|, |i|) is the offset of the |i|'th member from the start of the host-shareable structure |S|.
* <dfn noexport>StrideOf</dfn>(|A|) is the <dfn>element stride</dfn> of host-shareable array type |A|, defined
    as the number of bytes from the start of one array element to the start of the next element.
    It equals the size of the array's element type, rounded up to the alignment of the element type:
        <p algorithm="array element stride">
          [=StrideOf=](array<|E|, |N|>) = [=roundUp=]([=AlignOf=](E), [=SizeOf=](E))<br>
          [=StrideOf=](array<|E|>) = [=roundUp=]([=AlignOf=](E), [=SizeOf=](E))
        </p>


#### Alignment and Size ####  {#alignment-and-size}

Each [=host-shareable=] data type |T| has an alignment and size.

The <dfn>alignment</dfn> of a type is a constraint on where values of that type may be placed in memory, expressed
as an integer:
a type's alignment [=shader-creation error|must=] evenly divide
the byte address of the starting [=memory location=] of a value of that type.
Alignments enable use of more efficient hardware instructions for accessing the values,
or satisfy more restrictive hardware requirements on certain
address spaces. (See [address space layout constraints](#address-space-layout-constraints)).

Note: Each alignment value is always a power of two, by construction.

The <dfn>byte-size</dfn> of a type or structure member is the number of contiguous bytes
reserved in host-shareable memory for the purpose of storing a value of the type
or structure member.
The size may include non-addressable padding at the end of the type.
Consequently, loads and stores of a value might access fewer memory locations
than the value's size.

Alignment and size for host-shareable types are defined recursively in the
following table:

<table class='data'>
  <caption>
    Alignment and size for host-shareable types<br>
  </caption>
  <thead>
    <tr><th>Host-shareable type |T|
        <th>[=AlignOf=](|T|)
        <th>[=SizeOf=](|T|)
  </thead>
  <tr><td>[=i32=], [=u32=], or [=f32=]
      <td>4
      <td>4
  <tr><td>[=f16=]
      <td>2
      <td>2
  <tr><td>[=atomic type|atomic&lt;|T|&gt;=]
      <td>4
      <td>4
  <tr><td>[=vector|vec=]2&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>8
      <td>8
  <tr><td>vec2&lt;f16&gt;
      <td>4
      <td>4
  <tr><td>vec3&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>16
      <td>12
  <tr><td>vec3&lt;f16&gt;
      <td>8
      <td>6
  <tr><td>vec4&lt;|T|&gt;, |T| is [=i32=], [=u32=], or [=f32=]
      <td>16
      <td>16
  <tr><td>vec4&lt;f16&gt;
      <td>8
      <td>8
  <tr><td>[=matrix|mat=]|C|x|R| (col-major)<br>
      <p class="small">(General form)</p>
      <td>[=AlignOf=](vec|R|)
      <td>[=SizeOf=](array&lt;vec|R|, |C|&gt;)
  <tr><td>mat2x2&lt;f32&gt;
      <td>8
      <td>16
  <tr><td>mat2x2&lt;f16&gt;
      <td>4
      <td>8
  <tr><td>mat3x2&lt;f32&gt;
      <td>8
      <td>24
  <tr><td>mat3x2&lt;f16&gt;
      <td>4
      <td>12
  <tr><td>mat4x2&lt;f32&gt;
      <td>8
      <td>32
  <tr><td>mat4x2&lt;f16&gt;
      <td>4
      <td>16
  <tr><td>mat2x3&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat2x3&lt;f16&gt;
      <td>8
      <td>16
  <tr><td>mat3x3&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat3x3&lt;f16&gt;
      <td>8
      <td>24
  <tr><td>mat4x3&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat4x3&lt;f16&gt;
      <td>8
      <td>32
  <tr><td>mat2x4&lt;f32&gt;
      <td>16
      <td>32
  <tr><td>mat2x4&lt;f16&gt;
      <td>8
      <td>16
  <tr><td>mat3x4&lt;f32&gt;
      <td>16
      <td>48
  <tr><td>mat3x4&lt;f16&gt;
      <td>8
      <td>24
  <tr><td>mat4x4&lt;f32&gt;
      <td>16
      <td>64
  <tr><td>mat4x4&lt;f16&gt;
      <td>8
      <td>32
  <tr><td>[=structure|struct=] |S| with members M<sub>1</sub>...M<sub>N</sub>
      <td>max([=AlignOfMember=](S,1), ... , [=AlignOfMember=](S,N))<br>
      <td>[=roundUp=]([=AlignOf=](|S|), justPastLastMember)<br><br>
          where justPastLastMember = [=OffsetOfMember=](|S|,N) + [=SizeOfMember=](|S|,N)
  <tr><td>[=array=]<|E|, |N|><br>
      <td>[=AlignOf=](|E|)
      <td>|N| &times; [=roundUp=]([=AlignOf=](|E|), [=SizeOf=](|E|))
  <tr><td>array<|E|><br>
      <td>[=AlignOf=](|E|)
      <td>N<sub>runtime</sub> &times; [=roundUp=]([=AlignOf=](|E|),[=SizeOf=](|E|))<br><br>
          where N<sub>runtime</sub> is the runtime-determined number of elements of |T|
</table>


#### Structure Member Layout ####  {#structure-member-layout}

The |i|'th member of structure type |S| has a size and alignment, denoted
by [=SizeOfMember=](|S|, |i|) and [=AlignOfMember=](|S|, |i|), respectively.
The member sizes and alignments are used to calculate each member's byte offset from the start of the structure,
as described in [[#internal-value-layout]].

<p algorithm="structure member size">
  [=SizeOfMember=](|S|, |i|) is |k| if the |i|'th member of |S| has attribute [=attribute/size=](|k|).
  Otherwise, it is [=SizeOf=](|T|) where |T| is the type of the member.
</p>

<p algorithm="structure member alignment">
  [=AlignOfMember=](|S|, |i|) is |k| if the |i|'th member of |S| has attribute [=attribute/align=](|k|).
  Otherwise, it is [=AlignOf=](|T|) where |T| is the type of the member.
</p>

If a structure member is decorated with the [=attribute/size=] attribute, the
value [=shader-creation error|must=] be at least as large as the size of the
member's type:

<p algorithm="member size constraint">
  [=SizeOfMember=](|S|, |i|) &ge; [=SizeOf=](T)<br>
  Where |T| is the type of the |i|'th member of |S|.
</p>

The first structure member always has a zero byte offset from the start of the
structure:
<p algorithm="offset of first structure member">
  [=OffsetOfMember=](<var ignore>S</var>, 1) = 0
</p>

Each subsequent member is placed at the lowest offset that satisfies the member type alignment,
and which avoids overlap with the previous member.
For each member index |i| > 1:
<p algorithm="structure member offset">
  [=OffsetOfMember=](|S|, |i|) = [=roundUp=]([=AlignOfMember=](|S|, |i| ), [=OffsetOfMember=](|S|, |i|-1) + [=SizeOfMember=](|S|, |i|-1))<br>
</p>

<div class='example wgsl' heading='Layout of structures using implicit member sizes and alignments'>
  <xmp highlight='rust'>
    struct A {                                     //             align(8)  size(24)
        u: f32,                                    // offset(0)   align(4)  size(4)
        v: f32,                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>,                              // offset(8)   align(8)  size(8)
        x: f32                                     // offset(16)  align(4)  size(4)
        // -- implicit struct size padding --      // offset(20)            size(4)
    }

    struct B {                                     //             align(16) size(160)
        a: vec2<f32>,                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>,                              // offset(16)  align(16) size(12)
        c: f32,                                    // offset(28)  align(4)  size(4)
        d: f32,                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(4)
        e: A,                                      // offset(40)  align(8)  size(24)
        f: vec3<f32>,                              // offset(64)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(76)            size(4)
        g: array<A, 3>,    // element stride 24       offset(80)  align(8)  size(72)
        h: i32                                     // offset(152) align(4)  size(4)
        // -- implicit struct size padding --      // offset(156)           size(4)
    }

    @group(0) @binding(0)
    var<storage,read_write> storage_buffer: B;
  </xmp>
</div>

<div class='example wgsl' heading='Layout of structures with explicit member sizes and alignments'>
  <xmp highlight='rust'>
    struct A {                                     //             align(8)  size(32)
        u: f32,                                    // offset(0)   align(4)  size(4)
        v: f32,                                    // offset(4)   align(4)  size(4)
        w: vec2<f32>,                              // offset(8)   align(8)  size(8)
        @size(16) x: f32                           // offset(16)  align(4)  size(16)
    }

    struct B {                                     //             align(16) size(208)
        a: vec2<f32>,                              // offset(0)   align(8)  size(8)
        // -- implicit member alignment padding -- // offset(8)             size(8)
        b: vec3<f32>,                              // offset(16)  align(16) size(12)
        c: f32,                                    // offset(28)  align(4)  size(4)
        d: f32,                                    // offset(32)  align(4)  size(4)
        // -- implicit member alignment padding -- // offset(36)            size(12)
        @align(16) e: A,                           // offset(48)  align(16) size(32)
        f: vec3<f32>,                              // offset(80)  align(16) size(12)
        // -- implicit member alignment padding -- // offset(92)            size(4)
        g: array<A, 3>,    // element stride 32       offset(96)  align(8)  size(96)
        h: i32                                     // offset(192) align(4)  size(4)
        // -- implicit struct size padding --      // offset(196)           size(12)
    }

    @group(0) @binding(0)
    var<uniform> uniform_buffer: B;
  </xmp>
</div>

#### Array Layout Examples ####  {#array-layout-examples}

<div class='example wgsl function-scope' heading='Fixed-size array layout examples'>
  <xmp highlight='rust'>
    // Array where:
    //   - alignment is 4 = AlignOf(f32)
    //   - element stride is 4 = roundUp(AlignOf(f32),SizeOf(f32)) = roundUp(4,4)
    //   - size is 32 = stride * number_of_elements = 4 * 8
    var small_stride: array<f32, 8>;

    // Array where:
    //   - alignment is 16 = AlignOf(vec3<f32>) = 16
    //   - element stride is 16 = roundUp(AlignOf(vec3<f32>), SizeOf(vec3<f32>))
    //                          = roundUp(16,12)
    //   - size is 128 = stride * number_of_elements = 16 * 8
    var bigger_stride: array<vec3<f32>, 8>;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Runtime-sized array layout examples'>
  <xmp highlight='rust'>
    // Array where:
    //   - alignment is 4 = AlignOf(f32)
    //   - element stride is 4 = roundUp(AlignOf(f32),SizeOf(f32)) = 4
    // If B is the effective buffer binding size for the binding on the
    // draw or dispatch command, the number of elements is:
    //   N_runtime = floor(B / element stride) = floor(B / 4)
    @group(0) @binding(0)
    var<storage> weights: array<f32>;

    // Array where:
    //   - alignment is 16 = AlignOf(vec3<f32>) = 16
    //   - element stride is 16 = roundUp(AlignOf(vec3<f32>), SizeOf(vec3<f32>))
    //                          = roundUp(16,12)
    // If B is the effective buffer binding size for the binding on the
    // draw or dispatch command, the number of elements is:
    //   N_runtime = floor(B / element stride) = floor(B / 16)
    var<uniform> directions: array<vec3<f32>>;
  </xmp>
</div>

#### Internal Layout of Values ####  {#internal-value-layout}

This section describes how the internals of a value are placed in the byte locations
of a buffer, given an assumed placement of the overall value.
These layouts depend on the value's type,
and the [=attribute/align=] and [=attribute/size=] attributes on structure members.

The buffer byte offset at which a value is placed [=shader-creation
error|must=] satisfy the type alignment requirement: If a value of type |T| is
placed at buffer offset |k|, then |k| = |c| &times; [=AlignOf=](|T|), for some
non-negative integer |c|.

The data will appear identically regardless of the address space.

When a value |V| of type [=u32=] or [=i32=] is placed at byte offset |k| of a
host-shared buffer, then:
   * Byte |k| contains bits 0 through 7 of |V|
   * Byte |k|+1 contains bits 8 through 15 of |V|
   * Byte |k|+2 contains bits 16 through 23 of |V|
   * Byte |k|+3 contains bits 24 through 31 of |V|

Note: Recall that [=i32=] uses twos-complement representation, so the sign bit
is in bit position 31.

A value |V| of type [=f32=] is represented in [[!IEEE-754|IEEE-754]] binary32 format.
It has one sign bit, 8 exponent bits, and 23 fraction bits.
When |V| is placed at byte offset |k| of host-shared buffer, then:
   * Byte |k| contains bits 0 through 7 of the fraction.
   * Byte |k|+1 contains bits 8 through 15 of the fraction.
   * Bits 0 through 6 of byte |k|+2 contain bits 16 through 22 of the fraction.
   * Bit 7 of byte |k|+2 contains bit 0 of the exponent.
   * Bits 0 through 6 of byte |k|+3 contain bits 1 through 7 of the exponent.
   * Bit 7 of byte |k|+3 contains the sign bit.

A value |V| of type [=f16=] is represented in [[!IEEE-754|IEEE-754]] binary16 format.
It has one sign bit, 5 exponent bits, and 10 fraction bits.
When |V| is placed at byte offset |k| of host-shared buffer, then:
   * Byte |k| contains bits 0 through 7 of the fraction.
   * Bits 0 through 1 of byte |k|+1 contain bits 8 through 9 of the fraction.
   * Bits 2 through 6 of byte |k|+1 contain bits 0 through 4 of the exponent.
   * Bit 7 of byte |k|+1 contains the sign bit.

Note: The above rules imply that numeric values in host-shared buffers
are stored in little-endian format.

When a value |V| of [=atomic type=] `atomic`&lt;|T|&gt; is placed in a host-shared buffer,
it has the same internal layout as a value of the underlying type |T|.

When a value |V| of [=vector|vector type=] vec|N|&lt;|T|&gt; is placed at
byte offset |k| of a host-shared buffer, then:
   * |V|.x is placed at byte offset |k|
   * |V|.y is placed at byte offset |k| + [=SizeOf=](|T|)
   * If |N| &ge; 3, then |V|.z is placed at byte offset |k| + 2 &times; [=SizeOf=](|T|)
   * If |N| &ge; 4, then |V|.w is placed at byte offset |k| + 3 &times; [=SizeOf=](|T|)

When a value |V| of [=matrix|matrix type=] mat|C|x|R|&lt;|T|&gt; is placed at
byte offset |k| of a host-shared buffer, then:
  * Column vector |i| of |V| is placed at byte offset |k| + |i| &times; [=AlignOf=](vec|R|&lt;|T|&gt;)

When a value of [=array|array type=] |A| is placed at byte offset |k| of a host-shared memory buffer,
then:
   * Element |i| of the array is placed at byte offset |k| + |i| &times; [=StrideOf=](|A|)

When a value of [=structure|structure type=] |S| is placed at byte offset |k| of a host-shared memory buffer,
then:
   * The |i|'<sup>th</sup> member of the structure value is placed at byte offset |k| + [=OffsetOfMember=](|S|,|i|).
    See [[#structure-member-layout]].

#### Address Space Layout Constraints ####  {#address-space-layout-constraints}

The [=address spaces/storage=] and [=address spaces/uniform=] address spaces
have different buffer layout constraints which are described in this section.

All structure and array types directly or indirectly referenced by a variable
[=shader-creation error|must=] obey the constraints of the variable's address space.
Violations of an address space constraint results in a [=shader-creation error=].

In this section we define <dfn noexport>RequiredAlignOf</dfn>(|S|, |C|) as the
byte offset [=alignment=] requirement of values of host-shareable type |S| when
used in address space |C|.

<table class='data'>
  <caption>
    Alignment requirements of a host-shareable type for
    [=address spaces/storage=] and [=address spaces/uniform=] address spaces
  </caption>
  <thead>
    <tr><th>Host-shareable type |S|
        <th>[=RequiredAlignOf=](|S|, [=address spaces/storage=])
        <th>[=RequiredAlignOf=](|S|, [=address spaces/uniform=])
  </thead>
  <tr><td>[=i32=], [=u32=], [=f32=], or [=f16=]
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>[=atomic types|atomic=]&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr><td>[=vector|vec=]N&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of a matrix with C columns and R rows">
      <td>[=matrix|mat=]CxR&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=AlignOf=](|S|)
  <tr algorithm="alignment of an array">
      <td>[=array=]&lt;T, N&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of an runtime-sized array">
      <td>array&lt;T&gt;
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))
  <tr algorithm="alignment of a structure">
      <td>[=structure|struct=] |S|
      <td>[=AlignOf=](|S|)
      <td>[=roundUp=](16, [=AlignOf=](|S|))<br>
</table>

Structure members of type |T| [=shader-creation error|must=] have a byte offset
from the start of the structure that is a multiple of the [=RequiredAlignOf=](|T|, |C|)
for the address space |C|:

<p algorithm="structure member minimum alignment">
    [=OffsetOfMember=](|S|, |M|) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    Where |k| is a positive integer and |M| is a member of structure |S| with type |T|
</p>

Arrays of element type |T| [=shader-creation error|must=] have an [=element stride=] that is a
multiple of the [=RequiredAlignOf=](|T|, |C|) for the address space |C|:

<p algorithm="array element minimum alignment">
    [=StrideOf=](array<|T|, |N|>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    [=StrideOf=](array<|T|>) = |k| &times; [=RequiredAlignOf=](|T|, C)<br>
    Where |k| is a positive integer
</p>

Note: [=RequiredAlignOf=](|T|, |C|) does not impose any additional restrictions
on the values permitted for an [=attribute/align=] decoration, nor does it affect the rules
of [=AlignOf=](|T|). Data is laid out with the rules defined in previous
sections and then the resulting layout is validated against the
[=RequiredAlignOf=](|T|, |C|) rules.

The [=address spaces/uniform=] address space also requires that:
* Array elements are aligned to 16 byte boundaries.
    That is, [=StrideOf=](array&lt;|T|,|N|&gt;) = 16 &times; |k|' for some positive integer |k|'.
* If a structure member itself has a structure type `S`, then the number of
    bytes between the start of that member and the start of any following member
    [=shader-creation error|must=] be at least [=roundUp=](16, [=SizeOf=](S)).

Note: The following examples show how to use [=attribute/align=] and [=attribute/size=] attributes
on structure members to satisfy layout requirements for uniform buffers.
In particular, these techniques can be used mechanically transform a GLSL buffer with std140 layout
to WGSL.

<div class='example wgsl global-scope' heading='Satisfying offset requirements for uniform address space'>
  <xmp highlight='rust'>
    struct S {
      x: f32
    }
    struct Invalid {
      a: S,
      b: f32 // invalid: offset between a and b is 4 bytes, but must be at least 16
    }
    @group(0) @binding(0) var<uniform> invalid: Invalid;

    struct Valid {
      a: S,
      @align(16) b: f32 // valid: offset between a and b is 16 bytes
    }
    @group(0) @binding(1) var<uniform> valid: Valid;
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Satisfying stride requirements for uniform address space'>
  <xmp highlight='rust'>
    struct small_stride {
      a: array<f32,8> // stride 4
    }
    // Invalid, stride must be a multiple of 16
    @group(0) @binding(0) var<uniform> invalid: small_stride;

    struct wrapped_f32 {
      @size(16) elem: f32
    }
    struct big_stride {
      a: array<wrapped_f32,8> // stride 16
    }
    @group(0) @binding(1) var<uniform> valid: big_stride;     // Valid
  </xmp>
</div>

## Memory View Types ## {#memory-view-types}

In addition to calculating with [=plain types|plain=] values, a WGSL program will
also often read values from memory or write values to memory, via [=memory access=] operations.
Each memory access is performed via a [=memory view=].

A <dfn noexport>memory view</dfn> comprises:
* a set of [=memory locations=] in a particular [=address space=],
* an interpretation of the contents of those locations as a WGSL [=type=], known as the <dfn noexport>store type</dfn>, and
* an [=access mode=].

The access mode of a memory view [=shader-creation error|must=] be supported by the address space. See [[#address-space]].

WGSL has two kinds of types for representing memory views:
[=reference types=] and [=pointer types=].

<table class='data'>
  <thead>
    <tr><th>Constraint<th>Type<th>Description
  </thead>
  <tr algorithm="memory reference type">
    <td style="width:25%">|AS| is an [=address space=],<br>|T| is a [=storable=] type,<br>|AM| is an [=access mode=]
    <td>ref&lt;|AS|,|T|,|AM|&gt;
    <td>The <dfn noexport>reference type</dfn>
        identified with the set of [=memory views=] for memory locations in |AS| holding values of type |T|,
        supporting memory accesses described by mode |AM|.<br>
        Here, |T| is the [=store type=].<br>
        Reference types are not written in WGSL program source;
        instead they are used to analyze a WGSL program.
  <tr algorithm="pointer type">
    <td>|AS| is an [=address space=],<br>|T| is a [=storable=] type,<br>|AM| is an [=access mode=]
    <td>ptr&lt;|AS|,|T|,|AM|&gt;
    <td>The <dfn noexport>pointer type</dfn>
        identified with the set of [=memory views=] for memory locations in |AS| holding values of type |T|,
        supporting memory accesses described by mode |AM|.<br>
        Here, |T| is the [=store type=].<br>
        Pointer types may appear in WGSL program source.
</table>

When *analyzing* a WGSL program, reference and pointer types are fully parameterized by
an address space, a storable type, and an access mode.
In code examples in this specification, the comments show this fully parameterized form.

However, in WGSL *source* text:
* Reference types [=shader-creation error|must not=] appear.
* Pointer types may appear.
    * A pointer type is spelled with parameterization by:
        * [=address space=],
        * [=store type=], and
        * sometimes by [=access mode=], as specified in [[#access-mode-defaults]].
    * If a pointer type appears in the program source,
        it [=shader-creation error|must=] also be valid to [=variable declaration|declare a variable=],
        somewhere in the program,
        with the pointer type's [=address space=], [=store type=], and [=access mode=].

        Note: This restriction forbids the declaration of certain [=type aliases=]
        and function [=formal parameters=] that can never be used at runtime.
        Without the restriction, it would be valid to declare an alias to a pointer type,
        but never be able to create a pointer value of that type.
        Similarly, it would be valid to declare a function with a pointer formal parameter,
        but never be able to call that function.

<div class='example wgsl' heading='Pointer type'>
  <xmp highlight='rust'>
    fn my_function(
      /* 'ptr<function,i32,read_write>' is the type of a pointer value that references
         memory for keeping an 'i32' value, using memory locations in the 'function'
         address space.  Here 'i32' is the store type.
         The implied access mode is 'read_write'. See below for access mode defaults. */
      ptr_int: ptr<function,i32>,

      // 'ptr<private,array<f32,50>,read_write>' is the type of a pointer value that
      // refers to memory for keeping an array of 50 elements of type 'f32', using
      // memory locations in the 'private' address space.
      // Here the store type is 'array<f32,50>'.
      // The implied access mode is 'read_write'. See below for access mode defaults.
      ptr_array: ptr<private, array<f32, 50>>
    ) { }
  </xmp>
</div>

Reference types and pointer types are both sets of memory views:
a particular memory view is associated with a unique reference value and also a unique pointer value:

<blockquote algorithm="pointer reference correspondence">
Each pointer value |p| of type ptr&lt;|AS|,|T|,|AM|&gt; corresponds to a unique reference value |r| of type ref&lt;|AS|,|T|,|AM|&gt;,
and vice versa,
where |p| and |r| describe the same memory view.
</blockquote>

### Access Mode Defaults ### {#access-mode-defaults}

The access mode for a memory view is often determined by context:

* The [=address spaces/storage=] address space supports both [=access/read=] and [=access/read_write=] access modes.
* Each other address space supports only one access mode, as described in the <a href="#address-space-table">address space</a> table.

When writing a [=variable declaration=] or a [=pointer type=] in WGSL source:
* For the [=address spaces/storage=] address space, the access mode is optional, and defaults to [=access/read=].
* For other address spaces, the access mode [=shader-creation error|must not=] be written.

### Originating Variable ### {#originating-variable-section}

In WGSL a reference value always corresponds to the memory view
for some or all of the memory locations for some variable.
This defines the <dfn noexport>originating variable</dfn> for the reference value.

A pointer value always corresponds to a reference value, and so the originating variable
of a pointer is the same as the originating variable of the corresponding reference.

Note: The originating variable is a dynamic concept.
The originating variable for a formal parameter of a function depends on the
[=call site|call sites=] for the function.
Different call sites may supply pointers into different originating variables.

If a reference or pointer access is out of bounds, an <dfn noexport>invalid
memory reference</dfn> is produced.
[=Load Rule|Loads=] from an invalid reference return one of:
    * a value from any [=memory locations|memory location(s)=] of the [[WebGPU#buffers|WebGPU buffer]]
        bound to the [=originating variable=]
    * the [=zero value=] for store type of the reference
    * if the loaded value is a vector, the value (0, 0, 0, x), where x is:
        * 0, 1, or the maximum positive value for integer components
        * 0.0 or 1.0 for floating-point components
[=statement/assignment|Stores=] to an invalid reference may either:
    * store the value to any [=memory locations|memory location(s)=] of the
        [[WebGPU#buffers|WebGPU buffer]] bound to the [=originating variable=]
    * not be executed
It is a [=dynamic error=] if [[#atomic-rmw|read-modify-write atomics]] that
operate on an invalid memory reference load and store from different [=memory
locations|memory locations=] if they access memory.

### Use Cases for References and Pointers ### {#ref-ptr-use-cases}

References and pointers are distinguished by how they are used:

* The type of a [=variable=] is a reference type.
* The [=address-of=] operation (unary `&`) converts a reference value to its corresponding pointer value.
* The [=indirection=] operation (unary `*`) converts a pointer value to its corresponding reference value.
* A [=let declaration=] can be of pointer type, but not of reference type.
* A [=formal parameter=] can be of pointer type, but not of reference type.
* A [=simple assignment=] statement performs a [=write access=] to update the contents of memory via a reference, where:
    * The [=left-hand side=] of the assignment statement [=shader-creation error|must=] be of reference type, with access mode [=access/write=] or [=access/read_write=].
    * The [=right-hand side=] of the assignment statement [=shader-creation error|must=] evaluate to the store type of the left-hand side.
* The <dfn noexport>Load Rule</dfn>: Inside a function, a reference is automatically dereferenced (read from) to satisfy type rules:
    * In a function, when a reference expression |r| with store type |T| is used in a statement or an expression, where
    * |r| has an access mode of [=access/read=] or [=access/read_write=], and
    * The only potentially matching type rules require |r| to have a value of type |T|, then
    * That type rule requirement is considered to have been met, and
    * The result of evaluating |r| in that context is the value (of type |T|) stored in the memory locations
        referenced by |r| at the time of evaluation.
        That is, a [=read access=] is performed to produce the result value.

Defining references in this way enables simple idiomatic use of variables:

<div class='example wgsl' heading='Reference types enable simple use of variables'>
  <xmp highlight='rust'>
    @compute
    fn main() {
      // 'i' has reference type ref<function,i32,read_write>
      // The memory locations for 'i' store the i32 value 0.
      var i: i32 = 0;

      // 'i + 1' can only match a type rule where the 'i' subexpression is of type i32.
      // So the expression 'i + 1' has type i32, and at evaluation, the 'i' subexpression
      // evaluates to the i32 value stored in the memory locations for 'i' at the time
      // of evaluation.
      let one: i32 = i + 1;

      // Update the value in the locations referenced by 'i' so they hold the value 2.
      i = one + 1;

      // Update the value in the locations referenced by 'i' so they hold the value 5.
      // The evaluation of the right-hand-side occurs before the assignment takes effect.
      i = i + 3;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Returning a reference returns the value loaded via the reference'>
  <xmp highlight='rust'>
    var<private> age: i32;
    fn get_age() -> i32 {
      // The type of the expression in the return statement must be 'i32' since it
      // must match the declared return type of the function.
      // The 'age' expression is of type ref<private,i32,read_write>.
      // Apply the Load Rule, since the store type of the reference matches the
      // required type of the expression, and no other type rule applies.
      // The evaluation of 'age' in this context is the i32 value loaded from the
      // memory locations referenced by 'age' at the time the return statement is
      // executed.
      return age;
    }

    fn caller() {
      age = 21;
      // The copy_age constant will get the i32 value 21.
      let copy_age: i32 = get_age();
    }
  </xmp>
</div>

Defining pointers in this way enables two key use cases:

* Using a let declaration with pointer type, to form a short name for part of the contents of a variable.
* Using a formal parameter of a function to refer to the memory of a variable that is accessible to the [=calling function=].
    * The call to such a function [=shader-creation error|must=] supply a pointer value for that operand.
        This often requires using an [=address-of=] operation (unary `&`) to get a pointer to the variable's contents.

Note: The following examples use WGSL features explained later in this specification.

<div class='example wgsl' heading='Using a pointer as a short name for part of a variable'>
  <xmp highlight='rust'>
    struct Particle {
      position: vec3<f32>,
      velocity: vec3<f32>
    }
    struct System {
      active_index: i32,
      timestep: f32,
      particles: array<Particle,100>
    }
    @group(0) @binding(0) var<storage,read_write> system: System;

    @compute
    fn main() {
      // Form a pointer to a specific Particle in storage memory.
      let active_particle: ptr<storage,Particle> =
          &system.particles[system.active_index];

      let delta_position: vec3<f32> = (*active_particle).velocity * system.timestep;
      let current_position: vec3<f32>  = (*active_particle).position;
      (*active_particle).position = delta_position + current_position;
    }
  </xmp>
</div>

<div class='example wgsl' heading='Using a pointer as a formal parameter'>
  <xmp highlight='rust'>
    fn add_one(x: ptr<function,i32>) {
      /* Update the locations for 'x' to contain the next higher integer value,
         (or to wrap around to the largest negative i32 value).
         On the left-hand side, unary '*' converts the pointer to a reference that
         can then be assigned to. It has a read_write access mode, by default.
         /* On the right-hand side:
            - Unary '*' converts the pointer to a reference, with a read_write
              access mode.
            - The only matching type rule is for addition (+) and requires '*x' to
              have type i32, which is the store type for '*x'.  So the Load Rule
              applies and '*x' evaluates to the value stored in the memory for '*x'
              at the time of evaluation, which is the i32 value for 0.
            - Add 1 to 0, to produce a final value of 1 for the right-hand side. */
         Store 1 into the memory for '*x'. */
      *x = *x + 1;
    }

    @compute
    fn main() {
      var i: i32 = 0;

      // Modify the contents of 'i' so it will contain 1.
      // Use unary '&' to get a pointer value for 'i'.
      // This is a clear signal that the called function has access to the memory
      // for 'i', and may modify it.
      add_one(&i);
      let one: i32 = i;  // 'one' has value 1.
    }
  </xmp>
</div>

### Forming Reference and Pointer Values ### {#forming-references-and-pointers}

A reference value is formed in one of the following ways:

* The [=identifier=] [=resolves|resolving=] to an [=in scope|in-scope=] variable *v* denotes the reference value for *v*'s memory.
    * The resolved variable is the [=originating variable=] for the reference.
* Use the [=indirection=] (unary `*`) operation on a pointer.
    * The originating variable of the result is defined as the originating variable of the pointer.
* Use a <dfn noexport>composite reference component expression</dfn>.
    In each case the originating variable of the result is defined as the originating variable of the
    original reference.
    * Given a reference with a [=vector=] store type, appending a single-letter vector access phrase
        results in a reference to the named component of the vector.
        See [[#component-reference-from-vector-reference]].
    * Given a reference with a [=vector=] store type, appending an array index access phrase
        results in a reference to the indexed component of the vector.
        See [[#component-reference-from-vector-reference]].
    * Given a reference with a [=matrix=] store type, appending an array index access phrase
        results in a reference to the indexed column vector of the matrix.
        See [[#matrix-access-expr]].
    * Given a reference with an [=array=] store type, appending an array index access phrase
        results in a reference to the indexed element of the array.
        See [[#array-access-expr]].
    * Given a reference with a [=structure=] store type, appending a member access phrase
        results in a reference to the named member of the structure.
        See [[#struct-access-expr]].

In all cases, the [=access mode=] of the result is the same as the access mode of the original reference.

<div class='example wgsl' heading='Component reference from a composite reference'>
  <xmp highlight='rust'>
    struct S {
        age: i32,
        weight: f32
    }
    var<private> person: S;
    // Uses of 'person' denote the reference to the memory underlying the variable,
    // and will have type ref<private,S,read_write>.

    fn f() {
        var uv: vec2<f32>;
        // Uses of 'uv' denote the reference to the memory underlying the variable,
        // and will have type ref<function,vec2<f32>,read_write>.

        // Evaluate the left-hand side of the assignment:
        //   Evaluate 'uv.x' to yield a reference:
        //   1. First evaluate 'uv', yielding a reference to the memory for
        //      the 'uv' variable. The result has type ref<function,vec2<f32>,read_write>.
        //   2. Then apply the '.x' vector access phrase, yielding a reference to
        //      the memory for the first component of the vector pointed at by the
        //      reference value from the previous step.
        //      The result has type ref<function,f32,read_write>.
        // Evaluating the right-hand side of the assignment yields the f32 value 1.0.
        // Store the f32 value 1.0 into the storage memory locations referenced by uv.x.
        uv.x = 1.0;

        // Evaluate the left-hand side of the assignment:
        //   Evaluate 'uv[1]' to yield a reference:
        //   1. First evaluate 'uv', yielding a reference to the memory for
        //      the 'uv' variable. The result has type ref<function,vec2<f32>,read_write>.
        //   2. Then apply the '[1]' array index phrase, yielding a reference to
        //      the memory for second component of the vector referenced from
        //      the previous step.  The result has type ref<function,f32,read_write>.
        // Evaluating the right-hand side of the assignment yields the f32 value 2.0.
        // Store the f32 value 2.0 into the storage memory locations referenced by uv[1].
        uv[1] = 2.0;

        var m: mat3x2<f32>;
        // When evaluating 'm[2]':
        // 1. First evaluate 'm', yielding a reference to the memory for
        //    the 'm' variable. The result has type ref<function,mat3x2<f32>,read_write>.
        // 2. Then apply the '[2]' array index phrase, yielding a reference to
        //    the memory for the third column vector pointed at by the reference
        //    value from the previous step.
        //    Therefore the 'm[2]' expression has type ref<function,vec2<f32>,read_write>.
        // The 'let' declaration is for type vec2<f32>, so the declaration
        // statement requires the initializer to be of type vec2<f32>.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the vec2<f32> value loaded
        // from the memory locations referenced by 'm[2]' at the time the declaration
        // is executed.
        let p_m_col2: vec2<f32> = m[2];

        var A: array<i32,5>;
        // When evaluating 'A[4]'
        // 1. First evaluate 'A', yielding a reference to the memory for
        //    the 'A' variable. The result has type ref<function,array<i32,5>,read_write>.
        // 2. Then apply the '[4]' array index phrase, yielding a reference to
        //    the memory for the fifth element of the array referenced by
        //    the reference value from the previous step.
        //    The result value has type ref<function,i32,read_write>.
        // The let declaration requires the right-hand-side to be of type i32.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the i32 value loaded from
        // the memory locations referenced by 'A[4]' at the time the declaration
        // is executed.
        let A_4_value: i32 = A[4];

        // When evaluating 'person.weight'
        // 1. First evaluate 'person', yielding a reference to the memory for
        //    the 'person' variable declared at module scope.
        //    The result has type ref<private,S,read_write>.
        // 2. Then apply the '.weight' member access phrase, yielding a reference to
        //    the memory for the second member of the memory referenced by
        //    the reference value from the previous step.
        //    The result has type ref<private,f32,read_write>.
        // The let declaration requires the right-hand-side to be of type f32.
        // The Load Rule applies (because no other type rule can apply), and
        // the evaluation of the initializer yields the f32 value loaded from
        // the memory locations referenced by 'person.weight' at the time the
        // declaration is executed.
        let person_weight: f32 = person.weight;
    }
  </xmp>
</div>

A pointer value is formed in one of the following ways:

* Use the [=address-of=] (unary `&`) operator on a reference.
    * The originating variable of the result is defined as the originating variable of the reference.
* If a function [=formal parameter=] has pointer type, then when the function is invoked
    at runtime the uses of the formal parameter denote the pointer value
    provided to the corresponding operand at the [=call site=] in the [=calling function=].
    * The originating variable of the formal parameter (at runtime) is defined as
        the originating variable of the pointer operand at the call site.

In all cases, the access mode of the result is the same as the access mode of the original pointer.

<div class='example wgsl' heading='Pointer from a variable'>
  <xmp highlight='rust'>
    // Declare a variable in the private address space, for storing an f32 value.
    var<private> x: f32;

    fn f() {
        // Declare a variable in the function address space, for storing an i32 value.
        var y: i32;

        // The name 'x' resolves to the module-scope variable 'x',
        // and has reference type ref<private,f32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode is the same as the access mode of the original variable, so
        // the fully specified type is ptr<private,f32,read_write>.  But read_write
        // is the default access mode for function address space, so read_write does not
        // have to be spelled in this case
        let x_ptr: ptr<private,f32> = &x;

        // The name 'y' resolves to the function-scope variable 'y',
        // and has reference type ref<private,i32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode defaults to 'read_write'.
        let y_ptr: ptr<function,i32> = &y;

        // A new variable, distinct from the variable declared at module scope.
        var x: u32;

        // Here, the name 'x' resolves to the function-scope variable 'x' declared in
        // the previous statement, and has type ref<function,u32,read_write>.
        // Applying the unary '&' operator converts the reference to a pointer.
        // The access mode defaults to 'read_write'.
        let inner_x_ptr: ptr<function,u32> = &x;
    }
  </xmp>
</div>

### Comparison with References and Pointers in Other Languages ### {#pointers-other-languages}

This section is informative, not normative.

References and pointers in WGSL are more restricted than in other languages.
In particular:

* In WGSL a reference can't directly be declared as an alias to another reference or variable,
    either as a variable or as a formal parameter.
* In WGSL pointers and references are not [=storable=].
    That is, the content of a WGSL variable may not contain a pointer or a reference.
* In WGSL a function [=shader-creation error|must not=] return a pointer or reference.
* In WGSL there is no way to convert between integer values and pointer values.
* In WGSL there is no way to forcibly change the type of a pointer value into another pointer type.
    * A composite component reference expression is different:
        it takes a reference to a composite value and yields a reference to
        one of the components or elements inside the composite value.
        These are considered different references in WGSL, even though they may
        have the same machine address at a lower level of implementation abstraction.
* In WGSL there is no way to forcibly change the type of a reference value into another reference type.
* In WGSL there is no way to change the access mode of a pointer or reference.
    * By comparison, C++ automatically converts a non-const pointer to a const pointer,
        and has a `const_cast` to convert a const value to a non-const value.
* In WGSL there is no way to allocate new memory from a "heap".
* In WGSL there is no way to explicitly destroy a variable.
    The memory for a WGSL variable becomes inaccessible only when the variable goes out of scope.

Note: From the above rules, it is not possible to form a "dangling" pointer,
i.e. a pointer that does not reference the memory for a valid (or "live")
originating variable.

## Texture and Sampler Types ## {#texture-types}

A <dfn noexport>texel</dfn> is a scalar or vector used as the smallest independently accessible element of a [=texture=].
The word *texel* is short for *texture element*.

A <dfn noexport>texture</dfn> is a collection of texels supporting special operations useful for rendering.
In WGSL, those operations are invoked via texture builtin functions.
See [[#texture-builtin-functions]] for a complete list.

A WGSL texture corresponds to a [[WebGPU#gputexture|WebGPU GPUTexture]].

A texture is either arrayed, or non-arrayed:

* A <dfn noexport>non-arrayed texture</dfn> is a grid of texels. Each texel has a unique grid coordinate.
* An <dfn noexport>arrayed texture</dfn> is a homogeneous array of grids of texels.
    In an arrayed texture, each texel is identified with its unique combination of array index and grid coordinate.

A texture has the following features:

: texel format
:: The data in each texel. See [[#texel-formats]].
:  dimensionality
:: The number of dimensions in the grid coordinates, and how the coordinates are interpreted.
    The number of dimensions is 1, 2, or 3.
    Most textures use cartesian coordinates.
    Cube textures have six square faces, and are sampled with
    a three dimensional coordinate interpreted as a direction vector from the origin toward
    the cube centered on the origin.
: size
:: The extent of grid coordinates along each dimension.
: mip level count
:: The mip level count is at least 1 for sampled textures, and equal to 1 for storage textures.<br>
    <dfn>Mip level</dfn> 0 contains a full size version of the texture.
    Each successive mip level contains a filtered version of the previous mip level
    at half the size (within rounding) of the previous mip level.<br>
    When sampling a texture, an explicit or implicitly-computed level-of-detail is used
    to select the mip levels from which to read texel data.  These are then combined via
    filtering to produce the sampled value.
: arrayed
:: whether the texture is arrayed.
: <dfn noexport>array size</dfn>
:: the number of homogeneous grids, if the texture is arrayed

A texture's representation is typically optimized for rendering operations.
To achieve this, many details are hidden from the programmer, including data layouts, data types, and
internal operations that cannot be expressed directly in the shader language.

As a consequence, a shader does not have direct access to the texel memory within a texture variable.
Instead, access is mediated through an opaque handle:

* Within the shader:
    * Declare a module-scope variable
        where the [=store type=] is one of the texture types described in later sections.
        The variable stores an opaque handle to the underlying texture memory, and is
        automatically placed in the [=address spaces/handle=] address space.
    * Inside a function, call one of the texture builtin functions, and provide
        the texture variable or function parameter as the builtin function's
        first parameter.
* When constructing the WebGPU pipeline, the texture variable's store type and binding
    [=shader-creation error|must=] be compatible with the corresponding bind group layout entry.

In this way, the set of supported operations for a texture type
is determined by the availability of texture builtin functions accepting that texture type
as the first parameter.

Note: The handle stored by a texture variable cannot be changed by the shader.
That is, the variable is read-only, even if the underlying texture to which it provides
access may be mutable (e.g. a write-only storage texture).

A sampler is an opaque handle that controls how [=texel|texels=] are accessed
from a sampled texture.

A WGSL sampler maps to a [[WebGPU#gpusampler|WebGPU GPUSampler]].

Texel access is controlled via several properties of the sampler:

: addressing mode
:: Controls how texture boundaries and out-of-bounds
    coordinates are resolved.
    The addressing mode for each texture dimension can be set independently.
    See [[WebGPU#enumdef-gpuaddressmode|WebGPU GPUAddressMode]].
: filter mode
:: Controls which texels are accessed to produce the final result.
    Filtering can either use the nearest texel or interpolate between multiple
    texels.
    Multiple filter modes can be set independently.
    See [[WebGPU#enumdef-gpufiltermode|WebGPU GPUFilterMode]].
: LOD clamp
:: Controls the min and max levels of details that are accessed.
: comparison
:: Controls the type of comparison done for [=syntax/sampler_comparison|comparison sampler=].
    See [[WebGPU#enumdef-gpucomparefunction|WebGPU GPUCompareFunction]].
: max anisotropy
:: Controls the maximum anisotropy value used by the sampler.

Samplers cannot be created in WGSL programs and their state (e.g. the
properties listed above) are immutable within a shader and can only be set by
the WebGPU API.

It is a [=pipeline-creation error=] if a filtering sampler (i.e. any sampler
using interpolative filtering) is used with texture that has a non-filterable
format.

Note: The handle stored by a sampler variable cannot be changed by the shader.

### Texel Formats ### {#texel-formats}

In WGSL, certain texture types are parameterized by texel format.

A <dfn noexport>texel format</dfn> is characterized by:

: <dfn noexport>channels</dfn>
:: Each channel contains a scalar.
    A texel format has up to four channels: `r`, `g`, `b`, and `a`,
    normally corresponding to the concepts of red, green, blue, and alpha channels.
: <dfn noexport>channel format</dfn>
:: The number of bits in the channel, and how those bits are interpreted.

Each texel format in WGSL corresponds to a [[WebGPU#enumdef-gputextureformat|WebGPU GPUTextureFormat]]
with the same name.

Only certain texel formats are used in WGSL source code.
The channel formats used to define those texel formats are listed in the
<dfn dfn>Channel Formats</dfn> table.
The last column specifies the conversion from the stored channel bits to the value used in the shader.
This is also known as the <dfn noexport>channel transfer function</dfn>, or CTF.

<table class='data'>
  <caption>Channel Formats</caption>
  <thead>
    <tr><th>Channel format
        <th>Number of stored bits
        <th>Interpretation of stored bits
        <th>Shader type<td style="width:25%">Shader value
(Channel Transfer Function)
  </thead>
  <tr><td>8unorm<td>8<td>unsigned integer |v| &isinv; {0,...,255}<td>f32<td> |v| &div; 255
  <tr><td>8snorm<td>8<td>signed integer |v| &isinv; {-128,...,127}<td>f32<td> max(-1, |v| &div; 127)
  <tr><td>8uint<td>8<td>unsigned integer |v| &isinv; {0,...,255}<td>u32<td> |v|
  <tr><td>8sint<td>8<td>signed integer |v| &isinv; {-128,...,127}<td>i32<td> |v|
  <tr><td>16uint<td>16<td>unsigned integer |v| &isinv; {0,...,65535}<td>u32<td> |v|
  <tr><td>16sint<td>16<td>signed integer |v| &isinv; {-32768,...,32767}<td>i32<td> |v|
  <tr><td>16float<td>16<td>[[!IEEE-754|IEEE-754]] binary16 16-bit floating point value |v|, with 1 sign bit, 5 exponent bits, 10 mantissa bits<td>f32<td>|v|
  <tr><td>32uint<td>32<td>32-bit unsigned integer value |v|<td>u32<td>|v|
  <tr><td>32sint<td>32<td>32-bit signed integer value |v|<td>i32<td>|v|
  <tr><td>32float<td>32<td>[[!IEEE-754|IEEE-754]] binary32 32-bit floating point value |v|<td>f32<td>|v|
</table>

The texel formats listed in the
<dfn lt="storage-texel-formats">Texel Formats for Storage Textures</dfn> table
correspond to the [[WebGPU#plain-color-formats|WebGPU plain color formats]]
which support the [[WebGPU#dom-gputextureusage-storage|WebGPU STORAGE]] usage.
These texel formats are used to parameterize the storage texture types defined
in [[#texture-storage]].

When the texel format does not have all four channels, then:

* When reading the texel:
    * If the texel format has no green channel, then the second component of the shader value is 0.
    * If the texel format has no blue channel, then the third component of the shader value is 0.
    * If the texel format has no alpha channel, then the fourth component of the shader value is 1.
* When writing the texel, shader value components for missing channels are ignored.

The last column in the table below uses the format-specific
[=channel transfer function=] from the [=channel formats=] table.

<table class='data'>
  <caption>Texel Formats for Storage Textures</caption>
  <thead>
    <tr><th>Texel format
        <th>Channel format
        <th>Channels in memory order
        <th style="width:50%">Corresponding shader value
  </thead>
  <tr><td>rgba8unorm<td>8unorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8snorm<td>8snorm<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8uint<td>8uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba8sint<td>8sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16uint<td>16uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16sint<td>16sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba16float<td>16float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>r32uint<td>32uint<td>r<td>vec4&lt;u32&gt;(CTF(r), 0u, 0u, 1u)
  <tr><td>r32sint<td>32sint<td>r<td>vec4&lt;i32&gt;(CTF(r), 0, 0, 1)
  <tr><td>r32float<td>32float<td>r<td>vec4&lt;f32&gt;(CTF(r), 0.0, 0.0, 1.0)
  <tr><td>rg32uint<td>32uint<td>r, g<td>vec4&lt;u32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rg32sint<td>32sint<td>r, g<td>vec4&lt;i32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rg32float<td>32float<td>r, g<td>vec4&lt;f32&gt;(CTF(r), CTF(g), 0.0, 1.0)
  <tr><td>rgba32uint<td>32uint<td>r, g, b, a<td>vec4&lt;u32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba32sint<td>32sint<td>r, g, b, a<td>vec4&lt;i32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
  <tr><td>rgba32float<td>32float<td>r, g, b, a<td>vec4&lt;f32&gt;(CTF(r), CTF(g), CTF(b), CTF(a))
</table>

### Sampled Texture Types ### {#sampled-texture-type}

<pre class='def'>
`texture_1d<type>`
`texture_2d<type>`
`texture_2d_array<type>`
`texture_3d<type>`
`texture_cube<type>`
`texture_cube_array<type>`
</pre>
* type [=shader-creation error|must=] be `f32`, `i32` or `u32`
* The parameterized type for the images is the type after conversion from sampling.
    E.g. you can have an image with texels with 8bit unorm components, but when you sample
    them you get a 32-bit float result (or vec-of-f32).

### Multisampled Texture Types ### {#multisampled-texture-type}

<pre class='def'>
`texture_multisampled_2d<type>`
</pre>
* type [=shader-creation error|must=] be `f32`, `i32` or `u32`

### External Sampled Texture Types ### {#external-texture-type}

<pre class='def'>
`texture_external`
</pre>

`texture_external` is an opaque 2d float-sampled texture type similar to `texture_2d<f32>`
but potentially with a different representation.
It can be read using [[#textureload|textureLoad]] or [[#texturesamplelevel|textureSampleLevel]] built-in functions,
which handle these different representations opaquely.

See [[WebGPU#GPUExternalTexture]].

### Storage Texture Types ### {#texture-storage}

A <dfn noexport>storage texture</dfn> supports accessing a single texel without the use of a sampler.

* A <dfn noexport>write-only storage texture</dfn>
     supports writing a single texel, with automatic conversion of the shader value to a
     stored texel value.

A storage texture type [=shader-creation error|must=] be parameterized by one of the
[=storage-texel-format|texel formats for storage textures=].
The texel format determines the conversion function as specified in [[#texel-formats]].

For a write-only storage texture the *inverse* of the conversion function is used to convert the shader value to
the stored texel.

See [[#texture-builtin-functions]].

TODO(dneto): Move description of the conversion to the builtin function that actually does the reading.

<pre class='def'>
`texture_storage_1d<texel_format,access>`
`texture_storage_2d<texel_format,access>`
`texture_storage_2d_array<texel_format,access>`
`texture_storage_3d<texel_format,access>`
</pre>

* `texel_format` [=shader-creation error|must=] be one of the texel types specified in [=storage-texel-formats=]
* `access` [=shader-creation error|must=] be [=access/write=].

### Depth Texture Types ### {#texture-depth}
<pre class='def'>
`texture_depth_2d`
`texture_depth_2d_array`
`texture_depth_cube`
`texture_depth_cube_array`
`texture_depth_multisampled_2d`
</pre>

### Sampler Type ### {#sampler-type}

A <dfn>sampler</dfn> mediates access to a sampled texture or a depth texture, by performing a combination of:
* coordinate transformation.
* optionally modifying mip-level selection.
* for a sampled texture, optionally filtering retrieved texel values.
* for a depth texture, determining the comparison function applied to the retrieved texel.

<table class='data'>
  <thead>
    <tr><th>Type<th>Description
  </thead>
  <tr algorithm="sampler type">
    <td>sampler
    <td>Sampler. Mediates access to a sampled texture.</td>
  <tr algorithm="comparison sampler type">
    <td>sampler_comparison
    <td>Comparison sampler.
        Mediates access to a depth texture.</td>
</table>

Samplers are parameterized when created in the WebGPU API.
They cannot be modified by a WGSL program.

Samplers can only be used by the [[#texture-builtin-functions|texture builtin functions]].

<pre class='def'>
sampler
sampler_comparison
</pre>

### Texture Types Grammar ### {#texture-types-grammar}

<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_sampler_types</dfn> :

    | [=syntax/sampler_type=]

    | [=syntax/depth_texture_type=]

    | [=syntax/sampled_texture_type=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/multisampled_texture_type=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/storage_texture_type=] [=syntax/less_than=] [=syntax/texel_format=] [=syntax/comma=] [=syntax/access_mode=] [=syntax/greater_than=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampler_type</dfn> :

    | [=syntax/sampler=]

    | [=syntax/sampler_comparison=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampled_texture_type</dfn> :

    | [=syntax/texture_1d=]

    | [=syntax/texture_2d=]

    | [=syntax/texture_2d_array=]

    | [=syntax/texture_3d=]

    | [=syntax/texture_cube=]

    | [=syntax/texture_cube_array=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>multisampled_texture_type</dfn> :

    | [=syntax/texture_multisampled_2d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>storage_texture_type</dfn> :

    | [=syntax/texture_storage_1d=]

    | [=syntax/texture_storage_2d=]

    | [=syntax/texture_storage_2d_array=]

    | [=syntax/texture_storage_3d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>depth_texture_type</dfn> :

    | [=syntax/texture_depth_2d=]

    | [=syntax/texture_depth_2d_array=]

    | [=syntax/texture_depth_cube=]

    | [=syntax/texture_depth_cube_array=]

    | [=syntax/texture_depth_multisampled_2d=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texel_format</dfn> :

    | `'rgba8unorm'`

    | `'rgba8snorm'`

    | `'rgba8uint'`

    | `'rgba8sint'`

    | `'rgba16uint'`

    | `'rgba16sint'`

    | `'rgba16float'`

    | `'r32uint'`

    | `'r32sint'`

    | `'r32float'`

    | `'rg32uint'`

    | `'rg32sint'`

    | `'rg32float'`

    | `'rgba32uint'`

    | `'rgba32sint'`

    | `'rgba32float'`
</div>

## Type Aliases ## {#type-aliases}

A <dfn noexport>type alias</dfn> declares a new name for an existing type.
The declaration [=shader-creation error|must=] appear at [=module scope=], and its [=scope=] is the entire program.

<div class='syntax' noexport='true'>
  <dfn for=syntax>type_alias_decl</dfn> :

    | [=syntax/type=] [=syntax/ident=] [=syntax/equal=] [=syntax/type_decl=]
</div>

<div class='example wgsl global-scope' heading='Type Alias'>
  <xmp highlight='rust'>
    type Arr = array<i32, 5>;

    type RTArr = array<vec4<f32>>;

    type single = f32;     // Declare an alias for f32
    const pi_approx: single = 3.1415;
    fn two_pi() -> single {
      return single(2) * pi_approx;
    }
  </xmp>
</div>

## Type Declaration Grammar ## {#type-declarations}

<div class='syntax' noexport='true'>
  <dfn for=syntax>type_decl</dfn> :

    | [=syntax/ident=]

    | [=syntax/type_decl_without_ident=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>type_decl_without_ident</dfn> :

    | [=syntax/bool=]

    | [=syntax/float32=]

    | [=syntax/float16=]

    | [=syntax/int32=]

    | [=syntax/uint32=]

    | [=syntax/vec_prefix=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/mat_prefix=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/pointer=] [=syntax/less_than=] [=syntax/address_space=] [=syntax/comma=] [=syntax/type_decl=] ( [=syntax/comma=] [=syntax/access_mode=] ) ? [=syntax/greater_than=]

    | [=syntax/array_type_decl=]

    | [=syntax/atomic=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=]

    | [=syntax/texture_sampler_types=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>vec_prefix</dfn> :

    | [=syntax/vec2=]

    | [=syntax/vec3=]

    | [=syntax/vec4=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat_prefix</dfn> :

    | [=syntax/mat2x2=]

    | [=syntax/mat2x3=]

    | [=syntax/mat2x4=]

    | [=syntax/mat3x2=]

    | [=syntax/mat3x3=]

    | [=syntax/mat3x4=]

    | [=syntax/mat4x2=]

    | [=syntax/mat4x3=]

    | [=syntax/mat4x4=]
</div>

When the type declaration is an [=identifier=], then the expression [=shader-creation error|must=] be in scope of a
[=declaration=] of the identifier as a type alias or structure type.

<div class='example' heading="Type Declarations">
  <xmp>
    identifier
      Allows to specify types created by the type command

    bool
    f32
    i32
    u32
    vec2<f32>
    array<f32, 4>
    array<f32>
    mat2x3<f32>
  </xmp>
</div>

<div class='example wgsl global-scope' heading='Access modes for buffers'>
  <xmp highlight='rust'>
    // Storage buffers
    @group(0) @binding(0)
    var<storage,read> buf1: Buffer;       // Can read, cannot write.
    @group(0) @binding(0)
    var<storage> buf2: Buffer;            // Can read, cannot write.
    @group(0) @binding(1)
    var<storage,read_write> buf3: Buffer; // Can both read and write.

    // Uniform buffer. Always read-only, and has more restrictive layout rules.
    struct ParamsTable {weight: f32}
    @group(0) @binding(2)
    var<uniform> params: ParamsTable;     // Can read, cannot write.
  </xmp>
</div>

# Variable and Value Declarations # {#var-and-value}

## Value Declarations ## {#value-decls}

[SHORTNAME] authors can declare names for immutable values using a <dfn noexport>value declaration</dfn> which are either:

  * a [=let declaration=], or
  * an [=override declaration=], or
  * a [=creation-time constant=].

Value declarations do not have any associated storage.
That is, there are no [=memory locations=] associated with the declaration.

### `let` Declarations ### {#let-decls}

A <dfn noexport>let declaration</dfn> specifies a name for a value.
Once the value for a let-declaration is computed, it is immutable.
When an [=identifier=] use [=resolves=] to a let-declaration, the identifier denotes that value.

When a `let` identifier is declared without an explicitly specified type,
e.g. `let foo = 4`, the type is automatically inferred from the expression to the right of the equals token (`=`).
When the type is specified, e.g `let foo: i32 = 4`, the initializer expression [=shader-creation error|must=] evaluate to that type.

`let`-declarations can only appear within a function definition.

<div class='example wgsl let declaration at function-scope' heading='let-declared constants at function scope'>
  <xmp highlight='rust'>
    // 'blockSize' denotes the i32 value 1024.
    let blockSize: i32 = 1024;

    // 'row_size' denotes the u32 value 16u.  The type is inferred.
    let row_size = 16u;
  </xmp>
</div>

### `override` Declarations ### {#override-decls}

An <dfn noexport>override declaration</dfn> specifies a name for a
[=pipeline-overridable=] constant value.
The value of a <dfn noexport>pipeline-overridable</dfn> constant is fixed at
pipeline-creation time.
The value is the one specified by the WebGPU pipeline-creation method, if
specified, and otherwise is the value of its initializer expression.
When an [=identifier=] use [=resolves=] to a override-declaration, the identifier denotes that value.
`override`-declarations [=shader-creation error|must=] meet the following restrictions:

  * The declaration [=shader-creation error|must=] only occur at [=module scope=].
  * The declaration [=shader-creation error|must=] have at least one of a declared type, an initializer
      expression, or both.
  * The declared type, if present, [=shader-creation error|must=] be a [=scalar=].
  * The initializer expression, if present, [=shader-creation error|must=]:
      * evaluate to a [=scalar=] type.
      * evaluate to the declared type if it is present.
      * be composed only [=creation-time expressions=] or expressions where all
          identifiers [=resolve=] to overridable constants, [=creation-time
          constants=], or [=creation-time functions=].
          Such an expression is called an <dfn noexport>override expression</dfn>.
  * If the declaration has the [=attribute/id=] applied, the literal operand is
      known as the <dfn noexport>pipeline constant ID</dfn>, and [=shader-creation error|must=] be an
      integer value between 0 and 65535.
  * Pipeline constant IDs [=shader-creation error|must=] be unique within the WGSL program: Two `override`-declarations
    [=shader-creation error|must not=] use the same pipeline constant ID.
  * The application can specify its own value for the constant at pipeline-creation time.
    The pipeline creation API accepts a mapping from overridable constant to a
    value of the constant's type.
    The constant is identified by a <dfn export>pipeline-overridable constant identifier string</dfn>,
    which is the base-10 representation of the [=pipeline constant ID=] if specified, and otherwise
    the declared [=name=] of the constant.
  * The <dfn export>pipeline-overridable constant has a default value</dfn> if
    its declaration has an initializer expression.
    If it doesn't, it is a [=pipeline-creation error=] if a value is not provided at pipeline-creation time.

Note: Override expressions are a superset of [=creation-time expressions=].

<div class='example wgsl global-scope' heading='Module constants, pipeline-overrideable'>
  <xmp highlight='rust'>
    @id(0)    override has_point_light: bool = true;  // Algorithmic control
    @id(1200) override specular_param: f32 = 2.3;     // Numeric control
    @id(1300) override gain: f32;                     // Must be overridden
              override width: f32 = 0.0;              // Specified at the API level using
                                                      // the name "width".
              override depth: f32;                    // Specified at the API level using
                                                      // the name "depth".
                                                      // Must be overridden.
              override height = 2 * depth;            // The default value
                                                      // (if not set at the API level),
                                                      // depends on another
                                                      // overridable constant.

  </xmp>
</div>

### Creation-time Constants ### {#creation-time-consts}

A <dfn noexport>creation-time constant</dfn> specifies a name for value that is
fixed at [=shader module creation|shader-creation time=].
Once the constant is declared, its value is immutable.
When an [=identifier=] use [=resolves=] to a creation-time constant, the
identifier denotes that value.

When a creation-time constant is declared without an explicitly specified type,
e.g. `const foo = 4`, the type is automatically inferred from the expression to
the right of the [=syntax/equals=] token.
The type of a creation-time constant must be:
* a [=constructible=] type, or
* an [=abstract numeric type=], or
* a [=vector=], or
* a [=matrix=]

When the type is specified, e.g. `const foo : i32 = 4`, the initializer
expression must evaluate to that type.

Note: Since [=AbstractInt=] and [=AbstractFloat=] cannot be spelled in
WGSL source, named values can only use them through type inference.

A creation-time constant can be declared at module-scope or function-scope.
A creation-time constant must be declared with an initializer and be composed
only of [=creation-time expressions=].

<div class='example wgsl global-scope' heading='Creation-time constants'>
  <xmp>
    const a = 4;                  // AbstractInt with a value of 4.
    const b : i32 = 4;            // i32 with a value of 4.
    const c : u32 = 4;            // u32 with a value of 4.
    const d : f32 = 4;            // f32 with a value of 4.
    const e = vec3(a, a, a);      // vec3 of AbstractInt with a value of (4, 4, 4).
    const f = 4.0;                // AbstractFloat with a vaue of 4.
    const g = mat2x2(a, f, a, f); // mat2x2 of AbstractFloat with a value of ((2, 4), (2, 4)).
  </xmp>
</div>

## `var` Declarations ## {#var-decls}

A <dfn noexport>variable</dfn> is a named reference to memory that can contain a value of a
particular [=storable=] type.

Two types are associated with a variable: its [=store type=] (the type of value
that may be placed in the referenced memory) and its [=reference type=] (the type
of the variable itself).
If a variable has store type |T|, [=address space=] |AS|, and [=access mode=] |AM|,
then its reference type is ref&lt;|AS|,|T|,|AM|&gt;.
The [=store type=] of a variable is always [=concrete=].

A <dfn noexport>variable declaration</dfn>:

* Specifies the variable‚Äôs name.
* Specifies the [=address space=], [=store type=], and [=access mode=].
    Together these comprise the variable's [=reference type=].
* Ensures the execution environment allocates memory for a value of the store type, in the specified address space,
    supporting the given access mode, for the [=lifetime=] of the variable.
* Optionally has an *initializer* expression, if the variable is in the [=address spaces/private=] or [=address spaces/function=] address spaces.
    If present, the initializer expression [=shader-creation error|must=] evaluate to the variable's store type.

When an [=identifier=] use [=resolves=] to a variable declaration,
the identifier is an expression denoting the reference [=memory view=] for the variable's memory,
and its type is the variable's [=reference type=].
See [[#var-identifier-expr]].

See [[#module-scope-variables]] and [[#function-scope-variables]] for rules about where
a variable in a particular address space can be declared,
and when the address space decoration is required, optional, or forbidden.

The access mode always has a default, and except for variables in the [=address spaces/storage=] address space,
[=shader-creation error|must not=] be written in WGSL source text. See [[#access-mode-defaults]].

The <dfn noexport>lifetime</dfn> of a variable is the period during shader
execution for which the variable exists.
The lifetime of a [=module scope=] variable is the entire execution of the shader stage.

For a [=function scope=] variable, each invocation has its own independent
version of the variable.
The lifetime of the variable is determined by its scope:
* It begins when control enters the variable's declaration.
* It includes the entire execution of any function called from within the variable's scope.
* It ends when control leaves the variable's scope, other than calling a function from
    within the variable's scope.

Two variables with overlapping lifetimes will not have [=overlap|overlapping memory=].
When a variable's lifetime ends, its memory may be used for another variable.

When a variable is created, its memory contains an initial value as follows:

* For variables in the [=address spaces/private=] or [=address spaces/function=] address spaces:
    * The [=zero value=] for the store type, if the variable declaration has no initializer.
    * Otherwise, it is the result of evaluating the initializer expression at that point in the program execution.
* For variables in the [=address spaces/workgroup=] address space:
    * When the store type is [=constructible=], the [=zero value=] for the store type.
    * If the store type is an [=atomic type=], the [=zero value=] is that of the underlying type ([=integer scalar=]).
    * Otherwise, if the store type is not constructible, the [=zero value=] is determined by recursively applying these
        rules to each component of the [=composite=] until a [=constructible=] type is encountered.
        * Note: This commonly occurs when using an array with a [=pipeline-overridable=] element count or
            a composite that contains an atomic type.
* Variables in other address spaces are [=resources=]
    set by bindings in the [=draw command=] or [=dispatch command=].

Consider the following snippet of WGSL:
<div class='example wgsl function-scope' heading='Variable initial values'>
  <xmp highlight='rust'>
    var i: i32;         // Initial value is 0.  Not recommended style.
    loop {
      var twice: i32 = 2 * i;   // Re-evaluated each iteration.
      i++;
      if i == 5 { break; }
    }
  </xmp>
</div>
The loop body will execute five times.
Variable `i` will take on values 0, 1, 2, 3, 4, 5, and variable `twice` will take on values 0, 2, 4, 6, 8.

Consider the following snippet of WGSL:
<div class='example wgsl function-scope' heading='Reading a variable multiple times'>
  <xmp highlight='rust'>
    var x: f32 = 1.0;
    let y = x * x + x + 1;
  </xmp>
</div>
Because `x` is a variable, all accesses to it turn into load and store operations.
However, it is expected that either the browser or the driver optimizes this intermediate representation
such that the redundant loads are eliminated.

## Module Scope Variables ## {#module-scope-variables}

A variable declared outside all functions is at [=module scope=].
The variable name is [=in scope=] for the entire program.

Variables at [=module scope=] are restricted as follows:

* The variable [=shader-creation error|must not=] be in the [=address spaces/function=] address space.
* A variable in the [=address spaces/private=], [=address spaces/workgroup=], [=address spaces/uniform=], or [=address spaces/storage=] address spaces:
    * [=shader-creation error|Must=] be declared with an explicit address space decoration.
    * [=shader-creation error|Must=] use a [=store type=] as described in [[#address-space]].
* If the [=store type=] is a texture type or a sampler type, then the variable declaration [=shader-creation error|must not=]
    have an address space decoration.  The address space will always be [=address spaces/handle=].

A variable in the [=address spaces/uniform=] address space is a <dfn noexport>uniform buffer</dfn> variable.
Its [=store type=] [=shader-creation error|must=] be a [=host-shareable=] [=constructible=] type,
and [=shader-creation error|must=] satisfy [address space layout constraints](#address-space-layout-constraints).

A variable in the [=address spaces/storage=] address space is a <dfn noexport>storage buffer</dfn> variable.
Its [=store type=] [=shader-creation error|must=] be a [=host-shareable=] type
and [=shader-creation error|must=] satisfy [address space layout constraints](#address-space-layout-constraints).
The variable may be declared with a [=access/read=] or [=access/read_write=] access mode; the default is [=access/read=].

As described in [[#resource-interface]],
uniform buffers, storage buffers, textures, and samplers form the
[=resource interface of a shader=].
Such variables are declared with [=attribute/group=] and [=attribute/binding=] decorations.


WGSL defines the following attributes that can be applied to global variables:
 * [=attribute/binding=]
 * [=attribute/group=]

<div class='example wgsl global-scope' heading="Module scope variable declarations">
  <xmp highlight='rust'>
    var<private> decibels: f32;
    var<workgroup> worklist: array<i32,10>;

    struct Params {
      specular: f32,
      count: i32
    }
    @group(0) @binding(2)
    var<uniform> param: Params;    // A uniform buffer

    // A storage buffer, for reading and writing
    @group(0) @binding(0)
    var<storage,read_write> pbuf: array<vec2<f32>>;

    // Textures and samplers are always in "handle" space.
    @group(0) @binding(1)
    var filter_params: sampler;
  </xmp>
</div>

## Module Constants ## {#module-constants}

A [[#value-decls|value declaration]] appearing outside all functions declares a
[=module scope|module-scope=] constant.
Module-scope constants must be either [=override declarations=] or
[=creation-time constants=].
The name is [=in scope=] for the entire program.

<div class='example wgsl global-scope' heading='Module constants'>
  <xmp highlight='rust'>
    // The golden ratio.
    const golden: f32 = 1.61803398875;

    // The second unit vector for three dimensions, with inferred type.
    const e2 = vec3(0,1,0);
  </xmp>
</div>

When a variable or feature is used within control flow that depends on the
value of a constant, then that variable or feature is considered to be used by the
program.
This is true regardless of the value of the constant, whether that value
is the one from the constant's declaration or from a pipeline override.

## Function Scope Variables and Constants ## {#function-scope-variables}

A variable or constant declared in a declaration statement in a function body
is in <dfn noexport>function scope</dfn>.
The name is available for use immediately after its declaration statement, and
until the end of the brace-delimited list of statements immediately enclosing
the declaration.

A function-scope [=let declaration|let-declared=] constant [=shader-creation error|must=] be of
[=constructible=] type, or of [=pointer type=].

For a variable declared in function scope:
* The variable is always in the [=address spaces/function=] address space.
* The address space decoration is optional.
* The [=store type=] [=shader-creation error|must=] be a [=constructible=] type.
* When an initializer is specified, the store type may be omitted from the declaration.
    In this case the store type is the type of the result of evaluating the initializer.

<div class='example wgsl global-scope' heading="Function scope variables and constants">
  <xmp highlight='rust'>
    fn f() {
       var<function> count: u32;  // A variable in function address space.
       var delta: i32;            // Another variable in the function address space.
       var sum: f32 = 0.0;        // A function address space variable with initializer.
       var pi = 3.14159;          // Infer the f32 store type from the initializer.
       let unit: i32 = 1;         // Let-declared constants don't use an address space.
    }
  </xmp>
</div>

A variable or constant declared in the first clause of a `for` statement is available for use in the second
and third clauses and in the body of the `for` statement.

An instance of a function scope variable is a [=dynamic context=].
Each variable that is [=in scope=] for some invocation has an overlapping
[=lifetime=] and, therefore, has non-overlapping memory.
Variables with non-overlapping lifetimes may reuse the memory of previous
variables; however, new instances of the same variable are not guaranteed to
use the same memory.

## Variable and Value Declaration Grammar Summary ## {#var-and-value-decl-grammar}

<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_statement</dfn> :

    | [=syntax/variable_decl=]

    | [=syntax/variable_decl=] [=syntax/equal=] [=syntax/expression=]

    | [=syntax/let=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) [=syntax/equal=] [=syntax/expression=]

    | [=syntax/const=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) [=syntax/equal=] [=syntax/expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_decl</dfn> :

    | [=syntax/var=] [=syntax/variable_qualifier=] ? ( [=syntax/ident=] | [=syntax/variable_ident_decl=] )
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_ident_decl</dfn> :

    | [=syntax/ident=] [=syntax/colon=] [=syntax/type_decl=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>variable_qualifier</dfn> :

    | [=syntax/less_than=] [=syntax/address_space=] ( [=syntax/comma=] [=syntax/access_mode=] ) ? [=syntax/greater_than=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_variable_decl</dfn> :

    | [=syntax/attribute=] * [=syntax/variable_decl=] ( [=syntax/equal=] [=syntax/expression=] ) ?
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_constant_decl</dfn> :

    | [=syntax/const=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) [=syntax/equal=] [=syntax/expression=]

    | [=syntax/attribute=] * [=syntax/override=] ( [=syntax/ident=] | [=syntax/variable_ident_decl=] ) ( [=syntax/equal=] [=syntax/expression=] ) ?
</div>

# Expressions # {#expressions}

Expressions specify how values are computed.

## Creation-time Expressions ## {#creation-time-expr}

Expressions that are evaluated at [=shader module creation|shader-creation
time=] are called <dfn noexport>creation-time expressions</dfn>.
In order for an expression to be evaluated at shader-creation time all
[=identifiers=] used by the expression must [=resolve=] to [=creation-time
constants=] or [=creation-time functions=].

The types of creation-time expressions can resolve to types that include
[=abstract numeric types=].

Example:  `(42)` is analyzed as follows:
* The term `42` is the [=AbstractInt=] value 42.
* Surrounding that term with parentheses produces a new expression `(42)` that is
    of type [=AbstractInt=] with value 42.

Example:  `-5` is analyzed as follows:
* The term `5` is the [=AbstractInt=] value 5.
* Preceding that term with '`-`' produces a new expression `-5` that is
    of type [=AbstractInt=] with value -5.

Example:  `-2147483648` is analyzed as follows:
* The term `2147483648` is the [=AbstractInt=] value 2147483648.
    Note that this value does **not** fit in a 32-bit signed integer.
* Preceding that term with '`-`' produces a new expression `-2147483648` that is
    of type [=AbstractInt=] with value -2147483648.

Example:  `const minint = -2147483648;` is analyzed as follows:
* As above, `-2147483648` evaluates to a [=AbstractInt=] value -2147483648.
* A [=creation-time constant=] allows the initializer to be an [=abstract numeric type=].
* The result is that `minint` is declared to be the [=AbstractInt=] value -2147483648.

Example:  `let minint = -2147483648;` is analyzed as follows:
* As above, `-2147483648` evaluates to a [=AbstractInt=] value -2147483648.
* A [=let declaration=] requires the initializer to be [=constructible=].
* The let declaration does not have an explicit type, so [=overload resolution=] is used.
    The overload candidates that apply use [=feasible automatic conversions=] from [=AbstractInt=] to either [=i32=], [=u32=], or [=f32=].
    The one of lowest rank is to [=i32=], and so
    [=AbstractInt=] -2147483648 value is converted to the [=i32=] value -2147483648.
* The result is that `minint` is declared to be the i32 value -2147483648.

## Literal Value Expressions ## {#literal-expressions}

<table class='data'>
  <caption>Scalar literal type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td>
      <td>`true`: bool
      <td>`true` boolean value.
  <tr><td>
      <td>`false`: bool
      <td>`false` boolean value.
  <tr><td>|e| is an [=integer literal=] with no suffix
      <td>|e|: AbstractInt
      <td>Abstract integer literal value.
  <tr><td>|e| is a [=floating point literal=] with no suffix
      <td>|e|: AbstractFloat
      <td>Abstract float literal value.
  <tr><td>|e| is an [=integer literal=] with `i` suffix
      <td>|e|: i32
      <td>32-bit signed integer literal value.
  <tr><td>|e| is an [=integer literal=] with `u` suffix
      <td>|e|: u32
      <td>32-bit unsigned integer literal value.
  <tr><td>|e| is an [=floating point literal=] with `f` suffix
      <td>|e|: f32
      <td>32-bit floating point literal value.
  <tr><td>|e| is an [=floating point literal=] with `h` suffix
      <td>|e|: f16
      <td>16-bit floating point literal value.
</table>

## Parenthesized Expressions ## {#parenthesized-expressions}

<table class='data'>
  <caption>Parenthesized expression type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="parenthesized expression">
      <td>|e| : |T|
      <td>`(` |e| `)` : |T|
      <td>Evaluates to |e|.<br>
          Use parentheses to isolate an expression from the surrounding text.
</table>

## Type Constructor Expressions ## {#type-constructor-expr}

A type constructor expression explicitly creates a value of a given [=constructible=] type.

There are three kinds of constructor expressions:
* [[#construction-from-components]]
* [[#zero-value-expr]]
* [[#conversion-expr]]

### Construction From Components ### {#construction-from-components}

The expressions defined in this section create a [=constructible=] value by:
* Copying an existing value of the same type (i.e. the identity function), or
* Creating a composite value from an explicit list of components.

The scalar forms given here are redundant, but provide symmetry with scalar [=conversion expressions=],
and can be used to enhance readability.

The vector and matrix forms construct vector and matrix values from various combinations of components and subvectors
with matching component types.
There are [=overloads=] for constructing vectors and matrices that specify the dimensions of the target type without having to
specify the component type; the component type is inferred from the constructor arguments.

<table class='data'>
  <caption>Scalar constructor type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td>*e*: bool<td>`bool(e)`: bool<td>Identity.
  <tr><td>*e*: i32<td>`i32(e)`: i32<td>Identity.
  <tr><td>*e*: u32<td>`u32(e)`: u32<td>Identity.
  <tr><td>*e*: f32<td>`f32(e)`: f32<td>Identity.
  <tr><td>*e*: f16<td>`f16(e)`: f16<td>Identity.
</table>

<table class='data'>
  <caption>Vector constructor type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="construct a vector from copies of a single scalar">
    <td rowspan=2>|e|: |T|
    <td>`vec`|N|`<`|T|`>(`|e|`)`: vec|N|&lt;|T|&gt;
    <td rowspan=2>Evaluates |e| once. Results in the |N|-component vector where each component has the value of |e|.
  <tr>
    <td>`vec`|N|`(`|e|`)`: vec|N|&lt;|T|&gt;
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: *T*
    <td>`vec2<T>(e1,e2)`: vec2<*T*>
    <td rowspan=2>
  <tr>
    <td>`vec2(e1,e2)`: vec2<*T*>
  <tr>
    <td rowspan=2>*e*: vec2&lt;T&gt;
    <td>`vec2<T>(e)`: vec2<*T*>
    <td rowspan=2>Identity. The result is |e|.
  <tr>
    <td>`vec2(e)`: vec2<*T*>
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: *T*
    <td>`vec3<T>(e1,e2,e3)`: vec3<*T*>
    <td rowspan=2>
  <tr>
    <td>`vec3(e1,e2,e3)`: vec3<*T*>
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: vec2<*T*>
    <td>`vec3<T>(e1,e2)`: vec3<*T*><br>
        `vec3<T>(e2,e1)`: vec3<*T*>
    <td rowspan=2>
  <tr>
    <td>`vec3(e1,e2)`: vec3<*T*><br>
        `vec3(e2,e1)`: vec3<*T*>
  <tr>
    <td rowspan=2>*e*: vec3&lt;T&gt;
    <td>`vec3<T>(e)`: vec3<*T*>
    <td rowspan=2>Identity. The result is |e|.
  <tr>
    <td>`vec3(e)`: vec3<*T*>
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: *T*<br>
        *e4*: *T*
    <td class=nowrap>`vec4<T>(e1,e2,e3,e4)`: vec4<*T*>
    <td rowspan=2>
  <tr>
    <td class=nowrap>`vec4(e1,e2,e3,e4)`: vec4<*T*>
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: *T*<br>
        *e3*: vec2<*T*>
    <td class=nowrap>`vec4<T>(e1,e2,e3)`: vec4<*T*><br>
        `vec4<T>(e1,e3,e2)`: vec4<*T*><br>
        `vec4<T>(e3,e1,e2)`: vec4<*T*>
    <td rowspan=2>
  <tr>
    <td class=nowrap>`vec4(e1,e2,e3)`: vec4<*T*><br>
        `vec4(e1,e3,e2)`: vec4<*T*><br>
        `vec4(e3,e1,e2)`: vec4<*T*>
  <tr>
    <td rowspan=2>*e1*: vec2<*T*><br>
        *e2*: vec2<*T*>
    <td class=nowrap>`vec4<T>(e1,e2)`: vec4<*T*>
    <td rowspan=2>
  <tr>
    <td class=nowrap>`vec4(e1,e2)`: vec4<*T*>
  <tr>
    <td rowspan=2>*e1*: *T*<br>
        *e2*: vec3<*T*>
    <td class=nowrap>`vec4<T>(e1,e2)`: vec4<*T*><br>
        `vec4<T>(e2,e1)`: vec4<*T*>
    <td rowspan=2>
  <tr>
    <td>`vec4(e1,e2)`: vec4<*T*><br>
        `vec4(e2,e1)`: vec4<*T*>
  <tr>
    <td rowspan=2>*e*: vec4&lt;T&gt;
    <td class=nowrap>`vec4<T>(e)`: vec4<*T*>
    <td rowspan=2>Identity. The result is |e|.
  <tr>
    <td class=nowrap>`vec4(e)`: vec4<*T*>
</table>

<table class='data'>
  <caption>Matrix constructor type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr>
    <td>|e|: mat2x2&lt;|T|&gt;
    <td>`mat2x2<`|T|`>(`|e|`)`: mat2x2&lt;|T|&gt;<br>
        `mat2x2(`|e|`)`: mat2x2&lt;|T|&gt;<br>
    <td rowspan=9>Identity type conversion. The result is |e|.
  <tr>
    <td>|e|: mat2x3&lt;|T|&gt;
    <td>`mat2x3<`|T|`>(`|e|`)`: mat2x3&lt;|T|&gt;<br>
        `mat2x3(`|e|`)`: mat2x3&lt;|T|&gt;
  <tr>
    <td>|e|: mat2x4&lt;|T|&gt;
    <td>`mat2x4<`|T|`>(`|e|`)`: mat2x4&lt;|T|&gt;<br>
        `mat2x4(`|e|`)`: mat2x4&lt;|T|&gt;
  <tr>
    <td>|e|: mat3x2&lt;|T|&gt;
    <td>`mat3x2<`|T|`>(`|e|`)`: mat3x2&lt;|T|&gt;<br>
        `mat3x2(`|e|`)`: mat3x2&lt;|T|&gt;
  <tr>
    <td>|e|: mat3x3&lt;|T|&gt;
    <td>`mat3x3<`|T|`>(`|e|`)`: mat3x3&lt;|T|&gt;<br>
        `mat3x3(`|e|`)`: mat3x3&lt;|T|&gt;
  <tr>
    <td>|e|: mat3x4&lt;|T|&gt;
    <td>`mat3x4<`|T|`>(`|e|`)`: mat3x4&lt;|T|&gt;<br>
        `mat3x4(`|e|`)`: mat3x4&lt;|T|&gt;
  <tr>
    <td>|e|: mat4x2&lt;|T|&gt;
    <td>`mat4x2<`|T|`>(`|e|`)`: mat4x2&lt;|T|&gt;<br>
        `mat4x2(`|e|`)`: mat4x2&lt;|T|&gt;
  <tr>
    <td>|e|: mat4x3&lt;|T|&gt;
    <td>`mat4x3<`|T|`>(`|e|`)`: mat4x3&lt;|T|&gt;<br>
        `mat4x3(`|e|`)`: mat4x3&lt;|T|&gt;
  <tr>
    <td>|e|: mat4x4&lt;|T|&gt;
    <td>`mat4x4<`|T|`>(`|e|`)`: mat4x4&lt;|T|&gt;<br>
        `mat4x4(`|e|`)`: mat4x4&lt;|T|&gt;
  <tr>
    <td rowspan=2>|e1|: |T|<br>
        ...<br>
        |eN|: |T|<br>
    <td>`mat2x2<T>(e1,e2,e3,e4)`: mat2x2&lt;|T|&gt;<br>
        `mat3x2<T>(e1,...,e6)`: mat3x2&lt;|T|&gt;<br>
        `mat2x3<T>(e1,...,e6)`: mat2x3&lt;|T|&gt;<br>
        `mat4x2<T>(e1,...,e8)`: mat4x2&lt;|T|&gt;<br>
        `mat2x4<T>(e1,...,e8)`: mat2x4&lt;|T|&gt;<br>
        `mat3x3<T>(e1,...,e9)`: mat3x3&lt;|T|&gt;<br>
        `mat4x3<T>(e1,...,e12)`: mat4x3&lt;|T|&gt;<br>
        `mat3x4<T>(e1,...,e12)`: mat3x4&lt;|T|&gt;<br>
        `mat4x4<T>(e1,...,e16)`: mat4x4&lt;|T|&gt;
    <td rowspan=2>Column-major construction by elements.<br>
  <tr>
    <td>`mat2x2(e1,e2,e3,e4)`: mat2x2&lt;|T|&gt;<br>
        `mat3x2(e1,...,e6)`: mat3x2&lt;|T|&gt;<br>
        `mat2x3(e1,...,e6)`: mat2x3&lt;|T|&gt;<br>
        `mat4x2(e1,...,e8)`: mat4x2&lt;|T|&gt;<br>
        `mat2x4(e1,...,e8)`: mat2x4&lt;|T|&gt;<br>
        `mat3x3(e1,...,e9)`: mat3x3&lt;|T|&gt;<br>
        `mat4x3(e1,...,e12)`: mat4x3&lt;|T|&gt;<br>
        `mat3x4(e1,...,e12)`: mat3x4&lt;|T|&gt;<br>
        `mat4x4(e1,...,e16)`: mat4x4&lt;|T|&gt;
  <tr>
    <td rowspan=2>*e1*: vec2&lt;|T|&gt;<br>
        *e2*: vec2&lt;|T|&gt;<br>
        *e3*: vec2&lt;|T|&gt;<br>
        *e4*: vec2&lt;|T|&gt;<br>
    <td>`mat2x2<T>(e1,e2)`: mat2x2&lt;|T|&gt;<br>
        `mat3x2<T>(e1,e2,e3)`: mat3x2&lt;|T|&gt;<br>
        `mat4x2<T>(e1,e2,e3,e4)`: mat4x2&lt;|T|&gt;
    <td rowspan=2>Column by column construction.<br>
  <tr>
    <td>`mat2x2(e1,e2)`: mat2x2&lt;|T|&gt;<br>
        `mat3x2(e1,e2,e3)`: mat3x2&lt;|T|&gt;<br>
        `mat4x2(e1,e2,e3,e4)`: mat4x2&lt;|T|&gt;
  <tr>
    <td rowspan=2>*e1*: vec3&lt;|T|&gt;<br>
        *e2*: vec3&lt;|T|&gt;<br>
        *e3*: vec3&lt;|T|&gt;<br>
        *e4*: vec3&lt;|T|&gt;<br>
    <td>`mat2x3<T>(e1,e2)`: mat2x3&lt;|T|&gt;<br>
        `mat3x3<T>(e1,e2,e3)`: mat3x3&lt;|T|&gt;<br>
        `mat4x3<T>(e1,e2,e3,e4)`: mat4x3&lt;|T|&gt;
    <td rowspan=2>Column by column construction.<br>
  <tr>
    <td>`mat2x3(e1,e2)`: mat2x3&lt;|T|&gt;<br>
        `mat3x3(e1,e2,e3)`: mat3x3&lt;|T|&gt;<br>
        `mat4x3(e1,e2,e3,e4)`: mat4x3&lt;|T|&gt;
  <tr>
    <td rowspan=2>*e1*: vec4&lt;|T|&gt;<br>
        *e2*: vec4&lt;|T|&gt;<br>
        *e3*: vec4&lt;|T|&gt;<br>
        *e4*: vec4&lt;|T|&gt;<br>
    <td>`mat2x4<T>(e1,e2)`: mat2x4&lt;|T|&gt;<br>
        `mat3x4<T>(e1,e2,e3)`: mat3x4&lt;|T|&gt;<br>
        `mat4x4<T>(e1,e2,e3,e4)`: mat4x4&lt;|T|&gt;
    <td rowspan=2>Column by column construction.<br>
  <tr>
    <td>`mat2x4(e1,e2)`: mat2x4&lt;|T|&gt;<br>
        `mat3x4(e1,e2,e3)`: mat3x4&lt;|T|&gt;<br>
        `mat4x4(e1,e2,e3,e4)`: mat4x4&lt;|T|&gt;
</table>

<table class='data'>
  <caption>Array constructor type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="array value construction">
    <td>|e1|: |T|<br>
        ...<br>
        |eN|: |T|,<br>
        |T| is [=constructible=]<br>
    <td class="nowrap">`array<`|T|,|N|`>(`|e1|,...,|eN|`)` : array&lt;|T|,|N|&gt;
    <td>Construction of an array from elements.

        Note: array&lt;|T|,|N|&gt; is [=constructible=] because its [=element count=]
        is equal to the number of arguments to the constructor, and hence
        fully determined at [=shader module creation|shader-creation=] time.
</table>

<table class='data'>
  <caption>Structure constructor type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="structure value construction">
    <td>|e1|: |T1|<br>
        ...<br>
        |eN|: |TN|,<br>
        |S| is a [=constructible=] structure type with members having types |T1| ... |TN|.<br>
        The expression is in the scope of declaration of |S|.
    <td class="nowrap">|S|`(`|e1|,...,|eN|`)`: |S|
    <td>Construction of a structure from members.
</table>

### Zero Value Expressions ### {#zero-value-expr}

Each [=constructible=] *T* has a unique <dfn noexport>zero value</dfn>
written in WGSL as the type followed by an empty pair of parentheses: *T* `()`.

The zero values are as follows:

* `bool()` is `false`
* `i32()` is 0
* `u32()` is 0
* `f32()` is 0.0
* `f16()` is 0.0
* The zero value for an *N*-component vector of type *T* is the *N*-component vector of the zero value for *T*.
* The zero value for an *C*-column *R*-row matrix of type *T* is the matrix of those dimensions filled with the zero value for *T*.
* The zero value for a [=constructible=] *N*-element array with element type *E* is an array of *N* elements of the zero value for *E*.
* The zero value for a [=constructible=] structure type *S* is the structure value *S* with zero-valued members.

Note: WGSL does not have zero expression for [=atomic types=],
[=runtime-sized=] arrays, or other types that are not [=constructible=].

<table class='data'>
  <caption>Scalar zero value type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr><td><td>`bool()`: bool<td>false<br>Zero value
  <tr><td><td>`i32()`: i32<td>0<br>Zero value
  <tr><td><td>`u32()`: u32<td>0u<br>Zero value
  <tr><td><td>`f32()`: f32<td>0.0<br>Zero value
  <tr><td><td>`f16()`: f16<td>0.0<br>Zero value
</table>

<table class='data'>
  <caption>Vector zero type rules, where |T| is a scalar type</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr>
    <td>
    <td>`vec2<T>()`: vec2<|T|>
    <td>Zero value
  <tr>
    <td>
    <td>`vec3<T>()`: vec3<|T|>
    <td>Zero value
  <tr>
    <td>
    <td>`vec4<T>()`: vec4<|T|>
    <td>Zero value
</table>


<div class='example' heading="Zero-valued vectors">
  <xmp highlight='rust'>
    vec2<f32>()                 // The zero-valued vector of two f32 components.
    vec2<f32>(0.0, 0.0)         // The same value, written explicitly.

    vec3<i32>()                 // The zero-valued vector of three i32 components.
    vec3<i32>(0, 0, 0)          // The same value, written explicitly.
  </xmp>
</div>

<table class='data'>
  <caption>Matrix zero type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr>
    <td>|T| is f32 or f16
    <td>`mat2x2<T>()`: mat2x2&lt;|T|&gt;<br>
        `mat3x2<T>()`: mat3x2&lt;|T|&gt;<br>
        `mat4x2<T>()`: mat4x2&lt;|T|&gt;
    <td>Zero value
  <tr>
    <td>
    <td>`mat2x3<T>()`: mat2x3&lt;|T|&gt;<br>
        `mat3x3<T>()`: mat3x3&lt;|T|&gt;<br>
        `mat4x3<T>()`: mat4x3&lt;|T|&gt;
    <td>Zero value
  <tr>
    <td>
    <td>`mat2x4<T>()`: mat2x4&lt;|T|&gt;<br>
        `mat3x4<T>()`: mat3x4&lt;|T|&gt;<br>
        `mat4x4<T>()`: mat4x4&lt;|T|&gt;
    <td>Zero value
</table>

<table class='data'>
  <caption>Array zero type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="array zero value">
    <td>|T| is a [=constructible=]
    <td>`array<`|T|,|N|`>()`: array&lt;|T|,|N|&gt;
    <td>Zero-valued array
</table>

<div class='example' heading="Zero-valued arrays">
  <xmp highlight='rust'>
    array<bool, 2>()               // The zero-valued array of two booleans.
    array<bool, 2>(false, false)   // The same value, written explicitly.
  </xmp>
</div>

<table class='data'>
  <caption>Structure zero type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="structure zero value">
    <td>|S| is a [=constructible=] structure type.<br>
         The expression is in the scope of declaration of |S|.
    <td>|S|`()`: |S|
    <td>Zero-valued structure: a structure of type |S| where each member is the zero value for its member type.
</table>

<div class='example wgsl global-scope' heading="Zero-valued structures">
  <xmp highlight='rust'>
    struct Student {
      grade: i32,
      GPA: f32,
      attendance: array<bool,4>
    }

    fn func() {
      var s: Student;

      // The zero value for Student
      s = Student();

      // The same value, written explicitly.
      s = Student(0, 0.0, array<bool,4>(false, false, false, false));

      // The same value, written with zero-valued members.
      s = Student(i32(), f32(), array<bool,4>());
    }
  </xmp>
</div>


### Conversion Expressions ### {#conversion-expr}

WGSL does not implicitly convert or promote a numeric or boolean value to another type.
Instead use a <dfn>conversion expression</dfn> as defined in the tables below.

For details on conversion to and from floating point types, see [[#floating-point-conversion]].

<table class='data'>
  <caption>Scalar conversion type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="coercion to boolean from unsigned">
      <td>|e|: u32<td>`bool(`|e|`)`: bool
      <td>Coercion to boolean.<br>
          The result is false if |e| is 0, and true otherwise.
  <tr algorithm="coercion to boolean from signed">
      <td>|e|: i32<td>`bool(`|e|`)`: bool
      <td>Coercion to boolean.<br>
          The result is false if |e| is 0, and true otherwise.
  <tr algorithm="coercion to boolean from binary32 floating point">
      <td>|e|: f32<td>`bool(`|e|`)`: bool
      <td>Coercion to boolean.<br>
          The result is false if |e| is 0.0 or -0.0, and true otherwise.
          In particular NaN and infinity values map to true.
  <tr algorithm="coercion to boolean from binary16 floating point">
      <td>|e|: f16<td>`bool(`|e|`)`: bool
      <td>Coercion to boolean.<br>
          The result is false if |e| is 0.0 or -0.0, and true otherwise.
          In particular NaN and infinity values map to true.
  <tr algorithm="conversion from boolean to signed">
      <td>|e|: bool<td>`i32(`|e|`)`: i32
      <td>Conversion of a boolean value to a signed integer<br>
          The result is 1 if |e| is true and 0 otherwise.<br>
  <tr algorithm="scalar reinterpretation from unsigned to signed">
      <td>|e|: u32<td>`i32(`|e|`)`: i32
      <td>Reinterpretation of bits.<br>
          The result is the unique value in [=i32=] that has the same bit pattern as |e|.
  <tr algorithm="scalar conversion from floating point to signed integer">
      <td>|e|: f32<td>`i32(`|e|`)`: i32
      <td>Value conversion, rounding toward zero.
  <tr algorithm="scalar conversion from binary16 floating point to signed integer">
      <td>|e|: f16<td>`i32(`|e|`)`: i32
      <td>Value conversion, rounding toward zero.
  <tr algorithm="conversion from boolean to unsigned">
      <td>|e|: bool<td>`u32(`|e|`)`: u32
      <td>Conversion of a boolean value to an unsigned integer.<br>
          The result is 1u if |e| is true and 0u otherwise.
  <tr algorithm="scalar conversion from signed integer to unsigned integer">
      <td>|e|: AbstractInt or i32<td>`u32(`|e|`)`: u32
      <td>Reinterpretation of bits.<br>
          The result is the unique value in [=u32=] that has the same bit pattern as |e|.
  <tr algorithm="scalar conversion from floating point to unsigned integer">
      <td>|e|: f32<td>`u32(`|e|`)`: u32
      <td>Value conversion, rounding toward zero.
  <tr algorithm="scalar conversion from binary16 floating point to unsigned integer">
      <td>|e|: f16<td>`u32(`|e|`)`: u32
      <td>Value conversion, rounding toward zero.
  <tr algorithm="conversion from boolean to binary32 floating point">
      <td>|e|: bool<td>`f32(`|e|`)`: f32
      <td>Conversion of a boolean value to floating point.<br>
          The result is 1.0 if |e| is true and 0.0 otherwise.
  <tr algorithm="scalar conversion from signed integer to binary32 floating point">
      <td>|e|: i32<td>`f32(`|e|`)`: f32<td>Value conversion, including invalid cases.
  <tr algorithm="scalar conversion from unsigned integer to binary32 floating point">
      <td>|e|: u32<td>`f32(`|e|`)`: f32<td>Value conversion, including invalid cases.
  <tr algorithm="scalar conversion from binary16 floating point to binary32 floating point">
      <td>|e|: f16<td>`f32(`|e|`)`: f32<td>Exact value conversion.
  <tr algorithm="conversion from boolean to binary16 floating point">
      <td>|e|: bool<td>`f16(`|e|`)`: f16
      <td>Conversion of a boolean value to floating point<br>
          The result is 1.0 if |e| is true and 0.0 otherwise.
  <tr algorithm="scalar conversion from signed integer to binary16 floating point">
      <td>|e|: i32<td>`f16(`|e|`)`: f16<td>Value conversion, including invalid cases.
  <tr algorithm="scalar conversion from unsigned integer to binary16 floating point">
      <td>|e|: u32<td>`f16(`|e|`)`: f16<td>Value conversion, including invalid cases.
  <tr algorithm="scalar conversion from binary32 floating point to binary16 floating point">
      <td>|e|: f32<td>`f16(`|e|`)`: f16<td>Lossy value conversion.
</table>

Details of conversion to and from floating point are explained in [[#floating-point-conversion]].

<table class='data'>
  <caption>Vector conversion type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="vector coercion of unsigned integer to boolean">
     <td>|e|: vec|N|&lt;u32&gt;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>[=Component-wise=] coercion of a unsigned integer vector to a boolean vector.

  <tr algorithm="vector coercion of signed integer to boolean">
     <td>|e|: vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>[=Component-wise=] coercion of a signed integer vector to a boolean vector.

  <tr algorithm="vector coercion of binary32 floating point to boolean">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>[=Component-wise=] coercion of a binary32 floating point vector to a boolean vector.

  <tr algorithm="vector coercion of binary16 floating point to boolean">
     <td>|e|: vec|N|&lt;f16&gt;
     <td>`vec`|N|&lt;`bool`&gt;`(`|e|`)`: vec|N|&lt;bool&gt
     <td>[=Component-wise=] coercion of a binary16 floating point vector to a boolean vector.

  <tr algorithm="vector conversion from bool to signed">
     <td>|e|: vec|N|&lt;bool&gt;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt
     <td>[=Component-wise=] conversion of a boolean vector to signed.<br>
         Component |i| of the result is `i32(`|e|`[`|i|`])`

  <tr algorithm="vector reinterpretation from unsigned to signed">
     <td>|e|: vec|N|&lt;u32&gt;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt
     <td>[=Component-wise=] reinterpretation of bits.<br>
         Component |i| of the result is `i32(`|e|`[`|i|`])`

  <tr algorithm="vector conversion from binary32 floating point to signed integer">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt;
     <td>[=Component-wise=] value conversion to signed integer, including invalid cases.

  <tr algorithm="vector conversion from binary16 floating point to signed integer">
     <td>|e|: vec|N|&lt;f16&gt;
     <td>`vec`|N|&lt;`i32`&gt;`(`|e|`)`: vec|N|&lt;i32&gt;
     <td>[=Component-wise=] value conversion to signed integer, including invalid cases.

  <tr algorithm="vector conversion from bool to unsigned">
     <td>|e|: vec|N|&lt;bool&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt
     <td>[=Component-wise=] conversion of a boolean vector to unsigned.<br>
         Component |i| of the result is `u32(`|e|`[`|i|`])`

  <tr algorithm="vector reinterpretation from signed to unsigned">
     <td>|e|: vec|N|&lt;AbstractInt&gt; or vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt;
     <td>[=Component-wise=] reinterpretation of bits.

  <tr algorithm="vector conversion from binary32 floating point to unsigned integer">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt;
     <td>[=Component-wise=] value conversion to unsigned integer, including invalid cases.

  <tr algorithm="vector conversion from binary16 floating point to unsigned integer">
     <td>|e|: vec|N|&lt;f16&gt;
     <td>`vec`|N|&lt;`u32`&gt;`(`|e|`)`: vec|N|&lt;u32&gt;
     <td>[=Component-wise=] value conversion to unsigned integer, including invalid cases.

  <tr algorithm="vector conversion from bool to binary32 floating point">
     <td>|e|: vec|N|&lt;bool&gt;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt
     <td>[=Component-wise=] conversion of a boolean vector to floating point.<br>
         Component |i| of the result is `f32(`|e|`[`|i|`])`

  <tr algorithm="vector conversion from signed integer to binary32 floating point">
     <td>|e|: vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt;
     <td>[=Component-wise=] value conversion to binary32 floating point, including invalid cases.

  <tr algorithm="vector conversion from unsigned integer to binary32 floating point">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt;
     <td>[=Component-wise=] value conversion to binary32 floating point, including invalid cases.

  <tr algorithm="vector conversion from binary16 floating point to binary32 floating point">
     <td>|e|: vec|N|&lt;f16&gt;
     <td>`vec`|N|&lt;`f32`&gt;`(`|e|`)`: vec|N|&lt;f32&gt;
     <td>[=Component-wise=] exact value conversion to binary32 floating point.

  <tr algorithm="vector conversion from bool to binary16 floating point">
     <td>|e|: vec|N|&lt;bool&gt;
     <td>`vec`|N|&lt;`f16`&gt;`(`|e|`)`: vec|N|&lt;f16&gt
     <td>[=Component-wise=] conversion of a boolean vector to binary16 floating point.<br>
         Component |i| of the result is `f16(`|e|`[`|i|`])`

  <tr algorithm="vector conversion from signed integer to binary16 floating point">
     <td>|e|: vec|N|&lt;i32&gt;
     <td>`vec`|N|&lt;`f16`&gt;`(`|e|`)`: vec|N|&lt;f16&gt;
     <td>[=Component-wise=] value conversion to binary16 floating point, including invalid cases.

  <tr algorithm="vector conversion from unsigned integer to binary16 floating point">
     <td>|e|: vec|N|&lt;u32&gt;
     <td>`vec`|N|&lt;`f16`&gt;`(`|e|`)`: vec|N|&lt;f&gt;
     <td>[=Component-wise=] value conversion to binary16 floating point, including invalid cases.

  <tr algorithm="vector conversion from binary32 floating point to binary16 floating point">
     <td>|e|: vec|N|&lt;f32&gt;
     <td>`vec`|N|&lt;`f16`&gt;`(`|e|`)`: vec|N|&lt;f16&gt;
     <td>[=Component-wise=] lossy value conversion to binary16 floating point.

</table>

<table class='data'>
  <caption>Matrix conversion type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="matrix coercion of binary16 floating point to binary32 floating point">
     <td>|e|: mat|C|x|R|&lt;f16&gt;
     <td>`mat`|C|`x`|R|&lt;`f32`&gt;`(`|e|`)`: mat|C|x|R|&lt;f32&gt
     <td>[=Component-wise=] exact value conversion to binary32 floating point.

  <tr algorithm="vector coercion of binary32 floating point to binary16 floating point">
     <td>|e|: mat|C|x|R|&lt;f32&gt;
     <td>`mat`|C|`x`|R|&lt;`f16`&gt;`(`|e|`)`: mat|C|x|R|&lt;f16&gt
     <td>[=Component-wise=] lossy value conversion to binary16 floating point.

</table>

## Reinterpretation of Representation Expressions ## {#bitcast-expr}

A `bitcast` expression is used to reinterpet the bit representation of a
value in one type as a value in another type.

<table class='data'>
  <caption>Bitcast type rules</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="identity reinterpretation">
    <td>|e|: |T|<br>
    |T| is a [=numeric scalar=] or [=numeric vector=] type
    <td class="nowrap">bitcast&lt;|T|&gt;(|e|): |T|
    <td>Identity transform. [=Component-wise=] when |T| is a vector.<br>
    The result is |e|.

  <tr algorithm="32-bit scalar reinterpretation">
    <td>|e|: |T1|<br>
    |T1| is i32, u32, or f32<br>
    |T2| is not |T1| and is i32, u32, or f32
    <td class="nowrap">bitcast&lt;|T2|&gt;(|e|): |T2|
    <td>Reinterpretation of bits as |T2|. <br>
    The result is the reinterpretation of the bits in |e| as a |T2| value.

  <tr algorithm="32-bit elements vector reinterpretation">
    <td>|e|: vec|N|&lt;|T1|&gt;<br>
    |T1| is i32, u32, or f32<br>
    |T2| is not |T1| and is i32, u32, or f32
    <td class="nowrap">bitcast&lt;vec|N|&lt;|T2|&gt;&gt;(|e|): vec|N|&lt;|T2|&gt;
    <td>[=Component-wise=] reinterpretation of bits as |T2|.<br>
    The result is the reinterpretation of the bits in |e| as a vec|N|&lt;|T2|&gt; value.

  <tr algorithm="binary16x2 to 32-bit scalar reinterpretation">
    <td>|e|: vec2&lt;f16&gt;<br>
    |T| is i32, u32, or f32
    <td class="nowrap">bitcast&lt;|T|&gt;(|e|): |T|
    <td>Reinterpretation of bits as |T|.<br>
    The result is the reinterpretation of the 32 bits in |e| as a |T| value, following the internal layout rules.

  <tr algorithm="32-bit scalar to binary16x2 reinterpretation">
    <td>|e|: |T|<br>
    |T| is i32, u32, or f32
    <td class="nowrap">bitcast&lt;vec2&lt;f16&gt;&gt;(|e|): vec2&lt;f16&gt;
    <td>Reinterpretation of bits as vec2&lt;f16&gt;.<br>
    The result is the reinterpretation of the 32 bits in |e| as a vec2&lt;f16&gt; value, following the internal layout rules.

  <tr algorithm="binary16x4 to vec2 of 32-bit scalar reinterpretation">
    <td>|e|: vec4&lt;f16&gt;<br>
    |T| is i32, u32, or f32
    <td class="nowrap">bitcast&lt;vec2&lt;|T|&gt;&gt;(|e|): vec2&lt;|T|&gt;
    <td>Reinterpretation of bits as vec2&lt;|T|&gt;.<br>
    The result is the reinterpretation of the 64 bits in |e| as a vec2&lt;|T|&gt; value, following the internal layout rules.

  <tr algorithm="vec2 of 32-bit scalar to binary16x4 reinterpretation">
    <td>|e|: vec2&lt;|T|&gt;<br>
    |T| is i32, u32, or f32
    <td class="nowrap">bitcast&lt;vec4&lt;f16&gt;&gt;(|e|): vec4&lt;f16&gt;
    <td>Reinterpretation of bits as vec4&lt;f16&gt;.<br>
    The result is the reinterpretation of the 64 bits in |e| as a vec4&lt;f16&gt; value, following the internal layout rules.

</table>

The internal layout rules are described in [[#internal-value-layout]].

## Composite Value Decomposition Expressions ## {#composite-value-decomposition-expr}

### Vector Access Expression ### {#vector-access-expr}

Accessing components of a vector can be done either using array subscripting (e.g. `a[2]`) or using a sequence of convenience names, each mapping to a component of the source vector.

<ul>
  <li>The colour set of convenience names: `r`, `g`, `b`, `a` for vector components 0, 1, 2, and 3 respectively.
  <li>The dimensional set of convenience names: `x`, `y`, `z`, `w` for vector components 0, 1, 2, and 3, respectively.
</ul>

The convenience names are accessed using the `.` notation. (e.g. `color.bgra`).

NOTE: the convenience letterings can not be mixed. (i.e. you can not use `rybw`).

A convenience letter [=shader-creation error|must not=] access a component past the end of the vector.

The convenience letterings can be applied in any order, including duplicating letters as needed.
The provided number of letters [=shader-creation error|must=] be between 1 and 4.
That is, using convenience letters can only produce a valid vector type.

The result type depends on the number of letters provided. Assuming a `vec4<f32>`
<table>
  <thead>
    <tr><th>Accessor<th>Result type
  </thead>
  <tr><td>r<td>`f32`
  <tr><td>rg<td>`vec2<f32>`
  <tr><td>rgb<td>`vec3<f32>`
  <tr><td>rgba<td>`vec4<f32>`
</table>

<div class='example wgsl function-scope'>
  <xmp highlight='rust'>
    var a: vec3<f32> = vec3<f32>(1., 2., 3.);
    var b: f32 = a.y;          // b = 2.0
    var c: vec2<f32> = a.bb;   // c = (3.0, 3.0)
    var d: vec3<f32> = a.zyx;  // d = (3.0, 2.0, 1.0)
    var e: f32 = a[1];         // e = 2.0
  </xmp>
</div>

#### Vector Single Component Selection #### {#vector-single-component}

<table class='data'>
  <caption>Vector decomposition: single component selection</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="first vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
       <td class="nowrap">
           |e|`.x`: |T|<br>
           |e|`.r`: |T|
       <td>Select the first component of |e|
  <tr algorithm="second vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
       <td class="nowrap">
           |e|`.y`: |T|<br>
           |e|`.g`: |T|
       <td>Select the second component of |e|
  <tr algorithm="third vector component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
          |N| is 3 or 4
       <td class="nowrap">
           |e|`.z`: |T|<br>
           |e|`.b`: |T|
       <td>Select the third component of |e|
  <tr algorithm="fourth vector component selection"><td>|e|: vec4&lt;|T|&gt;
       <td class="nowrap">
           |e|`.w`: |T|<br>
           |e|`.a`: |T|
       <td>Select the fourth component of |e|
  <tr algorithm="vector indexed component selection"><td>|e|: vec|N|&lt;|T|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |e|[|i|]: |T|
       <td>Select the |i|'<sup>th</sup> component of vector<br>
           The first component is at index |i|=0.<br>
           If |i| is outside the range [0,|N|-1], then any valid value for |T|
           may be returned.
</table>

#### Vector Multiple Component Selection #### {#vector-multi-component}

<table class='data'>
  <caption>Vector decomposition: multiple component selection
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="two component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `x`, `y`, `z`, or `w`<br>
          |J| is the letter `x`, `y`, `z`, or `w`<br>
       <td class="nowrap">
           |e|`.`|I||J|: vec2&lt;|T|&gt;<br>
       <td>Computes the two-component vector with first component |e|.|I|, and second component |e|.|J|.<br>
           Letter `z` is valid only when |N| is 3 or 4.<br>
           Letter `w` is valid only when |N| is 4.
  <tr algorithm="two component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `r`, `g`, `b`, or `a`<br>
          |J| is the letter `r`, `g`, `b`, or `a`<br>
       <td class="nowrap">
           |e|`.`|I||J|: vec2&lt;|T|&gt;<br>
       <td>Computes the two-component vector with first component |e|.|I|, and second component |e|.|J|.<br>
           Letter `b` is valid only when |N| is 3 or 4.<br>
           Letter `a` is valid only when |N| is 4.
  <tr algorithm="three component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `x`, `y`, `z`, or `w`<br>
          |J| is the letter `x`, `y`, `z`, or `w`<br>
          |K| is the letter `x`, `y`, `z`, or `w`<br>
       <td class="nowrap">
           |e|`.`|I||J||K|: vec3&lt;|T|&gt;<br>
       <td>Computes the three-component vector with first component |e|.|I|, second component |e|.|J|, and third component |e|.|K|.<br>
           Letter `z` is valid only when |N| is 3 or 4.<br>
           Letter `w` is valid only when |N| is 4.
  <tr algorithm="three component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `r`, `g`, `b`, or `a`<br>
          |J| is the letter `r`, `g`, `b`, or `a`<br>
          |K| is the letter `r`, `g`, `b`, or `a`<br>
       <td class="nowrap">
           |e|`.`|I||J||K|: vec3&lt;|T|&gt;<br>
       <td>Computes the three-component vector with first component |e|.|I|, second component |e|.|J|, and third component |e|.|K|.<br>
           Letter `b` is only valid when |N| is 3 or 4.<br>
           Letter `a` is only valid when |N| is 4.
  <tr algorithm="four component vector selection using .x .y">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `x`, `y`, `z`, or `w`<br>
          |J| is the letter `x`, `y`, `z`, or `w`<br>
          |K| is the letter `x`, `y`, `z`, or `w`<br>
          |L| is the letter `x`, `y`, `z`, or `w`<br>
       <td class="nowrap">
           |e|`.`|I||J||K||L|: vec4&lt;|T|&gt;<br>
       <td>Computes the four-component vector with first component |e|.|I|, second component |e|.|J|, third component |e|.|K|, and fourth component |e|.|L|.<br>
           Letter `z` is valid only when |N| is 3 or 4.<br>
           Letter `w` is valid only when |N| is 4.
  <tr algorithm="four component vector selection using .r .g">
       <td class="nowrap">
          |e|: vec|N|&lt;|T|&gt;<br>
          |I| is the letter `r`, `g`, `b`, or `a`<br>
          |J| is the letter `r`, `g`, `b`, or `a`<br>
          |K| is the letter `r`, `g`, `b`, or `a`<br>
          |L| is the letter `r`, `g`, `b`, or `a`<br>
       <td class="nowrap">
           |e|`.`|I||J||K||L|: vec4&lt;|T|&gt;<br>
       <td>Computes the four-component vector with first component |e|.|I|, second component |e|.|J|, third component |e|.|K|, and fourth component |e|.|L|.<br>
           Letter `b` is only valid when |N| is 3 or 4.<br>
           Letter `a` is only valid when |N| is 4.
</table>

#### Component Reference from Vector Reference #### {#component-reference-from-vector-reference}

A [=write access=] to component of a vector **may** access all of the [=memory
location|memory locations=] associated with that vector.

Note: This means accesses to different components of a vector by different
invocations must be synchronized if at least one access is a [=write access=].
See [[#sync-builtin-functions]].

<table class='data'>
  <caption>Getting a reference to a component from a reference to a vector</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="first vector component reference selection">
       <td>|r|: ref&lt;|AS|,vec|N|&lt;|T|&gt;,|AM|&gt;<br>
       <td class="nowrap">
           |r|`.x`: ref&lt;|AS|,|T|,|AM|&gt;<br>
           |r|`.r`: ref&lt;|AS|,|T|,|AM|&gt;<br>
       <td>Compute a reference to the first component of the vector referenced by the reference |r|.<br>
           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
  <tr algorithm="second vector component reference selection">
       <td>|r|: ref&lt;|AS|,vec|N|&lt;|T|&gt;,|AM|&gt;<br>
       <td class="nowrap">
           |r|`.y`: ref&lt;|AS|,|T|,|AM|&gt;<br>
           |r|`.g`: ref&lt;|AS|,|T|,|AM|&gt;<br>
       <td>Compute a reference to the second component of the vector referenced by the reference |r|.<br>
           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
  <tr algorithm="third vector component reference selection">
       <td>|r|: ref&lt;|AS|,vec|N|&lt;|T|&gt;,|AM|&gt;<br>
           |N| is 3 or 4
       <td class="nowrap">
           |r|`.z`: ref&lt;|AS|,|T|,|AM|&gt;<br>
           |r|`.b`: ref&lt;|AS|,|T|,|AM|&gt;<br>
       <td>Compute a reference to the third component of the vector referenced by the reference |r|.<br>
           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
  <tr algorithm="fourth vector component reference selection">
       <td>|r|: ref&lt;|AS|,vec4&lt;|T|&gt;,|AM|&gt;<br>
       <td class="nowrap">
           |r|`.w`: ref&lt;|AS|,|T|,|AM|&gt;<br>
           |r|`.a`: ref&lt;|AS|,|T|,|AM|&gt;<br>
       <td>Compute a reference to the fourth component of the vector referenced by the reference |r|.<br>
           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
  <tr algorithm="vector indexed component reference selection">
       <td>|r|: ref&lt;|AS|,vec|N|&lt;|T|&gt;,|AM|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|AS|,|T|,|AM|&gt;
       <td>Compute a reference to the |i|'<sup>th</sup> component of the vector
           referenced by the reference |r|.

           If |i| is outside the range [0,|N|-1], then the expression evaluates
           to [=invalid memory reference=].

           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
</table>

### Matrix Access Expression ### {#matrix-access-expr}

<table class='data'>
  <caption>Column vector extraction</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="matrix indexed column vector selection">
       <td class="nowrap">
          |e|: mat|C|x|R|&lt;|T|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |e|[|i|]: vec|R|&lt;|T|&gt;
       <td>The result is the |i|'<sup>th</sup> column vector of |e|.

           If |i| is outside the range [0,|C|-1], then any valid value for
           vec|R|&lt;|T|&gt; may be returned.
</table>

<table class='data'>
  <caption>Getting a reference to a column vector from a reference to a matrix</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="matrix indexed column vector reference selection">
       <td class="nowrap">
          |r|: ref&lt;|AS|,mat|C|x|R|&lt;|T|&gt;,|AM|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|AS|,vec|R|&lt;|T|&gt;,|AM|&gt;
       <td>Compute a reference to the |i|'<sup>th</sup> column vector of the
           matrix referenced by the reference |r|.

           If |i| is outside the range [0,|C|-1], then the expression evaluates to
           [=invalid memory reference=].

           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
</table>

### Array Access Expression ### {#array-access-expr}

<table class='data'>
  <caption>Array element extraction</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="fixed-size array indexed element selection">
       <td class="nowrap">
          |e|: array&lt;|T|,|N|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |e|[|i|] : |T|
       <td>The result is the value of the |i|'<sup>th</sup> element of the array value |e|.

           If |i| is outside the range [0,|N|-1], then any valid value for |T|
           may be returned.
</table>

<table class='data'>
  <caption>Getting a reference to an array element from a reference to an array</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="fixed-size array indexed reference selection">
       <td class="nowrap">
          |r|: ref&lt;|AS|,array&lt;|T|,|N|&gt;,|AM|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|AS|,|T|,|AM|&gt;
       <td>Compute a reference to the |i|'<sup>th</sup> element of the array
           referenced by the reference |r|.

           If |i| is outside the range [0,|N|-1], then the expression evaluates
           to an [=invalid memory reference=].

           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
  <tr algorithm="array indexed reference selection">
       <td>|r|: ref&lt;|AS|,array&lt;|T|&gt;,|AM|&gt;<br>
          |i|: [INT]
       <td class="nowrap">
           |r|[|i|] : ref&lt;|AS|,|T|,|AM|&gt;
       <td>Compute a reference to the |i|'<sup>th</sup> element of the
           runtime-sized array referenced by the reference |r|.

           If at runtime the array has |N| elements, and |i| is outside the range
           [0,|N|-1], then the expression evaluates to an [=invalid memory
           reference=].

           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
</table>


### Structure Access Expression ### {#struct-access-expr}

<table class='data'>
  <caption>Structure member extraction</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="structure member extraction">
       <td class="nowrap">
          |S| is a structure type<br>
          |M| is the identifier name of a member of |S|, having type |T|<br>
          |e|: |S|<br>
       <td class="nowrap">
           |e|.|M|: |T|
       <td>The result is the value of the member with name |M| from the structure value |e|.
</table>

<table class='data'>
  <caption>Getting a reference to a structure member from a reference to a structure</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="structure member reference selection">
       <td class="nowrap">
          |S| is a structure type<br>
          |M| is the name of a member of |S|, having type |T|<br>
          |r|: ref&lt;|AS|,|S|,|AM|&gt;<br>
       <td class="nowrap">
           |r|.|M|: ref&lt;|AS|,|T|,|AM|&gt;
       <td>Given a reference to a structure, the result is a reference to the structure member with identifier name |M|.<br>
           The [=originating variable=] of the resulting reference is
           the same as the originating variable of |r|.
</table>

## Logical Expressions ## {#logical-expr}
<table class='data'>
  <caption>Unary logical operations</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="boolean negation"><td>|e|: T<br>|T| is bool or vec|N|&lt;bool&gt;
  <td>`!`|e|: |T|
  <td>Logical negation.
  The result is `true` when |e| is `false` and `false` when |e| is `true`.
  [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <caption>Binary logical expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="short-circuiting or"><td>|e1|: bool<br>|e2|: bool<td>|e1| `||` |e2|`: bool`
  <td>Short-circuiting "or". Yields `true` if either |e1| or |e2| are true;
  evaluates |e2| only if |e1| is false.

  <tr algorithm="short-circuiting and"><td>|e1|: bool<br>|e2|: bool
  <td>|e1| `&&` |e2|`: bool`
  <td>Short-circuiting "and". Yields `true` if both |e1| and |e2| are true;
  evaluates |e2| only if |e1| is true.

  <tr algorithm="logical or"><td>|e1|: |T|<br>|e2|: |T|<br>|T| is bool or vec|N|&lt;bool&gt;
  <td>|e1| `|` |e2|`:` |T|
  <td>Logical "or". [=Component-wise=] when |T| is a vector. Evaluates both |e1| and |e2|.

  <tr algorithm="logical and"><td>|e1|: |T|<br>|e2|: |T|<br>|T| is bool or vec|N|&lt;bool&gt;
  <td>|e1| `&` |e2|`:` |T|
  <td>Logical "and". [=Component-wise=] when |T| is a vector. Evaluates both |e1| and |e2|.
</table>


## Arithmetic Expressions ## {#arithmetic-expr}

<table class='data'>
  <caption>Unary arithmetic expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="negation"><td>|e|: |T|<br>
  |T| is AbstractInt, AbstractFloat, i32, f32, f16, vec|N|&lt;AbstractInt&gt;,
  vec|N|&lt;AbstractFloat&gt;, vec|N|&lt;i32&gt;, vec|N|&lt;f32&gt;, or vec|N|&lt;f16&gt;
  <td>`-`|e|`:` |T|
  <td>Negation. [=Component-wise=] when |T| is a vector.
  If |T| is an integral type and |e| evaluates to the largest negative value, then the result is |e|.
</table>

<table class='data'>
  <caption>Binary arithmetic expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="addition">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `+` |e2| : |T|
    <td>Addition. [=Component-wise=] when |T| is a vector.
    If |T| is a [=concrete=] integral type, then the result is modulo 2<sup>32</sup>.

  <tr algorithm="subtraction">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `-` |e2| : |T|
    <td>Subtraction [=Component-wise=] when |T| is a vector.
    If |T| is a [=concrete=] integral type, then the result is modulo 2<sup>32</sup>.

  <tr algorithm="multiplication">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `*` |e2| : |T|
    <td>Multiplication. [=Component-wise=] when |T| is a vector.
    If |T| is a [=concrete=] integral type, then the result is modulo 2<sup>32</sup>.

  <tr algorithm="division">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `/` |e2| : |T|
    <td>Division. [=Component-wise=] when |T| is a vector.

        If |T| is a signed integral type, the scalar case, evaluates to:
        * |e1|, when |e2| is zero.
        * |e1|, when |e1| is the most negative value in |T|, and |e2| is -1.
        * [=truncate=](|x|) otherwise, where |x| is the
            real-valued quotient |e1|&nbsp;&div;&nbsp;|e2|.

        Note:
        The need to ensure truncation behaviour may require an implementation
        to perform more operations than when computing an unsigned division.
        Use unsigned division when both operands are known to have the same sign.

        <!--
               where MINIT = most negative value in |T|
               where Divisor = select(e2, 1, (e2==0) | ((e1 == MININT) & (e2 == -1)))
               result is truncate(e1/Divisor)
        -->

        If |T| is an unsigned integral type, the scalar case, evaluates to:
        * |e1|, when |e2| is zero.
        * Otherwise, the integer |q| such that
            |e1|&nbsp;=&nbsp;|q|&nbsp;&times;&nbsp;|e2|&nbsp;+&nbsp;|r|,
            where 0 &le; |r| &lt; |e2|.

  <tr algorithm="Remainder">
    <td>|e1| : |T|<br>|e2| : |T|<br>[ALLNUMERICDECL]
    <td>|e1| `%` |e2| : |T|
    <td>Remainder. [=Component-wise=] when |T| is a vector.

       If |T| is a signed integral scalar type, evaluates |e1| and |e2| once, and evaluates to:
       * 0, when |e2| is zero.
       * 0, when |e1| is the most negative value in |T|, and |e2| is -1.
       * Otherwise, |e1|&nbsp;-&nbsp;[=truncate=](|e1|&nbsp;&div;&nbsp;|e2|)&nbsp;&times;&nbsp;|e2|
           where the quotient is computed as a real value.

       Note:
       When non-zero, the result has the same sign as |e1|.

       Note:
       The need to ensure consistent behaviour may require an implementation
       to perform more operations than when computing an unsigned remainder.

        <!--
               where MINIT = most negative value in |T|
               where Divisor = select(e2, 1, (e2==0) | ((e1 == MININT) & (e2 == -1)))
               result is e1 - truncate(e1/Divisor) * Divisor
        -->

        If |T| is an unsigned integral scalar type, evaluates to:
        * 0, when |e2| is zero.
        * Otherwise, the integer |r| such that
            |e1|&nbsp;=&nbsp;|q|&nbsp;&times;&nbsp;|e2|&nbsp;+&nbsp;|r|,
            where |q| is an integer and 0 &le; |r| &lt; |e2|.

        If |T| is a floating point type, the result is equal to:<br> |e1| - |e2| * trunc(|e1| / |e2|)

</table>

<table class='data'>
  <caption>Binary arithmetic expressions with mixed scalar and vector operands</caption>
  <thead>
    <th>Preconditions<th>Conclusions<th>Semantics
  </thead>
  <tr algorithm="vector-scalar arithmetic, any scalar type">
    <td rowspan="10">|S| is one of AbstractInt, AbstractFloat, f32, f16, i32, u32<br>
        |V| is vec|N|&lt;|S|&gt<br>
        |es|: |S|<br>
        |ev|: |V|
    <td>|ev| `+` |es|: |V|
    <td>|ev| `+` |V|(|es|)
  <tr>
    <td>|es| `+` |ev|: |V|
    <td>|V|(|es|) `+` |ev|
  <tr>
    <td>|ev| `-` |es|: |V|
    <td>|ev| `-` |V|(|es|)
  <tr>
    <td>|es| `-` |ev|: |V|
    <td>|V|(|es|) `-` |ev|
  <tr>
    <td>|ev| `*` |es|: |V|
    <td>|ev| `*` |V|(|es|)
  <tr>
    <td>|es| `*` |ev|: |V|
    <td>|V|(|es|) `*` |ev|
  <tr>
    <td>|ev| `/` |es|: |V|
    <td>|ev| `/` |V|(|es|)
  <tr>
    <td>|es| `/` |ev|: |V|
    <td>|V|(|es|) `/` |ev|
  <tr>
    <td>|ev| `%` |es|: |V|
    <td>|ev| `%` |V|(|es|)
  <tr>
    <td>|es| `%` |ev|: |V|
    <td>|V|(|es|) `%` |ev|
</table>

<table class='data'>
  <caption>Matrix arithmetic</caption>
  <thead>
    <th>Preconditions<th>Conclusions<th>Semantics
  </thead>
  <tr algorithm="matrix addition">
    <td rowspan=2>|e1|, |e2|: mat|C|x|R|&lt;|T|&gt<br>
        |T| is AbstractFloat, f32, or f16
    <td>|e1| `+` |e2|: mat|C|x|R|&lt;|T|&gt<br>
    <td>Matrix addition: column |i| of the result is |e1|[i] + |e2|[i]
  <tr algorithm="matrix subtraction">
    <td>|e1| `-` |e2|: mat|C|x|R|&lt;|T|&gt
    <td>Matrix subtraction: column |i| of the result is |e1|[|i|] - |e2|[|i|]
  <tr algorithm="matrix-scalar multiply">
    <td rowspan=2>|m|: mat|C|x|R|&lt;|T|&gt<br>
        |s|: |T|<br>
        |T| is AbstractFloat, f32, or f16
    <td>|m| `*` |s|:  mat|C|x|R|&lt;|T|&gt<br>
    <td>Component-wise scaling: (|m| `*` |s|)[i][j] is |m|[i][j] `*` |s|
  <tr algorithm="scalar-matrix multiply">
    <td>|s| `*` |m|:  mat|C|x|R|&lt;|T|&gt<br>
    <td>Component-wise scaling: (|s| `*` |m|)[i][j] is |m|[i][j] `*` |s|
  <tr algorithm="matrix-column-vector multiply">
    <td>|m|: mat|C|x|R|&lt;|T|&gt<br>
        |v|: vec|C|&lt;|T|&gt<br>
        |T| is AbstractFloat, f32, or f16
    <td>|m| `*` |v|:  vec|R|&lt;|T|&gt<br>
    <td>Linear algebra matrix-column-vector product:
        Component |i| of the result is `dot`(|m|[|i|],|v|)
  <tr algorithm="matrix-row-vector multiply">
    <td>
        |m|: mat|C|x|R|&lt;|T|&gt<br>
        |v|: vec|R|&lt;|T|&gt<br>
        |T| is AbstractFloat, f32, or f16
    <td>|v| `*` |m|:  vec|C|&lt;|T|&gt<br>
    <td>Linear algebra row-vector-matrix product:<br>
        [=transpose=](transpose(|m|) `*` transpose(|v|))
  <tr algorithm="matrix-matrix multiply">
    <td>|e1|: mat|K|x|R|&lt;|T|&gt<br>
        |e2|: mat|C|x|K|&lt;|T|&gt<br>
        |T| is AbstractFloat, f32, or f16
    <td>|e1| `*` |e2|:  mat|C|x|R|&lt;|T|&gt<br>
    <td>Linear algebra matrix product.

</table>

## Comparison Expressions ## {#comparison-expr}

<table class='data'>
  <caption>Comparisons</caption>
  <thead>
    <tr><th>Precondtion<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="equality">
    <td>|e1|: |T|<br>|e2|: |T|<br>
    |S| is AbstractInt, AbstractFloat, bool, i32, u32, f32, or f16<br>
    |T| is |S| or vec|N|&lt;|S|&gt;<br>
    |TB| is bool if |T| is scalar or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `==` |e2|`:` |TB|
    <td>Equality. [=Component-wise=] when |T| is a vector.
  <tr algorithm="inequality">
    <td>|e1|: |T|<br>|e2|: |T|<br>
    |S| is AbstractInt, AbstractFloat, bool, i32, u32, or f32<br>
    |T| is |S| or vec|N|&lt;|S|&gt;<br>
    |TB| is bool if |T| is scalar or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `!=` |e2|`:` |TB|
    <td>Inequality. [=Component-wise=] when |T| is a vector.
  <tr algorithm="less than">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is bool if |T| is scalar, or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `<` |e2|`:` |TB|
    <td>Less than. [=Component-wise=] when |T| is a vector.
  <tr algorithm="less than equal">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is bool if |T| is scalar, or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `<=` |e2|`:` |TB|
    <td>Less than or equal. [=Component-wise=] when |T| is a vector.
  <tr algorithm="greater than">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is bool if |T| is scalar, or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `>` |e2|`:` |TB|
    <td>Greater than. [=Component-wise=] when |T| is a vector.
  <tr algorithm="greater than equal">
    <td>|e1|: |T|<br>|e2|: |T|<br>[ALLNUMERICDECL]<br>
    |TB| is bool if |T| is scalar, or<br>
    vec|N|&lt;bool&gt; if |T| is a vector
    <td class="nowrap">|e1| `>=` |e2|`:` |TB|
    <td>Greater than or equal. [=Component-wise=] when |T| is a vector.

</table>

## Bit Expressions ## {#bit-expr}

<table class='data'>
  <caption>Unary bitwise operations</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="complement">
    <td>|e|: |T|<br>
    [ALLINTEGRALDECL]
    <td class="nowrap">`~`|e| : |T|
    <td>Bitwise complement on |e|.
    Each bit in the result is the opposite of the corresponding bit in |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <caption>Binary bitwise operations</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>
  <tr algorithm="bitwise or">
    <td>|e1|: |T|<br>
       |e2|: |T|<br>
       [ALLINTEGRALDECL]
    <td class="nowrap">|e1| `|` |e2|: |T|
    <td>Bitwise-or. [=Component-wise=] when |T| is a vector.
  <tr algorithm="bitwise and">
    <td>|e1|: |T|<br>
       |e2|: |T|<br>
       [ALLINTEGRALDECL]
    <td class="nowrap">|e1| `&` |e2|: |T|
    <td>Bitwise-and. [=Component-wise=] when |T| is a vector.
  <tr algorithm="bitwise exclusive or">
    <td>|e1|: |T|<br>
       |e2|: |T|<br>
       [ALLINTEGRALDECL]
    <td class="nowrap">|e1| `^` |e2|: |T|
    <td>Bitwise-exclusive-or. [=Component-wise=] when |T| is a vector.
</table>


<table class='data'>
  <caption>Bit shift expressions</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Notes
  </thead>

  <tr algorithm="concrete shift left">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |S| is [INT]<br>
    |T| is |S| or vec|N|&lt;|S|&gt;<br>
    |TS| is u32 when |T| is |S|, otherwise |TS| is vec|N|&lt;u32&gt;
    <td class="nowrap">|e1| `<<` |e2|: |T|
    <td>Shift left (concrete):

        Shift |e1| left, inserting zero bits at the least significant positions,
        and discarding the most significant bits.

        The number of bits to shift is the value of |e2|, modulo the bit width of |e1|.<br>

        [=Component-wise=] when |T| is a vector.

  <tr algorithm="abstract shift left">
    <td>|e1|: |T|<br>
    |e2|: |T|<br>
    |T| is AbstractInt or vec|N|&lt;AbstractInt&gt;
    <td class="nowrap">|e1| `<<` |e2|: |T|
    <td>Shift left (abstract):

        Shift |e1| left, inserting zero bits at the least significant positions,
        and discarding the most significant bits.

        The number of bits to shift is the value of |e2|.

        [=Component-wise=] when |T| is a vector.

        The |e2|+1 most significant bits of |e1| [=shader-creation error|must=] have the same bit value.
        Otherwise overflow would occur.

        It is a [=shader-creation error=] if any of the |e2| values are less than 0.

  <tr algorithm="concrete shift right">
    <td>|e1|: |T|<br>
    |e2|: |TS|<br>
    |S| is [INT]<br>
    |T| is |S| or vec|N|&lt;|S|&gt;<br>
    |TS| is u32 when |T| is |S|, otherwise |TS| is vec|N|&lt;u32&gt;
    <td class="nowrap">|e1| >> |e2|: |T|
    <td>Shift right (concrete).

        Shift |e1| right, inserting zero bits at the most significant positions,
        and discarding the least significant bits.

        The number of bits to shift is the value of |e2|, modulo the bit width of |e1|.<br>

        [=Component-wise=] when |T| is a vector.

  <tr algorithm="abstract shift right">
    <td>|e1|: |T|<br>
    |e2|: |T|<br>
    |T| is AbstractInt or vec|N|&lt;AbstractInt&gt;
    <td class="nowrap">|e1| >> |e2|: |T|
    <td>Shift right (abstract).

        Shift |e1| right, inserting zero bits at the most significant positions,
        and discarding the least significant bits.

        The number of bits to shift is the value of |e2|.

        [=Component-wise=] when |T| is a vector.

        It is a [=shader-creation error=] if any of the |e2| values are less than 0.
</table>

## Function Call Expression ## {#function-call-expr}

A function call expression executes a [=function call=] where the called
function has a [=return type=].
If the called function does not return a value, a function call statement
should be used instead.
See [[#function-call-statement]].

## Variable Identifier Expression ## {#var-identifier-expr}

<table class='data'>
  <caption>Getting a reference from a variable name</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="variable reference">
       <td>
          |v| is an [=identifier=] [=resolves|resolving=] to
          an [=in scope|in-scope=] variable declared in [=address space=] |AS|
          with [=store type=] |T| and [=access mode=] |AM|
       <td class="nowrap">
          |v|: ref&lt;|AS|,|T|,|AM|&gt;
       <td>Result is a reference to the memory for the named variable |v|.
</table>

## Formal Parameter Expression  ## {#formal-parameter-expr}

<table class='data'>
  <caption>Getting the value of an identifier declared as a formal parameter to a function</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="formal parameter value">
       <td>
          |a| is an [=identifier=] [=resolves|resolving=] to
          an [=in scope|in-scope=] formal parameter declaration with type |T|
       <td class="nowrap">
          |a|: |T|
       <td>Result is the value supplied for the corresponding function call operand at the [=call site=]
           invoking this instance of the function.
</table>

## Address-Of Expression  ## {#address-of-expr}

The <dfn noexport>address-of</dfn> operator converts a reference to its corresponding pointer.

<table class='data'>
  <caption>Getting a pointer from a reference</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="address-of expression">
       <td>
          |r|: ref&lt;|AS|,|T|,|AM|&gt;
       <td class="nowrap">
          `&`|r|: ptr&lt;|AS|,|T|,|AM|&gt;
       <td>Result is the pointer value corresponding to the
           same [=memory view=] as the reference value |r|.

           If |r| is an [=invalid memory reference=], then the resulting
           pointer is also an invalid memory reference.

           It is a [=shader-creation error=] if |AS| is the [=address spaces/handle=] address space.

           It is a [=shader-creation error=] if |r| is a
           [[#component-reference-from-vector-reference|reference to a vector component]].

</table>

## Indirection Expression  ## {#indirection-expr}

The <dfn noexport>indirection</dfn> operator converts a pointer to its corresponding reference.

<table class='data'>
  <caption>Getting a reference from a pointer</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="indirection expression">
       <td>
          |p|: ptr&lt;|AS|,|T|,|AM|&gt;
       <td class="nowrap">
          `*`|p|: ref&lt;|AS|,|T|,|AM|&gt;
       <td>Result is the reference value corresponding to the
           same [=memory view=] as the pointer value |p|.

           If |p| is an [=invalid memory reference=], then the resulting
           reference is also an invalid memory reference.

</table>

## Constant Identifier Expression  ## {#constant-identifier-expr}

<table class='data'>
  <caption>Getting the value of a `let`-declared identifier</caption>
  <thead>
    <tr><th>Precondition<th>Conclusion<th>Description
  </thead>
  <tr algorithm="pipeline-overridable constant value">
       <td>
          |c| is an [=identifier=] [=resolves|resolving=] to
          an [=in scope|in-scope=] [=override declaration=] with type |T|
       <td class="nowrap">
          |c|: |T|
       <td>If pipeline creation specified a value for the [=pipeline constant ID|constant ID=],
           then the result is that value.
           This value may be different for different pipeline instances.<br>
           Otherwise, the result is the value computed for the initializer expression.
           Pipeline-overridable constants appear at module-scope, so evaluation occurs
           before the shader begins execution.<br>
           Note: Pipeline creation fails if no initial value was specified in the API call
           and the `let`-declaration has no initializer expression.
  <tr algorithm="constant value">
       <td>
          |c| is an [=identifier=] [=resolves|resolving=] to
          an [=in scope|in-scope=] `let` declaration with type |T|
       <td class="nowrap">
          |c|: |T|
       <td>Result is the value computed for the initializer expression.<br>
           For a `let` declaration at module scope, evaluation occurs before the shader begins execution.<br>
           For a `let` declaration inside a function, evaluation occurs each time control reaches
           the declaration.<br>
</table>


## Expression Grammar Summary ## {#expression-grammar}

When an identifier is used as a [=syntax/callable=] item, it is one of:
* The name of a [=user-defined function=] or [=built-in function=],
    as part of a [=function call=].
* The name of a [[#struct-types|structure type]] or a [[#type-aliases|type alias]],
    as part of a [[#type-constructor-expr|constructor expression]].

[[#declaration-and-scope|Declaration and scope]] rules ensure those names are always distinct.

<div class='syntax' noexport='true'>
  <dfn for=syntax>primary_expression</dfn> :

    | [=syntax/ident=]

    | [=syntax/callable=] [=syntax/argument_expression_list=]

    | [=syntax/const_literal=]

    | [=syntax/paren_expression=]

    | [=syntax/bitcast=] [=syntax/less_than=] [=syntax/type_decl=] [=syntax/greater_than=] [=syntax/paren_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>callable</dfn> :

    | [=syntax/ident=]

    | [=syntax/type_decl_without_ident=]

    | [=syntax/vec_prefix=]

    | [=syntax/mat_prefix=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>paren_expression</dfn> :

    | [=syntax/paren_left=] [=syntax/expression=] [=syntax/paren_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>argument_expression_list</dfn> :

    | [=syntax/paren_left=] ( ( [=syntax/expression=] [=syntax/comma=] ) * [=syntax/expression=] [=syntax/comma=] ? ) ? [=syntax/paren_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>postfix_expression</dfn> :

    | [=syntax/bracket_left=] [=syntax/expression=] [=syntax/bracket_right=] [=syntax/postfix_expression=] ?

    | [=syntax/period=] [=syntax/ident=] [=syntax/postfix_expression=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>unary_expression</dfn> :

    | [=syntax/singular_expression=]

    | [=syntax/minus=] [=syntax/unary_expression=]

    | [=syntax/bang=] [=syntax/unary_expression=]

    | [=syntax/tilde=] [=syntax/unary_expression=]

    | [=syntax/star=] [=syntax/unary_expression=]

    | [=syntax/and=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>singular_expression</dfn> :

    | [=syntax/primary_expression=] [=syntax/postfix_expression=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>lhs_expression</dfn> :

    | ( [=syntax/star=] | [=syntax/and=] ) * [=syntax/core_lhs_expression=] [=syntax/postfix_expression=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>core_lhs_expression</dfn> :

    | [=syntax/ident=]

    | [=syntax/paren_left=] [=syntax/lhs_expression=] [=syntax/paren_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>multiplicative_expression</dfn> :

    | [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/star=] [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/forward_slash=] [=syntax/unary_expression=]

    | [=syntax/multiplicative_expression=] [=syntax/modulo=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>additive_expression</dfn> :

    | [=syntax/multiplicative_expression=]

    | [=syntax/additive_expression=] [=syntax/plus=] [=syntax/multiplicative_expression=]

    | [=syntax/additive_expression=] [=syntax/minus=] [=syntax/multiplicative_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>shift_expression</dfn> :

    | [=syntax/additive_expression=]

    | [=syntax/unary_expression=] [=syntax/shift_left=] [=syntax/unary_expression=]

    | [=syntax/unary_expression=] [=syntax/shift_right=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>relational_expression</dfn> :

    | [=syntax/shift_expression=]

    | [=syntax/shift_expression=] [=syntax/less_than=] [=syntax/shift_expression=]

    | [=syntax/shift_expression=] [=syntax/greater_than=] [=syntax/shift_expression=]

    | [=syntax/shift_expression=] [=syntax/less_than_equal=] [=syntax/shift_expression=]

    | [=syntax/shift_expression=] [=syntax/greater_than_equal=] [=syntax/shift_expression=]

    | [=syntax/shift_expression=] [=syntax/equal_equal=] [=syntax/shift_expression=]

    | [=syntax/shift_expression=] [=syntax/not_equal=] [=syntax/shift_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>short_circuit_and_expression</dfn> :

    | [=syntax/relational_expression=]

    | [=syntax/short_circuit_and_expression=] [=syntax/and_and=] [=syntax/relational_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>short_circuit_or_expression</dfn> :

    | [=syntax/relational_expression=]

    | [=syntax/short_circuit_or_expression=] [=syntax/or_or=] [=syntax/relational_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>binary_or_expression</dfn> :

    | [=syntax/unary_expression=]

    | [=syntax/binary_or_expression=] [=syntax/or=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>binary_and_expression</dfn> :

    | [=syntax/unary_expression=]

    | [=syntax/binary_and_expression=] [=syntax/and=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>binary_xor_expression</dfn> :

    | [=syntax/unary_expression=]

    | [=syntax/binary_xor_expression=] [=syntax/xor=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bitwise_expression</dfn> :

    | [=syntax/binary_and_expression=] [=syntax/and=] [=syntax/unary_expression=]

    | [=syntax/binary_or_expression=] [=syntax/or=] [=syntax/unary_expression=]

    | [=syntax/binary_xor_expression=] [=syntax/xor=] [=syntax/unary_expression=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>expression</dfn> :

    | [=syntax/relational_expression=]

    | [=syntax/short_circuit_or_expression=] [=syntax/or_or=] [=syntax/relational_expression=]

    | [=syntax/short_circuit_and_expression=] [=syntax/and_and=] [=syntax/relational_expression=]

    | [=syntax/bitwise_expression=]
</div>


# Statements # {#statements}

Statements are program fragments that control its execution.
Statements are generally executed in sequential order; however,
[[#control-flow|control flow statements]] may cause a program to execute in
non-sequential order.

## Compound Statement ## {#compound-statement-section}

A <dfn>compound statement</dfn> is a brace-enclosed sequence of zero or more statements.
When a [=declaration=] is one of those statements, its [=identifier=] is [=in scope=]
from the start of the next statement until the end of the compound statement.

<div class='syntax' noexport='true'>
  <dfn for=syntax>compound_statement</dfn> :

    | [=syntax/brace_left=] [=syntax/statement=] * [=syntax/brace_right=]
</div>

There are two special forms of compound statement:
* a [=syntax/continuing_compound_statement=] forms the body of a [[#continuing-statement|continuing]] statement,
     and allows an optional [[#break-if-statement|break-if]] statement at the end.
* a [=syntax/case_compound_statement=] forms the body of a `case` or `default` clause in a [[#switch-statement|switch]] statement,
     and allows an optional [=syntax/fallthrough_statement|fallthrough=] statement at the end.

## Assignment Statement ## {#assignment}

An <dfn noexport dfn-for="statement">assignment</dfn> evaluates an expression,
and optionally stores it in memory (thus updating the contents of a variable).


<div class='syntax' noexport='true'>
  <dfn for=syntax>assignment_statement</dfn> :

    | [=syntax/lhs_expression=] ( [=syntax/equal=] | [=syntax/compound_assignment_operator=] ) [=syntax/expression=]

    | [=syntax/underscore=] [=syntax/equal=] [=syntax/expression=]
</div>


The text to the left of the operator token is the <dfn noexport>left-hand side</dfn>,
and the
expression to the right of the operator token is the <dfn noexport>right-hand side</dfn>.

### Simple Assignment ### {#simple-assignment-section}

An [=statement/assignment=] is a <dfn noexport>simple assignment</dfn> when the
[=left-hand side=] is an expression, and the operator is the [=syntax/equal=] token.
In this case the value of the [=right-hand side=] is written to the memory referenced by the left-hand side.

<table class='data'>
  <thead>
    <tr><th style="width:40%">Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="updating assignment">
    <td>|e|: |T|,<br>
        |T| is a [=constructible=] type,<br>
        |r|: ref<|AS|,|T|,|AM|>,<br>
        |AS| is a writable [=address space=],<br>
        [=access mode=] |AM| is [=access/write=] or [=access/read_write=]<br>
    <td class="nowrap">|r| = |e|
    <td>Evaluates |e|, evaluates |r|, then writes the value computed for |e| into
        the [=memory locations=] referenced by |r|.
        Note: if the reference is an [=invalid memory reference=], the write
        may not execute, or may write to a different memory location than
        expected.
</table>

In the simplest case, the left hand side is the name of a variable.
See [[#forming-references-and-pointers]] for other cases.

    <div class='example wgsl' heading='Assignments'>
      <xmp highlight='rust'>
        struct S {
            age: i32,
            weight: f32
        }
        var<private> person: S;

        fn f() {
            var a: i32 = 20;
            a = 30;           // Replace the contents of 'a' with 30.

            person.age = 31;  // Write 31 into the age field of the person variable.

            var uv: vec2<f32>;
            uv.y = 1.25;      // Place 1.25 into the second component of uv.

            let uv_x_ptr: ptr<function,f32> = &uv.x;
            *uv_x_ptr = 2.5;   // Place 2.5 into the first component of uv.

            var friend: S;
            // Copy the contents of the 'person' variable into the 'friend' variable.
            friend = person;
        }
      </xmp>
    </div>

### Phony Assignment ### {#phony-assignment-section}

An [=statement/assignment=] is a <dfn noexport>phony assignment</dfn> when the
[=left-hand side=] is an underscore token.
In this case the [=right-hand side=] is evaluated, and then ignored.

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="phony-assignment">
    <td>|e|: |T|,<br>
        |T| is [=constructible=], a [=pointer type=], a [=texture=] type, or a [=sampler=] type
    <td class="nowrap">_ = |e|
    <td>Evaluates |e|.

        Note: The resulting value is not stored.
        The `_` token is not an identifier, and therefore cannot be used in an expression.
</table>

A phony-assignment is useful for:
* Calling a function that returns a value, but clearly expressing that the resulting value
    is not needed.
* [=statically accessed|Statically accessing=] a variable, thus establishing it as a part of
    the [=resource interface of a shader|shader's resource interface=].

    Note: A buffer variable's store type may not be constructible, e.g. it contains an atomic type, or a runtime-sized array.
    In these cases, use a pointer to the variable's contents instead.

<div class='example wgsl global-scope' heading='Using phony-assignment to throw away an un-needed function result'>
  <xmp highlight=rust>
    var<private> counter: i32;

    fn increment_and_yield_previous() -> i32 {
      let previous = counter;
      counter = counter + 1;
      return previous;
    }

    fn user() {
      // Increment the counter, but don't use the result.
      _ = increment_and_yield_previous();
    }
  </xmp>
</div>


<div class='example wgsl global-scope' heading='Using phony-assignment to occupy bindings without using them'>
  <xmp highlight=rust>
    struct BufferContents {
        counter: atomic<u32>,
        data: array<vec4<f32>>
    }
    @group(0) @binding(0) var<storage> buf: BufferContents;
    @group(0) @binding(1) var t: texture_2d<f32>;
    @group(0) @binding(2) var s: sampler;

    @fragment
    fn shade_it() -> @location(0) vec4<f32> {
      // Declare that buf, t, and s are part of the shader interface, without
      // using them for anything.
      _ = &buf;
      _ = t;
      _ = s;
      return vec4<f32>();
    }
  </xmp>
</div>

### Compound assignment ### {#compound-assignment-sec}

An [=statement/assignment=] is a <dfn noexport>compound assignment</dfn> when the
[=left-hand side=] is an expression, and the operator is one of the [=syntax/compound_assignment_operators=].

<div class='syntax' noexport='true'>
  <dfn for=syntax>compound_assignment_operator</dfn> :

    | [=syntax/plus_equal=]

    | [=syntax/minus_equal=]

    | [=syntax/times_equal=]

    | [=syntax/division_equal=]

    | [=syntax/modulo_equal=]

    | [=syntax/and_equal=]

    | [=syntax/or_equal=]

    | [=syntax/xor_equal=]

    | [=syntax/shift_right_equal=]

    | [=syntax/shift_left_equal=]
</div>

The type requirements, semantics, and behavior of each statement is defined as if
the compound assignment expands as in the following table, except that the reference expression |e1| is evaluated only once.

<table class='data'>
  <thead>
    <tr><th>Statement<th>Expansion
  </thead>
<tr algorithm="add-assign">
    <td class="nowrap">|e1| += |e2|
    <td>|e1| = |e1| + (|e2|)
<tr algorithm="subtract-assign">
    <td class="nowrap">|e1| -= |e2|
    <td>|e1| = |e1| - (|e2|)
<tr algorithm="multiply-assign">
    <td class="nowrap">|e1| *= |e2|
    <td>|e1| = |e1| * (|e2|)
<tr algorithm="divide-assign">
    <td class="nowrap">|e1| /= |e2|
    <td>|e1| = |e1| / (|e2|)
<tr algorithm="modulus-assign">
    <td class="nowrap">|e1| %= |e2|
    <td>|e1| = |e1| % (|e2|)
<tr algorithm="bitwise-and-assign">
    <td class="nowrap">|e1| &= |e2|
    <td>|e1| = |e1| & (|e2|)
<tr algorithm="bitwise-or-assign">
    <td class="nowrap">|e1| |= |e2|
    <td>|e1| = |e1| | (|e2|)
<tr algorithm="bitwise-xor-assign">
    <td class="nowrap">|e1| ^= |e2|
    <td>|e1| = |e1| ^ (|e2|)
<tr algorithm="bitwise-shiftright-assign">
    <td class="nowrap">|e1| >>= |e2|
    <td>|e1| = |e1| >> (|e2|)
<tr algorithm="bitwise-shiftleft-assign">
    <td class="nowrap">|e1| <<= |e2|
    <td>|e1| = |e1| << (|e2|)
</table>

Note: The syntax does not allow a [=compound assignment=] to also be a [=phony assignment=].

Note: Even though the reference |e1| is evaluated once, its underlying memory is accessed twice:
first a [=read access=] gets the old value, and then a [=write access=] stores the updated value.

<div class='example wgsl global-scope' heading="Compound assignment">
  <xmp highlight='rust'>
    var<private> next_item: i32 = 0;

    fn advance_item() -> i32 {
       next_item += 1;   // Adds 1 to next_item.
       return next_item - 1;
    }

    fn bump_item() {
      var data: array<f32,10>;
      next_item = 0;
      // Adds 5.0 to data[0], calling advance_item() only once.
      data[advance_item()] += 5.0;
      // next_item will be 1 here.
    }

    fn precedence_example() {
      var value = 1;
      // The right-hand side of a compound assignment is its own expression.
      value *= 2 + 3; // Same as value = value * (2 + 3);
      // 'value' now holds 5.
    }
  </xmp>
</div>

Note: A compound assignment can rewritten as different WGSL code that uses a [=simple assignment=] instead.
The idea is to use a pointer to hold the result of evaluating the reference once.

<p class="note" algorithm="translation compound assignment not vector component">For example,
when |e1| is *not* a reference to a component inside a vector, then
|e1|` += `|e2| can be rewritten as
`{let p = &(`|e1|`); *p = *p + (`|e2|`);}`,
where the identifier `p` is chosen to be different from all other identifiers in the program.
</p>

<p class="note" algorithm="translation compound assignment vector component">When
|e1| is a reference to a component inside a vector, the above technique
needs to be modified because WGSL does not allow [[#address-of-expr|taking the address]] in that case.
For example, if |ev| is a reference to a vector, the statement |ev|`[`|c|`] += ` |e2|
can be rewritten as `{let p = &(`|ev|`); let c0 = ` |c|`; (*p)[c0] = (*p)[c0] + (`|e2|`);}`, where
identifiers `c0` and `p` are chosen to be different from all other identifiers in the program.
</p>

## Increment and Decrement Statements ## {#increment-decrement}

An <dfn noexport>increment statement</dfn> adds 1 to the contents of a variable.
A <dfn noexport>decrement statement</dfn> subtracts 1 from the contents of a variable.

<div class='syntax' noexport='true'>
  <dfn for=syntax>increment_statement</dfn> :

    | [=syntax/lhs_expression=] [=syntax/plus_plus=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>decrement_statement</dfn> :

    | [=syntax/lhs_expression=] [=syntax/minus_minus=]
</div>

The expression [=shader-creation error|must=] evaluate to a reference with an [=integer scalar=] [=store type=] and [=access/read_write=] [=access mode=].

<table class='data'>
  <thead>
    <tr><th>Precondition<th>Statement<th>Description
  </thead>
  <tr algorithm="increment statement">
    <td class="nowrap">|r| : ref&lt;|AS|,|T|,[=access/read_write=]&gt;,<br>
        |T| is [=integer scalar=]<br>
    <td class="nowrap">|r|`++`
    <td>Adds 1 to the contents of memory referenced by |r|.
        <br>Same as |r| += |T|(1)
  <tr algorithm="decrement statement">
    <td class="nowrap">|r| : ref&lt;|AS|,|T|,[=access/read_write=]&gt;,<br>
        |T| is [=integer scalar=]<br>
    <td class="nowrap">|r|`--`
    <td>Subtracts 1 from the contents of memory referenced by |r|.
        <br>Same as |r| -= |T|(1)
</table>

    <div class='example wgsl' heading='Increment and decrement'>
      <xmp highlight='rust'>
        fn f() {
            var a: i32 = 20;
            a++;
            // Now a contains 21
            a--;
            // Now a contains 20
        }
      </xmp>
    </div>

## Control Flow ## {#control-flow}

Control flow statements may cause the program to execute in non-sequential order.

### If Statement ### {#if-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>if_statement</dfn> :

    | [=syntax/if=] [=syntax/expression=] [=syntax/compound_statement=] ( [=syntax/else=] [=syntax/else_statement=] ) ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>else_statement</dfn> :

    | [=syntax/compound_statement=]

    | [=syntax/if_statement=]
</div>

An <dfn noexport dfn-for="statement">if</dfn> statement conditionally executes at most one [=compound statement=] based on
the evaluation of the condition expressions.

The `if` statements in WGSL use an if/else if/else structure, that contains a single required
`if` clause, zero or more `else if` clauses and a single optional `else` clause.

[=Type rule precondition=]:
Each of the expressions for the `if` and `else if` clause conditions [=shader-creation error|must=] be scalar boolean expressions.

An `if` statement is executed as follows:
* The condition associated with the `if` clause is evaluated.
    If the result is `true`,
    control transfers to the first compound statement (immediately after the parenthesized condition expression).
* Otherwise, the condition of the next `else if` clause in textual order (if one exists) is evaluated
     and, if the result is `true`, control transfers to the associated compound statement.
     * This behavior is repeated for all `else if` clauses until one of the conditions evaluates to `true`.
* If no condition evaluates to `true`, then control transfers to the compound statement
    associated with the `else` clause (if it exists).

### Switch Statement ### {#switch-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>switch_statement</dfn> :

    | [=syntax/switch=] [=syntax/expression=] [=syntax/brace_left=] [=syntax/switch_body=] + [=syntax/brace_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>switch_body</dfn> :

    | [=syntax/case=] [=syntax/case_selectors=] [=syntax/colon=] ? [=syntax/case_compound_statement=]

    | [=syntax/default=] [=syntax/colon=] ? [=syntax/case_compound_statement=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>case_selectors</dfn> :

    | [=syntax/expression=] ( [=syntax/comma=] [=syntax/expression=] ) * [=syntax/comma=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>case_compound_statement</dfn> :

    | [=syntax/brace_left=] [=syntax/statement=] * [=syntax/fallthrough_statement=] ? [=syntax/brace_right=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>fallthrough_statement</dfn> :

    | [=syntax/fallthrough=] [=syntax/semicolon=]
</div>

A <dfn noexport dfn-for="statement">switch</dfn> statement transfers control to one of a set of case clauses, or to the `default` clause,
depending on the evaluation of a selector expression.

If the selector value equals a value in a case selector list, then control is transferred to
the body of that case clause.
The expressions in the [=syntax/case_selectors=] [=shader-creation error|must=]
be [=creation-time expressions=].
If the selector value does not equal any of the case selector values, then control is
transferred to the `default` clause.

Each switch statement [=shader-creation error|must=] have exactly one default clause.

[=Type rule precondition=]:
For a single switch statement, the selector expression and all case selector expressions [=shader-creation error|must=] be of the same [=integer scalar=] type.

A literal value [=shader-creation error|must not=] appear more than once in the case selectors for a switch statement.

Note: The value of the literal is what matters, not the spelling.
For example `0` and `0x0000` both denote the zero value.

When control reaches the end of a case body, control normally transfers to the first statement
after the switch statement.
Alternately, executing a <dfn noexport dfn-for="statement">fallthrough</dfn> statement
transfers control to the body of the next case clause or
default clause, whichever appears next in the switch body.
A `fallthrough` statement [=shader-creation error|must not=] appear as the last statement in the last clause of a switch.
When a [=declaration=] appears in a case body, its [=identifier=] is [=in scope=] from
the start of the next statement until the end of the case body.

Note: Identifiers declared in a case body are not [=in scope=] of case bodies
which are reachable via a `fallthrough` statement.

<div class='example wgsl function-scope' heading='WGSL Switch'>
  <xmp highlight='rust'>
    var a : i32;
    let x : i32 = generateValue();
    switch x {
      case 0: {      // the colon is optional
        a = 1;
      }
      default {      // the default needn't appear last
        a = 2;
      }
      case 1, 2 {    // multiple selector values can be used
        a = 3;       // a will be overridden in the next case
        fallthrough;
      }
      case 3 {
        a = 4;
      }
    }
  </xmp>
</div>

### Loop Statement ### {#loop-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>loop_statement</dfn> :

    | [=syntax/loop=] [=syntax/brace_left=] [=syntax/statement=] * [=syntax/continuing_statement=] ? [=syntax/brace_right=]
</div>

A <dfn noexport dfn-for="statement">loop</dfn> statement repeatedly executes a <dfn noexport>loop body</dfn>;
the loop body is specified as a [=compound statement=].
Each execution of the loop body is called an <dfn noexport>iteration</dfn>.

The [=identifier=] of a [=declaration=] in a loop is [=in scope=] from the start of the
next statement until the end of the loop body.
The declaration is executed each time it is reached, so each new iteration
creates a new instance of the variable or constant, and re-initializes it.

This repetition can be interrupted by a [=statement/break=], [=statement/return=], or
[=statement/discard=] statement.

Optionally, the last statement in the loop body may be a
[=statement/continuing=] statement.

Note: The loop statement is one of the biggest differences from other shader
languages.

This design directly expresses loop idioms commonly found in compiled code.
In particular, placing the loop update statements at the end of the loop body
allows them to naturally use values defined in the loop body.

<div class='example glsl' heading='GLSL Loop'>
  <xmp>
    int a = 2;
    for (int i = 0; i < 4; i++) {
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop">
  <xmp highlight='rust'>
    let a: i32 = 2;
    var i: i32 = 0;      // <1>
    loop {
      if i >= 4 { break; }

      a = a * 2;

      i++;
    }
  </xmp>
</div>
* <1> The initialization is listed before the loop.

<div class='example glsl' heading='GLSL Loop with continue'>
  <xmp>
    int a = 2;
    let int step = 1;
    for (int i = 0; i < 4; i += step) {
      if i % 2 == 0 continue;
      a *= 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop with continue">
  <xmp highlight='rust'>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }

      let step: i32 = 1;

      i = i + step;
      if i % 2 == 0 { continue; }

      a = a * 2;
    }
  </xmp>
</div>

<div class='example wgsl function-scope' heading="WGSL Loop with continue and continuing">
  <xmp highlight='rust'>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }

      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {   // <2>
        i = i + step;
      }
    }
  </xmp>
</div>
* <2> The continue construct is placed at the end of the `loop`

### For Statement ### {#for-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>for_statement</dfn> :

    | [=syntax/for=] [=syntax/paren_left=] [=syntax/for_header=] [=syntax/paren_right=] [=syntax/compound_statement=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>for_header</dfn> :

    | [=syntax/for_init=] ? [=syntax/semicolon=] [=syntax/expression=] ? [=syntax/semicolon=] [=syntax/for_update=] ?
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>for_init</dfn> :

    | [=syntax/variable_statement=]

    | [=syntax/increment_statement=]

    | [=syntax/decrement_statement=]

    | [=syntax/assignment_statement=]

    | [=syntax/func_call_statement=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>for_update</dfn> :

    | [=syntax/increment_statement=]

    | [=syntax/decrement_statement=]

    | [=syntax/assignment_statement=]

    | [=syntax/func_call_statement=]
</div>

The <dfn dfn-for="statement">for</dfn> statement takes the form
`for (initializer; condition; update_part) { body }` and is syntactic sugar on top of a [=statement/loop=] statement with the same `body`.
Additionally:
* If `initializer` is non-empty, it is executed inside an additional [=scope=] before the first [=iteration=].
    The scope of a declaration in the initializer extends to the end of the loop body.
* If `condition` is non-empty, it is checked at the beginning of the loop body and if unsatisfied then a [[#break-statement]] is executed.
* If `update_part` is non-empty, it becomes a [=statement/continuing=] statement at the end of the loop body.

[=Type rule precondition=]: The condition [=shader-creation error|must=] be of [=bool=] type.

The `initializer` of a for loop is executed once prior to executing the loop.
When a [=declaration=] appears in the initializer, its [=identifier=] is [=in scope=] until the end of the `body`.
Unlike declarations in the `body`, the declaration is not re-initialized each iteration.

The `condition`, `body` and `update_part` execute in that order to form a loop [=iteration=].
The `body` is a special form of [=compound statement=].
The identifier of a declaration in the `body` is [=in scope=] from the start of
the next statement until the end of the `body`.
The declaration is executed each time it is reached, so each new iteration
creates a new instance of the variable or constant, and re-initializes it.

<div class='example glsl' heading="For to Loop transformation">
  <xmp>
    for(var i: i32 = 0; i < 4; i++) {
      if a == 0 {
        continue;
      }
      a = a + 2;
    }
  </xmp>
</div>

Converts to:

<div class='example wgsl function-scope' heading="For to Loop transformation">
  <xmp highlight='rust'>
    { // Introduce new scope for loop variable i
      var i: i32 = 0;
      var a: i32 = 0;
      loop {
        if !(i < 4) {
          break;
        }

        if a == 0 {
          continue;
        }
        a = a + 2;

        continuing {
          i++;
        }
      }
    }
  </xmp>
</div>

### While Statement ### {#while-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>while_statement</dfn> :

    | [=syntax/while=] [=syntax/expression=] [=syntax/compound_statement=]
</div>

The <dfn noexport dfn-for="statement">while</dfn> statement is a kind of loop parameterized by a condition.
At the start of each loop [=iteration=], a boolean condition is evaluated.
If the condition is false, the while loop ends execution.
Otherwise, the rest of the iteration is executed.

[=Type rule precondition=]: The condition [=shader-creation error|must=] be of [=bool=] type.

A while loop can be viewed as syntactic sugar over either a [=statement/loop=] or [=statement/for=] statement.
The following statement forms are equivalent:
* `while`  *condition*  `{` *body_statements* `}`
* `loop { if !` *condition* `{break;}` *body_statements* `}`
* `for (;`  *condition* `;) {` *body_statements*  `}`

### Break Statement ### {#break-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>break_statement</dfn> :

    | [=syntax/break=]
</div>

A <dfn noexport dfn-for="statement">break</dfn> statement transfers control to immediately
after the body of the nearest-enclosing loop
or [=statement/switch=] statement, thus ending execution of the loop or switch statement.

A `break` statement [=shader-creation error|must=] only be used within [=statement/loop=], [=statement/for=], [=statement/while=], and [=statement/switch=] statements.

A `break` statement [=shader-creation error|must not=] be placed such that it would exit from a loop's [[#continuing-statement|continuing]] statement.
Use a [[#break-if-statement|break-if]] statement instead.

<div class='example wgsl function-scope' heading="WGSL Invalid loop break from a continuing clause">
  <xmp highlight='rust'>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        if i >= 4 { break; } // Invalid.  Use break-if instead.
      }
    }
  </xmp>
</div>

### Break-If Statement ### {#break-if-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>break_if_statement</dfn> :

    | [=syntax/break=] [=syntax/if=] [=syntax/expression=] [=syntax/semicolon=]
</div>

A <dfn noexport dfn-for="statement">break-if</dfn> statement evaluates a boolean condition;
If the condition is true, control is transferred to immediately after the body of the nearest-enclosing [=statement/loop=]
statement, ending execution of that loop.

[=Type rule precondition=]: The condition [=shader-creation error|must=] be of [=bool=] type.

Note: A break-if statement may only appear as the last statement in the body of a [[#continuing-statement|continuing]]
statement.

<div class='example wgsl function-scope' heading="WGSL Valid loop break-if from a continuing clause">
  <xmp highlight='rust'>
    var a: i32 = 2;
    var i: i32 = 0;
    loop {
      let step: i32 = 1;

      if i % 2 == 0 { continue; }

      a = a * 2;

      continuing {
        i = i + step;
        break if i >= 4;
      }
    }
  </xmp>
</div>

### Continue Statement ### {#continue-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>continue_statement</dfn> :

    | [=syntax/continue=]
</div>

A <dfn noexport dfn-for="statement">continue</dfn> statement transfers control in the nearest-enclosing [=statement/loop=]:

*  forward to the [=statement/continuing=] statement at the end of the body of that loop, if it exists.
*  otherwise backward to the first statement in the loop body, starting the next [=iteration=].

A `continue` statement [=shader-creation error|must=] only be used in a [=statement/loop=], [=statement/for=] or [=statement/while=] statement.
A `continue` statement [=shader-creation error|must not=] be placed such that it would transfer
control to an enclosing [=statement/continuing=] statement.
(It is a *forward* branch when branching to a `continuing` statement.)

A `continue` statement [=shader-creation error|must not=] be placed such that it would transfer
control past a declaration used in the targeted [=statement/continuing=] statement.

Note: A `continue` can only be used in a `continuing` statement if it is used for transferring control
flow within another loop nested in the `continuing` statement. That is, a `continue`
cannot be used to transfer control to the start of the currently executing `continuing` statement.

<div class='example wgsl function-scope expect-error' heading="Invalid continue bypasses declaration">
  <xmp highlight='rust'>
    var i: i32 = 0;
    loop {
      if i >= 4 { break; }
      if i % 2 == 0 { continue; } // <3>

      let step: i32 = 2;

      continuing {
        i = i + step;
      }
    }
  </xmp>
</div>
* <3> The `continue` is invalid because it bypasses the declaration of `step` used in the `continuing` construct

### Continuing Statement ### {#continuing-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>continuing_statement</dfn> :

    | [=syntax/continuing=] [=syntax/continuing_compound_statement=]
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>continuing_compound_statement</dfn> :

    | [=syntax/brace_left=] [=syntax/statement=] * [=syntax/break_if_statement=] ? [=syntax/brace_right=]
</div>

A <dfn dfn-for="statement">continuing</dfn> statement specifies a [=compound statement=] to be executed at the end of a loop [=iteration=].
The construct is optional.

The compound statement [=shader-creation error|must not=] contain a [=statement/return=] at any compound statement nesting level.

The compound statement [=shader-creation error|must not=] contain a [=statement/discard=] at any compound statement nesting level nor through function calls.
See [[#behaviors]] for a more formal description of this rule.

### Return Statement ### {#return-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>return_statement</dfn> :

    | [=syntax/return=] [=syntax/expression=] ?
</div>

A <dfn noexport dfn-for="statement">return</dfn> statement ends execution of the current function.
If the function is an [=entry point=], then the current shader invocation
is terminated.
Otherwise, evaluation continues with the next expression or statement after
the evaluation of the [=call site=] of the current function invocation.

If the function does not have a [=return type=], then the [=statement/return=] statement is
optional. If the return statement is provided for such a function, it [=shader-creation error|must not=]
supply a value.
Otherwise the expression [=shader-creation error|must=] be present, and is called the <dfn>return value</dfn>.
In this case the call site of this function invocation evaluates to the return value.
The type of the return value [=shader-creation error|must=] match the return type of the function.

### Discard Statement ### {#discard-statement}

A <dfn dfn-for="statement">discard</dfn> statement immediately ends execution of a fragment shader invocation and throws away the fragment.
The `discard` statement [=shader-creation error|must=] only be used in a [=fragment=] shader stage.

More precisely, executing a `discard` statement will:

* immediately terminate the current invocation, and
* prevent evaluation and generation of a [=return value=] for the [=entry point=], and
* prevent the current fragment from being processed downstream in the [=GPURenderPipeline=].

Only statements
executed prior to the `discard` statement will have observable effects.

Note: A `discard` statement may be executed by any
[=functions in a shader stage|function in a fragment stage=] and the effect is the same:
immediate termination of the invocation.

After a `discard` statement is executed, control flow is [[=uniform control flow|non-uniform=]] for the
duration of the entry point.

<div class='example wgsl' heading='Using the discard statement to throw away a fragment'>
  <xmp highlight='rust'>
  var<private> will_emit_color: bool = false;

  fn discard_if_shallow(pos: vec4<f32>) {
    if pos.z < 0.001 {
      // If this is executed, then the will_emit_color flag will
      // never be set to true.
      discard;
    }
    will_emit_color = true;
  }

  @fragment
  fn main(@builtin(position) coord_in: vec4<f32>)
    -> @location(0) vec4<f32>
  {
    discard_if_shallow(coord_in);

    // Set the flag and emit red, but only if the helper function
    // did not execute the discard statement.
    will_emit_color = true;
    return vec4<f32>(1.0, 0.0, 0.0, 1.0);
  }
  </xmp>
</div>

## Function Call Statement ## {#function-call-statement}

<div class='syntax' noexport='true'>
  <dfn for=syntax>func_call_statement</dfn> :

    | [=syntax/ident=] [=syntax/argument_expression_list=]
</div>

A function call statement executes a [=function call=].

Note: If the function [=return value|returns a value=], that value is ignored.

## Static Assertion Statement ## {#static-assert-statement}

A static assertion statement produces a [=shader-creation error=] if the
expression evaluates to `false`.
The expression [=shader-creation error|must=] be a [=creation-time expression=].
The statement can satisfy [=statically accessed|static access=] requirements in
a shader, but otherwise has no effect on the compiled shader.
This statement can be used at [=module scope=] and within [=function scope|functions=].

<div class='syntax' noexport='true'>
  <dfn for=syntax>static_assert_statement</dfn> :

    | [=syntax/staticAssert=] [=syntax/expression=]
</div>

<div class='example wgsl global-scope' heading="Static assertion examples">
  <xmp highlight='rust'>
    const x = 1;
    const y = 2;
    staticAssert x < y; // valid at module-scope.
    staticAssert(y != 0); // parentheses are optional.

    fn foo() {
      const z = x + y - 2;
      staticAssert z > 0; // valid in functions.
      let a  = 3;
      staticAssert a != 0; // invalid, the expresion must be a creation-time expression.
    }
  </xmp>
</div>

## Statements Grammar Summary ## {#statements-summary}

The [=syntax/statement=] rule matches statements that can be used in most places inside a function body.

<div class='syntax' noexport='true'>
  <dfn for=syntax>statement</dfn> :

    | [=syntax/semicolon=]

    | [=syntax/return_statement=] [=syntax/semicolon=]

    | [=syntax/if_statement=]

    | [=syntax/switch_statement=]

    | [=syntax/loop_statement=]

    | [=syntax/for_statement=]

    | [=syntax/while_statement=]

    | [=syntax/func_call_statement=] [=syntax/semicolon=]

    | [=syntax/variable_statement=] [=syntax/semicolon=]

    | [=syntax/break_statement=] [=syntax/semicolon=]

    | [=syntax/continue_statement=] [=syntax/semicolon=]

    | [=syntax/discard=] [=syntax/semicolon=]

    | [=syntax/assignment_statement=] [=syntax/semicolon=]

    | [=syntax/compound_statement=]

    | [=syntax/increment_statement=] [=syntax/semicolon=]

    | [=syntax/decrement_statement=] [=syntax/semicolon=]

    | [=syntax/static_assert_statement=] [=syntax/semicolon=]
</div>

Additionally, certain statements may only be used in very specific contexts:
* [=syntax/break_if_statement=]
* [=syntax/case_compound_statement=]
* [=syntax/continuing_compound_statement=]
* [=syntax/fallthrough_statement=]

## Statements Behavior Analysis ## {#behaviors}

### Rules ### {#behaviors-rules}

Some statements affecting control-flow are only valid in some contexts.
For example, [=statement/fallthrough=] is invalid outside of a [=statement/switch=],
and [=statement/continue=] is invalid outside of a [=statement/loop=], [=statement/for=], or [=statement/while=].
Additionally, the uniformity analysis (see [[#uniformity]]) needs to know when control flow can exit a statement in multiple different ways.

Both goals are achieved by a system for summarizing execution behaviors of statements and expressions. Behavior analysis maps each statement and expression to the set of possible ways execution proceeds after evaluation of the statement or expression completes.
As with type analysis for values and expressions, behavior analysis proceeds bottom up: first determine behaviors for certain basic statements, and then determine behavior for higher level constructs by applying combining rules.

A <dfn export>behavior</dfn> is a set, whose elements may be:
- Return
- Discard
- Break
- Continue
- Fallthrough
- Next

Each of those correspond to a way to exit a compound statement: either through a keyword, or by falling to the next statement ("Next").

We note "*s*: *B*" to say that *s* respects the rules regarding behaviors, and has [=behavior=] *B*.

For each function:
- Its body [=shader-creation error|must=] be a valid statement by these rules.
- If the function has a return type, the [=behavior=] of its body [=shader-creation error|must=] be one of {Return} or {Return, Discard}.
- Otherwise, the [=behavior=] of its body [=shader-creation error|must=] be a subset of {Next, Return, Discard}.

We assign a [=behavior=] to each function: it is its body's [=behavior=] (treating the body as a regular statement), with any "Return" replaced by "Next".
As a consequence of the rules above, a function behavior is always one of {}, {Next}, {Discard}, or {Next, Discard}.

Similarly, we assign a [=behavior=] to each expression, since expressions can include function calls, which can discard.
Like functions, expression behaviors are always one of {}, {Next}, {Discard}, or {Next, Discard}.

Note: There is currently no valid program with an expression that does not have Next in its [=behavior=].
The reason is that only functions without a return type can have such a [=behavior=], and there is no compound expression in which such a function can be called.

<table class='data'>
  <caption>Rules for analyzing and validating the behaviors of statements</caption>
  <thead>
    <tr><th>Statement<th>Preconditions<th>Resulting behavior
  </thead>
  <tr>
    <td class="nowrap">*empty statement*
    <td>
    <td class="nowrap">{Next}
  <tr algorithm="braced statement behavior">
    <td class="nowrap">{|s|}
    <td>|s|: |B|
    <td class="nowrap">|B|
  <tr algorithm="statement sequence behavior with next">
    <td class="nowrap" rowspan=2>|s1| |s2|

        Note: |s1| often ends in a semicolon.

    <td class="nowrap">|s1|: |B1|<br>
        Next in |B1|<br>
        |s2|: |B2|
    <td class="nowrap">(|B1|&#x2216;{Next}) &cup; |B2|
  <tr algorithm="statement sequence behavior without next">
    <td class="nowrap">|s1|: |B1|<br>
        Next not in |B1|<br>
        |s2|: <var ignore>B2</var>
    <td class="nowrap">|B1|
  <tr algorithm="variable declaration behavior">
    <td class="nowrap">var x:T;
    <td>
    <td>{Next}
  <tr algorithm="let declaration behavior">
    <td class="nowrap">let x = |e|;
    <td class="nowrap">|e|: |B|
    <td>|B|
  <tr algorithm="initialized variable declaration behavior">
    <td class="nowrap">var x = |e|;
    <td class="nowrap">|e|: |B|
    <td>|B|
  <tr algorithm="assignment behavior">
    <td class="nowrap">|x| = |e|;
    <td class="nowrap">|x|: |B1|<br>
      |e|: |B2|<br>
      |x| is not `_`
    <td>|B1| &cup; |B2|
  <tr algorithm="phony assignment behavior">
    <td class="nowrap">_ = |e|;
    <td class="nowrap">|e|: |B|
    <td>|B|
  <tr algorithm="function call statement behavior">
    <td class="nowrap">|f|(|e1|, ..., |en|);
    <td class="nowrap">|e1|: |B1|<br>
        ...<br>
        |en|: |Bn|<br>
        |f| has behavior |B|
    <td class="nowrap">|B| &cup; ((|B1| &cup; ... &cup; |Bn|)&#x2216;{Next})
  <tr algorithm="return behaviour">
    <td>return;
    <td>
    <td>{Return}
  <tr algorithm="return value behavior">
    <td class="nowrap">return |e|;
    <td class="nowrap">|e|: |B|<br>
    <td class="nowrap">(|B|&#x2216;{Next}) &cup; {Return}
  <tr algorithm="discard behaviour">
    <td>discard;
    <td>
    <td>{Discard}
  <tr algorithm="break behavior">
    <td>break;
    <td>
    <td>{Break}
  <tr algorithm="break if behavior">
    <td>break if |e|;
    <td class="nowrap">|e|: |B|
    <td>|B| &cup; {Break}
  <tr algorithm="continue behavior">
    <td>continue;
    <td>
    <td>{Continue}
  <tr algorithm="fallthrough behavior">
    <td>fallthrough;
    <td>
    <td>{Fallthrough}
  <tr algorithm="if statement behavior">
    <td class="nowrap">if |e| |s1| else |s2|
    <td class="nowrap">|e|: |B|<br>
        |s1|: |B1|<br>
        |s2|: |B2|
    <td class="nowrap">(|B|&#x2216;{Next}) &cup; |B1| &cup; |B2|
  <tr algorithm="loop with continuing without break behavior">
    <td class="nowrap" rowspan=2>loop {|s1| continuing {|s2|}}
    <td class="nowrap">|s1|: |B1|<br>
        |s2|: |B2|<br>
        None of {Continue, Return, Discard} are in |B2|<br>
        Break is not in (|B1| &cup; |B2|)
    <td class="nowrap">(|B1| &cup; |B2|)&#x2216;{Continue, Next}
  <tr algorithm="loop with continuing with break behavior">
    <td class="nowrap">|s1|: |B1|<br>
        |s2|: |B2|<br>
        None of {Continue, Return, Discard} are in |B2|<br/>
        Break is in (|B1| &cup; |B2|)
    <td class="nowrap">(|B1| &cup; |B2| &cup; {Next})&#x2216;{Break, Continue}
  <tr algorithm="switch behavior">
    <td class="nowrap" rowspan=2>switch |e|  {case <var ignore>c1</var>: |s1| ... case <var ignore>cn</var>: |sn|}
    <td class="nowrap">|e|: |B|<br>
        |s1|: |B1|<br>
        ...<br>
        |sn|: |Bn|<br>
        Fallthrough is not in |Bn|<br>
        Break is not in (|B1| &cup; ... &cup; |Bn|)
    <td class="nowrap">((|B|&#x2216;{Next}) &cup; |B1| &cup; ... &cup; |Bn|)&#x2216;{Fallthrough}
  <tr algorithm="switch with break behavior">
    <td class="nowrap">|e|: |B|<br>
        |s1|: |B1|<br>
        ...<br>
        |sn|: |Bn|<br>
        Fallthrough is not in |Bn|<br>
        Break is in (|B1| &cup; ... &cup; |Bn|)
    <td class="nowrap">(|B| &cup; |B1| &cup; ... &cup; |Bn| &cup; {Next})&#x2216;{Break, Fallthrough}
</table>

Note: The empty statement case occurs when a `loop` has an empty body, or when a `for` loop lacks an initialization or update statement.

For the purpose of this analysis:
- `for` loops get desugared (see [[#for-statement]])
- `while` loops get desugared (see [[#while-statement]])
- `loop {s}` is treated as `loop {s continuing {}}`
- `if` statements without an `else` branch are treated as if they had an empty else branch (which adds Next to their [=behavior=])
- `if` statements with `else if` branches are treated as if they were nested simple `if/else` statements
- a [=syntax/switch_body=] starting with `default` behaves just like a [=syntax/switch_body=] starting with `case _:`

<table class='data'>
  <caption>Rules for analyzing and validating the behaviors of expressions</caption>
  <thead>
    <tr><th>Expression<th>Preconditions<th>Resulting behavior
  </thead>
  <tr algorithm="function call behavior">
    <td class="nowrap">|f|(|e1|, ..., |en|)
    <td class="nowrap">|e1|: |B1|<br>
        ...<br>
        |en|: |Bn|<br>
        |f| has behavior |B|
    <td class="nowrap">|B| &cup; ((|B1| &cup; ... &cup; |Bn|)&#x2216;{Next})
  <tr algorithm="literal expression behavior">
    <td class="nowrap">Any literal
    <td>
    <td class="nowrap">{Next}
  <tr algorithm="variable expression behavior">
    <td class="nowrap">Any variable reference
    <td>
    <td class="nowrap">{Next}
  <tr algorithm="array-like index expression behavior">
    <td class="nowrap">|e1|[|e2|]
    <td class="nowrap">|e1|: |B1|<br>
        |e2|: |B2|
    <td class="nowrap">|B1| &cup; |B2|
  <tr algorithm="structure member expression behavior">
    <td class="nowrap">|e|.field
    <td class="nowrap">|e|: |B|
    <td class="nowrap">|B|
  <tr algorithm="short-circuiting or expression behavior">
    <td class="nowrap">|e1| || |e2|
    <td class="nowrap">|e1|: |B1|<br>
        |e2|: |B2|
    <td class="nowrap">|B1| &cup; |B2|
  <tr algorithm="short-circuiting and expression behavior">
    <td class="nowrap">|e1| && |e2|
    <td class="nowrap">|e1|: |B1|<br>
        |e2|: |B2|
    <td class="nowrap">|B1| &cup; |B2|
</table>

Each [=built-in function=] has a [=behavior=] of {Next}.
And each operator application not listed in the table above has the same [=behavior=] as if it were a function call with the same operands and with a function's [=behavior=] of {Next}.

A [=shader-creation error=] results if behavior analysis fails:
- Behavior analysis [=shader-creation error|must=] be able to determine a non-empty [=behavior=] for each statement, expression, and function.
- The function behaviors [=shader-creation error|must=] satisfy the rules given above.
- The behaviors of compute and vertex entry points [=shader-creation error|must not=] contain Discard.

### Notes ### {#behaviors-notes}

This section is informative, non-normative.

Here is the full list of ways that these rules can cause a program to be rejected (this is just restating information already listed above):
- The body of a function (treated as a regular statement) has a behavior not included in {Next, Return, Discard}.
- The body of a function with a return type has a behavior which is neither {Return} nor {Return, Discard}.
- The behavior of a continuing block contains any of Continue, Return, or Discard.
- The behavior of the last case of a switch contains Fallthrough.
- The behavior of a compute or vertex entry point function contains Discard.
- Some obviously infinite loops have an empty behaviour set, and are therefore invalid.

This analysis can be run in linear time, by analyzing the call-graph bottom-up (since the behavior of a function call can depend on the function's code).

### Examples ### {#behaviors-examples}

Here are some examples showing this analysis in action:
<div class='example wgsl expect-error' heading='Trivially dead code is allowed'>
   <xmp highlight='rust'>
    fn simple() -> i32 {
      var a: i32;
      return 0;  // Behavior: {Return}
      a = 1;     // Valid, statically unreachable code.
                 //   Statement behavior: {Next}
                 //   Overall behavior (due to sequential statements): {Return}
      return 2;  // Valid, statically unreachable code. Behavior: {Return}
    } // Function behaviour: {Return}
   </xmp>
</div>

<div class='example wgsl expect-error' heading='Compound statements are supported'>
   <xmp highlight='rust'>
    fn nested() -> i32 {
      var a: i32;
      {             // The start of a compound statement.
        a = 2;      // Behavior: {Next}
        return 1;   // Behavior: {Return}
      }             // The compound statement as a whole has behavior {Return}
      a = 1;        // Valid, statically unreachable code.
                    //   Statement behavior: {Next}
                    //   Overall behavior (due to sequential statements): {Return}
      return 2;     // Valid, statically unreachable code. Behavior: {Return}
    }
   </xmp>
</div>

<div class='example wgsl' heading='if/then behaves as if there is an empty else'>
   <xmp highlight='rust'>
    fn if_example() {
      var a: i32 = 0;
      loop {
        if a == 5 {
          break;      // Behavior: {Break}
        }             // Behavior of the whole if compound statement: {Break, Next},
                      //   as the if has an implicit empty else
        a = a + 1;    // Valid, as the previous statement had "Next" in its behavior
      }
    }
   </xmp>
</div>

<div class='example wgsl expect-error' heading='if/then/else has the behavior of both sides'>
   <xmp highlight='rust'>
    fn if_example() {
      var a: i32 = 0;
      loop {
        if a == 5 {
          break;      // Behavior: {Break}
        } else {
          continue;   // Behavior: {Continue}
        }             // Behavior of the whole if compound statement: {Break, Continue}
        a = a + 1;    // Valid, statically unreachable code.
                      //   Statement behavior: {Next}
                      //   Overall behavior: {Break, Continue}
      }
    }
   </xmp>
</div>

<div class='example wgsl' heading='if/else if/else behaves like a nested if/else'>
   <xmp highlight='rust'>
    fn if_example() {
      var a: i32 = 0;
      loop {
        // if e1 s1 else if e2 s2 else s3
        // is identical to
        // if e1 else { if e2 s2 else s3 }
        if a == 5 {
          break;      // Behavior: {Break}
        } else if a == 42 {
          continue;   // Behavior: {Continue}
        } else {
          return;     // Behavior {Return}
        }             // Behavior of the whole if compound statement:
                      //   {Break, Continue, Return}
      }               // Behavior of the whole loop compound statement {Next, Return}
    }                 // Behavior of the whole function {Next}
   </xmp>
</div>

<div class='example wgsl' heading='Break in switch becomes Next'>
   <xmp highlight='rust'>
    fn switch_example() {
      var a: i32 = 0;
      switch a {
        default: {
          break;   // Behavior: {Break}
        }
      }            // Behavior: {Next}, as switch replaces Break by Next
      a = 5;       // Valid, as the previous statement had Next in its behavior
    }
   </xmp>
</div>

<div class='example wgsl' heading='Obviously infinite loops'>
   <xmp highlight='rust'>
    fn invalid_infinite_loop() {
      loop { }     // Behavior: { }.  Invalid because it's empty.
    }
   </xmp>
</div>

<div class='example wgsl' heading='A conditional continue with continuing statement'>
   <xmp highlight='rust'>
    fn conditional_continue() {
      var a: i32;
      loop {
        if a == 5 { break; } // Behavior: {Break, Next}
        if a % 2 == 1 {      // Valid, as the previous statement has Next in its behavior
          continue;          // Behavior: {Continue}
        }                    // Behavior: {Continue, Next}
        a = a * 2;           // Valid, as the previous statement has Next in its behavior
        continuing {         // Valid as the continuing statement has behavior {Next}
                             //  which does not include any of:
                             //  {Break, Continue, Discard, Return}
          a = a + 1;
        }
      }                      // The loop as a whole has behavior {Next},
                             //  as it absorbs "Continue" and "Next",
                             //  then replaces "Break" with "Next"
    }
   </xmp>
</div>

<div class='example wgsl' heading='A redundant continue with continuing statement'>
   <xmp highlight='rust'>
    fn redundant_continue_with_continuing() {
      var a: i32;
      loop {
        if a == 5 { break; }
        continue;   // Valid. This is redundant, branching to the next statement.
        continuing {
          a = a + 1;
        }
      }
    }
   </xmp>
</div>

<div class='example wgsl' heading='A continue at the end of a loop body'>
   <xmp highlight='rust'>
    fn continue_end_of_loop_body() {
      for (var i: i32 = 0; i < 5; i++ ) {
        continue;   // Valid. This is redundant,
                    //   branching to the end of the loop body.
      }             // Behavior: {Next},
                    //   as loops absorb "Continue",
                    //   and "for" loops always add "Next"
    }
   </xmp>
</div>
`for` loops desugar to `loop` with a conditional break. As shown in a previous example, the conditional break has [=behavior=] {Break, Next}, which leads to adding "Next" to the loop's [=behavior=].

<div class='example wgsl expect-error' heading='Effect of a function that discards unconditionally'>
   <xmp highlight='rust'>
    fn always_discard() {
      discard;
    }                   // The whole function has behavior {Discard}
    fn code_after_discard() {
      var a: i32;
      always_discard(); // Behavior: {Discard}
      a = a + 1;        // Valid, statically unreachable code.
                        //   Statement behavior: {Next}
                        //   Overall behavior: {Discard}
    }
   </xmp>
</div>

<div class='example wgsl' heading='Effect of a function that discards conditionally'>
   <xmp highlight='rust'>
    fn sometimes_discard(a: i32) {
      if a {
        discard;        // Behavior: {Discard}
      }                 // Behavior: {Next, Discard}
    }                   // The whole function has behavior {Next, Discard}
    fn code_after_discard() {
      var a: i32;
      a = 42;
      sometimes_discard(a);  // Behavior: {Next, Discard}
      a = a + 1;             // Valid
    }                        // The whole function has behavior {Next, Discard}
   </xmp>
</div>

<div class='example wgsl expect-error' heading='return required in functions that have a return type'>
   <xmp highlight='rust'>
    fn missing_return () -> i32 {
      var a: i32 = 0;
      if a == 42 {
        return a;       // Behavior: {Return}
      }                 // Behavior: {Next, Return}
    }                   // Error: Next is invalid in the body of a
                        //   function with a return type
   </xmp>
</div>

<div class='example wgsl expect-error' heading='continue must be in a loop'>
   <xmp highlight='rust'>
    fn continue_out_of_loop () {
      var a: i32 = 0;
      if a > 0  {
        continue;       // Behavior: {Continue}
      }                 // Behavior: {Next, Continue}
    }                   // Error: Continue is invalid in the body of a function
   </xmp>
</div>
The same example would also be invalid for the same reason if `continue` was replaced by `break` or `fallthrough`.

# Functions # {#functions}

A <dfn dfn-for="function" noexport>function</dfn> performs computational work when invoked.

A function is invoked in one of the following ways:
* By evaluating a function call expression. See [[#function-call-expr]].
* By executing a function call statement. See [[#function-call-statement]].
* An [=entry point=] function is invoked by the WebGPU implementation to perform
    the work of a [=shader stage=] in a [=pipeline=]. See [[#entry-points]]

There are two kinds of functions:
* A [=built-in function=] is provided by the WGSL implementation,
    and is always available to a WGSL program.
    See [[#builtin-functions]].
* A <dfn noexport>user-defined function</dfn> is declared in a WGSL program.

## Declaring a User-defined Function ## {#function-declaration-sec}

A <dfn noexport>function declaration</dfn> creates a user-defined function, by specifying:
* An optional set of [=attributes=].
* The name of the function.
* The formal parameter list: an ordered sequence of zero
    or more [=formal parameter=] declarations,
    separated by commas, and
    surrounded by parentheses.
* An optional, possibly decorated, <dfn noexport>return type</dfn>.
* The <dfn noexport>function body</dfn>.
    This is the set of statements to be executed when the function is [=function call|called=].

A function declaration [=shader-creation error|must=] only occur at [=module scope=].
A function name is [=in scope=] for the entire program.

A <dfn noexport>formal parameter</dfn> [=declaration=] specifies an [=identifier=] name and a type for a value that [=shader-creation error|must=] be
provided when invoking the function.
A formal parameter may have attributes.
See [[#function-calls]].
The identifier is [=in scope=] until the end of the function.
Two formal parameters for a given function [=shader-creation error|must not=] have the same name.

Note: Some built-in functions may allow parameters to be [=abstract numeric types=];
however, this functionality is not currently supported for user-declared
functions.

The [=return type=], if specified, [=shader-creation error|must=] be [=constructible=].

<div class='syntax' noexport='true'>
  <dfn for=syntax>function_decl</dfn> :

    | [=syntax/attribute=] * [=syntax/function_header=] [=syntax/compound_statement=]
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>function_header</dfn> :

    | [=syntax/fn=] [=syntax/ident=] [=syntax/paren_left=] [=syntax/param_list=] ? [=syntax/paren_right=] ( [=syntax/arrow=] [=syntax/attribute=] * [=syntax/type_decl=] ) ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>param_list</dfn> :

    | ( [=syntax/param=] [=syntax/comma=] ) * [=syntax/param=] [=syntax/comma=] ?
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>param</dfn> :

    | [=syntax/attribute=] * [=syntax/variable_ident_decl=]
</div>

WGSL defines the following attributes that can be applied to function declarations:
 * the [=pipeline stage attributes=]: [=attribute/vertex=], [=attribute/fragment=], and [=attribute/compute=]
 * [=attribute/workgroup_size=]

WGSL defines the following attributes that can be applied to function
parameters and return types:
 * [=attribute/builtin=]
 * [=attribute/location=]

<div class='example wgsl' heading='Simple functions'>
  <xmp highlight='rust'>
    // Declare the add_two function.
    // It has two formal paramters, i and b.
    // It has a return type of i32.
    // It has a body with a return statement.
    fn add_two(i: i32, b: f32) -> i32 {
      return i + 2;  // A formal parameter is available for use in the body.
    }

    // A compute shader entry point function, 'main'.
    // It has no specified return type.
    // It invokes the ordinary_two function, and captures
    // the resulting value in the named value 'six'.
    @compute fn main() {
       let six: i32 = add_two(4, 5.0);
    }
  </xmp>
</div>

## Function Calls ## {#function-calls}

A <dfn noexport>function call</dfn> is a statement or expression which invokes a function.

The function containing the function call is the <dfn>calling function</dfn>, or <dfn noexport>caller</dfn>.
The function being invoked is the <dfn>called function</dfn>, or <dfn noexport>callee</dfn>.

The function call:
* Names the [=called function=], and
* Provides a parenthesized, comma-separated list of argument value expressions.

The function call [=shader-creation error|must=] supply the same number of argument values as there are
[=formal parameter|formal parameters=] in the [=called function=].
Each argument value [=shader-creation error|must=] evaluate to the same type as the corresponding formal
parameter, by position.

In summary, when calling a function:
1. Execution of the [=calling function=] is suspended.
2. The [=called function=] executes until it [=returns=].
3. Execution of the [=calling function=] resumes.

A called function <dfn>returns</dfn> as follows:
* A [=built-in function=] returns when its work has completed.
* A [=user-defined function=] with a [=return type=] returns when it executes a [=statement/return=] statement.
* A [=user-defined function=] with no [=return type=] returns when it executes a [=statement/return=] statement,
    or when execution reaches the end of its [=function body=].

In detail, when a function call is executed the following steps occur:
1. Function call argument values are evaluated.
    The relative order of evaluation is left-to-right.
2. Execution of the [=calling function=] is suspended.
    All [=function scope=] variables and constants maintain their current values.
3. If the called function is [=user-defined function|user-defined=],
    memory is allocated for each function scope variable in the called function.
    * Initialization occurs as described in [[#var-and-value]].
4. Values for the formal parameters of the called function are determined
    by matching the function call argument values by position.
    For example, in the body of the called function the first formal parameter will denote
    the value of the first argument at the [=call site=].
5. If the called function is [=user-defined function|user-defined=],
    control is transferred to the first statement in its [=function body|body=].
6. The called function is executed, until it [=returns=].
7. Control is transferred back to the calling function, and the called function's execution is
    unsuspended.
    If the called function [=return value|returns a value=], that value is supplied for the
    value of the function call expression.

Note: The current function will not resume execution if the called function or
any descendent called function executes a [=statement/discard=] statement.

The location of a function call is referred to as a <dfn noexport>call site</dfn>.
Call sites are a [=dynamic context=].
As such, the same textual location may represent multiple call sites.

## Creation-time Functions ## {#creation-time-funcs}

A function declared with a [=attribute/const=] attribute can be
evaluated at [=shader module creation|shader-creation time=].
These functions are called <dfn noexport>creation-time functions</dfn>.
Calls to these functions can part of [=creation-time expressions=].

It is a [=shader-creation error=] if the function contains any expressions that
are not [=creation-time expressions=], or any declarations that are not
[=creation-time constants=].

Note: The [=attribute/const=] attribute cannot be applied to user-declared functions.

<div class='example wgsl' heading='Creation-time functions'>
  <xmp>
    const first_one = firstLeadingBit(1234 + 4567); // Evaluates to 12
                                                    // first_one has the type i32, because
                                                    // firstLeadingBit cannot operate on
                                                    // AbstractInt

    @id(1) override x : i32;
    override y = firstLeadingBit(x); // Creation-time expressions can be
                                     // used in override expressions.
                                     // firstLeadingBit(x) is not a
                                     // creation-time expression in this context.

    fn foo() {
      var a : array<i32, firstLeadingBit(257)>; // Creation-time functions can be used in
                                                // creation-time expressions if all their
                                                // parameters are creation-time expressions.
    }
  </xmp>
</div>

## Restrictions on Functions ## {#function-restriction}

* A [=vertex=] shader [=shader-creation error|must=] return the `position` [=built-in output value=].
    See [[#builtin-values]].
* An entry point [=shader-creation error|must=] never be the target of a [=function call=].
* If a function has a return type, it [=shader-creation error|must=] be a [=constructible=] type.
* A [=formal parameter|function parameter=] [=shader-creation error|must=] one the following types:
    * a constructible type
    * a pointer type
    * a texture type
    * a sampler type
* Each function call argument [=shader-creation error|must=] evaluate to the type of the corresponding
    function parameter.
    * In particular, an argument that is a pointer [=shader-creation error|must=] agree with the formal parameter
        on [=address space=], [=store type=], and [=access mode=].
* For [=user-defined functions=], a parameter of pointer type [=shader-creation error|must=] be in one of
    the following address spaces:
    * [=address spaces/function=]
    * [=address spaces/private=]
    * [=address spaces/workgroup=]
* For [=built-in functions=], a parameter of pointer type [=shader-creation error|must=] be in one of
    the following address spaces:
    * [=address spaces/function=]
    * [=address spaces/private=]
    * [=address spaces/workgroup=]
    * [=address spaces/storage=]
* Each argument of pointer type to a [=user-defined function=] [=shader-creation error|must=] be one of:
    * An [[#address-of-expr|address-of expression]] of a
        [[#var-identifier-expr|variable identifier expression]]
    * A [=formal parameter|function parameter=]

Note: Recursion is disallowed because cycles are not permitted among any kinds
of declarations.

### Aliasing Memory Views ### {#function-aliasing}

[=Memory locations=] can be accessed during the execution of a function using [=memory views=].
Within a function, each [=memory view=] has a particular root identifier.
The root identifier can be an [=originating variable=] or a [=formal parameter=]
of [=pointer type=].

Locally derived expressions of [=reference type|reference=] or
[=pointer type|pointer=] type may introduce new names for a particular root identifier,
but each expression has a statically determinable root identifier.
While the [=originating variable=] of a root identifier is a dynamic concept that
depends on the [=call sites=] for the function, WGSL programs can be
statically analyzed to determine the set of all possible [=originating
variables=] for each root identifier.

Two root identifiers <dfn noexport>alias</dfn> when they have the same
[=originating variable=].
It is a [=dynamic error=] if:
* more than one aliased root identifiers access the same [=memory locations=], and
* at least one access is a [=write access|write=], and
* both accesses occur during the execution of the same call of the function

Note: This aliasing restriction applies to memory locations written by
[=function calls=] made in the function.

Note: [=Originating variables=] cannot have aliased [=memory locations=].
See [[#var-decls]] and [[#resource-interface]].

<div class='example wgsl' heading='Aliased memory views'>
  <xmp highlight='rust'>
    var x : i32 = 0;

    fn foo() {
      bar(&x, &x); // Both p and q parameters are aliases of x.
    }

    // This function produces a dynamic error because of the aliased
    // memory accesses.
    fn bar(p : ptr<private, i32>, q : ptr<private, i32>) {
      if (x == 0) {
        *p = 1;
      } else {
        *q = 2;
      }
    }
  </xmp>
</div>

<div class='example wgsl' heading='Aliasing in a helper function'>
  <xmp highlight='rust'>
    var x : i32 = 0;

    fn baz(p : ptr<private, i32>) {
      *p = 2;
    }

    // This function produces a dynamic error if x == 0, because x is read and
    // written through different root identifiers even though the write occurs
    // in the scope of baz.
    fn bar(p : ptr<private, i32>) {
      if (x == 0) {
        baz(p);
      }
    }

    fn foo() {
      bar(&x); // p in bar is aliased to x.
    }
  </xmp>
</div>

# Entry Points # {#entry-points}

An <dfn noexport>entry point</dfn> is a [=user-defined function=] that performs
the work for a particular [=shader stage=].

## Shader Stages ## {#shader-stages-sec}

WebGPU issues work to the GPU in the form of [=draw command|draw=] or [=dispatch commands=].
These commands execute a pipeline in the context of a set of
[=pipeline input|inputs=], [=pipeline output|outputs=], and attached [=resources=].

A <dfn noexport>pipeline</dfn> describes the work to be performed on the GPU, as a sequence
of stages, some of which are programmable.
In WebGPU, a pipeline is created before scheduling a draw or dispatch command for execution.
There are two kinds of pipelines: GPUComputePipeline, and GPURenderPipeline.

A [=dispatch command=] uses a <dfn noexport>GPUComputePipeline</dfn> to run a
<dfn noexport>compute shader stage</dfn> over a logical
grid of points with a controllable amount of parallelism,
while reading and possibly updating buffer and image resources.

A [=draw command=] uses a <dfn noexport>GPURenderPipeline</dfn> to run a multi-stage process with
two programmable stages among other fixed-function stages:

* A <dfn noexport>vertex shader stage</dfn> maps input attributes for a single vertex into
    output attributes for the vertex.
* Fixed-function stages map vertices into graphic primitives (such as triangles)
    which are then rasterized to produce fragments.
* A <dfn noexport>fragment shader stage</dfn> processes each fragment,
    possibly producing a fragment output.
* Fixed-function stages consume a fragment output, possibly updating external state
    such as color attachments and depth and stencil buffers.

The WebGPU specification describes pipelines in greater detail.

WGSL defines three <dfn noexport>shader stages</dfn>, corresponding to the
programmable parts of pipelines:

* <dfn noexport>compute</dfn>
* <dfn noexport>vertex</dfn>
* <dfn noexport>fragment</dfn>

Each shader stage has its own set of features and constraints, described elsewhere.

## Entry Point Declaration ## {#entry-point-decl}

To create an [=entry point=], declare a [=user-defined function=] with a [=pipeline stage attribute=].

When configuring a [=pipeline=] in the WebGPU API,
the entry point's function name maps to the `entryPoint` attribute of the
[[WebGPU#GPUProgrammableStage]] object.

The entry point's [=formal parameters=] form the stage's [=pipeline inputs=].
The entry point's [=return type=], if specified, forms the stage's [=pipeline output=].
Each input and output [=shader-creation error|must=] be an [=entry point IO type=].

Note: [=Compute=] entry points never have a return type.

<div class='example wgsl global-scope' heading='Entry Point'>
  <xmp highlight='rust'>
    @vertex
    fn vert_main() -> @builtin(position) vec4<f32> {
      return vec4<f32>(0.0, 0.0, 0.0, 1.0);
    }

    @fragment
    fn frag_main(@builtin(position) coord_in: vec4<f32>) -> @location(0) vec4<f32> {
      return vec4<f32>(coord_in.x, coord_in.y, 0.0, 1.0);
    }

    @compute
    fn comp_main() { }
  </xmp>
</div>

The set of <dfn noexport>functions in a shader stage</dfn> is the union of:

* The entry point function for the stage.
* The targets of function calls from within the body of a function
    in the shader stage, whether or not that call is executed.

The union is applied repeatedly until it stabilizes.
It will stabilize in a finite number of steps.

### Function Attributes for Entry Points ### {#entry-point-attributes}

WGSL defines the following attributes that can be applied to entry point declarations:
 * the [=pipeline stage attributes=]: [=attribute/vertex=], [=attribute/fragment=], and [=attribute/compute=]
 * [=attribute/workgroup_size=]

ISSUE: Can we query upper bounds on workgroup size dimensions?  Is it independent of the shader, or
  a property to be queried after creating the shader module?

<div class='example wgsl global-scope' heading='workgroup_size Attribute'>
  <xmp highlight='rust'>
    @compute @workgroup_size(8,4,1)
    fn sorter() { }

    @compute @workgroup_size(8u)
    fn reverser() { }

    // Using an pipeline-overridable constant.
    @id(42) override block_width = 12u;
    @compute @workgroup_size(block_width)
    fn shuffler() { }

    // Error: workgroup_size must be specified on compute shader
    @compute
    fn bad_shader() { }
  </xmp>
</div>

## Shader Interface ## {#shader-interface}

The shader interface is the set of objects
through which the shader accesses data external to the [=shader stage=],
either for reading or writing.
The interface includes:

* Pipeline inputs and outputs
* Buffer resources
* Texture resources
* Sampler resources

These objects are represented by module-scope variables in certain [=address spaces=].

When an [=identifier=] used in a [=function declaration=] [=resolves=] to a [=module scope|module-scope=] variable,
then we say the variable is <dfn>statically accessed</dfn> by the function.
Static access of a `let`-declared constant is defined similarly.
Note that being statically accessed is independent of whether an execution of the shader
will actually evaluate the expression referring to the variable,
or even execute the statement that may enclose the expression.

More precisely, the <dfn noexport>interface of a shader stage</dfn> consists of:
  - all parameters of the entry point
  - the result value of the entry point
  - all [=module scope=] variables that are [=statically accessed=] by [=functions in a shader stage|functions in the shader stage=],
    and which are in address spaces [=address spaces/uniform=], [=address spaces/storage=], or [=address spaces/handle=].

### Pipeline Input and Output Interface ### {#pipeline-inputs-outputs}

The <dfn dfn>entry point IO type</dfn>s include the following:
  - Built-in values. See [[#builtin-inputs-outputs]].
  - User-defined IO. See [[#user-defined-inputs-outputs]]
  - Structures containing only built-in values and user-defined IO.
    The structure [=shader-creation error|must not=] contain a nested structure.

A <dfn noexport>pipeline input</dfn> is data provided to the shader stage from upstream in the pipeline.
A pipeline input is denoted by the arguments of the entry point.

A <dfn noexport>pipeline output</dfn> is data the shader provides for further processing downstream in the pipeline.
A pipeline output is denoted by the return type of the entry point.

Each pipeline input or output is one of:

* A built-in value. See [[#builtin-inputs-outputs]].
* A user-defined value. See [[#user-defined-inputs-outputs]].

#### Built-in Inputs and Outputs #### {#builtin-inputs-outputs}

A <dfn noexport>built-in input value</dfn> provides access to system-generated control information.
The set of built-in inputs are listed in [[#builtin-values]].

A built-in input for stage *S* with name *X* and type *T*<sub>*X*</sub> is accessed via a
[=formal parameter=] to an [=entry point=] for [=shader stage=] *S*, in one of two ways:

1. The parameter has attribute `builtin(`*X*`)` and is of type *T*<sub>*X*</sub>.
2. The parameter has structure type, where one of the structure members has attribute `builtin(`*X*`)` and is of type *T*<sub>*X*</sub>.

Conversely, when a parameter or member of a parameter for an entry point has a `builtin` attribute,
the corresponding builtin [=shader-creation error|must=] be an input for the entry point's shader stage.

A <dfn noexport>built-in output value</dfn> is used by the shader to convey
control information to later processing steps in the pipeline.
The set of built-in outputs are listed in [[#builtin-values]].

A built-in output for stage *S* with name *Y* and type *T*<sub>*Y*</sub> is set via the [=return value=] for an
[=entry point=] for [=shader stage=] *S*, in one of two ways:

1. The entry point [=return type=] has attribute `builtin(`*Y*`)` and is of type *T*<sub>*Y*</sub>.
2. The entry point [=return type=] has structure type, where one of the structure members has attribute `builtin(`*Y*`)` and is of type *T*<sub>*Y*</sub>.

Conversely, when the return type or member of a return type for an entry point has a `builtin` attribute,
the corresponding builtin [=shader-creation error|must=] be an output for the entry point's shader stage.

Note: The `position` built-in is both an output of a vertex shader, and an input to the fragement shader.

#### User-defined Inputs and Outputs #### {#user-defined-inputs-outputs}

User-defined data can be passed as input to the start of a pipeline, passed
between stages of a pipeline or output from the end of a pipeline.
User-defined IO [=shader-creation error|must not=] be passed to [=compute=] shader entry points.
User-defined IO [=shader-creation error|must=] be of [=IO-shareable=] type.
All user-defined IO [=shader-creation error|must=] be assigned locations (See [[#input-output-locations]]).

#### Interpolation #### {#interpolation}

Authors can control how user-defined IO data is interpolated through the use of
the [=attribute/interpolate=] attribute.
WGSL offers two aspects of interpolation to control: the type of
interpolation, and the sampling of the interpolation.

The <dfn noexport>interpolation type</dfn> [=shader-creation error|must=] be one of:
* `perspective` - Values are interpolated in a perspective correct manner.
* `linear` - Values are interpolated in a linear, non-perspective correct manner.
* `flat` - Values are not interpolated.
    Interpolation sampling is not used with `flat` interpolation.

The <dfn noexport>interpolation sampling</dfn> [=shader-creation error|must=] be one of:
* `center` - Interpolation is performed at the center of the pixel.
* `centroid` - Interpolation is performed at a point that lies within all the
    samples covered by the fragment within the current primitive.
    This value is the same for all samples in the primitive.
* `sample` - Interpolation is performed per sample.
    The [=fragment=] shader is invoked once per sample when this attribute is
    applied.

For user-defined IO of scalar or vector floating-point type:
* If the interpolation attribute is not specified, then `@interpolate(perspective, center)` is assumed.
* If the interpolation attribute is specified with an interpolation type:
    * If the interpolation type is `flat`, then interpolation sampling [=shader-creation error|must not=] be specified.
    * If the interpolation type is `perspective` or `linear`, then:
         * Any interpolation sampling is valid.
         * If interpolation sampling is not specified, `center` is assumed.

User-defined [=vertex=] outputs and [=fragment=] inputs of scalar or vector
integer type [=shader-creation error|must=] always be specified as
`@interpolate(flat)`.

Interpolation attributes [=shader-creation error|must=] match between [=vertex=] outputs and [=fragment=]
inputs with the same [=attribute/location=] assignment within the same [=pipeline=].

#### Input-output Locations #### {#input-output-locations}

Each location can store a value up to 16 bytes in size.
The byte size of a type is defined using the *SizeOf* column in [[#alignment-and-size]].
For example, a four-component vector of floating-point values occupies a single location.

Locations are specified via the [=attribute/location=] attribute.

Every user-defined input and output [=shader-creation error|must=] have a fully specified set of
locations.
Each structure member in the entry point IO [=shader-creation error|must=] be one of either a built-in value
(see [[#builtin-inputs-outputs]]), or assigned a location.

Locations [=shader-creation error|must not=] overlap within each of the following sets:
* Members within a structure type.
    This applies to any structure, not just those used in pipeline inputs or outputs.
* An entry point's pipeline inputs,
    i.e. locations for its formal parameters, or for the members of its formal parameters of structure type.

Note: Location numbering is distinct between inputs and outputs:
Location numbers for an entry point's pipeline inputs do not conflict with location numbers for the entry point's pipeline outputs.

Note: No additional rule is required to prevent location overlap within an entry point's outputs.
When the output is a structure, the first rule above prevents overlap.
Otherwise, the output is a scalar or a vector, and can have only a single location assigned to it.

Note: The number of available locations for an entry point is defined by the WebGPU API.

<div class='example wgsl applying location attribute' heading='Applying location attributes'>
  <xmp highlight='rust'>
    struct A {
      @location(0) x: f32,
      // Despite locations being 16-bytes, x and y cannot share a location
      @location(1) y: f32
    }

    // in1 occupies locations 0 and 1.
    // in2 occupies location 2.
    // The return value occupies location 0.
    @fragment
    fn fragShader(in1: A, @location(2) in2: f32) -> @location(0) vec4<f32> {
     // ...
    }
  </xmp>
</div>

User-defined IO can be mixed with built-in values in the same structure. For example,

<div class='example wgsl mixing builtins and user-defined IO' heading='Mixing builtins and user-defined IO'>
  <xmp highlight='rust'>
    // Mixed builtins and user-defined inputs.
    struct MyInputs {
      @location(0) x: vec4<f32>,
      @builtin(front_facing) y: bool,
      @location(1) @interpolate(flat) z: u32
    }

    struct MyOutputs {
      @builtin(frag_depth) x: f32,
      @location(0) y: vec4<f32>
    }

    @fragment
    fn fragShader(in1: MyInputs) -> MyOutputs {
      // ...
    }
  </xmp>
</div>

<div class='example wgsl invalid locations' heading='Invalid location assignments'>
  <xmp highlight='rust'>
    struct A {
      @location(0) x: f32,
      // Invalid, x and y cannot share a location.
      @location(0) y: f32
    }

    struct B {
      @location(0) x: f32
    }

    struct C {
      // Invalid, structures with user-defined IO cannot be nested.
      b: B
    }

    struct D {
      x: vec4<f32>
    }

    @fragment
    // Invalid, location cannot be applied to a structure type.
    fn fragShader1(@location(0) in1: D) {
      // ...
    }

    @fragment
    // Invalid, in1 and in2 cannot share a location.
    fn fragShader2(@location(0) in1: f32, @location(0) in2: f32) {
      // ...
    }

    @fragment
    // Invalid, location cannot be applied to a structure.
    fn fragShader3(@location(0) in1: vec4<f32>) -> @location(0) D {
      // ...
    }
  </xmp>
</div>

### Resource Interface ### {#resource-interface}

A <dfn noexport>resource</dfn> is an object,
other than a [[#pipeline-inputs-outputs|pipeline input or output]],
which provides access to data external to a [=shader stage=].
Resources are shared by all invocations of the shader.

There are four kinds of resources:

* [=uniform buffers=]
* [=storage buffers=]
* textures
* samplers

The <dfn noexport>resource interface of a shader</dfn> is the set of module-scope
resource variables [=statically accessed=] by
[=functions in a shader stage|functions in the shader stage=].

Each resource variable [=shader-creation error|must=] be declared with both [=attribute/group=] and [=attribute/binding=]
attributes.
Together with the shader's stage, these identify the binding address
of the resource on the shader's pipeline.
See [[WebGPU#pipeline-layout|WebGPU &sect; GPUPipelineLayout]].

Bindings [=shader-creation error|must not=] alias within a shader stage:
two different variables in the resource interface of a given
shader [=shader-creation error|must not=] have the same group and binding values, when considered as a pair of values.

### Resource Layout Compatibility ### {#resource-layout-compatibility}

WebGPU requires that a shader's resource interface match the [[WebGPU#pipeline-layout|layout of the pipeline]]
using the shader.

It is a [=pipeline-creation error=] if a WGSL variable in a resource interface is bound to an incompatible WebGPU
[[WebGPU#binding-resource-type|resource type]] or
[[WebGPU#binding-type|binding type]],
where compatibility is defined by the following table.
<table class='data'>
  <caption>WebGPU binding type compatibility</caption>
  <thead>
    <tr><th>WGSL resource
        <th>WebGPU<br>[[WebGPU#binding-resource-type|Resource type]]
        <th colspan=2>WebGPU [[WebGPU#binding-type|Binding type]]
  </thead>
  <tr><td>[=uniform buffer=]
      <td rowspan=3>[[WebGPU#dictdef-gpubufferbinding|GPUBufferBinding]]
      <td rowspan=3>GPUBufferBindingType
      <td>[[WebGPU#dom-gpubufferbindingtype-uniform|uniform]]
  <tr><td>[=storage buffer=] with [=access/read_write=] access
      <td>[[WebGPU#dom-gpubufferbindingtype-storage|storage]]
  <tr><td>[=storage buffer=] with [=access/read=] access
      <td>[[WebGPU#dom-gpubufferbindingtype-read-only-storage|read-only-storage]]
  <tr><td rowspan=2>sampler
      <td rowspan=3>[[WebGPU#gpusampler|GPUSampler]]
      <td rowspan=3>GPUSamplerBindingType
      <td>[[WebGPU#dom-gpusamplerbindingtype-filtering|filtering]]
  <tr>
      <td>[[WebGPU#dom-gpusamplerbindingtype-non-filtering|non-filtering]]
  <tr><td>sampler_comparison
      <td>[[WebGPU#dom-gpusamplerbindingtype-comparison|comparison]]
  <tr><td rowspan=5>sampled texture
      <td rowspan=5>[[WebGPU#gputextureview|GPUTextureView]]
      <td rowspan=5>GPUTextureSampleType
      <td>[[WebGPU#dom-gputexturesampletype-float|float]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-unfilterable-float|unfilterable-float]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-sint|sint]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-uint|uint]]
  <tr>
      <td>[[WebGPU#dom-gputexturesampletype-depth|depth]]
  <tr><td>[=write-only storage texture=]
      <td>[[WebGPU#gputextureview|GPUTextureView]]
      <td>GPUStorageTextureAccess
      <td>[[WebGPU#dom-gpustoragetextureaccess-write-only|write-only]]
</table>

See the [[WebGPU#abstract-opdef-validating-gpuprogrammablestage|WebGPU API]]
specification for interface validation requirements.

# Language Extensions # {#language-extensions}

The WGSL language is expected to evolve over time.

An <dfn noexport>extension</dfn> is a named grouping for a coherent
set of modifications to a particular version of the WGSL specification, consisting of any combination of:
* Addition of new concepts and behaviours via new syntax, including:
    * declarations, statements, attributes, and built-in functions.
* Removal of restrictions in the current specification or in previously published extensions.
* Syntax for reducing the set of permissible behaviours.
* Syntax for limiting the features available to a part of the program.
* A description of how the extension interacts with the existing specification, and optionally with other extensions.

Hypothetically, extensions could be used to:
* Add numeric scalar types, such as different bit width integers.
* Add syntax to constrain floating point rounding mode.
* Add syntax to signal that a shader does not use atomic types.
* Add new kinds of statements.
* Add new built-in functions.
* Add constraints on how shader invocations execute.
* Add new shader stages.

## Enable Directive ## {#enable-directive-section}

An <dfn noexport>enable directive</dfn> indicates that the functionality
described by a particular named
[=extension=] may be used.
The grammar rules imply that all enable directives [=shader-creation error|must=] appear before any [=declarations=].

The directive uses an [=identifier=], [=keyword=], or [=reserved word=] to name the extension. The valid extension name are listed in [[#extension-list]].

If the name is an identifier, the directive does not
create a [=scope=] for the identifier.
Use of the identifier by the directive does not conflict with the
use of that identifier as the name in any [=declaration=].

<div class='syntax' noexport='true'>
  <dfn for=syntax>enable_directive</dfn> :

    | [=syntax/enable=] [=syntax/ident=] [=syntax/semicolon=]
</div>

Note: The grammar rule includes the terminating semicolon token,
ensuring the additional functionality is usable only after that semicolon.
Therefore any WGSL implementation can parse the entire `enable` directive.
When an implementation encounters an enable directive for an unsupported extension,
the implementation can issue a clear diagnostic.

<div class='example wgsl using extensions expect-error' heading="Using hypothetical extensions">
  <xmp highlight='rust'>
    // Enable a hypothetical extension for arbitrary precision floating point types.
    enable aribtrary_precision_float;
    enable arbitrary_precision_float; // A redundant enable directive is ok.

    // Enable a hypothetical extension to control the rounding mode.
    enable rounding_mode;

    // Assuming arbitrary_precision_float enables use of:
    //    - a type f<E,M>
    //    - as a type in function return, formal parameters and let-declarations
    //    - as a type constructor from AbstractFloat
    //    - operands to division operator: /
    // Assuming @rounding_mode attribute is enabled by the rounding_mode enable directive.
    @rounding_mode(round_to_even)
    fn halve_it(x : f<8, 7>) -> f<8, 7> {
      let two = f<8, 7>(2);
      return x / 2; // uses round to even rounding mode.
    }
  </xmp>
</div>

## Extensions list ## {#extension-list}

<table class='data'>
  <caption>Extension identifier</caption>
  <thead>
    <tr><th>Identifier
        <th>WebGPU extension name
        <th>Description
  </thead>
  <tr><td><dfn noexport dfn-for="extension">`f16`</dfn>
      <td>`"shader-f16"`
      <td>Keyword `f16` and any [=floating point literal=] with a `h` suffix is valid if and only if this extension is enabled. Otherwise, using `f16` keyword or any [=floating point literal=] with a `h` suffix will result in a [=shader-creation error=].
</table>

# WGSL Program # {#wgsl-program}

A WGSL program is a sequence of optional [=directives=] followed by [=module scope=] [=declarations=].

<div class='syntax' noexport='true'>
  <dfn for=syntax>translation_unit</dfn> :

    | [=syntax/global_directive=] * [=syntax/global_decl=] *
</div>

<div class='syntax' noexport='true'>
  <dfn for=syntax>global_decl</dfn> :

    | [=syntax/semicolon=]

    | [=syntax/global_variable_decl=] [=syntax/semicolon=]

    | [=syntax/global_constant_decl=] [=syntax/semicolon=]

    | [=syntax/type_alias_decl=] [=syntax/semicolon=]

    | [=syntax/struct_decl=]

    | [=syntax/function_decl=]

    | [=syntax/static_assert_statement=] [=syntax/semicolon=]
</div>

## Limits ## {#limits}

A program [=shader-creation error|must=] satisfy the following limits:

<table class='data'>
  <caption>Quantifiable shader complexity limits</caption>
  <thead>
    <tr><th>Limit<th>Maximum value
  </thead>
    <tr><td>Number of members in a [=structure=] type<td>16383
    <tr><td>[=Nesting depth=] of a [=composite=] type<td>255
    <tr><td>Number of [=formal parameter|parameters=] for a function<td>255
    <tr><td>Number of case selector values in a [=statement/switch=] statement<td>16383
</table>

# Execution # {#execution}

[[#technical-overview]] describes how a shader is invoked and partitioned into [=invocations=].
This section describes further constraints on how invocations execute,
individually and collectively.

## Program Order Within an Invocation ## {#program-order}

Each statement in a WGSL program may be executed zero or more times during
execution.
For a given invocation, each execution of a given statement represents a unique
<dfn noexport>dynamic statement instance</dfn>.

When a statement includes an expression, the statement‚Äôs semantics determines:
* Whether the expression is evaluated as part of statement execution.
* The relative ordering of evaluation between independent expressions in the statement.

Expression nesting defines data dependencies which must be satisfied to
complete evaluation.
That is, a nested expression must be evaluated before the enclosing expression
can be evaluated.
The order of evaluation for operands of an expression is left-to-right in
WGSL.
For example, `foo() + bar()` must evaluate `foo()` before `bar()`.
See [[#expressions]].

Statements in a WGSL program are executed in control flow order.
See [[#statements]] and [[#function-calls]].

## Uniformity ## {#uniformity}

### Terminology and concepts ### {#uniformity-concepts}

The following definitions are merely informative, trying to give an intuition for what the analysis in the next subsection is computing.
The analysis is what actually defines these concepts, and when a program is valid or breaks the uniformity rules.

For a given group of invocations:
- If all invocations in a given scope execute as if they are executing in lockstep at a given
    point in the program, that point is said to have <dfn noexport>uniform control flow</dfn>.
    - For a [=compute shader stage=], the scope of uniform control flow is all invocations
        in the same [=compute shader stage/workgroup=].
    - For other shader stages, the scope of uniform control flow is all invocations for that
        [=entry point=] in the same [=draw command=].
- If an expression is executed in uniform control flow, and all invocations compute the
    same value, it is said to be a <dfn noexport>uniform value</dfn>.
- If invocations hold the same value for a local variable at every point where it is live,
    it is said to be a <dfn noexport>uniform variable</dfn>.

### Uniformity analysis overview ### {#uniformity-overview}

Some functions (e.g. barriers and derivatives) are only safe to call in [=uniform control flow=].
In this section we specify an analysis that verifies that these functions are only called in such a context.

<div class="note">Note: This analysis has the following desirable properties:
      - Sound (meaning that it rejects every program that would break the uniformity requirements of builtins)
      - Linear time complexity (in the number of tokens in the program)
      - Refactoring a piece of code into a function, or inlining a function, cannot make a shader invalid if it was valid before the transformation
      - If the analysis refuses a program, it provides a straightforward chain of implications that can be used by the user agent to craft a good error message
</div>

The analysis analyzes each function, verifying that there is a context where it is safe to call this function. It rejects the program as invalid if there is no such context.

At the same time, it computes metadata about the function to help analyze its callers in turn.
This means that the call graph must first be built, and functions must be analyzed from the leaves upwards, i.e. from functions that call no function outside the standard library toward the entry point.
This way, whenever a function is analyzed, the metadata for all of its callees has already been computed.
There is no risk of being trapped in a cycle, as recurrence is forbidden in the language.

Note: another way of saying the same thing is that we do a topological sort of functions ordered by the "is a (possibly indirect) callee of" partial order, and analyze them in that order.

### Analyzing the uniformity requirements of a function ### {#uniformity-function}

Each function is analyzed in two phases.

The first phase walks over the syntax of the function, building a directed graph along the way based on the rules in the following subsections.
The second phase explores that graph, resulting in either rejecting the program, or computing the constraints on calling this function.

<div class="note">Note: apart from two special nodes RequiredToBeUniform and MayBeNonUniform, all nodes can be understood as having one of the following meanings:
        - A specific point of the program [=shader-creation error|must=] be executed in [=uniform control flow=]
        - An expression [=shader-creation error|must=] be a [=uniform value=]
        - A variable [=shader-creation error|must=] be a [=uniform variable=]

        An edge can be understood as an implication from the statement corresponding to its source node to the statement corresponding to its target node.

        To express that uniformity requirement (e.g. the control flow at the call site of a derivative), we add an edge from RequiredToBeUniform to the corresponding node.
        One way to understand this, is that RequiredToBeUniform corresponds to the proposition True, so that RequiredToBeUniform -> X is the same as saying that X is true.

        Reciprocally, to express that we cannot ensure the uniformity of something (e.g. a variable which holds the thread id), we add an edge from the corresponding node to MayBeNonUniform.
        One way to understand this, is that MayBeNonUniform corresponds to the proposition False, so that X -> MayBeNonUniform is the same as saying that X is false.

        A consequence of this interpretation is that every node reachable from RequiredToBeUniform corresponds to something which is required to be uniform for the program to be valid, and every node from which MayBeNonUniform is reachable corresponds to something whose uniformity we cannot guarantee. It follows that we have a uniformity violation (and thus reject the program) if there is any path from RequiredToBeUniform to MayBeNonUniform.
</div>

For each function, two tags are computed:
  * A <dfn noexport>call site tag</dfn> describing the control flow uniformity requirements on the [=call sites=] of the function, and
  * A <dfn noexport>function tag</dfn> describing the function's effects on uniformity.

Additionally, for each [=formal parameter=] of a function, a <dfn
noexport>parameter tag</dfn> is computed that describes the uniformity
requirement of the parameter value.

<table class='data'>
  <caption>[=Call site tag=] values</caption>
  <thead>
    <tr><th>Call Site Tag<th>Description
  </thead>
  <tr><td><dfn noexport>CallSiteRequiredToBeUniform</dfn>
      <td>The function [=shader-creation error|must=] only be called from [=uniform control flow=].
  <tr><td><dfn noexport>CallSiteNoRestriction</dfn>
      <td>The function may be called from [=uniform control flow|non-uniform control flow=].
</table>

<table class='data'>
  <caption>[=Function tag=] values</caption>
  <thead>
    <tr><th>Function Tag<th>Description
  </thead>
  <tr><td><dfn noexport>SubsequentControlFlowMayBeNonUniform</dfn>
      <td>Calling this function may cause control flow to be non-uniform immediately after the [=call site=].
  <tr><td><dfn noexport>ReturnValueMayBeNonUniform</dfn>
      <td>The [=return value=] of the function may be non-uniform.
  <tr><td><dfn noexport>NoRestriction</dfn>
      <td>The function does not introduce non-uniformity.
</table>

<table class='data'>
  <caption>[=Parameter tag=] values</caption>
  <thead>
    <tr><th>Parameter Tag<th>Description
  </thead>
  <tr><td><dfn noexport>ParameterRequiredToBeUniform</dfn>
      <td>The parameter [=shader-creation error|must=] be a [=uniform value=].
  <tr><td><dfn noexport>ParameterRequiredToBeUniformForSubsequentControlFlow</dfn>
      <td>The parameter [=shader-creation error|must=] be a [=uniform value=] for control flow after the function call to be [=uniform control flow|uniform=].
  <tr><td><dfn noexport>ParameterRequiredToBeUniformForReturnValue</dfn>
      <td>The parameter [=shader-creation error|must=] be a [=uniform value=] in order for the [=return value=] to be a uniform value.
  <tr><td><dfn noexport>ParameterNoRestriction</dfn>
      <td>The parameter value has no uniformity requirement.
</table>

The following algorithm describes how to compute these tags for a given function:

* Create nodes called "RequiredToBeUniform", "MayBeNonUniform", "CF_start", "CF_return", and if the function has a [=return type=] a node called "Value_return".
* Create one node for each parameter of the function which we'll call "arg_i".
* Walk over the syntax of the function, adding nodes and edges to the graph following the rules of the next sections ([[#uniformity-statements]], [[#uniformity-function-calls]], [[#uniformity-expressions]]), using CF_start as the starting control-flow for the function's body.
* Look at which nodes are reachable from "RequiredToBeUniform".
    * If this set includes the node "MayBeNonUniform", then reject the program.
    * If this set includes "CF_start", then the [=call site tag=] for the function is [=CallSiteRequiredToBeuniform=].
    * Otherwise, the [=call site tag=] is [=CallSiteNoRestriction=].
    * For each "arg_i" in this set, the corresponding [=parameter tag=] is [=ParameterRequiredToBeUniform=].
    * Remove from the graph all nodes that have been visited.
* Look at which nodes are reachable from "CF_return"
    * If this set includes "MayBeNonUniform", then the [=function tag=] for the function is [=SubsequentControlFlowMayBeNonUniform=].
    * For each "arg_i" in this set, the corresponding [=parameter tag=] is [=ParameterRequiredToBeUniformForSubsequentControlFlow=].
    * Remove from the graph all nodes that have been visited.
* If "Value_return" exists, look at which nodes are reachable from it
    * If this set includes "MayBeNonUniform", then the [=function tag=] is [=ReturnValueMayBeNonUniform=].
    * For each "arg_i" in this set, the corresponding [=parameter tag=] is [=ParameterRequiredToBeUniformForReturnValue=].
* If the [=function tag=] has not been assigned, then it is [=NoRestriction=].
* For each parameter, if it has not been assigned a [=parameter tag=], then it is [=ParameterNoRestriction=].

Note: The entire graph can be destroyed at this point. The tags listed above are all that we need to remember to analyze callers of this function.

### Uniformity rules for statements ### {#uniformity-statements}

The rules for analyzing statements take as argument both the statement itself and the node corresponding to control flow at the beginning of it (which we'll note "CF" below) and return both of the following:

* A node corresponding to control flow at the exit of it
* A set of new nodes and edges to add to the graph

In the table below, `(CF1, S) => CF2` means "run the analysis on S starting with control flow CF1, apply the required changes to the graph, and name the resulting control flow CF2".
Similarly, `(CF1, E) => (CF2, V)` means "run the analysis on expression E, starting with control flow CF1, apply the required changes to the graph, and name the resulting control flow node CF2 and the resulting value node V" (see next section for the analysis of expressions).

We have a similar set of rules for expressions in left-value positions, that we denote by `LValue: (CF, E) => (CF, L)`. Instead of computing the node which corresponds to the uniformity of the value, it computes the node which corresponds to the uniformity of the variable we are addressing.

When several edges have to be created we use `X -> {Y, Z}` as a short-hand for `X -> Y, X -> Z`.

<table class='data'>
  <caption>Uniformity rules for statements</caption>
  <thead>
    <tr><th>Statement<th>New nodes<th>Recursive analyses<th>Resulting control flow node<th>New edges
  </thead>
  <tr><td class="nowrap">{*s*}
      <td>
      <td class="nowrap">(*CF*, *s*) => *CF'*
      <td>*CF'*
      <td>
  <tr><td class="nowrap">*s1* *s2*,<br>
        with Next in behavior of *s1*

        Note: *s1* often ends in a semicolon.

      <td>
      <td class="nowrap">(*CF*, *s1*) => *CF1*<br>
          (*CF1*, *s2*) => *CF2*
      <td>*CF2*
      <td>
  <tr><td class="nowrap">*s1* *s2*,<br>
        without Next in behavior of *s1*

        Note: *s1* often ends in a semicolon.

      <td>
      <td>(*CF*, *s1*) => *CF1*<br>

      Note: *s2* is statically unreachable and not recursively analyzed.
      *s2* does not contribute to the uniformity analysis.
      <td>*CF1*
      <td>
  <tr><td class="nowrap">if *e* *s1* else *s2*<br> with behavior {Next}
      <td>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)<br>
          (*V*, *s1*) => *CF1*<br>
          (*V*, *s2*) => *CF2*
      <td>*CF*
      <td>
  <tr><td class="nowrap">if *e* *s1* else *s2*<br> with another behavior
      <td>*CFend*
      <td>*CFend*
      <td class="nowrap">*CFend* -> {*CF1*, *CF2*}
  <tr><td class="nowrap">loop {*s1* continuing {*s2*}}<br> with behavior {Next}
      <td rowspan=2>*CF'*
      <td rowspan=2 class="nowrap">(*CF'*, *s1*) => *CF1*<br>
          (*CF1*, *s2*) => *CF2*
      <td>*CF*
      <td rowspan=2 class="nowrap">*CF'* -> {*CF2*, *CF*}
  <tr><td class="nowrap">loop {*s1* continuing {*s2*}}<br> with another behavior
      <td>*CF'*
  <tr><td class="nowrap">loop {*s1*}<br> with behavior {Next}
      <td rowspan=2>*CF'*
      <td rowspan=2 class="nowrap">(*CF'*, *s1*) => *CF1*
      <td>*CF*
      <td rowspan=2 class="nowrap">*CF'* -> {*CF1*, *CF*}
  <tr><td class="nowrap">loop {*s1*}<br> with another behavior
      <td>*CF'*
  <tr><td class="nowrap">switch *e* case _: *s_1* .. case _: *s_n*<br> with behavior {Next}
      <td>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)<br>
        (*V*, *s_1*) => *CF_1*<br>
        ...<br>
        if *s_(n-1)* may fallthrough, (*CF_(n-1)*, *s_n*) => *CF_n*<br>
        else (*V*, *s_n*) => *CF_n*
      <td>*CF*
      <td>
  <tr><td class="nowrap">switch *e* case _: *s_1* .. case _: *s_n*<br> with another behavior
      <td>*CFend*
      <td>*CFend*
      <td class="nowrap">*CFend* -> {*CF_1*, ..., *CF_n*}
  <tr><td class="nowrap">var x: T;
      <td rowspan=2>
      <td rowspan=2>
      <td rowspan=2>*CF*
      <td rowspan=2>
  <tr><td class="nowrap">break;
  <tr><td class="nowrap">break if *e*;
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>
  <tr><td class="nowrap">continue;
      <td rowspan=3>
      <td rowspan=3>
      <td rowspan=3>*CF*
      <td rowspan=3>
  <tr><td class="nowrap">fallthrough;
  <tr><td class="nowrap">discard;
  <tr><td class="nowrap">return;
      <td>
      <td>
      <td>*CF*
      <td>*CF_return* -> *CF*
  <tr><td class="nowrap">return *e*;
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>*CF_return* -> *CF'*<br>
          *Value_return* -> *V*
  <tr><td class="nowrap">*e2* = *e1*;
      <td>
      <td class="nowrap">(*CF*, *e1*) => (*CF1*, *V1*)<br>
          LValue: (*CF1*, *e2*) => (*CF2*, *L2*)
      <td>*CF2*
      <td>*L2* -> *V1*
  <tr><td class="nowrap">_ = *e*
      <td>
      <td class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td>*CF'*
      <td>
  <tr><td class="nowrap">let x = *e*;
      <td rowspan=2>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, V)
      <td rowspan=2>*CF'*
      <td rowspan=2>
  <tr><td class="nowrap">var x = *e*;
</table>

Analysis of [[#for-statement|for]] and [[#while-statement|while]] loops follows
from their respective desugaring translations to [[#loop-statement|loop]] statements.

In [[#switch-statement|switch]], a `default` block is treated exactly like a case block with regards to uniformity.

Note: If the set of behaviors (see [[#behaviors]]) for an if, switch, or loop statement is {Next}, this means that we either did not diverge within the statement, or we reconverged, so we pick the node corresponding to control flow at the start of the statement as the node corresponding to control flow at the exit of the statement.

### Uniformity rules for function calls ### {#uniformity-function-calls}

The most complex rule is for function calls:
- For each argument, apply the corresponding expression rule, with the control flow at the exit of the previous argument (using the control flow at the beginning of the function call for the first argument). Name the corresponding value nodes "arg_i" and the corresponding control flow nodes "CF_i"
- Create two new nodes, named "Result" and "CF_after"
- If the [=call site tag=] of the function is [=CallSiteRequiredToBeuniform=], then add an edge from RequiredToBeUniform to the last CF_i
- Otherwise add an edge from CF_after to the last CF_i
- If the [=function tag=] is [=SubsequentControlFlowMayBeNonUniform=], then add an edge from CF_after to MayBeNonUniform
- Otherwise if the [=function tag=] is [=ReturnValueMayBeNonUniform=], then add an edge from Result to MayBeNonUniform
- Add an edge from Result to CF_after
- For each argument *i*:
    - If the corresponding [=parameter tag=] is [=ParameterRequiredToBeUniform=], then add an edge from RequiredToBeUniform to arg_i
    - Otherwise if the [=parameter tag=] is [=ParameterRequiredToBeUniformForSubsequentControlFlow=], then add an edge from CF_after to arg_i
    - Otherwise if the [=parameter tag=] is [=ParameterRequiredToBeUniformForReturnValue=], then add an edge from Result to arg_i

Note: Notice that this rule only requires adding a number of edges bounded by 3 + the number of parameters of the functions, independently of how complex the implementation of the function might be. This is key to the linear complexity of the overall algorithm.

Most built-in functions have tags of:
- A [=call site tag=] of [=CallSiteNoRestriction=].
- A [=function tag=] of [=NoRestriction=].
- For each parameter, a [=parameter tag|tag=] of [=ParameterRequiredToBeUniformForReturnValue=].

Here is the list of exceptions:
- All functions in [[#sync-builtin-functions]] have a [=call site tag=] of  [=CallSiteRequiredToBeuniform=].
- All functions in [[#derivative-builtin-functions]], [[#texturesample]], [[#texturesamplebias]], and [[#texturesamplecompare]] have a [=call site tag=] of [=CallSiteRequiredToBeUniform=] and a [=function tag=] of [=ReturnValueMayBeNonUniform=].
- `arrayLength` (see [[#array-builtin-functions]]) has a [=call site tag=] of
    [=CallSiteNoRestriction=], a [=function tag=] of [=NoRestriction=] and
    the input parameter `p` has a [=parameter tag=] of [=ParameterNoRestriction=]

### Uniformity rules for expressions ### {#uniformity-expressions}

The rules for analyzing expressions take as argument both the expression itself and the node corresponding to control flow at the beginning of it (which we'll note "CF" below) and return the following:

* A node corresponding to control flow at the exit of it
* A node corresponding to its value
* A set of new nodes and edges to add to the graph

<table class='data'>
  <caption>Uniformity rules for expressions (in normal rvalue position)</caption>
  <thead>
    <tr><th>Expression<th>New nodes<th>Recursive analyses<th>Resulting control flow node, value node<th>New edges
  </thead>
  <tr><td class="nowrap">*e1* || *e2*<br>
      with behavior {Next}
      <td rowspan=4>
      <td rowspan=4 class="nowrap">(*CF*, *e1*) => (*CF1*, *V1*)<br>
          (*V1*, *e2*) => (*CF2*, *V2*)
      <td rowspan=2 class="nowrap">*CF*, *V2*
      <td rowspan=4>
  <tr><td class="nowrap">*e1* && *e2*<br>
      with behavior {Next}
  <tr><td class="nowrap">*e1* || *e2*<br>
      with behavior other than {Next}
      <td rowspan=2 class="nowrap">*CF2*, *V2*
  <tr><td class="nowrap">*e1* && *e2*<br>
      with behavior other than {Next}
  <tr><td class="nowrap">Literal
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td>reference to function-scope variable, creation-time constant,
      let-declaration, or non-built-in parameter "x"
      <td>*Result*
      <td class="nowrap">*X* is the node corresponding to "x"
      <td class="nowrap">*CF*, *Result*
      <td class="nowrap">*Result* -> {*CF*, *X*}
   <tr><td class="nowrap">reference to uniform built-in value "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td class="nowrap">reference to non-uniform built-in value "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *MayBeNonUniform*
      <td>
   <tr><td class="nowrap">reference to read-only module-scope variable "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *CF*
      <td>
   <tr><td class="nowrap">reference to non-read-only module-scope variable "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *MayBeNonUniform*
      <td>
   <tr><td class="nowrap">*op* *e*,<br> where *op* is a unary operator
      <td rowspan=2>
      <td rowspan=2 class="nowrap">(*CF*, *e*) => (*CF'*, *V*)
      <td rowspan=2 class="nowrap">*CF'*, *V*
      <td rowspan=2>
   <tr><td class="nowrap">*e*.field
   <tr><td>*e1* *op* *e2*,<br> where *op* is a non-short-circuiting binary operator
      <td rowspan=2> *Result*
      <td rowspan=2 class="nowrap">(*CF*, *e1*) => (*CF1*, *V1*)<br>
          (*CF1*, *e2*) => (*CF2*, *V2*)
      <td rowspan=2 class="nowrap">*CF2*, *Result*
      <td rowspan=2 class="nowrap">*Result* -> {*V1*, *V2*}
   <tr><td class="nowrap">e1[e2]
</table>

The following built-in input variables are considered uniform:
- workgroup_id
- num_workgroups

All other ones (see [[#builtin-values]]) are considered non-uniform.

<table class='data'>
  <caption>Uniformity rules for expressions in lvalue positions</caption>
  <thead>
    <tr><th>Expression<th>New nodes<th>Recursive analyses<th>Resulting control flow node, variable node<th>New edges
  </thead>
  <tr><td>reference to function-scope variable, creation-time constant, let-declaration, or parameter "x"
      <td>
      <td class="nowrap">*X* is the node corresponding to "x"
      <td class="nowrap">*CF*, *X*
      <td>
  <tr><td class="nowrap">reference to module-scope variable "x"
      <td>
      <td>
      <td class="nowrap">*CF*, *MayBeNonUniform*
      <td>
  <tr><td class="nowrap">*e*.field
      <td>
      <td class="nowrap">LValue: (*CF*, *e*) => (*CF1*, *L1*)
      <td class="nowrap">*CF1*, *L1*
      <td>
  <tr><td class="nowrap">*e1*[*e2*]
      <td>
      <td class="nowrap">LValue: (*CF*, *e1*) => (*CF1*, *L1*)<br>
          (*CF1*, *e2*) => (*CF2*, *V2*)
      <td class="nowrap">*CF2*, *L1*
      <td class="nowrap">*L1* -> *V2*
</table>

### Annotating the uniformity of every point in the control-flow ### {#uniformity-optional-diagnosis-mode}

This entire subsection is non-normative.

If implementers want to provide developers with a diagnostic mode that shows for each point in the control-flow of the entire shader whether it is uniform or not (and thus whether it would be valid to call a function that requires uniformity there), we suggest the following:
- Run the (mandatory, normative) analysis described in the previous subsections, keeping the graph for every function.
- Reverse all edges in all of those graphs
- Go through each function, starting with the entry point and never visiting a function before having visited all of its callers:
    - Add an edge from MayBeNonUniform to every argument that was non-uniform in at least one caller
    - Add an edge from MayBeNonUniform to CF_start if the function was called in non-uniform control-flow in at least one caller
    - Look at which nodes are reachable from MayBeNonUniform. Every node visited is an expression or point in the control-flow whose uniformity cannot be proven by the analysis

Any node which is not visited by these reachability analyses can be proven to be uniform by the analysis (and so it would be safe to call a derivative or similar function there).

Note: The bottom-up analysis is still required, as it lets us know what edges to add to the graphs when encountering calls.

## Compute Shaders and Workgroups ## {#compute-shader-workgroups}

A <dfn noexport for="compute shader stage">workgroup</dfn> is a set of invocations which
concurrently execute a [=compute shader stage=] [=entry point=],
and share access to shader variables in the [=address spaces/workgroup=] address space.

The <dfn noexport>workgroup grid</dfn> for a compute shader is the set of points
with integer coordinates *(i,j,k)* with:

*  0 &leq; i &lt; workgroup_size_x
*  0 &leq; j &lt; workgroup_size_y
*  0 &leq; k &lt; workgroup_size_z

where *(workgroup_size_x, workgroup_size_y, workgroup_size_z)* is
the value specified for the [=attribute/workgroup_size=] attribute of the
entry point.

There is exactly one invocation in a workgroup for each point in the workgroup grid.

An invocation's <dfn noexport>local invocation ID</dfn> is the coordinate
triple for the invocation's corresponding workgroup grid point.

When an invocation has [=local invocation ID=] (i,j,k), then its
<dfn noexport>local invocation index</dfn> is

  i +
  (j * workgroup_size_x) +
  (k * workgroup_size_x * workgroup_size_y)

<p algorithm="local index range">Note that if a workgroup has |W| invocations,
then each invocation |I| the workgroup has a unique local invocation index |L|(|I|)
such that 0 &le; |L|(|I|) &lt; |W|,
and that entire range is covered.</p>

A compute shader begins execution when a WebGPU implementation
removes a dispatch command from a queue and begins the specified work on the GPU.
The dispatch command specifies a <dfn noexport>dispatch size</dfn>,
which is an integer triple *(group_count_x, group_count_y, group_count_z)*
indicating the number of workgroups to be executed, as described in the following.

The <dfn noexport>compute shader grid</dfn> for a particular dispatch
is the set of points with integer coordinates *(CSi,CSj,CSk)* with:

*  0 &leq; CSi &lt; workgroup_size_x &times; group_count_x
*  0 &leq; CSj &lt; workgroup_size_y &times; group_count_y
*  0 &leq; CSk &lt; workgroup_size_z &times; group_count_z

where *workgroup_size_x*,
*workgroup_size_y*, and
*workgroup_size_z* are as above for the compute shader entry point.

The work to be performed by a compute shader dispatch is to execute exactly one
invocation of the entry point for each point in the compute shader grid.

An invocation's <dfn noexport>global invocation ID</dfn> is the coordinate
triple for the invocation's corresponding compute shader grid point.

The invocations are organized into workgroups, so that each invocation
*(CSi, CSj, CSk)* is identified with the workgroup grid point

   ( *CSi* mod workgroup_size_x ,
     *CSj* mod workgroup_size_y ,
     *CSk* mod workgroup_size_z )

in <dfn noexport>workgroup ID</dfn>

   ( &lfloor; *CSi* &div; workgroup_size_x &rfloor;,
     &lfloor; *CSj* &div; workgroup_size_y &rfloor;,
     &lfloor; *CSk* &div; workgroup_size_z &rfloor;).

WebGPU provides no guarantees about:

* Whether invocations from different workgroups execute concurrently.
    That is, you cannot assume more than one workgroup executes at a time.
* Whether, once invocations from a workgroup begin executing, that other workgroups
    are blocked from execution.
    That is, you cannot assume that only one workgroup executes at a time.
    While a workgroup is executing, the implementation may choose to
    concurrently execute other workgroups as well, or other queued but unblocked work.
* Whether invocations from one particular workgroup begin executing before
    the invocations of another workgroup.
    That is, you cannot assume that workgroups are launched in a particular order.

## Collective Operations ## {#collective-operations}

### Barriers ### {#barrier}

A barrier is a [[#sync-builtin-functions|synchronization built-in function]]
that orders memory operations in a program.
A <dfn noexport>control barrier</dfn> is executed by all invocations in the
same [=compute shader stage/workgroup=] as if it were executed concurrently.
As such, control barriers [=shader-creation error|must=] only be executed in [=uniform control flow=] in a
[=compute shader stage|compute=] shader.

### Derivatives ### {#derivatives}

A <dfn noexport>partial derivative</dfn> is the rate of change of a value along an axis.

Fragment shader invocations operating on neighbouring fragments (in screen-space coordinates)
collaborate to compute approximate partial derivatives.
These neighbouring fragments are referred to as a <dfn noexport>quad</dfn>.

Partial derivatives of the *fragment coordinate* are computed implicitly as part
of operation of the following built-in functions:
* [[#texturesample|textureSample]],
* [[#texturesamplebias|textureSampleBias]], and
* [[#texturesamplecompare|textureSampleCompare]].

For these, the derivatives help determine the mip levels of texels to be sampled, or in the case of
`textureSampleCompare`, sampled and compared against a reference value.

Partial derivatives of *invocation-specified* values are computed by the
built-in functions described in [[#derivative-builtin-functions]]:
* `dpdx`, `dpdxCoarse`, and `dpdxFine` compute partial derivatives along the x axis.
* `dpdy`, `dpdyCoarse`, and `dpdyFine` compute partial derivatives along the y axis.
* `fwidth`, `fwidthCoarse`, and `fwidthFine` compute the Manhattan metric over the associated x and y partial derivatives.

Because neighbouring invocations collaborate to compute derivatives, these
functions [=shader-creation error|must=] only be invoked in [=uniform control
flow=] in a fragment shader.

## Floating Point Evaluation ## {#floating-point-evaluation}

WGSL follows the [[!IEEE-754|IEEE-754]] standard for floating point computation with
the following exceptions:
* No floating point exceptions are generated.
* Signaling NaNs may not be generated.
    Any signaling NaN may be converted to a quiet NaN.
* Implementations may assume that NaNs and infinities are not present.
    * In such an implementation, when an evaluation would produce an infinity or a NaN,
        an undefined value of the target type is produced instead.
    * Note: This means some functions (e.g. `min` and `max`)
        may not return the expected result due to optimizations about the presence
        of NaNs and infinities.
* Implementations may ignore the sign of a zero.
    That is, a zero with a positive sign may behave like a zero a with a negative sign, and vice versa.
* No rounding mode is specified.
* Implementations may flush denormalized value on the input and/or output of
    any operation listed in [[#floating-point-accuracy]].
    * Other operations are required to preserve denormalized numbers.
* The accuracy of operations is given in [[#floating-point-accuracy]].

### Floating Point Accuracy ### {#floating-point-accuracy}

<div algorithm="correctly rounded">
Let |x| be the exact real-valued or infinite result of an operation when computed with unbounded precision.
The <dfn>correctly rounded</dfn> result of the operation for floating point type |T| is:
* |x|, when |x| is in |T|,
* Otherwise:
    * the smallest value in |T| greater than |x|, or
    * the largest value in |T| less than |x|.

</div>

That is, the result may be rounded up or down:
WGSL does not specify a rounding mode.

Note: Floating point types include positive and negative infinity, so
the correctly rounded result may be finite or infinite.

The units in the last place, <dfn noexport>ULP</dfn>, for a floating point
number `x` is the minimum distance between two non-equal floating point numbers
`a` and `b` such that `a` &le; `x` &le; `b` (i.e. `ulp(x) =
min`<sub>`a,b`</sub>`|b - a|`).

In the following tables, the accuracy of an operation is provided among five
possibilities:
* Correct result (for non-floating point return values).
* [=Correctly rounded=].
* A relative error bound expressed as [=ULP=].
* A function that the accuracy is <dfn noexport>inherited from</dfn>.
    That is, the accuracy is equal to implementing the operation in terms of the derived function.
* An absolute error bound.

For any accuracy values specified over a range, the accuracy is undefined for
results outside that range.

If an allowable return value for any operation is greater in magnitude than the
largest representable finite floating-point value, then that operation may additionally
return either the infinity with the same sign or the largest finite
value with the same sign.

<table class='data'>
  <caption>Accuracy of expressions</caption>
  <thead>
    <tr><th>Expression<th>Accuracy for f32<th>Accuracy for f16
  </thead>

  <tr><td>`x + y`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`x - y`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`x * y`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`x / y`<td>2.5 ULP for `|y|` in the range [2<sup>-126</sup>, 2<sup>126</sup>]<td>2.5 ULP for `|y|` in the range [2<sup>-14</sup>, 2<sup>14</sup>]
  <tr><td>`x % y`<td colspan=2 style="text-align:left;">Derived from `x - y * trunc(x/y)`
  <tr><td>`-x`<td colspan=2 style="text-align:left;">Correctly rounded

  <tr><td>`x == y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x != y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x < y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x <= y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x > y`<td colspan=2 style="text-align:left;">Correct result
  <tr><td>`x >= y`<td colspan=2 style="text-align:left;">Correct result
</table>

<table class='data'>
  <caption>Accuracy of built-in functions</caption>
  <thead>
    <tr><th>Built-in Function<th>Accuracy for f32<th>Accuracy for f16
  </thead>

  <tr><td>`abs(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`acos(x)`<td colspan=2 style="text-align:left;">Inherited from `atan2(sqrt(1.0 - x * x), x)`
  <tr><td>`acosh(x)`<td colspan=2 style="text-align:left;">Inherited from `log(x + sqrt(x * x - 1.0))`
  <tr><td>`asin(x)`<td colspan=2 style="text-align:left;">Inherited from `atan2(x, sqrt(1.0 - x * x))`
  <tr><td>`asinh(x)`<td colspan=2 style="text-align:left;">Inherited from `log(x + sqrt(x * x + 1.0))`
  <tr><td>`atan(x)`<td>4096 ULP<td>5 ULP
  <tr><td>`atan2(y, x)`<td>4096 ULP<td>5 ULP
  <tr><td>`atanh(x)`<td colspan=2 style="text-align:left;">Inherited from `log( (1.0 + x) / (1.0 - x) ) * 0.5`
  <tr><td>`ceil(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`clamp(x,low,high)`<td colspan=2 style="text-align:left;">Inherited from `min(max(x, low), high)` and median of `[x, low, high]`
  <tr><td>`cos(x)`<td>Absolute error &le; 2<sup>-11</sup> inside the range of [-&pi;, &pi;]<td>Absolute error &le; 2<sup>-7</sup> inside the range of [-&pi;, &pi;]
  <tr><td>`cosh(x)`<td colspan=2 style="text-align:left;">Inherited from `(exp(x) - exp(-x)) * 0.5`
  <tr><td>`cross(x, y)`<td colspan=2 style="text-align:left;">Inherited from `(x[i] * y[j] - x[j] * y[i])`
  <tr><td>`degrees(x)`<td colspan=2 style="text-align:left;">Inherited from `x * 57.295779513082322865`
  <tr><td>`distance(x, y)`<td colspan=2 style="text-align:left;">Inherited from `length(x - y)`
  <tr><td>`dot(x, y)`<td colspan=2 style="text-align:left;">Inherited from sum of `x[i] * y[i]`
  <tr><td>`exp(x)`<td>`3 + 2 * |x|` ULP<td>`1 + 2 * |x|` ULP
  <tr><td>`exp2(x)`<td>`3 + 2 * |x|` ULP<td>`1 + 2 * |x|` ULP
  <tr><td class="nowrap">`faceForward(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `select(-x, x, dot(z, y) < 0.0)`
  <tr><td>`floor(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`fma(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `x * y + z`
  <tr><td>`fract(x)`<td colspan=2 style="text-align:left;">Inherited from `x - floor(x)`
  <tr><td>`frexp(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`inverseSqrt(x)`<td colspan=2 style="text-align:left;">2 ULP
  <tr><td>`ldexp(x, y)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`length(x)`<td colspan=2 style="text-align:left;">Inherited from `sqrt(dot(x, x))`
  <tr><td>`log(x)`<td>3 ULP outside the range [0.5, 2.0].<br>Absolute error &lt; 2<sup>-21</sup> inside the range [0.5, 2.0]<td>3 ULP outside the range [0.5, 2.0].<br>Absolute error &lt; 2<sup>-7</sup> inside the range [0.5, 2.0]
  <tr><td>`log2(x)`<td>3 ULP outside the range [0.5, 2.0].<br>Absolute error &lt; 2<sup>-21</sup> inside the range [0.5, 2.0]<td>3 ULP outside the range [0.5, 2.0].<br>Absolute error &lt; 2<sup>-7</sup> inside the range [0.5, 2.0]
  <tr><td>`max(x, y)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`min(x, y)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`mix(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `x * (1.0 - z) + y * z`
  <tr><td>`modf(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`normalize(x)`<td colspan=2 style="text-align:left;">Inherited from `x / length(x)`
  <tr><td>`pow(x, y)`<td colspan=2 style="text-align:left;">Inherited from `exp2(y * log2(x))`
  <tr><td>`radians(x)`<td colspan=2 style="text-align:left;">Inherited from `x * 0.017453292519943295474`
  <tr><td>`reflect(x, y)`<td colspan=2 style="text-align:left;">Inherited from `x - 2.0 * dot(x, y) * y`
  <tr><td>`refract(x, y, z)`<td colspan=2 style="text-align:left;">Inherited from `z * x - (z * dot(y, x) + sqrt(k)) * y`,<br>where `k = 1.0 - z * z * (1.0 - dot(y, x) * dot(y, x))`<br>If `k < 0.0` the result is precisely 0.0
  <tr><td>`round(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`sign(x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`sin(x)`<td>Absolute error &le; 2<sup>-11</sup> inside the range [-&pi;, &pi;]<td>Absolute error &le; 2<sup>-7</sup> inside the range [-&pi;, &pi;]
  <tr><td>`sinh(x)`<td colspan=2 style="text-align:left;">Inherited from `(exp(x) - exp(-x)) * 0.5`
  <tr><td>`smoothstep(low, high, x)`<td colspan=2 style="text-align:left;">Inherited from `t * t * (3.0 - 2.0 * t)`,<br>where `t = clamp((x - low) / (high - low), 0.0, 1.0)`
  <tr><td>`sqrt(x)`<td colspan=2 style="text-align:left;">Inherited from `1.0 / inverseSqrt(x)`
  <tr><td>`step(edge, x)`<td colspan=2 style="text-align:left;">Correctly rounded
  <tr><td>`tan(x)`<td colspan=2 style="text-align:left;">Inherited from `sin(x) / cos(x)`
  <tr><td>`tanh(x)`<td colspan=2 style="text-align:left;">Inherited from `sinh(x) / cosh(x)`
  <tr><td>`trunc(x)`<td colspan=2 style="text-align:left;">Correctly rounded

</table>

<dfn noexport>Reassociation</dfn> is the reordering of operations in an
expression such that the answer is the same if computed exactly. For example:
* `(a + b) + c` reassociates to `a + (b + c)`
* `(a - b) + c` reassociates to `(a + c) - b`
* `(a * b) / c` reassociates to `(a / c) * b`

However, the result may not be the same when computed in floating point.
The reassociated result may be inaccurate due to approximation, or may trigger
an overflow or NaN when computing intermediate results.

An implementation may reassociate operations.

An implementation may fuse operations if the transformed expression is
at least as accurate as the original formulation.
For example, some fused multiply-add implementations can be more accurate
than performing a multiply followed by an addition.

### Floating Point Conversion ### {#floating-point-conversion}

In this section, a floating point type may be any of:
* The [=f32=] and [=f16=] type in WGSL.
* A hypothetical type corresponding to a binary format defined by the [[!IEEE-754|IEEE-754]]
    floating point standard.

Note: Recall that the [=f32=] WGSL type corresponds to the IEEE-754 binary32 format, and the [=f16=] WGSL type corresponds to the IEEE-754 binary16 format.

When converting a floating point scalar value to an integral type:
* If the original value is exactly representable in the destination type, then the result is that value.
* Otherwise, the original value is rounded toward zero.
    * If the rounded value is exactly representable in the destination type, the result is that value.
    * Otherwise, the result is the value in the destination type that is closest to the rounded value.

Note: In other words, floating point to integer conversion rounds toward zero, then saturates.

Note: The result in the overflow case may not yield the value with the maximum magnitude in the target type, because
that value may not be exactly representable in the original floating point type.
For example, the maximum value in [=u32=] is 4294967295, but 4294967295.0 is not exactly representable in `f32`.
For any real number |x| with 4294967040 &leq; |x| &leq; 4294967295,
the f32 value nearest to |x| is either larger than 429467295 or rounds down to 4294967040.
Therefore the maximum u32 value resulting from a floating point conversion is 4294967040u.

When converting a value to a floating point type:
* If the original value is exactly representable in the destination type, then the result is that value.
    * Additionally, if the original value is zero and of integral type, then the resulting value has a zero sign bit.
* Otherwise, the original value is not exactly representable.
    * If the original value is different from but lies between two adjacent finite values representable in the destination type,
         then the result is one of those two values.
         WGSL does not specify whether the larger or smaller representable
         value is chosen, and different instances of such a conversion may choose differently.
    * Otherwise, the original value lies outside the finite range of the destination type:
         * A [=shader-creation error=] results if the original value is of [=abstract numeric type=].
         * Otherwise the conversion proceeds as follows:
             1. Set |X| to the original value.
             2. If the source type is a floating point type with more mantissa bits than the destination type,
                 the extra mantissa bits of the source value *may* be discarded (i.e. treated as if they are 0).
                 Update |X| accordingly.
             3. If |X| is the most-positive or most-negative normal value of the destination type, then the result is |X|.
             4. Otherwise, the result is the infinity value of the destination type, with the same sign as |X|.
    * Otherwise, if the original value is a NaN for the source type, then the result is a NaN in the destination type.

NOTE: An integer value may lie between two adjacent representable floating point values.
In particular, the [=f32=] type uses 23 explicit fractional bits.
Additionally, when the floating point value is in the normal range (the exponent is neither extreme value), then the mantissa is
the set of fractional bits together with an extra 1-bit at the most significant position at bit position 23.
Then, for example, integers 2<sup>28</sup> and 1+2<sup>28</sup> both map to the same floating point value: the difference in the
least significant 1 bit is not representable by the floating point format.
This kind of collision occurs for pairs of adjacent integers with a magnitude of at least 2<sup>25</sup>.

Note: The original value is always within range of the destination type when
the original type is one of [=i32=] or [=u32=] and the destination type is [=f32=].

Note: The original value is always within range of the destination type when
the source type is a floating point type with fewer exponent and mantissa bits than the target floating point type.

Issue: Check behaviour of the f32 to f16 conversion for numbers just beyond the max normal f16 values.
I've written what an NVIDIA GPU does.  See https://github.com/google/amber/pull/918 for an executable test case.

# Memory Model # {#memory-model}

In general, WGSL follows the [[!VulkanMemoryModel|Vulkan Memory Model]].
The remainder of this section describes how WGSL programs map to the
Vulkan Memory Model.

Note: The Vulkan Memory Model is a textual version of a [formal Alloy
model](https://github.com/KhronosGroup/Vulkan-MemoryModel/blob/master/alloy/spirv.als).

## Memory Operation ## {#memory-operation}

In WGSL, a [=read access=] is equivalent to a memory read operation in
the Vulkan Memory Model.
A WGSL, a [=write access=] is equivalent to a memory write operation in
the Vulkan Memory Model.

A [=read access=] occurs when an invocation executes one of the following:
* An evaluation of the [=Load Rule=]
* Any [[#texture-builtin-functions|texture builtin function]] except:
    * [[#texturedimensions|textureDimensions]]
    * [[#texturestore|textureStore]]
    * [[#texturenumlayers|textureNumLayers]]
    * [[#texturenumlevels|textureNumLevels]]
    * [[#texturenumsamples|textureNumSamples]]
* Any atomic built-in function except [[#atomic-store|atomicStore]]

A [=write access=] occurs when an invocation executes one of the following:
* An [=statement/assignment=] statement
* A [[#texturestore|textureStore]] built-in function
* Any atomic built-in function except [[#atomic-load|atomicLoad]]
    * [[#atomic-rmw|atomicCompareExchangeWeak]] only performs a write if the
        `exchanged` member of the returned result is `true`

[[#atomic-rmw|Atomic read-modify-write]] built-in functions perform a single
memory operation that is both a [=read access=] and a [=write access=].

Read and write accesses do not occur under any other circumstances.
Read and write accesses are collectively known as [=memory model memory
operation|memory operations=] in the Vulkan Memory Model.

A memory operation accesses exactly the set of [=memory location|locations=]
associated with the particular [=memory view=] used in the operation.  For
example, a memory read that accesses a [=u32=] from a struct containing
multiple members, only reads the memory locations associated with that u32
member.

<div class='example wgsl memory locations accessed' heading="Accessing memory locations">
  <xmp highlight='rust'>
    struct S {
      a : f32,
      b : u32,
      c : f32
    }

    @group(0) @binding(0)
    var<storage> v : S;

    fn foo() {
      let x = v.b; // Does not access memory locations for v.a or v.c.
    }
  </xmp>
</div>

## Memory Model Reference ## {#memory-model-reference}

Each module-scope variable in WGSL forms a unique [=memory model
reference=] for the lifetime of a given entry point.
Each function-scope variable in WGSL forms a unique [=memory model
reference=] for the lifetime of the variable.

## Scoped Operations ## {#scoped-operations}

When an invocation performs a scoped operation, it will affect one or two sets
of invocations.
These sets are the memory scope and the execution scope.  The <dfn
noexport>memory scope</dfn> specifies the set of invocations that will see any
updates to memory contents affected by the operation.
For [[#sync-builtin-functions|synchronization built-in functions]], this also
means that all affected memory operations program ordered before the function
are visible to affected operations program ordered after the function.
The <dfn noexport>execution scope</dfn> specifies the set of invocations which
may participate in an operation (see [[#collective-operations]]).

[[#atomic-builtin-functions|Atomic built-in functions]] map to [=memory model atomic
operation|atomic operations=] whose memory [=memory model scope|scope=] is:
* `Workgroup` if the atomic pointer is in the [=address spaces/workgroup=]
    address space
* `QueueFamily` if the atomic pointer is in the [=address spaces/storage=]
    address space

[[#sync-builtin-functions|Synchronization built-in functions]] map to control
barriers whose execution and memory [=memory model scope|scopes=] are
`Workgroup`.

Implicit and explicit derivatives have an implicit [=quad=] execution scope.

Note: If the Vulkan memory model is not enabled in generated shaders, `Device`
scope should be used instead of `QueueFamily`.

## Memory Semantics ## {#memory-semantics}

All [[#atomic-builtin-functions|Atomic built-in functions]] use `Relaxed`
[=memory model memory semantics|memory semantics=] and, thus, no address space
semantics.

[[#sync-builtin-functions|workgroupBarrier]] uses `AcquireRelease` [=memory
model memory semantics|memory semantics=] and `WorkgroupMemory` semantics.
[[#sync-builtin-functions|storageBarrier]] uses `AcquireRelease` [=memory model
memory semantics|memory semantics=] and `UniformMemory` semantics.

Note: A combined `workgroupBarrier` and `storageBarrier` uses `AcquireRelease`
ordering semantics and both `WorkgroupMemory` and `UniformMemory` memory
semantics.

Note: No atomic or synchronization built-in functions use `MakeAvailable` or
`MakeVisible` semantics.

## Private vs Non-private ## {#private-vs-non-private}

All non-atomic [=read accesses=] in the [=address spaces/storage=] or
[=address spaces/workgroup=] address spaces are considered
[=memory model non-private|non-private=] and correspond to read operations with
`NonPrivatePointer | MakePointerVisible` memory operands with the `Workgroup`
scope.

All non-atomic [=write accesses=] in the [=address spaces/storage=] or
[=address spaces/workgroup=] address spaces are considered
[=memory model non-private|non-private=] and correspond to write operations
with `NonPrivatePointer | MakePointerAvailable` memory operands with the
`Workgroup` scope.

Issue: https://github.com/gpuweb/gpuweb/issues/1621

# Keyword and Token Summary # {#grammar}

## Keyword Summary ## {#keyword-summary}

### Type-defining Keywords ### {#type-defining-keywords}

<div class='syntax' noexport='true'>
  <dfn for=syntax>array</dfn> :

    | `'array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>atomic</dfn> :

    | `'atomic'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bool</dfn> :

    | `'bool'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>float32</dfn> :

    | `'f32'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>float16</dfn> :

    | `'f16'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>int32</dfn> :

    | `'i32'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat2x2</dfn> :

    | `'mat2x2'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat2x3</dfn> :

    | `'mat2x3'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat2x4</dfn> :

    | `'mat2x4'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat3x2</dfn> :

    | `'mat3x2'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat3x3</dfn> :

    | `'mat3x3'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat3x4</dfn> :

    | `'mat3x4'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat4x2</dfn> :

    | `'mat4x2'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat4x3</dfn> :

    | `'mat4x3'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>mat4x4</dfn> :

    | `'mat4x4'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>override</dfn> :

    | `'override'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>pointer</dfn> :

    | `'ptr'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampler</dfn> :

    | `'sampler'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>sampler_comparison</dfn> :

    | `'sampler_comparison'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>staticAssert</dfn> :

    | `'staticAssert'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>struct</dfn> :

    | `'struct'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_1d</dfn> :

    | `'texture_1d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_2d</dfn> :

    | `'texture_2d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_2d_array</dfn> :

    | `'texture_2d_array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_3d</dfn> :

    | `'texture_3d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_cube</dfn> :

    | `'texture_cube'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_cube_array</dfn> :

    | `'texture_cube_array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_multisampled_2d</dfn> :

    | `'texture_multisampled_2d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_1d</dfn> :

    | `'texture_storage_1d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_2d</dfn> :

    | `'texture_storage_2d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_2d_array</dfn> :

    | `'texture_storage_2d_array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_storage_3d</dfn> :

    | `'texture_storage_3d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_2d</dfn> :

    | `'texture_depth_2d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_2d_array</dfn> :

    | `'texture_depth_2d_array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_cube</dfn> :

    | `'texture_depth_cube'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_cube_array</dfn> :

    | `'texture_depth_cube_array'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>texture_depth_multisampled_2d</dfn> :

    | `'texture_depth_multisampled_2d'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>uint32</dfn> :

    | `'u32'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>vec2</dfn> :

    | `'vec2'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>vec3</dfn> :

    | `'vec3'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>vec4</dfn> :

    | `'vec4'`
</div>

### Other Keywords ### {#other-keywords}

<div class='syntax' noexport='true'>
  <dfn for=syntax>bitcast</dfn> :

    | `'bitcast'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>break</dfn> :

    | `'break'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>case</dfn> :

    | `'case'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>const</dfn> :

    | `'const'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>continue</dfn> :

    | `'continue'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>continuing</dfn> :

    | `'continuing'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>default</dfn> :

    | `'default'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>discard</dfn> :

    | `'discard'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>else</dfn> :

    | `'else'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>enable</dfn> :

    | `'enable'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>fallthrough</dfn> :

    | `'fallthrough'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>false</dfn> :

    | `'false'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>fn</dfn> :

    | `'fn'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>for</dfn> :

    | `'for'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>function</dfn> :

    | `'function'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>if</dfn> :

    | `'if'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>let</dfn> :

    | `'let'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>loop</dfn> :

    | `'loop'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>private</dfn> :

    | `'private'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>return</dfn> :

    | `'return'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>storage</dfn> :

    | `'storage'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>switch</dfn> :

    | `'switch'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>true</dfn> :

    | `'true'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>type</dfn> :

    | `'type'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>uniform</dfn> :

    | `'uniform'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>var</dfn> :

    | `'var'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>while</dfn> :

    | `'while'`
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>workgroup</dfn> :

    | `'workgroup'`
</div>

## Reserved Words ## {#reserved-words}

A <dfn>reserved word</dfn> is a [=token=] which is reserved for future use.
A WGSL program [=shader-creation error|must not=] contain a reserved word.

The following are reserved words:

<div class='syntax' noexport='true'>
  <dfn for=syntax>_reserved</dfn> :

    | `'AppendStructuredBuffer'`   <!-- HLSL -->

    | `'BlendState'`   <!-- HLSL -->

    | `'Buffer'`   <!-- HLSL -->

    | `'ByteAddressBuffer'`   <!-- HLSL -->

    | `'CompileShader'`   <!-- HLSL -->

    | `'ComputeShader'`   <!-- HLSL -->

    | `'ConsumeStructuredBuffer'`   <!-- HLSL -->

    | `'DepthStencilState'`   <!-- HLSL -->

    | `'DepthStencilView'`   <!-- HLSL -->

    | `'DomainShader'`   <!-- HLSL -->

    | `'GeometryShader'`   <!-- HLSL -->

    | `'Hullshader'`   <!-- HLSL -->

    | `'InputPatch'`   <!-- HLSL -->

    | `'LineStream'`   <!-- HLSL -->

    | `'NULL'`   <!-- HLSL -->

    | `'OutputPatch'`   <!-- HLSL -->

    | `'PixelShader'`   <!-- HLSL -->

    | `'PointStream'`   <!-- HLSL -->

    | `'RWBuffer'`   <!-- HLSL -->

    | `'RWByteAddressBuffer'`   <!-- HLSL -->

    | `'RWStructuredBuffer'`   <!-- HLSL -->

    | `'RWTexture1D'`   <!-- HLSL -->

    | `'RWTexture1DArray'`   <!-- HLSL -->

    | `'RWTexture2D'`   <!-- HLSL -->

    | `'RWTexture2DArray'`   <!-- HLSL -->

    | `'RWTexture3D'`   <!-- HLSL -->

    | `'RasterizerState'`   <!-- HLSL -->

    | `'RenderTargetView'`   <!-- HLSL -->

    | `'SamplerComparisonState'`   <!-- HLSL -->

    | `'SamplerState'`   <!-- HLSL -->

    | `'Self'`   <!-- Rust -->

    | `'StructuredBuffer'`   <!-- HLSL -->

    | `'Texture1D'`   <!-- HLSL -->

    | `'Texture1DArray'`   <!-- HLSL -->

    | `'Texture2D'`   <!-- HLSL -->

    | `'Texture2DArray'`   <!-- HLSL -->

    | `'Texture2DMS'`   <!-- HLSL -->

    | `'Texture2DMSArray'`   <!-- HLSL -->

    | `'Texture3D'`   <!-- HLSL -->

    | `'TextureCube'`   <!-- HLSL -->

    | `'TextureCubeArray'`   <!-- HLSL -->

    | `'TriangleStream'`   <!-- HLSL -->

    | `'VertexShader'`   <!-- HLSL -->

    | `'abstract'`   <!-- Rust -->

    | `'active'`   <!-- GLSL(reserved) -->

    | `'alignas'`   <!-- C++ -->

    | `'alignof'`   <!-- C++ -->

    | `'as'`   <!-- ECMAScript2022 Rust -->

    | `'asm'`   <!-- C++ HLSL GLSL(reserved) WGSL -->

    | `'asm_fragment'`   <!-- HLSL -->

    | `'async'`   <!-- ECMAScript2022 -->

    | `'atomic_uint'`   <!-- GLSL -->

    | `'attribute'`   <!-- GLSL -->

    | `'auto'`   <!-- C++ -->

    | `'await'`   <!-- ECMAScript2022 -->

    | `'become'`   <!-- Rust -->

    | `'bf16'`   <!-- WGSL -->

    | `'binding_array'`   <!-- WGSL -->

    | `'cast'`   <!-- GLSL(reserved) -->

    | `'catch'`   <!-- C++ ECMAScript2022 -->

    | `'cbuffer'`   <!-- HLSL -->

    | `'char'`   <!-- C++ -->

    | `'class'`   <!-- C++ ECMAScript2022 HLSL GLSL(reserved) -->

    | `'co_await'`   <!-- C++ -->

    | `'co_return'`   <!-- C++ -->

    | `'co_yield'`   <!-- C++ -->

    | `'coherent'`   <!-- GLSL -->

    | `'column_major'`   <!-- HLSL -->

    | `'common'`   <!-- GLSL(reserved) -->

    | `'compile'`   <!-- HLSL -->

    | `'compile_fragment'`   <!-- HLSL -->

    | `'concept'`   <!-- C++ -->

    | `'const_cast'`   <!-- C++ -->

    | `'consteval'`   <!-- C++ -->

    | `'constexpr'`   <!-- C++ -->

    | `'constinit'`   <!-- C++ -->

    | `'crate'`   <!-- Rust -->

    | `'debugger'`   <!-- ECMAScript2022 -->

    | `'decltype'`   <!-- C++ -->

    | `'delete'`   <!-- C++ ECMAScript2022 -->

    | `'demote'`   <!-- WGSL -->

    | `'demote_to_helper'`   <!-- WGSL -->

    | `'do'`   <!-- C++ ECMAScript2022 Rust HLSL GLSL WGSL -->

    | `'dword'`   <!-- HLSL -->

    | `'dynamic_cast'`   <!-- C++ -->

    | `'enum'`   <!-- C++ ECMAScript2022 Rust GLSL(reserved) WGSL -->

    | `'explicit'`   <!-- C++ -->

    | `'export'`   <!-- C++ C++ ECMAScript2022 HLSL -->

    | `'extends'`   <!-- ECMAScript2022 -->

    | `'extern'`   <!-- C++ Rust HLSL GLSL(reserved) -->

    | `'external'`   <!-- GLSL(reserved) -->

    | `'f64'`   <!-- WGSL -->

    | `'filter'`   <!-- GLSL(reserved) -->

    | `'final'`   <!-- Rust -->

    | `'finally'`   <!-- ECMAScript2022 -->

    | `'fixed'`   <!-- GLSL(reserved) -->

    | `'friend'`   <!-- C++ -->

    | `'from'`   <!-- ECMAScript2022 -->

    | `'fvec2'`   <!-- GLSL(reserved) -->

    | `'fvec3'`   <!-- GLSL(reserved) -->

    | `'fvec4'`   <!-- GLSL(reserved) -->

    | `'fxgroup'`   <!-- HLSL -->

    | `'get'`   <!-- ECMAScript2022 -->

    | `'goto'`   <!-- C++ GLSL(reserved) -->

    | `'groupshared'`   <!-- HLSL -->

    | `'handle'`   <!-- WGSL -->

    | `'highp'`   <!-- GLSL -->

    | `'hvec2'`   <!-- GLSL(reserved) -->

    | `'hvec3'`   <!-- GLSL(reserved) -->

    | `'hvec4'`   <!-- GLSL(reserved) -->

    | `'i16'`   <!-- WGSL -->

    | `'i64'`   <!-- WGSL -->

    | `'i8'`   <!-- WGSL -->

    | `'iimage1D'`   <!-- GLSL -->

    | `'iimage1DArray'`   <!-- GLSL -->

    | `'iimage2D'`   <!-- GLSL -->

    | `'iimage2DArray'`   <!-- GLSL -->

    | `'iimage2DMS'`   <!-- GLSL -->

    | `'iimage2DMSArray'`   <!-- GLSL -->

    | `'iimage2DRect'`   <!-- GLSL -->

    | `'iimage3D'`   <!-- GLSL -->

    | `'iimageBuffer'`   <!-- GLSL -->

    | `'iimageCube'`   <!-- GLSL -->

    | `'iimageCubeArray'`   <!-- GLSL -->

    | `'image1D'`   <!-- GLSL -->

    | `'image1DArray'`   <!-- GLSL -->

    | `'image2D'`   <!-- GLSL -->

    | `'image2DArray'`   <!-- GLSL -->

    | `'image2DMS'`   <!-- GLSL -->

    | `'image2DMSArray'`   <!-- GLSL -->

    | `'image2DRect'`   <!-- GLSL -->

    | `'image3D'`   <!-- GLSL -->

    | `'imageBuffer'`   <!-- GLSL -->

    | `'imageCube'`   <!-- GLSL -->

    | `'imageCubeArray'`   <!-- GLSL -->

    | `'impl'`   <!-- Rust -->

    | `'implements'`   <!-- ECMAScript2022 -->

    | `'import'`   <!-- C++ ECMAScript2022 -->

    | `'inline'`   <!-- C++ HLSL GLSL(reserved) -->

    | `'inout'`   <!-- HLSL GLSL -->

    | `'instanceof'`   <!-- ECMAScript2022 -->

    | `'interface'`   <!-- ECMAScript2022 HLSL GLSL(reserved) -->

    | `'invariant'`   <!-- GLSL -->

    | `'isampler1D'`   <!-- GLSL -->

    | `'isampler1DArray'`   <!-- GLSL -->

    | `'isampler2D'`   <!-- GLSL -->

    | `'isampler2DArray'`   <!-- GLSL -->

    | `'isampler2DMS'`   <!-- GLSL -->

    | `'isampler2DMSArray'`   <!-- GLSL -->

    | `'isampler2DRect'`   <!-- GLSL -->

    | `'isampler3D'`   <!-- GLSL -->

    | `'isamplerBuffer'`   <!-- GLSL -->

    | `'isamplerCube'`   <!-- GLSL -->

    | `'isamplerCubeArray'`   <!-- GLSL -->

    | `'isubpassInput'`   <!-- GLSL -->

    | `'isubpassInputMS'`   <!-- GLSL -->

    | `'itexture1D'`   <!-- GLSL -->

    | `'itexture1DArray'`   <!-- GLSL -->

    | `'itexture2D'`   <!-- GLSL -->

    | `'itexture2DArray'`   <!-- GLSL -->

    | `'itexture2DMS'`   <!-- GLSL -->

    | `'itexture2DMSArray'`   <!-- GLSL -->

    | `'itexture2DRect'`   <!-- GLSL -->

    | `'itexture3D'`   <!-- GLSL -->

    | `'itextureBuffer'`   <!-- GLSL -->

    | `'itextureCube'`   <!-- GLSL -->

    | `'itextureCubeArray'`   <!-- GLSL -->

    | `'layout'`   <!-- GLSL -->

    | `'line'`   <!-- HLSL -->

    | `'lineadj'`   <!-- HLSL -->

    | `'lowp'`   <!-- GLSL -->

    | `'macro'`   <!-- Rust -->

    | `'macro_rules'`   <!-- Rust -->

    | `'mat'`   <!-- WGSL -->

    | `'match'`   <!-- Rust -->

    | `'matrix'`   <!-- HLSL -->

    | `'mediump'`   <!-- GLSL -->

    | `'meta'`   <!-- ECMAScript2022 -->

    | `'mod'`   <!-- Rust -->

    | `'module'`   <!-- C++ -->

    | `'move'`   <!-- Rust -->

    | `'mut'`   <!-- Rust -->

    | `'mutable'`   <!-- C++ -->

    | `'namespace'`   <!-- C++ HLSL GLSL(reserved) -->

    | `'new'`   <!-- C++ ECMAScript2022 -->

    | `'nil'`   <!-- Smalltalk -->

    | `'noexcept'`   <!-- C++ -->

    | `'noinline'`   <!-- GLSL(reserved) -->

    | `'nointerpolation'`   <!-- HLSL -->

    | `'noperspective'`   <!-- HLSL GLSL -->

    | `'null'`   <!-- ECMAScript2022 WGSL -->

    | `'nullptr'`   <!-- C++ -->

    | `'of'`   <!-- ECMAScript2022 -->

    | `'operator'`   <!-- C++ -->

    | `'package'`   <!-- ECMAScript2022 -->

    | `'packoffset'`   <!-- HLSL -->

    | `'partition'`   <!-- GLSL(reserved) -->

    | `'pass'`   <!-- HLSL -->

    | `'patch'`   <!-- GLSL -->

    | `'pixelfragment'`   <!-- HLSL -->

    | `'point'`   <!-- HLSL -->

    | `'precise'`   <!-- HLSL GLSL -->

    | `'precision'`   <!-- GLSL -->

    | `'premerge'`   <!-- WGSL -->

    | `'priv'`   <!-- Rust -->

    | `'protected'`   <!-- C++ ECMAScript2022 -->

    | `'pub'`   <!-- Rust -->

    | `'public'`   <!-- C++ ECMAScript2022 GLSL(reserved) -->

    | `'readonly'`   <!-- GLSL -->

    | `'ref'`   <!-- Rust -->

    | `'regardless'`   <!-- WGSL -->

    | `'register'`   <!-- C++ HLSL -->

    | `'reinterpret_cast'`   <!-- C++ -->

    | `'requires'`   <!-- C++ -->

    | `'resource'`   <!-- GLSL(reserved) -->

    | `'restrict'`   <!-- GLSL -->

    | `'row_major'`   <!-- HLSL -->

    | `'samper'`   <!-- HLSL -->

    | `'sampler1D'`   <!-- GLSL -->

    | `'sampler1DArray'`   <!-- GLSL -->

    | `'sampler1DArrayShadow'`   <!-- GLSL -->

    | `'sampler1DShadow'`   <!-- GLSL -->

    | `'sampler2D'`   <!-- GLSL -->

    | `'sampler2DArray'`   <!-- GLSL -->

    | `'sampler2DArrayShadow'`   <!-- GLSL -->

    | `'sampler2DMS'`   <!-- GLSL -->

    | `'sampler2DMSArray'`   <!-- GLSL -->

    | `'sampler2DRect'`   <!-- GLSL -->

    | `'sampler2DRectShadow'`   <!-- GLSL -->

    | `'sampler2DShadow'`   <!-- GLSL -->

    | `'sampler3D'`   <!-- GLSL -->

    | `'sampler3DRect'`   <!-- GLSL(reserved) -->

    | `'samplerBuffer'`   <!-- GLSL -->

    | `'samplerCube'`   <!-- GLSL -->

    | `'samplerCubeArray'`   <!-- GLSL -->

    | `'samplerCubeArrayShadow'`   <!-- GLSL -->

    | `'samplerCubeShadow'`   <!-- GLSL -->

    | `'samplerShadow'`   <!-- GLSL -->

    | `'self'`   <!-- Rust Smalltalk -->

    | `'set'`   <!-- ECMAScript2022 -->

    | `'shared'`   <!-- HLSL GLSL -->

    | `'signed'`   <!-- C++ -->

    | `'sizeof'`   <!-- C++ GLSL(reserved) -->

    | `'smooth'`   <!-- GLSL -->

    | `'snorm'`   <!-- HLSL -->

    | `'stateblock'`   <!-- HLSL -->

    | `'stateblock_state'`   <!-- HLSL -->

    | `'static'`   <!-- C++ ECMAScript2022 Rust HLSL GLSL(reserved) -->

    | `'static_assert'`   <!-- C++ -->

    | `'static_cast'`   <!-- C++ -->

    | `'std'`   <!-- WGSL -->

    | `'string'`   <!-- HLSL -->

    | `'subpassInput'`   <!-- GLSL -->

    | `'subpassInputMS'`   <!-- GLSL -->

    | `'subroutine'`   <!-- GLSL -->

    | `'super'`   <!-- ECMAScript2022 Rust Smalltalk -->

    | `'superp'`   <!-- GLSL(reserved) -->

    | `'target'`   <!-- ECMAScript2022 -->

    | `'tbuffer'`   <!-- HLSL -->

    | `'technique'`   <!-- HLSL -->

    | `'technique10'`   <!-- HLSL -->

    | `'technique11'`   <!-- HLSL -->

    | `'template'`   <!-- C++ GLSL(reserved) -->

    | `'texture1D'`   <!-- GLSL -->

    | `'texture1DArray'`   <!-- GLSL -->

    | `'texture2D'`   <!-- GLSL -->

    | `'texture2DArray'`   <!-- GLSL -->

    | `'texture2DMS'`   <!-- GLSL -->

    | `'texture2DMSArray'`   <!-- GLSL -->

    | `'texture2DRect'`   <!-- GLSL -->

    | `'texture3D'`   <!-- GLSL -->

    | `'textureBuffer'`   <!-- GLSL -->

    | `'textureCube'`   <!-- GLSL -->

    | `'textureCubeArray'`   <!-- GLSL -->

    | `'this'`   <!-- C++ ECMAScript2022 GLSL(reserved) -->

    | `'thread_local'`   <!-- C++ -->

    | `'throw'`   <!-- C++ ECMAScript2022 -->

    | `'trait'`   <!-- Rust -->

    | `'triangle'`   <!-- HLSL -->

    | `'triangleadj'`   <!-- HLSL -->

    | `'try'`   <!-- C++ ECMAScript2022 -->

    | `'typedef'`   <!-- C++ HLSL GLSL(reserved) WGSL -->

    | `'typeid'`   <!-- C++ -->

    | `'typename'`   <!-- C++ -->

    | `'typeof'`   <!-- ECMAScript2022 Rust -->

    | `'u16'`   <!-- WGSL -->

    | `'u64'`   <!-- WGSL -->

    | `'u8'`   <!-- WGSL -->

    | `'uimage1D'`   <!-- GLSL -->

    | `'uimage1DArray'`   <!-- GLSL -->

    | `'uimage2D'`   <!-- GLSL -->

    | `'uimage2DArray'`   <!-- GLSL -->

    | `'uimage2DMS'`   <!-- GLSL -->

    | `'uimage2DMSArray'`   <!-- GLSL -->

    | `'uimage2DRect'`   <!-- GLSL -->

    | `'uimage3D'`   <!-- GLSL -->

    | `'uimageBuffer'`   <!-- GLSL -->

    | `'uimageCube'`   <!-- GLSL -->

    | `'uimageCubeArray'`   <!-- GLSL -->

    | `'union'`   <!-- C++ Rust GLSL(reserved) -->

    | `'unless'`   <!-- WGSL -->

    | `'unorm'`   <!-- HLSL -->

    | `'unsafe'`   <!-- Rust -->

    | `'unsigned'`   <!-- C++ HLSL GLSL(reserved) -->

    | `'unsized'`   <!-- Rust -->

    | `'usampler1D'`   <!-- GLSL -->

    | `'usampler1DArray'`   <!-- GLSL -->

    | `'usampler2D'`   <!-- GLSL -->

    | `'usampler2DArray'`   <!-- GLSL -->

    | `'usampler2DMS'`   <!-- GLSL -->

    | `'usampler2DMSArray'`   <!-- GLSL -->

    | `'usampler2DRect'`   <!-- GLSL -->

    | `'usampler3D'`   <!-- GLSL -->

    | `'usamplerBuffer'`   <!-- GLSL -->

    | `'usamplerCube'`   <!-- GLSL -->

    | `'usamplerCubeArray'`   <!-- GLSL -->

    | `'use'`   <!-- Rust -->

    | `'using'`   <!-- C++ GLSL(reserved) WGSL -->

    | `'usubpassInput'`   <!-- GLSL -->

    | `'usubpassInputMS'`   <!-- GLSL -->

    | `'utexture1D'`   <!-- GLSL -->

    | `'utexture1DArray'`   <!-- GLSL -->

    | `'utexture2D'`   <!-- GLSL -->

    | `'utexture2DArray'`   <!-- GLSL -->

    | `'utexture2DMS'`   <!-- GLSL -->

    | `'utexture2DMSArray'`   <!-- GLSL -->

    | `'utexture2DRect'`   <!-- GLSL -->

    | `'utexture3D'`   <!-- GLSL -->

    | `'utextureBuffer'`   <!-- GLSL -->

    | `'utextureCube'`   <!-- GLSL -->

    | `'utextureCubeArray'`   <!-- GLSL -->

    | `'varying'`   <!-- GLSL -->

    | `'vec'`   <!-- WGSL -->

    | `'vector'`   <!-- HLSL -->

    | `'vertexfragment'`   <!-- HLSL -->

    | `'virtual'`   <!-- C++ Rust -->

    | `'void'`   <!-- C++ ECMAScript2022 HLSL GLSL WGSL -->

    | `'volatile'`   <!-- C++ HLSL GLSL -->

    | `'wchar_t'`   <!-- C++ -->

    | `'wgsl'`   <!-- WGSL -->

    | `'where'`   <!-- Rust -->

    | `'with'`   <!-- ECMAScript2022 -->

    | `'writeonly'`   <!-- GLSL -->

    | `'yield'`   <!-- ECMAScript2022 Rust -->

</div>

## Syntactic Tokens ## {#syntactic-tokens}

A <dfn>syntactic token</dfn> is a sequence of special code points, used:
* to spell an expression operator, or
* as punctuation: to group, sequence, or separate other grammar elements.

<div class='syntax' noexport='true'>
  <dfn for=syntax>and</dfn> :

    | `'&'` (Code point: `U+0026`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>and_and</dfn> :

    | `'&&'` (Code points: `U+0026` `U+0026`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>arrow</dfn> :

    | `'->'` (Code points: `U+002D` `U+003E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>attr</dfn> :

    | `'@'` (Code point: `U+0040`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>forward_slash</dfn> :

    | `'/'` (Code point: `U+002F`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bang</dfn> :

    | `'!'` (Code point: `U+0021`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bracket_left</dfn> :

    | `'['` (Code point: `U+005B`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>bracket_right</dfn> :

    | `']'` (Code point: `U+005D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>brace_left</dfn> :

    | `'{'` (Code point: `U+007B`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>brace_right</dfn> :

    | `'}'` (Code point: `U+007D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>colon</dfn> :

    | `':'` (Code point: `U+003A`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>comma</dfn> :

    | `','` (Code point: `U+002C`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>equal</dfn> :

    | `'='` (Code point: `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>equal_equal</dfn> :

    | `'=='` (Code points: `U+003D` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>not_equal</dfn> :

    | `'!='` (Code points: `U+0021` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>greater_than</dfn> :

    | `'>'` (Code point: `U+003E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>greater_than_equal</dfn> :

    | `'>='` (Code points: `U+003E` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>shift_right</dfn> :

    | `'>>'` (Code point: `U+003E` `U+003E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>less_than</dfn> :

    | `'<'` (Code point: `U+003C`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>less_than_equal</dfn> :

    | `'<='` (Code points: `U+003C` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>shift_left</dfn> :

    | `'<<'` (Code points: `U+003C` `U+003C`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>modulo</dfn> :

    | `'%'` (Code point: `U+0025`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>minus</dfn> :

    | `'-'` (Code point: `U+002D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>minus_minus</dfn> :

    | `'--'` (Code points: `U+002D` `U+002D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>period</dfn> :

    | `'.'` (Code point: `U+002E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>plus</dfn> :

    | `'+'` (Code point: `U+002B`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>plus_plus</dfn> :

    | `'++'` (Code points: `U+002B` `U+002B`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>or</dfn> :

    | `'|'` (Code point: `U+007C`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>or_or</dfn> :

    | `'||'` (Code points: `U+007C` `U+007C`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>paren_left</dfn> :

    | `'('` (Code point: `U+0028`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>paren_right</dfn> :

    | `')'` (Code point: `U+0029`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>semicolon</dfn> :

    | `';'` (Code point: `U+003B`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>star</dfn> :

    | `'*'` (Code point: `U+002A`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>tilde</dfn> :

    | `'~'` (Code point: `U+007E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>underscore</dfn> :

    | `'_'` (Code point: `U+005F`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>xor</dfn> :

    | `'^'` (Code point: `U+005E`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>plus_equal</dfn> :

    | `'+='` (Code points: `U+002B` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>minus_equal</dfn> :

    | `'-='` (Code points: `U+002D` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>times_equal</dfn> :

    | `'*='` (Code points: `U+002A` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>division_equal</dfn> :

    | `'/='` (Code points: `U+002F` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>modulo_equal</dfn> :

    | `'%='` (Code points: `U+0025` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>and_equal</dfn> :

    | `'&='` (Code points: `U+0026` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>or_equal</dfn> :

    | `'|='` (Code points: `U+007C` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>xor_equal</dfn> :

    | `'^='` (Code points: `U+005E` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>shift_right_equal</dfn> :

    | `'>>='` (Code points: `U+003E` `U+003E` `U+003D`)
</div>
<div class='syntax' noexport='true'>
  <dfn for=syntax>shift_left_equal</dfn> :

    | `'<<='` (Code points: `U+003C` `U+003C` `U+003D`)
</div>

# Built-in Values # {#builtin-values}

The following table lists the available [=built-in input values=] and [=built-in output values=].

See [[#builtin-inputs-outputs]] for how to declare a built-in value.

<table class='data'>
  <caption>Built-in input and output values</caption>
  <thead>
    <tr><th>Name<th>Stage<th>Input or Output<th>Type<th>Description
  </thead>

  <tr><td>`vertex_index`
      <td>vertex
      <td>input
      <td>u32
      <td style="width:50%">Index of the current vertex within the current API-level draw command,
         independent of draw instancing.

         For a non-indexed draw, the first vertex has an index equal to the `firstVertex` argument
         of the draw, whether provided directly or indirectly.
         The index is incremented by one for each additional vertex in the draw instance.

         For an indexed draw, the index is equal to the index buffer entry for the
         vertex, plus the `baseVertex` argument of the draw, whether provided directly or indirectly.

  <tr><td>`instance_index`
      <td>vertex
      <td>input
      <td>u32
      <td style="width:50%">Instance index of the current vertex within the current API-level draw command.

         The first instance has an index equal to the `firstInstance` argument of the draw,
         whether provided directly or indirectly.
         The index is incremented by one for each additional instance in the draw.

  <tr><td>`position`
      <td>vertex
      <td>output
      <td>vec4&lt;f32&gt;
      <td style="width:50%">Output position of the current vertex, using homogeneous coordinates.
      After homogeneous normalization (where each of the *x*, *y*, and *z* components
      are divided by the *w* component), the position is in the WebGPU normalized device
      coordinate space.
      See [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]].

  <tr><td>`position`
      <td>fragment
      <td>input
      <td>vec4&lt;f32&gt;
      <td style="width:50%">Framebuffer position of the current fragment in [[WebGPU#rasterization|framebuffer space]].
      (The *x*, *y*, and *z* components have already been scaled such that *w* is now 1.)
      See [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]].

  <tr><td>`front_facing`
      <td>fragment
      <td>input
      <td>bool
      <td style="width:50%">True when the current fragment is on a front-facing primitive.
         False otherwise.
         See [[WebGPU#front-facing|WebGPU &sect; Front-facing]].

  <tr><td>`frag_depth`
      <td>fragment
      <td>output
      <td>f32
      <td style="width:50%">Updated depth of the fragment, in the viewport depth range.
      See [[WebGPU#coordinate-systems|WebGPU &sect; Coordinate Systems]].

  <tr><td>`local_invocation_id`
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
      <td style="width:50%">The current invocation's [=local invocation ID=],
            i.e. its position in the [=workgroup grid=].

  <tr><td>`local_invocation_index`
      <td>compute
      <td>input
      <td>u32
      <td style="width:50%">The current invocation's [=local invocation index=], a linearized index of
          the invocation's position within the [=workgroup grid=].

  <tr><td>`global_invocation_id`
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
      <td style="width:50%">The current invocation's [=global invocation ID=],
          i.e. its position in the [=compute shader grid=].

  <tr><td>`workgroup_id`
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
      <td style="width:50%">The current invocation's [=workgroup ID=],
          i.e. the position of the workgroup in the [=workgroup grid=].

  <tr><td>`num_workgroups`
      <td>compute
      <td>input
      <td>vec3&lt;u32&gt;
      <td style="width:50%">The [=dispatch size=], `vec<u32>(group_count_x,
      group_count_y, group_count_z)`, of the compute shader
      [[WebGPU#dom-gpucomputepassencoder-dispatch|dispatched]] by the API.

  <tr><td>`sample_index`
      <td>fragment
      <td>input
      <td>u32
      <td style="width:50%">Sample index for the current fragment.
         The value is least 0 and at most `sampleCount`-1, where
         [[WebGPU#dom-gpurenderpipelinedescriptor-samplecount|sampleCount]]
         is the number of MSAA samples specified for the GPU render pipeline.
         <br>See [[WebGPU#render-pipeline|WebGPU &sect; GPURenderPipeline]].

  <tr><td>`sample_mask`
      <td>fragment
      <td>input
      <td>u32
      <td style="width:50%">Sample coverage mask for the current fragment.
         It contains a bitmask indicating which samples in this fragment are covered
         by the primitive being rendered.
         <br>See [[WebGPU#sample-masking|WebGPU &sect; Sample Masking]].

  <tr><td>`sample_mask`
      <td>fragment
      <td>output
      <td>u32
      <td style="width:50%">Sample coverage mask control for the current fragment.
         The last value written to this variable becomes the
         [[WebGPU#shader-output-mask|shader-output mask]].
         Zero bits in the written value will cause corresponding samples in
         the color attachments to be discarded.
         <br>See [[WebGPU#sample-masking|WebGPU &sect; Sample Masking]].
</table>

<div class='example wgsl global-scope' heading="Declaring built-in values">
  <xmp highlight='rust'>
    struct VertexOutput {
      @builtin(position) my_pos: vec4<f32>
    }

    @vertex
    fn vs_main(
      @builtin(vertex_index) my_index: u32,
      @builtin(instance_index) my_inst_index: u32,
    ) -> VertexOutput {}

    struct FragmentOutput {
      @builtin(frag_depth) depth: f32,
      @builtin(sample_mask) mask_out: u32
    }

    @fragment
    fn fs_main(
      @builtin(front_facing) is_front: bool,
      @builtin(position) coord: vec4<f32>,
      @builtin(sample_index) my_sample_index: u32,
      @builtin(sample_mask) mask_in: u32,
    ) -> FragmentOutput {}

    @compute
    fn cs_main(
      @builtin(local_invocation_id) local_id: vec3<u32>,
      @builtin(local_invocation_index) local_index: u32,
      @builtin(global_invocation_id) global_id: vec3<u32>,
   ) {}
  </xmp>
</div>

# Built-in Functions # {#builtin-functions}

Certain functions are [=predeclared=], provided by the implementation, and
therefore always available for use in a WGSL program.
These are called <dfn noexport>built-in functions</dfn>.

A built-in function is a family of functions, all with the same name,
but distinguished by the number, order, and types of their [=formal parameters=].
Each of these distinct function variations is an [=overload=].

Note: Each [=user-defined function=] only has one [=overload=].

Each [=overload=] is described below via:
* Type parameterizations, if any.
* The built-in function name, a parenthesized list of [=formal parameters=], and optionally a [=return type=].
* The behaviour of this overload of the function.

Since a built-in function is always in scope, it is a [=shader-creation error=]
to attempt to redefine one or to use the name of a built-in function as an
[=identifier=] for any other [=module scope|module-scope=] declaration.

When calling a built-in function, all arguments to the function are evaluated
before function evaluation begins.
See [[#function-calls]].

## Logical Built-in Functions ## {#logical-builtin-functions}

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>
  <tr algorithm="vector all">
    <th scope="row">Overload
    <td><xmp highlight=rust>@const fn all(e: vecN<bool>) -> bool</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns true if each component of |e| is true.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>
  <tr algorithm="scalar all">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>@const fn all(e: bool) -> bool</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |e|.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>
  <tr algorithm="vector any">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn any(e: vecN<bool>) -> bool
</xmp>
  <tr>
    <th scope="row" style="width:10%">Description
    <td>Returns true if any component of |e| is true.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>
  <tr algorithm="scalar any">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>@const fn any(e: bool) -> bool</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |e|.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [=scalar=], [=abstract numeric type=], or [=vector=]
  <tr algorithm="scalar select">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn select(f: T,
                 t: T,
                 cond: bool) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |t| when |cond| is true, and |f| otherwise.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [=scalar=] or [=abstract numeric type=]
  <tr algorithm="vector select">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn select(f: vecN<T>,
                 t: vecN<T>,
                 cond: vecN<bool>) -> vecN<T>
</xmp>
  <tr>
    <th scope="row">Description
    <td>[=Component-wise=] selection. Result component |i| is evaluated
        as `select(`|f|`[`|i|`], `|t|`[`|i|`], `|cond|`[`|i|`])`.
</table>

## Array Built-in Functions ## {#array-builtin-functions}
<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|E| is an element type for a [=runtime-sized=] array,<br>
        [=access mode=] |AM| is [=access/read=] or [=access/read_write=]
  <tr algorithm="runtime-sized array length">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
fn arrayLength(p: ptr<storage, array<E>, AM>) -> u32
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the number of elements in the [=runtime-sized=] array.
</table>

## Float Built-in Functions ## {#float-builtin-functions}


<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="float abs">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn abs(e: T ) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the absolute value of |e| (e.g. |e| with a positive sign bit).
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="acos">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn acos(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the arc cosine of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="acosh">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn acosh(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the hyperbolic arc cosine of |e|.
    The result is 0 when |e| &lt; 1.<br>
    Computes the non-negative functional inverse of `cosh`.<br>
    [=Component-wise=] when |T| is a vector.

    Note: The result is not mathematically meaningful when |e| &lt; 1.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="asin">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn asin(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the arc sine of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="asinh">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn asinh(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the hyperbolic arc sine of |e|.<br>
    Computes the functional inverse of `sinh`.<br>
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="atan">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn atan(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the arc tangent of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="atanh">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn atanh(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the hyperbolic arc tangent of |e|.
    The result is 0 when `abs`(|e|) &ge; 1.<br>
    Computes the functional inverse of `tanh`.<br>
    [=Component-wise=] when |T| is a vector.

    Note: The result is not mathematically meaningful when `abs`(|e|) &ge; 1.<br>
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="atan2">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn atan2(e1: T,
                e2: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the arc tangent of |e1| over |e2|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="ceil">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn ceil(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the [=ceiling expression|ceiling=] of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="clamp">
  <th scope="row">Overload
  <td class="nowrap"><xmp highlight=rust>
@const fn clamp(e: T,
                low: T,
                high: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns either `min(max(`|e|`,`|low|`),`|high|`)`, or the median of
    the three values |e|, |low|, |high|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="cos">
  <th scope="row">Overload
  <td class="nowrap"><xmp highlight=rust>
@const fn cos(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the cosine of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="cosh">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn cosh(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the hyperbolic cosine of |e|.
    [=Component-wise=] when |T| is a vector
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is AbstractFloat, f32, or f16
  <tr algorithm="vector case, cross">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn cross(e1: vec3<T>,
                e2: vec3<T>) -> vec3<T>
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the cross product of |e1| and |e2|.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="degrees">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn degrees(e1: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Converts radians to degrees, approximating |e1|&nbsp;&times;&nbsp;180&nbsp;&div;&nbsp;&pi;.
    [=Component-wise=] when |T| is a vector<br>
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="distance">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn distance(e1: T,
                   e2: T) -> f32
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the distance between |e1| and |e2| (e.g. `length(`|e1|` - `|e2|`)`).
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="exp">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn exp(e1: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the natural exponentiation of |e1| (e.g. `e`<sup>|e1|</sup>).
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="exp2">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn exp2(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns 2 raised to the power |e| (e.g. `2`<sup>|e|</sup>).
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is vec|N|&lt;AbstractFloat&gt;, vec|N|&lt;f32&gt;, or vec|N|&lt;f16&gt;
  <tr algorithm="faceForward">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn faceForward(e1: T,
                      e2: T,
                      e3: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |e1| if `dot(`|e2|`,`|e3|`)` is negative, and `-`|e1| otherwise.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="floor">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn floor(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the [=floor expression|floor=] of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="fma">
  <th scope="row">Overload
  <td class="nowrap"><xmp highlight=rust>
@const fn fma(e1: T,
              e2: T,
              e3: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |e1| `*` |e2| `+` |e3|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="fract">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn fract(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the fractional part of |e|, computed as |e| `- floor(`|e|`)`.<br>
    [=Component-wise=] when |T| is a vector.

    Note: Valid results are in the closed interval [0, 1.0].
    For example, if |e| is a very small negative number, then `fract`(|e|) may be 1.0.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32
  <tr algorithm="scalar case, binary32, frexp">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn frexp(e: T) -> __frexp_result
</xmp>
  <tr>
    <th scope="row">Description
    <td>Splits |e| into a significand and exponent of the form `significand * 2`<sup>`exponent`</sup>.
    Returns the `__frexp_result` built-in structure, defined as follows:
    ```rust
struct __frexp_result {
  sig : f32, // significand part
  exp : i32  // exponent part
}
    ```
    The magnitude of the significand is in the range of [0.5, 1.0) or 0.

    Note: A value cannot be explicitly declared with the type `__frexp_result`,
    but a value may infer the type.

    <div class='example wgsl function-scope' heading='frexp usage'>
    <xmp highlight='rust'>
     // Infers result type
     let sig_and_exp = frexp(1.5);
     // Sets fraction_direct to 0.75
     let fraction_direct = frexp(1.5).sig;
    </xmp>
    </div>
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f16
  <tr algorithm="scalar case, binary16, frexp">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn frexp(e: T) -> __frexp_result_f16
</xmp>
  <tr>
    <th scope="row">Description
    <td>Splits |e| into a significand and exponent of the form `significand * 2`<sup>`exponent`</sup>.
    Returns the `__frexp_result_f16` built-in structure, defined as if as follows:
    ```rust
struct __frexp_result_f16 {
  sig : f16, // significand part
  exp : i32  // exponent part
}
    ```
    The magnitude of the significand is in the range of [0.5, 1.0) or 0.

    Note: A value cannot be explicitly declared with the type `__frexp_result_f16`,
    but a value may infer the type.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is vec|N|&lt;f32&gt;
  <tr algorithm="vector case, binary32, frexp">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn frexp(e: T) -> __frexp_result_vecN
</xmp>
  <tr>
    <th scope="row">Description
    <td>Splits the components of |e| into a significand and exponent of the form
    `significand * 2`<sup>`exponent`</sup>.

    Returns the `__frexp_result_vec`|N| built-in structure, defined as follows:
    ```rust
struct __frexp_result_vecN {
  sig : vecN<f32>, // significand part
  exp : vecN<i32>  // exponent part
}
    ```
    The magnitude of each component of the significand is in the range of [0.5, 1.0) or 0.

    Note: A value cannot be explicitly declared with the type `__frexp_result_vec`|N|,
    but a value may infer the type.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is vec|N|&lt;f16&gt;
  <tr algorithm="vector case, binary16, frexp">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn frexp(e: T) -> __frexp_result_vecN_f16
</xmp>
  <tr>
    <th scope="row">Description
    <td>Splits the components of |e| into a significand and exponent of the form
    `significand * 2`<sup>`exponent`</sup>.

    Returns the `__frexp_result_vec`|N| built-in structure, defined as if as follows:
    ```rust
struct __frexp_result_vecN_f16 {
  sig : vecN<f16>, // significand part
  exp : vecN<i32>  // exponent part
}
    ```
    The magnitude of each component of the significand is in the range of [0.5, 1.0) or 0.

    Note: A value cannot be explicitly declared with the type `__frexp_result_vec`|N|`_f16`,
    but a value may infer the type.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="inverseSqrt">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn inverseSqrt(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the reciprocal of `sqrt(`|e|`)`.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]<br>
        |I| is [ALLSIGNEDINTEGRAL]<br>
        |I| is a vector if and only if |T| is a vector<br>
        |I| is [=concrete=] if and only if |T| is a [=concrete=]
  <tr algorithm="ldexp">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn ldexp(e1: T,
                e2: I) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |e1| `* 2`<sup>|e2|</sup>.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="length">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn length(e: T) -> f32
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the length of |e| (e.g. `abs(`|e|`)` if |T| is a scalar, or
        `sqrt(`|e|`[0]`<sup>`2`</sup> `+` |e|`[1]`<sup>`2`</sup> `+ ...)` if |T| is a vector).
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="log">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn log(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the natural logarithm of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="log2">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn log2(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the base-2 logarithm of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="max">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn max(e1: T,
              e2: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |e2| if |e1| is less than |e2|, and |e1| otherwise.
    If one operand is a NaN, the other is returned.
    If both operands are NaNs, a NaN is returned.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="min">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn min(e1: T,
              e2: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |e2| if |e2| is less than |e1|, and |e1| otherwise.
    If one operand is a NaN, the other is returned.
    If both operands are NaNs, a NaN is returned.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="mix all same type operands">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn mix(e1: T,
              e2: T,
              e3: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the linear blend of |e1| and |e2| (e.g. |e1|`*(1-`|e3|`)+`|e2|`*`|e3|).
    [=Component-wise=] when |T| is a vector.
    <br>
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is AbstractFloat, f32, or f16<br>
        |T2| is vec|N|&lt;|T|&gt;
  <tr algorithm="vector mix with scalar blending factor">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn mix(e1: T2,
              e2: T2,
              e3: T) -> T2
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the component-wise linear blend of |e1| and |e2|,
        using scalar blending factor |e3| for each component.<br>
        Same as `mix(`|e1|`, `|e2|`, `|T2|`(`|e3|`))`.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32
  <tr algorithm="scalar case, binary32, modf">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn modf(e: T) -> __modf_result
</xmp>
  <tr>
    <th scope="row">Description
    <td>Splits |e| into fractional and whole number parts.

    The whole part is (|e| % 1.0), and the fractional part is |e| minus the whole part.

    Returns the `__modf_result` built-in structure, defined as follows:
    ```rust
struct __modf_result {
  fract : f32, // fractional part
  whole : f32  // whole part
}
    ```

    Note: A value cannot be explicitly declared with the type `__modf_result`,
    but a value may infer the type.

    <div class='example wgsl function-scope' heading='modf usage'>
    <xmp highlight='rust'>
     // Infers result type
     let fract_and_whole = modf(1.5);
     // Sets fract_direct to 0.5
     let fract_direct = modf(1.5).fract;
    </xmp>
    </div>
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f16
  <tr algorithm="scalar case, binary16, modf">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn modf(e: T) -> __modf_result_f16
</xmp>
  <tr>
    <th scope="row">Description
    <td>Splits |e| into fractional and whole number parts.

    The whole part is (|e| % 1.0), and the fractional part is |e| minus the whole part.

    Returns the `__modf_result_f16` built-in structure, defined as if as follows:
    ```rust
struct __modf_result_f16 {
  fract : f16, // fractional part
  whole : f16  // whole part
}
    ```

    Note: A value cannot be explicitly declared with the type `__modf_result_f16`,
    but a value may infer the type.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is vec|N|&lt;f32&gt;
  <tr algorithm="vector case, binary32, modf">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn modf(e: T) -> __modf_result_vecN
</xmp>
  <tr>
    <th scope="row">Description
    <td>Splits the components of |e| into fractional and whole number parts.

    The |i|'th component of the whole and fractional parts equal the whole and fractional parts
    of `modf`(|e|[|i|]).

    Returns the `__modf_result_vec`|N| built-in structure, defined as follows:
    ```rust
struct __modf_result_vecN {
  fract : vecN<f32>, // fractional part
  whole : vecN<f32>  // whole part
}
    ```

    Note: A value cannot be explicitly declared with the type `__modf_result_vec`|N|,
    but a value may infer the type.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is vec|N|&lt;f16&gt;
  <tr algorithm="vector case, binary16, modf">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn modf(e: T) -> __modf_result_vecN_f16
</xmp>
  <tr>
    <th scope="row">Description
    <td>Splits the components of |e| into fractional and whole number parts.

    The |i|'th component of the whole and fractional parts equal the whole and fractional parts
    of `modf`(|e|[|i|]).

    Returns the `__modf_result_vec`|N|`_f16` built-in structure, defined as if as follows:
    ```rust
struct __modf_result_vecN_f16 {
  fract : vecN<f16>, // fractional part
  whole : vecN<f16>  // whole part
}
    ```

    Note: A value cannot be explicitly declared with the type `__modf_result_vec`|N|`_f16`,
    but a value may infer the type.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is AbstractFloat, f32, or f16
  <tr algorithm="vector case, normalize">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn normalize(e: vecN<T> ) -> vecN<T>
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns a unit vector in the same direction as |e|.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="pow">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn pow(e1: T,
              e2: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |e1| raised to the power |e2|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32 or vec|N|&lt;f32&gt;
  <tr algorithm="quantize to f16">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn quantizeToF16(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Quantizes a 32-bit floating point value |e| as if |e| were converted to
        a [[!IEEE-754|IEEE 754]] binary16 value, and then converted back to a
        IEEE 754 binary32 value.<br>
        See [[#floating-point-conversion]].<br>
        [=Component-wise=] when |T| is a vector.<br>

        Note: The vec2&lt;f32&gt; case is the same as `unpack2x16float(pack2x16float(`|e|`))`.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="radians">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn radians(e1: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Converts degrees to radians, approximating |e1|&nbsp;&times;&nbsp;&pi;&nbsp;&div;&nbsp;180.
    [=Component-wise=] when |T| is a vector<br>
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is vec|N|&lt;AbstractFloat&gt;, vec|N|&lt;f32&gt;, or vec|N|&lt;f16&gt;
  <tr algorithm="reflect">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn reflect(e1: T,
                  e2: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>For the incident vector |e1| and surface orientation |e2|, returns the reflection direction
    |e1|`-2*dot(`|e2|`,`|e1|`)*`|e2|.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is vec|N|&lt;|I|&gt;<br>
        |I| is AbstractFloat, f32, or f16
  <tr algorithm="refract">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn refract(e1: T,
                  e2: T,
                  e3: I) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>For the incident vector |e1| and surface normal |e2|, and the ratio of
    indices of refraction |e3|,
    let `k = 1.0 - `|e3|` * `|e3|` * (1.0 - dot(`|e2|`, `|e1|`) * dot(`|e2|`, `|e1|`))`.
    If `k < 0.0`, returns the refraction vector 0.0, otherwise return the refraction vector
    |e3|` * `|e1|` - (`|e3|` * dot(`|e2|`, `|e1|`) + sqrt(k)) * `|e2|.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="round">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn round(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Result is the integer |k| nearest to |e|, as a floating point value.<br>
        When |e| lies halfway between integers |k| and |k|+1,
        the result is |k| when |k| is even, and |k|+1 when |k| is odd.<br>
        [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="float sign">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn sign(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the sign of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="sin">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn sin(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the sine of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="sinh">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn sinh(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the hyperbolic sine of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="smoothstep">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn smoothstep(low: T,
                     high: T,
                     x: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the smooth Hermite interpolation between 0 and 1.
    [=Component-wise=] when |T| is a vector.

    For scalar |T|, the result is
    |t| * |t| * (3.0 - 2.0 * |t|),
    where |t| = clamp((|x| - |low|) / (|high| - |low|), 0.0, 1.0).
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="sqrt">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn sqrt(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the square root of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="step">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn step(edge: T,
               x: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns 1.0 if |edge| &le; |x|, and 0.0 otherwise.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="tan">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn tan(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the tangent of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="tanh">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn tanh(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the hyperbolic tangent of |e|.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLFLOATINGDECL]
  <tr algorithm="trunc">
        <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn trunc(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns [=truncate=](|e|), the nearest whole number whose absolute value
    is less than or equal to |e|.
    [=Component-wise=] when |T| is a vector.
</table>

## Integer Built-in Functions ## {#integer-builtin-functions}

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLINTEGRALDECL]
  <tr algorithm="integral abs">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn abs(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>The absolute value of |e|.
        [=Component-wise=] when |T| is a vector.
        If |e| is a signed integral scalar type and evaluates to the largest negative
        value, then the result is |e|.
        If |e| is an unsigned integral type, then the result is |e|.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLINTEGRALDECL]
  <tr algorithm="integral clamp">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn clamp(e: T,
                low: T,
                high: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns `min(max(`|e|`,`|low|`),`|high|`)`.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [INTEGRAL]
  <tr algorithm="count leading zeroes">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn countLeadingZeros(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>The number of consecutive 0 bits starting from the most significant bit
        of |e|, when |T| is a scalar type.<br>
        [=Component-wise=] when |T| is a vector.<br>
        Also known as "clz" in some languages.<br>
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [INTEGRAL]
  <tr algorithm="count 1 bits">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn countOneBits(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>The number of 1 bits in the representation of |e|.<br>
        Also known as "population count".<br>
        [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [INTEGRAL]
  <tr algorithm="count trailing zeroes">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn countTrailingZeros(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>The number of consecutive 0 bits starting from the least significant bit
        of |e|, when |T| is a scalar type.<br>
        [=Component-wise=] when |T| is a vector.<br>
        Also known as "ctz" in some languages.<br>
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [SIGNEDINTEGRAL]
  <tr algorithm="signed find most significant one bit">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn firstLeadingBit(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>For scalar |T|, the result is:
        <ul>
        <li>-1 if |e| is 0 or -1.
        <li>Otherwise the position of the most significant bit in
            |e| that is different from |e|'s sign bit.
        </ul>

        Note: Since signed integers use twos-complement representation,
        the sign bit appears in the most significant bit position.

        [=Component-wise=] when |T| is a vector.<br>
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [UNSIGNEDINTEGRAL]
  <tr algorithm="unsigned find most significant one bit">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn firstLeadingBit(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>For scalar |T|, the result is:
        <ul>
        <li>|T|(-1) if |e| is zero.
        <li>Otherwise the position of the most significant 1
            bit in |e|.
        </ul>
        [=Component-wise=] when |T| is a vector.<br>
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [INTEGRAL]
  <tr algorithm="find least significant one bit">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn firstTrailingBit(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>For scalar |T|, the result is:
        <ul>
        <li>|T|(-1) if |e| is zero.
        <li>Otherwise the position of the least significant 1
            bit in |e|.
        </ul>
        [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [SIGNEDINTEGRAL]
  <tr algorithm="signed extract bits">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn extractBits(e: T,
                      offset: u32,
                      count: u32) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Reads bits from an integer, with sign extension.

    When |T| is a scalar type, then:
    <ul>
    <li>|w| is the bit width of |T|
    <li>|o| = min(|offset|,|w|)
    <li>|c| = min(|count|, |w| - |o|)
    <li>The result is 0 if |c| is 0.
    <li>Otherwise, bits 0..|c|-1 of the result are copied from bits
       |o|..|o|+|c|-1 of |e|.
       Other bits of the result are the same as bit |c|-1 of the result.
    </ul>
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [UNSIGNEDINTEGRAL]
  <tr algorithm="unsigned extract bits">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn extractBits(e: T,
                      offset: u32,
                      count: u32) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Reads bits from an integer, without sign extension.

    When |T| is a scalar type, then:
    <ul>
    <li>|w| is the bit width of |T|
    <li>|o| = min(|offset|,|w|)
    <li>|c| = min(|count|, |w| - |o|)
    <li>The result is 0 if |c| is 0.
    <li>Otherwise, bits 0..|c|-1 of the result are copied from bits
       |o|..|o|+|c|-1 of |e|.
       Other bits of the result are 0.
    </ul>
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [INTEGRAL]
  <tr algorithm="insert bits">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn insertBits(e: T,
                     newbits: T,
                     offset: u32,
                     count: u32) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Sets bits in an integer.

    When |T| is a scalar type, then:
    <ul>
    <li>|w| is the bit width of |T|
    <li>|o| = min(|offset|,|w|)
    <li>|c| = min(|count|, |w| - |o|)
    <li>The result is |e| if |c| is 0.
    <li>Otherwise,
       bits |o|..|o|+|c|-1 of the result are copied from bits 0..|c|-1 of |newbits|.
       Other bits of the result are copied from |e|.
    </ul>
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLINTEGRALDECL]
  <tr algorithm="integral max">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn max(e1: T,
              e2: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |e2| if |e1| is less than |e2|, and |e1| otherwise.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>[ALLINTEGRALDECL]
  <tr algorithm="integral min">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn min(e1: T,
              e2: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns |e1| if |e1| is less than |e2|, and |e2| otherwise.
    [=Component-wise=] when |T| is a vector.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is [INTEGRAL]
  <tr algorithm="bit reversal">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn reverseBits(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Reverses the bits in |e|:  The bit at position |k| of the result equals the
        bit at position 31-|k| of |e|.<br>
        [=Component-wise=] when |T| is a vector.
</table>

## Matrix Built-in Functions ## {#matrix-builtin-functions}
<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is AbstractFloat, f32, or f16
  <tr algorithm="determinant">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn determinant(e: matCxC<T>) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the determinant of |e|.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is AbstractFloat, f32, or f16
  <tr algorithm="transpose">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn transpose(e: matRxC<T>) -> matCxR<T>
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the transpose of |e|.
</table>

## Vector Built-in Functions ## {#vector-builtin-functions}

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is AbstractInt, AbstractFloat, i32, u32, f32, or f16
  <tr algorithm="dot">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn dot(e1: vecN<T>,
              e2: vecN<T>) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the dot product of |e1| and |e2|.
</table>

## Derivative Built-in Functions ## {#derivative-builtin-functions}

See [[#derivatives]].

These functions:
* [=shader-creation error|Must=] only be used in a [=fragment=] shader stage.
* [=shader-creation error|Must=] only be invoked in [=uniform control flow=].

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32 or vecN&lt;f32&gt;
  <tr algorithm="dpdx">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
fn dpdx(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Partial derivative of |e| with respect to window x coordinates.
    The result is the same as either `dpdxFine(`|e|`)` or `dpdxCoarse(`|e|`)`.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32 or vecN&lt;f32&gt;
  <tr algorithm="dpdxCoarse">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
fn dpdxCoarse(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the partial derivative of |e| with respect to window x coordinates using local differences.
    This may result in fewer unique positions that `dpdxFine(`|e|`)`.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32 or vecN&lt;f32&gt;
  <tr algorithm="dpdxFine">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
fn dpdxFine(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the partial derivative of |e| with respect to window x coordinates.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32 or vecN&lt;f32&gt;
  <tr algorithm="dpdy">
  <th scope="row">Overload
  <td class="nowrap"><xmp highlight=rust>
fn dpdy(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Partial derivative of |e| with respect to window y coordinates.
    The result is the same as either `dpdyFine(`|e|`)` or `dpdyCoarse(`|e|`)`.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32 or vecN&lt;f32&gt;
  <tr algorithm="dpdyCoarse">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
fn dpdyCoarse(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the partial derivative of |e| with respect to window y coordinates using local differences.
    This may result in fewer unique positions that `dpdyFine(`|e|`)`.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32 or vecN&lt;f32&gt;
  <tr algorithm="dpdyFine">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
fn dpdyFine(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns the partial derivative of |e| with respect to window y coordinates.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32 or vecN&lt;f32&gt;
  <tr algorithm="fwidth">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
fn fwidth(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns `abs(dpdx(`|e|`)) + abs(dpdy(`|e|`))`.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32 or vecN&lt;f32&gt;
  <tr algorithm="fwidthCoarse">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
fn fwidthCoarse(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns `abs(dpdxCoarse(`|e|`)) + abs(dpdyCoarse(`|e|`))`.
</table>

<table class='data'>
  <tr>
    <th scope="row" style="width:10%">Parameterization
    <td>|T| is f32 or vecN&lt;f32&gt;
  <tr algorithm="fwidthFine">
    <th scope="row">Overload
    <td class="nowrap"><xmp highlight=rust>
fn fwidthFine(e: T) -> T
</xmp>
  <tr>
    <th scope="row">Description
    <td>Returns `abs(dpdxFine(`|e|`)) + abs(dpdyFine(`|e|`))`.
</table>

## Texture Built-in Functions ## {#texture-builtin-functions}

Parameter values [=shader-creation error|must=] be valid for the respective texture types.

### `textureDimensions` ### {#texturedimensions}

Returns the dimensions of a texture, or texture's mip level in texels.


<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureDimensions 1d">
    <td><var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_1d<ST>` or `texture_storage_1d<F,A>`
    <td><xmp highlight=rust>fn textureDimensions(t: T) -> u32</xmp>

  <tr algorithm="textureDimensions 1d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]<br><br>
        |T| is `texture_1d<ST>`
    <td><xmp highlight=rust>
fn textureDimensions(t: T,
                     level: u32) -> u32</xmp>

  <tr algorithm="textureDimensions 2d">
    <td><var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_2d<ST>`, `texture_2d_array<ST>`, `texture_cube<ST>`,
               `texture_cube_array<ST>`, `texture_multisampled_2d<ST>`,
               `texture_depth_2d`, `texture_depth_2d_array`, `texture_depth_cube`,
               `texture_depth_cube_array`, `texture_depth_multisampled_2d`,
               `texture_storage_2d<F,A>`, `texture_storage_2d_array<F,A>`,
               or `texture_external`
    <td><xmp highlight=rust>fn textureDimensions(t: T) -> vec2<u32></xmp>

  <tr algorithm="textureDimensions 2d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]<br><br>
        |T| is `texture_2d<ST>`, `texture_2d_array<ST>`, `texture_cube<ST>`,
               `texture_cube_array<ST>`, `texture_depth_2d`, `texture_depth_2d_array`,
               `texture_depth_cube`, or `texture_depth_cube_array`
    <td><xmp highlight=rust>
fn textureDimensions(t: T,
                     level: u32) -> vec2<u32></xmp>

  <tr algorithm="textureDimensions 3d">
    <td><var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]<br>
        <var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br><br>
        |T| is `texture_3d<ST>` or `texture_storage_3d<F,A>`
    <td><xmp highlight=rust>fn textureDimensions(t: T) -> vec3<u32></xmp>

  <tr algorithm="textureDimensions 3d level">
    <td><var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]<br><br>
        |T| is `texture_3d<ST>`
    <td><xmp highlight=rust>
fn textureDimensions(t: T,
                     level: u32) -> vec3<u32></xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type),
  [multisampled](#multisampled-texture-type), [depth](#texture-depth),
  [storage](#texture-storage), or [external](#external-texture-type) texture.
  <tr><td>`level`<td>
  The mip level, with level 0 containing a full size version of the texture.<br>
  If omitted, the dimensions of level 0 are returned.
</table>

**Returns:**

The dimensions of the texture in texels.

For textures based on cubes, the results are the dimensions of each face of the cube.
Cube faces are square, so the x and y components of the result are equal.

If `level` is outside the range `[0, textureNumLevels(t))` then any valid value
for the return type may be returned.

### `textureGather` ### {#texturegather}

A <dfn noexport>texture gather</dfn> operation reads from a 2D, 2D array, cube, or cube array texture,
computing a four-component vector as follows:
* Find the four texels that would be used in a sampling operation with linear filtering,
    from [=mip level=] 0:
    * Use the specified coordinate, array index (when present), and offset (when present).
    * The texels are adjacent, forming a square, when considering their texture space coordinates (*u*,*v*).
    * Selected texels at the texture edge, cube face edge, or cube corners are handled
        as in ordinary texture sampling.
* For each texel, read one channel and convert it into a scalar value.
    * For non-depth textures, a zero-based `component` parameter specifies the channel to use.
        * If the texture format supports the specified channel, i.e. has more than `component` channels:
             * Yield scalar value `v[component]` when the texel value is `v`.
        * Otherwise:
             * Yield 0.0 when `component` is 1 or 2.
             * Yield 1.0 when `component` is 3 (the alpha channel).
    * For depth textures, yield the texel value. (Depth textures only have one channel.)
* Yield the four-component vector, arranging scalars produced by the previous step into components
    according to the relative coordinates of the texels, as follows:
    * <table>
        <thead class='data'><td>Result component<td>Relative texel coordinate</thead>
        <tr><td>x<td>(*u*<sub>min</sub>,*v*<sub>max</sub>)
        <tr><td>y<td>(*u*<sub>max</sub>,*v*<sub>max</sub>)
        <tr><td>z<td>(*u*<sub>max</sub>,*v*<sub>min</sub>)
        <tr><td>w<td>(*u*<sub>min</sub>,*v*<sub>min</sub>)
        </table>

TODO: The four texels are the "sample footprint" that should be described by the WebGPU spec.
https://github.com/gpuweb/gpuweb/issues/2343

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureGather 2d">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureGather(component: C,
                 t: texture_2d<ST>,
                 s: sampler,
                 coords: vec2<f32>) -> vec4<ST></xmp>

  <tr algorithm="textureGather 2d offset">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureGather(component: C,
                 t: texture_2d<ST>,
                 s: sampler,
                 coords: vec2<f32>,
                 offset: vec2<i32>) -> vec4<ST></xmp>

  <tr algorithm="textureGather 2d array">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureGather(component: C,
                 t: texture_2d_array<ST>,
                 s: sampler,
                 coords: vec2<f32>,
                 array_index: C) -> vec4<ST></xmp>

  <tr algorithm="textureGather 2d array offset">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureGather(component: C,
                 t: texture_2d_array<ST>,
                 s: sampler,
                 coords: vec2<f32>,
                 array_index: C,
                 offset: vec2<i32>) -> vec4<ST></xmp>

  <tr algorithm="textureGather cube">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureGather(component: C,
                 t: texture_cube<ST>,
                 s: sampler,
                 coords: vec3<f32>) -> vec4<ST></xmp>

  <tr algorithm="textureGather cube array">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureGather(component: C,
                 t: texture_cube_array<ST>,
                 s: sampler,
                 coords: vec3<f32>,
                 array_index: C) -> vec4<ST></xmp>

  <tr algorithm="textureGather 2d depth">
    <td>
    <td><xmp highlight=rust>
fn textureGather(t: texture_depth_2d,
                 s: sampler,
                 coords: vec2<f32>) -> vec4<f32></xmp>

  <tr algorithm="textureGather 2d depth offset">
    <td>
    <td><xmp highlight=rust>
fn textureGather(t: texture_depth_2d,
                 s: sampler,
                 coords: vec2<f32>,
                 offset: vec2<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureGather cube depth">
    <td>
    <td><xmp highlight=rust>
fn textureGather(t: texture_depth_cube,
                 s: sampler,
                 coords: vec3<f32>) -> vec4<f32></xmp>

  <tr algorithm="textureGather 2d depth array">
    <td><var ignore>C</var> is [=i32=] or [=u32=]
    <td><xmp highlight=rust>
fn textureGather(t: texture_depth_2d_array,
                 s: sampler,
                 coords: vec2<f32>,
                 array_index: C) -> vec4<f32></xmp>

  <tr algorithm="textureGather 2d depth array offset">
    <td><var ignore>C</var> is [=i32=] or [=u32=]
    <td><xmp highlight=rust>
fn textureGather(t: texture_depth_2d_array,
                 s: sampler,
                 coords: vec2<f32>,
                 array_index: C,
                 offset: vec2<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureGather cube depth array">
    <td><var ignore>C</var> is [=i32=] or [=u32=]
    <td><xmp highlight=rust>
fn textureGather(t: texture_depth_cube_array,
                 s: sampler,
                 coords: vec3<f32>,
                 array_index: C) -> vec4<f32></xmp>
</table>

**Parameters:**

<table class='data'>
  <tr><td>`component`<td>
  Only applies to non-depth textures.
  <br>The index of the channel to read from the selected texels.
  <br>When provided, the `component` expression [=shader-creation error|must=] be a [=creation-time expression=] (e.g. `1`).<br>
  Its value must be at least 0 and at most 3.
  Values outside of this range will result in a [=shader-creation error=].
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type) or [depth](#texture-depth) texture to read from.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A four component vector with components extracted from the specified channel from the selected texels, as described above.

<div class='example wgsl global-scope' heading="Gather components from texels in 2D texture">
  <xmp highlight='rust'>
    @group(0) @binding(0) var t: texture_2d<f32>;
    @group(0) @binding(1) var dt: texture_depth_2d;
    @group(0) @binding(2) var s: sampler;

    fn gather_x_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(0,t,s,c);
    }
    fn gather_y_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(1,t,s,c);
    }
    fn gather_z_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(2,t,s,c);
    }
    fn gather_depth_components(c: vec2<f32>) -> vec4<f32> {
      return textureGather(dt,s,c);
    }
  </xmp>
</div>

### `textureGatherCompare` ### {#texturegathercompare}

A <dfn noexport>texture gather compare</dfn> operation performs a depth comparison on four texels in a depth
texture and collects the results into a single vector, as follows:

* Find the four texels that would be used in a depth sampling operation with linear filtering,
    from [=mip level=] 0:
    * Use the specified coordinate, array index (when present), and offset (when present).
    * The texels are adjacent, forming a square, when considering their texture space coordinates (*u*,*v*).
    * Selected texels at the texture edge, cube face edge, or cube corners are handled
        as in ordinary texture sampling.
* For each texel, perform a comparison against the depth reference value,
    yielding a 0.0 or 1.0 value, as controlled by the comparison sampler parameters.
* Yield the four-component vector where the components are the comparison results with the texels with
       relative texel coordinates as follows:
    * <table>
        <thead class='data'><td>Result component<td>Relative texel coordinate</thead>
        <tr><td>x<td>(*u*<sub>min</sub>,*v*<sub>max</sub>)
        <tr><td>y<td>(*u*<sub>max</sub>,*v*<sub>max</sub>)
        <tr><td>z<td>(*u*<sub>max</sub>,*v*<sub>min</sub>)
        <tr><td>w<td>(*u*<sub>min</sub>,*v*<sub>min</sub>)
        </table>

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureGatherCompare 2d depth">
    <td>
    <td><xmp highlight=rust>
fn textureGatherCompare(t: texture_depth_2d,
                        s: sampler_comparison,
                        coords: vec2<f32>,
                        depth_ref: f32) -> vec4<f32></xmp>

  <tr algorithm="textureGatherCompare 2d depth offset">
    <td>
    <td><xmp highlight=rust>
fn textureGatherCompare(t: texture_depth_2d,
                        s: sampler_comparison,
                        coords: vec2<f32>,
                        depth_ref: f32,
                        offset: vec2<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureGatherCompare 2d depth array">
    <td><var ignore>C</var> is [=i32=] or [=u32=]
    <td><xmp highlight=rust>
fn textureGatherCompare(t: texture_depth_2d_array,
                        s: sampler_comparison,
                        coords: vec2<f32>,
                        array_index: C,
                        depth_ref: f32) -> vec4<f32></xmp>

  <tr algorithm="textureGatherCompare 2d depth array offset">
    <td><var ignore>C</var> is [=i32=] or [=u32=]
    <td><xmp highlight=rust>
fn textureGatherCompare(t: texture_depth_2d_array,
                        s: sampler_comparison,
                        coords: vec2<f32>,
                        array_index: C,
                        depth_ref: f32,
                        offset: vec2<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureGatherCompare 2d depth cube">
    <td>
    <td><xmp highlight=rust>
fn textureGatherCompare(t: texture_depth_cube,
                        s: sampler_comparison,
                        coords: vec3<f32>,
                        depth_ref: f32) -> vec4<f32></xmp>

  <tr algorithm="textureGatherCompare 2d depth cube array">
    <td><var ignore>C</var> is [=i32=] or [=u32=]
    <td><xmp highlight=rust>
fn textureGatherCompare(t: texture_depth_cube_array,
                        s: sampler_comparison,
                        coords: vec3<f32>,
                        array_index: C,
                        depth_ref: f32) -> vec4<f32></xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [depth](#texture-depth) texture to read from.
  <tr><td>`s`<td>
  The [sampler comparison](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`depth_ref`<td>
  The reference value to compare the sampled depth value against.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A four component vector with comparison result for the selected texels, as described above.

<div class='example wgsl global-scope' heading="Gather depth comparison">
  <xmp highlight='rust'>
    @group(0) @binding(0) var dt: texture_depth_2d;
    @group(0) @binding(1) var s: sampler;

    fn gather_depth_compare(c: vec2<f32>, depth_ref: f32) -> vec4<f32> {
      return textureGatherCompare(dt,s,c,depth_ref);
    }
  </xmp>
</div>

### `textureLoad` ### {#textureload}

Reads a single texel from a texture without sampling or filtering.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureLoad 1d">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureLoad(t: texture_1d<ST>,
               coords: C,
               level: C) -> vec4<ST></xmp>

  <tr algorithm="textureLoad 2d">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureLoad(t: texture_2d<ST>,
               coords: vec2<C>,
               level: C) -> vec4<ST></xmp>

  <tr algorithm="textureLoad 2d array">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureLoad(t: texture_2d_array<ST>,
              coords: vec2<C>,
              array_index: C,
              level: C) -> vec4<ST></xmp>

  <tr algorithm="textureLoad 3d">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureLoad(t: texture_3d<ST>,
               coords: vec3<C>,
               level: C) -> vec4<ST></xmp>

  <tr algorithm="textureLoad 2d multisampled">
    <td><var ignore>C</var> is [=i32=] or [=u32=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]
    <td><xmp highlight=rust>
fn textureLoad(t: texture_multisampled_2d<ST>,
               coords: vec2<C>,
               sample_index: C)-> vec4<ST></xmp>

  <tr algorithm="textureLoad 2d depth">
    <td><var ignore>C</var> is [=i32=] or [=u32=]
    <td><xmp highlight=rust>
fn textureLoad(t: texture_depth_2d,
               coords: vec2<C>,
               level: C) -> f32</xmp>

  <tr algorithm="textureLoad 2d depth array">
    <td><var ignore>C</var> is [=i32=] or [=u32=]
    <td><xmp highlight=rust>
fn textureLoad(t: texture_depth_2d_array,
               coords: vec2<C>,
               array_index: C,
               level: C) -> f32</xmp>

<tr algorithm="textureLoad 2d depth multisampled">
    <td><var ignore>C</var> is [=i32=] or [=u32=]
    <td><xmp highlight=rust>
fn textureLoad(t: texture_depth_multisampled_2d,
               coords: vec2<C>,
               sample_index: C)-> f32</xmp>

  <tr algorithm="textureLoad external">
    <td><var ignore>C</var> is [=i32=] or [=u32=]
    <td><xmp highlight=rust>
fn textureLoad(t: texture_external,
               coords: vec2<C>) -> vec4<f32></xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type),
  [multisampled](#multisampled-texture-type), [depth](#texture-depth),
  or [external](#external-texture-type) texture.
  <tr><td>`coords`<td>
  The 0-based texel coordinate.
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`level`<td>
  The mip level, with level 0 containing a full size version of the texture.
  <tr><td>`sample_index`<td>
  The 0-based sample index of the multisampled texture.
</table>

**Returns:**

The unfiltered texel data.

An out of bounds access occurs if:
* any element of `coords` is outside the range `[0, textureDimensions(t, level))`
    for the corresponding element, or
* `array_index` is outside the range `[0, textureNumLayers(t))`, or
* `level` is outside the range `[0, textureNumLevels(t))`, or
* `sample_index` is outside the range `[0, textureNumSamples(s))`

If an out of bounds access occurs, the built-in function returns one of:
* The data for some texel within bounds of the texture
* A vector (0,0,0,0) or (0,0,0,1) of the appropriate type for non-depth textures
* 0.0 for depth textures

### `textureNumLayers` ### {#texturenumlayers}

Returns the number of layers (elements) of an array texture.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="texturenumlayers">
    <td><var ignore>F</var> is a [=texel format=]<br>
        <var ignore>A</var> is an [=access mode=]<br>
        <var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]<br><br>
        <var ignore>T</var> is `texture_2d_array<ST>`, `texture_cube_array<ST>`,
                               `texture_depth_2d_array`, `texture_depth_cube_array`,
                               or `texture_storage_2d_array<F,A>`
    <td><xmp highlight=rust>
fn textureNumLayers(t: T) -> u32</xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type),
  [depth](#texture-depth) or
  [storage](#texture-storage) array texture.
</table>

**Returns:**

The number of layers (elements) of the array texture.


### `textureNumLevels` ### {#texturenumlevels}

Returns the number of mip levels of a texture.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="texturenumlevels">
    <td><var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]<br><br>
        <var ignore>T</var> is `texture_1d<ST>`, `texture_2d<ST>`,
                               `texture_2d_array<ST>`, `texture_3d<ST>`,
                               `texture_cube<ST>`, `texture_cube_array<ST>`,
                               `texture_depth_2d`, `texture_depth_2d_array`,
                               `texture_depth_cube`, or `texture_depth_cube_array`
    <td><xmp highlight=rust>
fn textureNumLevels(t: T) -> u32</xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type) or [depth](#texture-depth) texture.
</table>

**Returns:**

The number of mip levels for the texture.


### `textureNumSamples` ### {#texturenumsamples}

Returns the number samples per texel in a multisampled texture.

<table class='data'>
  <thead>
    <tr><td style="width:45%">Parameterization<th>Overload
  </thead>
  <tr algorithm="texturenumsamples">
    <td><var ignore>ST</var> is [=i32=], [=u32=] or [=f32=]<br><br>
        <var ignore>T</var> is `texture_multisamlped_2d<ST>`
                                or `texture_depth_multisampled_2d`
    <td><xmp highlight=rust>
fn textureNumSamples(t: T) -> u32</xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [multisampled](#multisampled-texture-type) texture.
</table>

**Returns:**

The number of samples per texel in the multisampled texture.


### `textureSample` ### {#texturesample}

Samples a texture.

[=shader-creation error|Must=] only be used in a [=fragment=] shader stage.
[=shader-creation error|Must=] only be invoked in [=uniform control flow=].

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSample 1d">
    <td>
    <td><xmp highlight=rust>
fn textureSample(t: texture_1d<f32>,
                 s: sampler,
                 coords: f32) -> vec4<f32></xmp>

  <tr algorithm="textureSample 2d">
    <td>
    <td><xmp highlight=rust>
fn textureSample(t: texture_2d<f32>,
                 s: sampler,
                 coords: vec2<f32>) -> vec4<f32></xmp>

  <tr algorithm="textureSample 2d offset">
    <td>
    <td><xmp highlight=rust>
fn textureSample(t: texture_2d<f32>,
                 s: sampler,
                 coords: vec2<f32>,
                 offset: vec2<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureSample 2d array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSample(t: texture_2d_array<f32>,
                 s: sampler,
                 coords: vec2<f32>,
                 array_index: C) -> vec4<f32></xmp>

  <tr algorithm="textureSample 2d array offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSample(t: texture_2d_array<f32>,
                 s: sampler,
                 coords: vec2<f32>,
                 array_index: C,
                 offset: vec2<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureSample 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td><xmp highlight=rust>
fn textureSample(t: T,
                 s: sampler,
                 coords: vec3<f32>) -> vec4<f32></xmp>

  <tr algorithm="textureSample 3d offset">
    <td>
    <td><xmp highlight=rust>
fn textureSample(t: texture_3d<f32>,
                 s: sampler,
                 coords: vec3<f32>,
                 offset: vec3<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureSample cube array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSample(t: texture_cube_array<f32>,
                 s: sampler,
                 coords: vec3<f32>,
                 array_index: C) -> vec4<f32></xmp>

  <tr algorithm="textureSample 2d depth">
    <td>
    <td><xmp highlight=rust>
fn textureSample(t: texture_depth_2d,
                 s: sampler,
                 coords: vec2<f32>) -> f32</xmp>

  <tr algorithm="textureSample 2d depth offset">
    <td>
    <td><xmp highlight=rust>
fn textureSample(t: texture_depth_2d,
                 s: sampler,
                 coords: vec2<f32>,
                 offset: vec2<i32>) -> f32</xmp>

  <tr algorithm="textureSample 2d depth array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSample(t: texture_depth_2d_array,
                 s: sampler,
                 coords: vec2<f32>,
                 array_index: C) -> f32</xmp>

  <tr algorithm="textureSample 2d depth array offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSample(t: texture_depth_2d_array,
                 s: sampler,
                 coords: vec2<f32>,
                 array_index: C,
                 offset: vec2<i32>) -> f32</xmp>

  <tr algorithm="textureSample cube depth">
    <td>
    <td><xmp highlight=rust>
fn textureSample(t: texture_depth_cube,
                 s: sampler,
                 coords: vec3<f32>) -> f32</xmp>

  <tr algorithm="textureSample cube depth array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSample(t: texture_depth_cube_array,
                 s: sampler,
                 coords: vec3<f32>,
                 array_index: C) -> f32</xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type), [depth](#texture-depth),
  or [external](#external-texture-type)
  texture to sample.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.

### `textureSampleBias` ### {#texturesamplebias}

Samples a texture with a bias to the mip level.

[=shader-creation error|Must=] only be used in a [=fragment=] shader stage.
[=shader-creation error|Must=] only be invoked in [=uniform control flow=].

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleBias 2d">
    <td>
    <td><xmp highlight=rust>
fn textureSampleBias(t: texture_2d<f32>,
                     s: sampler,
                     coords: vec2<f32>,
                     bias: f32) -> vec4<f32></xmp>

<tr algorithm="textureSampleBias 2d offset">
    <td>
    <td><xmp highlight=rust>
fn textureSampleBias(t: texture_2d<f32>,
                     s: sampler,
                     coords: vec2<f32>,
                     bias: f32,
                     offset: vec2<i32>) -> vec4<f32></xmp>

<tr algorithm="textureSampleBias 2d array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleBias(t: texture_2d_array<f32>,
                     s: sampler,
                     coords: vec2<f32>,
                     array_index: C,
                     bias: f32) -> vec4<f32></xmp>

<tr algorithm="textureSampleBias 2d array offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleBias(t: texture_2d_array<f32>,
                     s: sampler,
                     coords: vec2<f32>,
                     array_index: C,
                     bias: f32,
                     offset: vec2<i32>) -> vec4<f32></xmp>

<tr algorithm="textureSampleBias 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td><xmp highlight=rust>
fn textureSampleBias(t: T,
                     s: sampler,
                     coords: vec3<f32>,
                     bias: f32) -> vec4<f32></xmp>

<tr algorithm="textureSampleBias 3d offset">
    <td>
    <td><xmp highlight=rust>
fn textureSampleBias(t: texture_3d<f32>,
                     s: sampler,
                     coords: vec3<f32>,
                     bias: f32,
                     offset: vec3<i32>) -> vec4<f32></xmp>

<tr algorithm="textureSampleBias cube array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleBias(t: texture_cube_array<f32>,
                     s: sampler,
                     coords: vec3<f32>,
                     array_index: C,
                     bias: f32) -> vec4<f32></xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [texture](#sampled-texture-type) to sample.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`bias`<td>
  The bias to apply to the mip level before sampling.
  `bias` [=shader-creation error|must=] be between `-16.0` and `15.99`.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.


### `textureSampleCompare` ### {#texturesamplecompare}

Samples a depth texture and compares the sampled depth values against a reference value.

[=shader-creation error|Must=] only be used in a [=fragment=] shader stage.
[=shader-creation error|Must=] only be invoked in [=uniform control flow=].

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleCompare 2d depth">
    <td>
    <td><xmp highlight=rust>
fn textureSampleCompare(t: texture_depth_2d,
                        s: sampler_comparison,
                        coords: vec2<f32>,
                        depth_ref: f32) -> f32</xmp>

  <tr algorithm="textureSampleCompare 2d depth offset">
    <td>
    <td><xmp highlight=rust>
fn textureSampleCompare(t: texture_depth_2d,
                        s: sampler_comparison,
                        coords: vec2<f32>,
                        depth_ref: f32,
                        offset: vec2<i32>) -> f32</xmp>

  <tr algorithm="textureSampleCompare 2d array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleCompare(t: texture_depth_2d_array,
                        s: sampler_comparison,
                        coords: vec2<f32>,
                        array_index: C,
                        depth_ref: f32) -> f32</xmp>

  <tr algorithm="textureSampleCompare 2d depth array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleCompare(t: texture_depth_2d_array,
                        s: sampler_comparison,
                        coords: vec2<f32>,
                        array_index: C,
                        depth_ref: f32,
                        offset: vec2<i32>) -> f32</xmp>

  <tr algorithm="textureSampleCompare cube depth">
    <td>
    <td><xmp highlight=rust>
fn textureSampleCompare(t: texture_depth_cube,
                        s: sampler_comparison,
                        coords: vec3<f32>,
                        depth_ref: f32) -> f32</xmp>

  <tr algorithm="textureSampleCompare cube depth array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleCompare(t: texture_depth_cube_array,
                        s: sampler_comparison,
                        coords: vec3<f32>,
                        array_index: C,
                        depth_ref: f32) -> f32</xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [depth](#texture-depth) texture to sample.
  <tr><td>`s`<td>
  The [sampler comparision](#sampler-type) type.
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`depth_ref`<td>
  The reference value to compare the sampled depth value against.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

A value in the range `[0.0..1.0]`.

Each sampled texel is compared against the reference value using the comparision
operator defined by the `sampler_comparison`, resulting in either a `0` or `1`
value for each texel.

If the sampler uses bilinear filtering then the returned value is
the filtered average of these values, otherwise the comparision result of a
single texel is returned.


### `textureSampleCompareLevel` ### {#texturesamplecomparelevel}

Samples a depth texture and compares the sampled depth values against a reference value.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleCompareLevel 2d depth">
    <td>
    <td><xmp highlight=rust>
fn textureSampleCompareLevel(t: texture_depth_2d,
                             s: sampler_comparison,
                             coords: vec2<f32>,
                             depth_ref: f32) -> f32</xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth offset">
    <td>
    <td><xmp highlight=rust>
fn textureSampleCompareLevel(t: texture_depth_2d,
                             s: sampler_comparison,
                             coords: vec2<f32>,
                             depth_ref: f32,
                             offset: vec2<i32>) -> f32</xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleCompareLevel(t: texture_depth_2d_array,
                             s: sampler_comparison,
                             coords: vec2<f32>,
                             array_index: C,
                             depth_ref: f32) -> f32</xmp>

  <tr algorithm="textureSampleCompareLevel 2d depth array offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleCompareLevel(t: texture_depth_2d_array,
                             s: sampler_comparison,
                             coords: vec2<f32>,
                             array_index: C,
                             depth_ref: f32,
                             offset: vec2<i32>) -> f32</xmp>

  <tr algorithm="textureSampleCompareLevel cube depth">
    <td>
    <td><xmp highlight=rust>
fn textureSampleCompareLevel(t: texture_depth_cube,
                             s: sampler_comparison,
                             coords: vec3<f32>,
                             depth_ref: f32) -> f32</xmp>

  <tr algorithm="textureSampleCompareLevel cube depth array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleCompareLevel(t: texture_depth_cube_array,
                             s: sampler_comparison,
                             coords: vec3<f32>,
                             array_index: C,
                             depth_ref: f32) -> f32</xmp>

</table>

The `textureSampleCompareLevel` function is the same as `textureSampleCompare`, except that:

* `textureSampleCompareLevel` always samples texels from mip level 0.
    * The function does not compute derivatives.
    * There is no requirement for `textureSampleCompareLevel` to be invoked in [=uniform control flow=].
* `textureSampleCompareLevel` may be invoked in any shader stage.

### `textureSampleGrad` ### {#texturesamplegrad}

Samples a texture using explicit gradients.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleGrad 2d">
    <td>
    <td><xmp highlight=rust>
fn textureSampleGrad(t: texture_2d<f32>,
                     s: sampler,
                     coords: vec2<f32>,
                     ddx: vec2<f32>,
                     ddy: vec2<f32>) -> vec4<f32></xmp>

  <tr algorithm="textureSampleGrad 2d offset">
    <td>
    <td><xmp highlight=rust>
fn textureSampleGrad(t: texture_2d<f32>,
                     s: sampler,
                     coords: vec2<f32>,
                     ddx: vec2<f32>,
                     ddy: vec2<f32>,
                     offset: vec2<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureSampleGrad 2d array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleGrad(t: texture_2d_array<f32>,
                     s: sampler,
                     coords: vec2<f32>,
                     array_index: C,
                     ddx: vec2<f32>,
                     ddy: vec2<f32>) -> vec4<f32></xmp>

  <tr algorithm="textureSampleGrad 2d array offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleGrad(t: texture_2d_array<f32>,
                     s: sampler,
                     coords: vec2<f32>,
                     array_index: C,
                     ddx: vec2<f32>,
                     ddy: vec2<f32>,
                     offset: vec2<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureSampleGrad 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td><xmp highlight=rust>
fn textureSampleGrad(t: T,
                     s: sampler,
                     coords: vec3<f32>,
                     ddx: vec3<f32>,
                     ddy: vec3<f32>) -> vec4<f32></xmp>

  <tr algorithm="textureSampleGrad 3d offset">
    <td>
    <td><xmp highlight=rust>
fn textureSampleGrad(t: texture_3d<f32>,
                     s: sampler,
                     coords: vec3<f32>,
                     ddx: vec3<f32>,
                     ddy: vec3<f32>,
                     offset: vec3<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureSampleGrad cube array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleGrad(t: texture_cube_array<f32>,
                     s: sampler,
                     coords: vec3<f32>,
                     array_index: C,
                     ddx: vec3<f32>,
                     ddy: vec3<f32>) -> vec4<f32></xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [texture](#sampled-texture-type) to sample.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`ddx`<td>
  The x direction derivative vector used to compute the sampling locations.
  <tr><td>`ddy`<td>
  The y direction derivative vector used to compute the sampling locations.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.


### `textureSampleLevel` ### {#texturesamplelevel}

Samples a texture using an explicit mip level, or at mip level 0.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureSampleLevel 2d">
    <td>
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_2d<f32>,
                      s: sampler,
                      coords: vec2<f32>,
                      level: f32) -> vec4<f32></xmp>

  <tr algorithm="textureSampleLevel 2d offset">
    <td>
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_2d<f32>,
                      s: sampler,
                      coords: vec2<f32>,
                      level: f32,
                      offset: vec2<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureSampleLevel 2d array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_2d_array<f32>,
                      s: sampler,
                      coords: vec2<f32>,
                      array_index: C,
                      level: f32) -> vec4<f32></xmp>

  <tr algorithm="textureSampleLevel 2d array offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_2d_array<f32>,
                      s: sampler,
                      coords: vec2<f32>,
                      array_index: C,
                      level: f32,
                      offset: vec2<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureSampleLevel 3d">
    <td><var ignore>T</var> is `texture_3d<f32>`, or `texture_cube<f32>`
    <td><xmp highlight=rust>
fn textureSampleLevel(t: T,
                      s: sampler,
                      coords: vec3<f32>,
                      level: f32) -> vec4<f32></xmp>

  <tr algorithm="textureSampleLevel 3d offset">
    <td>
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_3d<f32>,
                      s: sampler,
                      coords: vec3<f32>,
                      level: f32,
                      offset: vec3<i32>) -> vec4<f32></xmp>

  <tr algorithm="textureSampleLevel cube array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_cube_array<f32>,
                      s: sampler,
                      coords: vec3<f32>,
                      array_index: C,
                      level: f32) -> vec4<f32></xmp>

  <tr algorithm="textureSampleLevel 2d depth">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_depth_2d,
                      s: sampler,
                      coords: vec2<f32>,
                      level: C) -> f32</xmp>

  <tr algorithm="textureSampleLevel 2d depth offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_depth_2d,
                      s: sampler,
                      coords: vec2<f32>,
                      level: C,
                      offset: vec2<i32>) -> f32</xmp>

  <tr algorithm="textureSampleLevel 2d depth array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_depth_2d_array,
                      s: sampler,
                      coords: vec2<f32>,
                      array_index: C,
                      level: C) -> f32</xmp>

  <tr algorithm="textureSampleLevel 2d depth array offset">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_depth_2d_array,
                      s: sampler,
                      coords: vec2<f32>,
                      array_index: C,
                      level: C,
                      offset: vec2<i32>) -> f32</xmp>

  <tr algorithm="textureSampleLevel cube depth">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_depth_cube,
                      s: sampler,
                      coords: vec3<f32>,
                      level: C) -> f32</xmp>

  <tr algorithm="textureSampleLevel cube depth array">
    <td><var ignore>C</var> is [=i32=], or [=u32=]
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_depth_cube_array,
                      s: sampler,
                      coords: vec3<f32>,
                      array_index: C,
                      level: C) -> f32
</xmp>
  <tr algorithm="textureSampleLevel external">
    <td>
    <td><xmp highlight=rust>
fn textureSampleLevel(t: texture_external,
                      s: sampler,
                      coords: vec2<f32>) -> vec4<f32></xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [sampled](#sampled-texture-type) or [depth](#texture-depth) texture to
  sample.
  <tr><td>`s`<td>
  The [sampler type](#sampler-type).
  <tr><td>`coords`<td>
  The texture coordinates used for sampling.
  <tr><td>`array_index`<td>
  The 0-based texture array index to sample.
  <tr><td>`level`<td>
  The mip level, with level 0 containing a full size version of the texture.
  For the functions where `level` is a `f32`, fractional values may interpolate
  between two levels if the format is filterable according to the
  [Texture Format Capabilities](https://gpuweb.github.io/gpuweb/#texture-format-caps).<br>
  When not specified, mip level 0 is sampled.
  <tr><td>`offset`<td>
  The optional texel offset applied to the unnormalized texture coordinate
  before sampling the texture. This offset is applied before applying any
  texture wrapping modes.<br>
  The `offset` expression [=shader-creation error|must=] be a [=creation-time expression=] (e.g. `vec2<i32>(1, 2)`).<br>
  Each `offset` component [=shader-creation error|must=] be at least `-8` and at most `7`. Values outside
  of this range will result in a [=shader-creation error=].
</table>

**Returns:**

The sampled value.


### `textureStore` ### {#texturestore}

Writes a single texel to a texture.

<table class='data'>
  <thead>
    <tr><td style="width:25%">Parameterization<th>Overload
  </thead>
  <tr algorithm="textureStore 1d">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td><xmp highlight=rust>
fn textureStore(t: texture_storage_1d<F,write>,
                coords: C,
                value: vec4<CF>)</xmp>

  <tr algorithm="textureStore 2d">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td><xmp highlight=rust>
fn textureStore(t: texture_storage_2d<F,write>,
                coords: vec2<C>,
                value: vec4<CF>)</xmp>

  <tr algorithm="textureStore 2d array">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td><xmp highlight=rust>
fn textureStore(t: texture_storage_2d_array<F,write>,
                coords: vec2<C>,
                array_index: C,
                value: vec4<CF>)</xmp>

  <tr algorithm="textureStore 3d">
    <td>|F| is a [=texel format=]<br>
        <var ignore>C</var> is [=i32=], or [=u32=]<br>
        <var ignore>CF</var> depends on the storage texel format |F|.
        [See the texel format table](#storage-texel-formats) for the mapping of texel
        format to channel format.
    <td><xmp highlight=rust>
fn textureStore(t: texture_storage_3d<F,write>,
                coords: vec3<C>,
                value: vec4<CF>)</xmp>

</table>

**Parameters:**

<table class='data'>
  <tr><td>`t`<td>
  The [write-only storage texture](#texture-storage).
  <tr><td>`coords`<td>
  The 0-based texel coordinate.<br>
  <tr><td>`array_index`<td>
  The 0-based texture array index.
  <tr><td>`value`<td>
  The new texel value.<br>
</table>

**Note:**

An out-of-bounds access occurs if:
* any element of `coords` is outside the range `[0, textureDimensions(t))`
    for the corresponding element, or
* `array_index` is outside the range of `[0, textureNumLayers(t))`

If an out-of-bounds access occurs, the built-in function may do any of the following:
* not be executed
* store `value` to some in bounds texel

## Atomic Built-in Functions ## {#atomic-builtin-functions}

Atomic built-in functions can be used to read/write/read-modify-write atomic
objects. They are the only operations allowed on [[#atomic-types]].

All atomic built-in functions use a `relaxed` [[#memory-semantics|memory
ordering]].  This means synchronization and ordering guarantees only apply among
atomic operations acting on the same [=memory locations=].  No synchronization
or ordering guarantees apply between atomic and non-atomic memory accesses, or
between atomic accesses acting on different memory locations.

Atomic built-in functions [=shader-creation error|must not=] be used in a [=vertex=] shader stage.

The address space `AS` of the `atomic_ptr` parameter in all atomic built-in
functions [=shader-creation error|must=] be either [=address spaces/storage=] or [=address spaces/workgroup=].

|T| [=shader-creation error|must=] be either [=u32=] or [=i32=]

### Atomic Load ### {#atomic-load}

```rust
fn atomicLoad(atomic_ptr: ptr<AS, atomic<T>, read_write>) -> T
```

Returns the atomically loaded the value pointed to by `atomic_ptr`.
It does not [=atomic modification|modify=] the object.

### Atomic Store ### {#atomic-store}

```rust
fn atomicStore(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T)
```

Atomically stores the value `v` in the atomic object pointed to by `atomic_ptr`.

### Atomic Read-modify-write ### {#atomic-rmw}

```rust
fn atomicAdd(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicSub(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicMax(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicMin(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicAnd(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicOr(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
fn atomicXor(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
```
Each function performs the following steps atomically:

1. Load the original value pointed to by `atomic_ptr`.
2. Obtains a new value by performing the operation (e.g. max) from the function
    name with the value |v|.
3. Store the new value using `atomic_ptr`.

Each function returns the original value stored in the atomic object.

```rust
fn atomicExchange(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T
```

Atomically stores the value `v` in the atomic object pointed to
`atomic_ptr` and returns the original value stored in the atomic object.

```rust
fn atomicCompareExchangeWeak(atomic_ptr: ptr<AS, atomic<T>, read_write>, cmp: T, v: T) -> __atomic_compare_exchange_result<T>

struct __atomic_compare_exchange_result<T> {
  old_value : T; // old value stored in the atomic
  exchanged : bool; // true if the exchange was done
}
```

Note: A value cannot be explicitly declared with the type
`__atomic_compare_exchange_result`, but a value may infer the type.

Performs the following steps atomically:

1. Load the original value pointed to by `atomic_ptr`.
2. Compare the original value to the value `v` using an equality operation.
3. Store the value `v` `only if` the result of the equality comparison was `true`.

Returns a two member structure, where the first member, `old_value`, is the
original value of the atomic object and the second member, `exchanged`, is
whether or not the comparison succeeded.

Note: the equality comparison may spuriously fail on some implementations. That
is, the second component of the result vector may be `false` even if the first
component of the result vector equals `cmp`.

## Data Packing Built-in Functions ## {#pack-builtin-functions}

Data packing builtin functions can be used to encode values using data formats that
do not correspond directly to types in WGSL.
This enables a program to write many densely packed values to memory, which can
reduce a shader's memory bandwidth demand.

<table class='data'>
  <tr algorithm="packing 4x8snorm">
    <th scope="row" style="width:10%">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn pack4x8snorm(e: vec4<f32>) -> u32
</xmp>
  <tr>
    <th scope="row">Description
    <td>Converts four normalized floating point values to 8-bit signed integers, and then combines them
        into one `u32` value.<br>
        Component |e|[|i|] of the input is converted to an 8-bit twos complement integer value
        &lfloor; 0.5 + 127 &times; min(1, max(-1, |e|[|i|])) &rfloor; which is then placed in bits
        8 &times; |i| through
        8 &times; |i| + 7 of the result.
</table>

<table class='data'>
  <tr algorithm="packing 4x8unorm">
    <th scope="row" style="width:10%">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn pack4x8unorm(e: vec4<f32>) -> u32
</xmp>
  <tr>
    <th scope="row">Description
    <td>Converts four normalized floating point values to 8-bit unsigned integers, and then combines them
        into one `u32` value.<br>
        Component |e|[|i|] of the input is converted to an 8-bit unsigned integer value
        &lfloor; 0.5 + 255 &times; min(1, max(0, |e|[|i|])) &rfloor; which is then placed in bits
        8 &times; |i| through
        8 &times; |i| + 7 of the result.
</table>

<table class='data'>
  <tr algorithm="packing 2x16snorm">
    <th scope="row" style="width:10%">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn pack2x16snorm(e: vec2<f32>) -> u32
</xmp>
  <tr>
    <th scope="row">Description
    <td>Converts two normalized floating point values to 16-bit signed integers, and then combines them
        into one `u32` value.<br>
        Component |e|[|i|] of the input is converted to a 16-bit twos complement integer value
        &lfloor; 0.5 + 32767 &times; min(1, max(-1, |e|[|i|])) &rfloor; which is then placed in bits
        16 &times; |i| through
        16 &times; |i| + 15 of the result.
</table>

<table class='data'>
  <tr algorithm="packing 2x16unorm">
    <th scope="row" style="width:10%">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn pack2x16unorm(e: vec2<f32>) -> u32
</xmp>
  <tr>
    <th scope="row">Description
    <td>Converts two normalized floating point values to 16-bit unsigned integers, and then combines them
        into one `u32` value.<br>
        Component |e|[|i|] of the input is converted to a 16-bit unsigned integer value
        &lfloor; 0.5 + 65535 &times; min(1, max(0, |e|[|i|])) &rfloor; which is then placed in bits
        16 &times; |i| through
        16 &times; |i| + 15 of the result.
</table>

<table class='data'>
  <tr algorithm="packing 2x16float">
    <th scope="row" style="width:10%">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn pack2x16float(e: vec2<f32>) -> u32
</xmp>
  <tr>
    <th scope="row">Description
    <td>Converts two floating point values to half-precision floating point numbers, and then combines
        them into one `u32` value.<br>
        Component |e|[|i|] of the input is converted to a [[!IEEE-754|IEEE-754]] binary16 value, which is then
        placed in bits
        16 &times; |i| through
        16 &times; |i| + 15 of the result.
        See [[#floating-point-conversion]].
</table>

## Data Unpacking Built-in Functions ## {#unpack-builtin-functions}

Data unpacking builtin functions can be used to decode values in
data formats that do not correspond directly to types in WGSL.
This enables a program to read many densely packed values from memory, which can
reduce a shader's memory bandwidth demand.

<table class='data'>
  <tr algorithm="unpacking 4x8snorm">
    <th scope="row" style="width:10%">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn unpack4x8snorm(e: u32) -> vec4<f32>
</xmp>
  <tr>
    <th scope="row">Description
    <td>Decomposes a 32-bit value into four 8-bit chunks, then reinterprets
        each chunk as a signed normalized floating point value.<br>
        Component |i| of the result is max(|v| &div; 127, -1), where |v| is the interpretation of
        bits 8&times;|i| through 8&times;|i|+7 of |e| as a twos-complement signed integer.
</table>

<table class='data'>
  <tr algorithm="unpacking 4x8unorm">
    <th scope="row" style="width:10%">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn unpack4x8unorm(e: u32) -> vec4<f32>
</xmp>
  <tr>
    <th scope="row">Description
    <td>Decomposes a 32-bit value into four 8-bit chunks, then reinterprets
        each chunk as an unsigned normalized floating point value.<br>
        Component |i| of the result is |v| &div; 255, where |v| is the interpretation of
        bits 8&times;|i| through 8&times;|i|+7 of |e| as an unsigned integer.
</table>

<table class='data'>
  <tr algorithm="unpacking 2x16snorm">
    <th scope="row" style="width:10%">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn unpack2x16snorm(e: u32) -> vec2<f32>
</xmp>
  <tr>
    <th scope="row">Description
    <td>Decomposes a 32-bit value into two 16-bit chunks, then reinterprets
        each chunk as a signed normalized floating point value.<br>
        Component |i| of the result is max(|v| &div; 32767, -1), where |v| is the interpretation of
        bits 16&times;|i| through 16&times;|i|+15 of |e| as a twos-complement signed integer.
</table>

<table class='data'>
  <tr algorithm="unpacking 2x16unorm">
    <th scope="row" style="width:10%">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn unpack2x16unorm(e: u32) -> vec2<f32>
</xmp>
  <tr>
    <th scope="row">Description
    <td>Decomposes a 32-bit value into two 16-bit chunks, then reinterprets
        each chunk as an unsigned normalized floating point value.<br>
        Component |i| of the result is |v| &div; 65535, where |v| is the interpretation of
        bits 16&times;|i| through 16&times;|i|+15 of |e| as an unsigned integer.
</table>

<table class='data'>
  <tr algorithm="unpacking 2x16float">
    <th scope="row" style="width:10%">Overload
    <td class="nowrap"><xmp highlight=rust>
@const fn unpack2x16float(e: u32) -> vec2<f32>
</xmp>
  <tr>
    <th scope="row">Description
    <td>Decomposes a 32-bit value into two 16-bit chunks, and reinterpets each chunk
        as a floating point value.<br>
        Component |i| of the result is the f32 representation of |v|,
        where |v| is the interpretation of bits 16&times;|i| through 16&times;|i|+15 of |e|
        as an [[!IEEE-754|IEEE-754]] binary16 value.
        See [[#floating-point-conversion]].
</table>

## Synchronization Built-in Functions ## {#sync-builtin-functions}

WGSL provides the following synchronization functions:

```rust
fn storageBarrier()
fn workgroupBarrier()
```

All synchronization functions execute a [=control barrier=] with
Acquire/Release [[#memory-semantics|memory ordering]].
That is, all synchronization functions, and affected memory and atomic
operations are ordered in [[#program-order|program order]] relative to the
synchronization function.
Additionally, the affected memory and atomic operations program-ordered before
the synchronization function must be visible to all other threads in the
workgroup before any affected memory or atomic operation program-ordered after
the synchronization function is executed by a member of the workgroup.
All synchronization functions use the `Workgroup` [=memory scope=].
All synchronization functions have a `Workgroup` [=execution scope=].
All synchronization functions [=shader-creation error|must=] only be used in the [=compute=] shader
stage.

`storageBarrier` affects memory and atomic operations in the [=address spaces/storage=] address space.

`workgroupBarrier` affects memory and atomic operations in the [=address spaces/workgroup=] address space.

